Documentation of ifdeftoif on sqlite3

24.11.2014 -- Problem with SQLITE_DEFAULT_MEMSTATUS
	SQLITE_DEFAULT_MEMSTATUS is not replaced. It is used as first element in struct sqlite3Config.
	After ifdeftoif, the struct is duplicated, but the first element is still "SQLITE_DEFAULT_MEMSTATUS".
	According to documentation it is a "0 or 1" option, so it should be a feature.
		/*
		** The SQLITE_DEFAULT_MEMSTATUS macro must be defined as either 0 or 1.
		** It determines whether or not the features related to 
		** SQLITE_CONFIG_MEMSTATUS are available by default or not. This value can
		** be overridden at runtime using the sqlite3_config() API.
		*/
	Perhaps this initialization is the key to why it does not work.
		#if !defined(SQLITE_DEFAULT_MEMSTATUS)
		# define SQLITE_DEFAULT_MEMSTATUS 1
		#endif
	I did an experiment. In the rest of the code SQLITE_DEFAULT_MEMSTATUS seems to be defined.
	Perhaps typeChef does not support using #if options as macros?
	Replaced 
		SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config = {
			SQLITE_DEFAULT_MEMSTATUS,  /* bMemstat */ ...
	with 
		SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config = {
			#if SQLITE_DEFAULT_MEMSTATUS==1
			1
			#else
			0
			#endif
			, ...
	Effect: We duplicate the struct. 
	def(SQLITE_DEFAULT_MEMSTATUS) means that SQLITE_DEFAULT_MEMSTATUS was set by the user (assuming to 0)
	!def(SQLITE_DEFAULT_MEMSTATUS) means that it was not set by the user and initialized to 1 by the above default initialization.
	(We are lucky that the value is not used before the default initialization. Otherwise the case where a user defined value 1 would be interpreted wrong.

24.11.2014
Linker problem with allocateBtreePage
	/usr/bin/ld: .libs/sqlite3.o: relocation R_X86_64_PC32 against undefined symbol `_701_allocateBtreePage' can not be used when making a shared object; recompile with -fPIC
	/usr/bin/ld: final link failed: Bad value
	According to renamings_Functions.txt, has only one variant
		allocateBtreePage@52995 -> _701_allocateBtreePage if !def(SQLITE_OMIT_AUTOVACUUM)
	So it does not need to be renamed?

2.12.
SQLITE_HAS_CODEC causes problems, undefined extern functions (optional user-defined functions?); adding it to limitations. Occurs only in function "attachFunc".
	Problem: Adding it !defined(SQLITE_HAS_CODEC) with --featureModelFExpr is not enough. 
	The condition defined(SQLITE_HAS_CODEC) || defined(SQLITE_ENABLE_CEROD) will not be simplified by the Preprocessor.
	And the limitation will only be used during parsing, not during type checking
	So we copy the limitations file to sqlite3.pc before starting Hercules. PCs are used during parsing AND typechecking.

3.12.
	The azCompileOpt struct caused problems again.
	SQLITE_HAS_CODEC is now switched off in the parser, so the struct is different (misses one entry).
	I could not get it working with the replacement parts. Replaced the part directly in sqlite3_modified.c
	
3.12 Fix SQLITE_THREADSAFE=0 in partialConfiguration.h (cannot assign values in pc). From the documentation:
	"The pthreads library is needed to make SQLite threadsafe. 
	But since the CLI is single threaded, we could instruct SQLite to build in a non-threadsafe mode and thereby omit the pthreads library:
	gcc -DSQLITE_THREADSAFE=0 shell.c sqlite3.c -ldl"

3.12. Activate the SQLITE_OMIT_LOAD_EXTENSION option in custom limitations. From the documentation:
	"The -ldl library is needed to support dynamic loading, the sqlite3_load_extension() interface and the load_extension() SQL function. 
	If these features are not required, then they can be omitted using SQLITE_OMIT_LOAD_EXTENSION compile-time option:"
3.12.
	Added !defined(SQLITE_ENABLE_SQLLOG) and !defined(SQLITE_ENABLE_CEROD) to custom_limitations.txt to avoid linker errors
