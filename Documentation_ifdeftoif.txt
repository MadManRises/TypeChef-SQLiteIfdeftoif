Documentation of ifdeftoif on sqlite3

24.11.2014 -- Problem with SQLITE_DEFAULT_MEMSTATUS
	SQLITE_DEFAULT_MEMSTATUS is not replaced. It is used as first element in struct sqlite3Config.
	After ifdeftoif, the struct is duplicated, but the first element is still "SQLITE_DEFAULT_MEMSTATUS".
	According to documentation it is a "0 or 1" option, so it should be a feature.
		/*
		** The SQLITE_DEFAULT_MEMSTATUS macro must be defined as either 0 or 1.
		** It determines whether or not the features related to 
		** SQLITE_CONFIG_MEMSTATUS are available by default or not. This value can
		** be overridden at runtime using the sqlite3_config() API.
		*/
	Perhaps this initialization is the key to why it does not work.
		#if !defined(SQLITE_DEFAULT_MEMSTATUS)
		# define SQLITE_DEFAULT_MEMSTATUS 1
		#endif
	I did an experiment. In the rest of the code SQLITE_DEFAULT_MEMSTATUS seems to be defined.
	Perhaps typeChef does not support using #if options as macros?
	Replaced 
		SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config = {
			SQLITE_DEFAULT_MEMSTATUS,  /* bMemstat */ ...
	with 
		SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config = {
			#if SQLITE_DEFAULT_MEMSTATUS==1
			1
			#else
			0
			#endif
			, ...
	Effect: We duplicate the struct. 
	def(SQLITE_DEFAULT_MEMSTATUS) means that SQLITE_DEFAULT_MEMSTATUS was set by the user (assuming to 0)
	!def(SQLITE_DEFAULT_MEMSTATUS) means that it was not set by the user and initialized to 1 by the above default initialization.
	(We are lucky that the value is not used before the default initialization. Otherwise the case where a user defined value 1 would be interpreted wrong.
09.12.2014 Above solution for SQLITE_DEFAULT_MEMSTATUS does not work with TypeChef. It cannot process the SQLITE_DEFAULT_MEMSTATUS==1.
	Solution: #if defined(SQLITE_DEFAULT_MEMSTATUS)
			1
			#else
			0
			#endif
		It is equivialent as long as no user defines SQLITE_DEFAULT_MEMSTATUS to 0.
24.11.2014
Linker problem with allocateBtreePage
	/usr/bin/ld: .libs/sqlite3.o: relocation R_X86_64_PC32 against undefined symbol `_701_allocateBtreePage' can not be used when making a shared object; recompile with -fPIC
	/usr/bin/ld: final link failed: Bad value
	According to renamings_Functions.txt, has only one variant
		allocateBtreePage@52995 -> _701_allocateBtreePage if !def(SQLITE_OMIT_AUTOVACUUM)
	So it does not need to be renamed?

2.12.
SQLITE_HAS_CODEC causes problems, undefined extern functions (optional user-defined functions?); adding it to limitations. Occurs only in function "attachFunc".
	Problem: Adding it !defined(SQLITE_HAS_CODEC) with --featureModelFExpr is not enough. 
	The condition defined(SQLITE_HAS_CODEC) || defined(SQLITE_ENABLE_CEROD) will not be simplified by the Preprocessor.
	And the limitation will only be used during parsing, not during type checking
	So we copy the limitations file to sqlite3.pc before starting Hercules. PCs are used during parsing AND typechecking.

3.12.
	The azCompileOpt struct caused problems again.
	SQLITE_HAS_CODEC is now switched off in the parser, so the struct is different (misses one entry).
	I could not get it working with the replacement parts. Replaced the part directly in sqlite3_modified.c
	
3.12 Fix SQLITE_THREADSAFE=0 in partialConfiguration.h (cannot assign values in pc). From the documentation:
	"The pthreads library is needed to make SQLite threadsafe. 
	But since the CLI is single threaded, we could instruct SQLite to build in a non-threadsafe mode and thereby omit the pthreads library:
	gcc -DSQLITE_THREADSAFE=0 shell.c sqlite3.c -ldl"

3.12. Activate the SQLITE_OMIT_LOAD_EXTENSION option in custom limitations. From the documentation:
	"The -ldl library is needed to support dynamic loading, the sqlite3_load_extension() interface and the load_extension() SQL function. 
	If these features are not required, then they can be omitted using SQLITE_OMIT_LOAD_EXTENSION compile-time option:"
3.12.
	Added !defined(SQLITE_ENABLE_SQLLOG) and !defined(SQLITE_ENABLE_CEROD) to custom_limitations.txt to avoid linker errors
9.12. TypeChef has Problems with the SQLITE_MALLOC_SOFT_LIMIT macro.
		warning: inline expansion of macro SQLITE_MALLOC_SOFT_LIMIT is not exaustive. assuming 0 for def(SQLITE_MALLOC_SOFT_LIMIT)
		sqlite3.c:22446:4: warning: inline expansion of macro SQLITE_MALLOC_SOFT_LIMIT is not exaustive. assuming 0 for def(SQLITE_MALLOC_SOFT_LIMIT)
		Default value for this macro is 1024 (set in source code). To avoid problems i initialize the macro to this value in partial configuration. 
9.12. TypeChef warnings with SQLITE_ENABLE_LOCKING_STYLE macro. Same warning as above with different macro.
		SQLITE_ENABLE_LOCKING_STYLE sets different styles of file locking such that multiple processes can access the same database file.
		We are not interested in multi-process setups. Therefore we can define it to 0 in partial configuration.
9.12. TypeChef cannot handle full expressions in #if. Problem with different MALLOC variants:
			#if defined(SQLITE_SYSTEM_MALLOC) \
			  + defined(SQLITE_WIN32_MALLOC) \
			  + defined(SQLITE_ZERO_MALLOC) \
			  + defined(SQLITE_MEMDEBUG)>1
		Only one of the options may be active. The different options mean this:
			**     SQLITE_SYSTEM_MALLOC          // Use normal system malloc()
			**     SQLITE_WIN32_MALLOC           // Use Win32 native heap API
			**     SQLITE_ZERO_MALLOC            // Use a stub allocator that always fails
			**     SQLITE_MEMDEBUG               // Debugging version of system malloc()
		We don't use Win32 and we don't debug or want to implement a stub. So we use SQLITE_SYSTEM_MALLOC and deactivate the others in partial configuration.
		#define SQLITE_SYSTEM_MALLOC
		#undef SQLITE_WIN32_MALLOC
		#undef SQLITE_ZERO_MALLOC
		#undef SQLITE_MEMDEBUG
9.12. SQLITE_ENABLE_UPDATE_DELETE_LIMIT: Online documentation says that this option must not be used when building from amalgation because it must also be used during generation of a pre-packaged file.
		partial configuration: #undef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
