#include "/local/garbe/ifdeftoif/id2i_optionstruct.h"
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
const char sqlite3_version[] =  "3.8.1";
const char *sqlite3_libversion(void );
const char *sqlite3_sourceid(void );
int sqlite3_libversion_number(void );
int sqlite3_compileoption_used(const  char *zOptName );
const char *sqlite3_compileoption_get(int N );
int sqlite3_threadsafe(void );
typedef struct  sqlite3   sqlite3;
typedef long long int sqlite_int64;
typedef unsigned long long int sqlite_uint64;
typedef sqlite_int64 sqlite3_int64;
typedef sqlite_uint64 sqlite3_uint64;
int sqlite3_close(sqlite3 * );
int sqlite3_close_v2(sqlite3 * );
typedef int ( *sqlite3_callback)(void * , int , char ** , char ** );
int sqlite3_exec(sqlite3 * , const  char *sql , int ( *callback)(void * , int , char ** , char ** ) , void * , char **errmsg );
typedef struct  sqlite3_file   sqlite3_file;
struct  sqlite3_file {
  const  struct  sqlite3_io_methods   *pMethods ;
}  ;
typedef struct  sqlite3_io_methods   sqlite3_io_methods;
struct  sqlite3_io_methods {
  int iVersion ;
  int ( *xClose)(sqlite3_file * ) ;
  int ( *xRead)(sqlite3_file * , void * , int iAmt , sqlite3_int64 iOfst ) ;
  int ( *xWrite)(sqlite3_file * , const  void * , int iAmt , sqlite3_int64 iOfst ) ;
  int ( *xTruncate)(sqlite3_file * , sqlite3_int64 size ) ;
  int ( *xSync)(sqlite3_file * , int flags ) ;
  int ( *xFileSize)(sqlite3_file * , sqlite3_int64 *pSize ) ;
  int ( *xLock)(sqlite3_file * , int ) ;
  int ( *xUnlock)(sqlite3_file * , int ) ;
  int ( *xCheckReservedLock)(sqlite3_file * , int *pResOut ) ;
  int ( *xFileControl)(sqlite3_file * , int op , void *pArg ) ;
  int ( *xSectorSize)(sqlite3_file * ) ;
  int ( *xDeviceCharacteristics)(sqlite3_file * ) ;
  int ( *xShmMap)(sqlite3_file * , int iPg , int pgsz , int , void  volatile ** ) ;
  int ( *xShmLock)(sqlite3_file * , int offset , int n , int flags ) ;
  void ( *xShmBarrier)(sqlite3_file * ) ;
  int ( *xShmUnmap)(sqlite3_file * , int deleteFlag ) ;
  int ( *xFetch)(sqlite3_file * , sqlite3_int64 iOfst , int iAmt , void **pp ) ;
  int ( *xUnfetch)(sqlite3_file * , sqlite3_int64 iOfst , void *p ) ;
}  ;
typedef struct  sqlite3_mutex   sqlite3_mutex;
typedef struct  sqlite3_vfs   sqlite3_vfs;
typedef void ( *sqlite3_syscall_ptr)(void );
struct  sqlite3_vfs {
  int iVersion ;
  int szOsFile ;
  int mxPathname ;
  sqlite3_vfs *pNext ;
  const  char *zName ;
  void *pAppData ;
  int ( *xOpen)(sqlite3_vfs * , const  char *zName , sqlite3_file * , int flags , int *pOutFlags ) ;
  int ( *xDelete)(sqlite3_vfs * , const  char *zName , int syncDir ) ;
  int ( *xAccess)(sqlite3_vfs * , const  char *zName , int flags , int *pResOut ) ;
  int ( *xFullPathname)(sqlite3_vfs * , const  char *zName , int nOut , char *zOut ) ;
  void *( *xDlOpen)(sqlite3_vfs * , const  char *zFilename ) ;
  void ( *xDlError)(sqlite3_vfs * , int nByte , char *zErrMsg ) ;
  void ( *( *xDlSym)(sqlite3_vfs * , void * , const  char *zSymbol ))(void ) ;
  void ( *xDlClose)(sqlite3_vfs * , void * ) ;
  int ( *xRandomness)(sqlite3_vfs * , int nByte , char *zOut ) ;
  int ( *xSleep)(sqlite3_vfs * , int microseconds ) ;
  int ( *xCurrentTime)(sqlite3_vfs * , double * ) ;
  int ( *xGetLastError)(sqlite3_vfs * , int , char * ) ;
  int ( *xCurrentTimeInt64)(sqlite3_vfs * , sqlite3_int64 * ) ;
  int ( *xSetSystemCall)(sqlite3_vfs * , const  char *zName , sqlite3_syscall_ptr ) ;
  sqlite3_syscall_ptr ( *xGetSystemCall)(sqlite3_vfs * , const  char *zName ) ;
  const  char *( *xNextSystemCall)(sqlite3_vfs * , const  char *zName ) ;
}  ;
int sqlite3_initialize(void );
int sqlite3_shutdown(void );
int sqlite3_os_init(void );
int sqlite3_os_end(void );
int sqlite3_config(int , ...);
int sqlite3_db_config(sqlite3 * , int op , ...);
typedef struct  sqlite3_mem_methods   sqlite3_mem_methods;
struct  sqlite3_mem_methods {
  void *( *xMalloc)(int ) ;
  void ( *xFree)(void * ) ;
  void *( *xRealloc)(void * , int ) ;
  int ( *xSize)(void * ) ;
  int ( *xRoundup)(int ) ;
  int ( *xInit)(void * ) ;
  void ( *xShutdown)(void * ) ;
  void *pAppData ;
}  ;
int sqlite3_extended_result_codes(sqlite3 * , int onoff );
sqlite3_int64 sqlite3_last_insert_rowid(sqlite3 * );
int sqlite3_changes(sqlite3 * );
int sqlite3_total_changes(sqlite3 * );
void sqlite3_interrupt(sqlite3 * );
int sqlite3_complete(const  char *sql );
int sqlite3_complete16(const  void *sql );
int sqlite3_busy_handler(sqlite3 * , int ( *)(void * , int ) , void * );
int sqlite3_busy_timeout(sqlite3 * , int ms );
int sqlite3_get_table(sqlite3 *db , const  char *zSql , char ***pazResult , int *pnRow , int *pnColumn , char **pzErrmsg );
void sqlite3_free_table(char **result );
char *sqlite3_mprintf(const  char * , ...);
char *sqlite3_vmprintf(const  char * , va_list );
char *sqlite3_snprintf(int , char * , const  char * , ...);
char *sqlite3_vsnprintf(int , char * , const  char * , va_list );
void *sqlite3_malloc(int );
void *sqlite3_realloc(void * , int );
void sqlite3_free(void * );
sqlite3_int64 sqlite3_memory_used(void );
sqlite3_int64 sqlite3_memory_highwater(int resetFlag );
void sqlite3_randomness(int N , void *P );
int sqlite3_set_authorizer(sqlite3 * , int ( *xAuth)(void * , int , const  char * , const  char * , const  char * , const  char * ) , void *pUserData );
void *sqlite3_trace(sqlite3 * , void ( *xTrace)(void * , const  char * ) , void * );
void *sqlite3_profile(sqlite3 * , void ( *xProfile)(void * , const  char * , sqlite3_uint64 ) , void * );
void sqlite3_progress_handler(sqlite3 * , int , int ( *)(void * ) , void * );
int sqlite3_open(const  char *filename , sqlite3 **ppDb );
int sqlite3_open16(const  void *filename , sqlite3 **ppDb );
int sqlite3_open_v2(const  char *filename , sqlite3 **ppDb , int flags , const  char *zVfs );
const char *sqlite3_uri_parameter(const  char *zFilename , const  char *zParam );
int sqlite3_uri_boolean(const  char *zFile , const  char *zParam , int bDefault );
sqlite3_int64 sqlite3_uri_int64(const  char * , const  char * , sqlite3_int64 );
int sqlite3_errcode(sqlite3 *db );
int sqlite3_extended_errcode(sqlite3 *db );
const char *sqlite3_errmsg(sqlite3 * );
const void *sqlite3_errmsg16(sqlite3 * );
const char *sqlite3_errstr(int );
typedef struct  sqlite3_stmt   sqlite3_stmt;
int sqlite3_limit(sqlite3 * , int id , int newVal );
int sqlite3_prepare(sqlite3 *db , const  char *zSql , int nByte , sqlite3_stmt **ppStmt , const  char **pzTail );
int sqlite3_prepare_v2(sqlite3 *db , const  char *zSql , int nByte , sqlite3_stmt **ppStmt , const  char **pzTail );
int sqlite3_prepare16(sqlite3 *db , const  void *zSql , int nByte , sqlite3_stmt **ppStmt , const  void **pzTail );
int sqlite3_prepare16_v2(sqlite3 *db , const  void *zSql , int nByte , sqlite3_stmt **ppStmt , const  void **pzTail );
const char *sqlite3_sql(sqlite3_stmt *pStmt );
int sqlite3_stmt_readonly(sqlite3_stmt *pStmt );
int sqlite3_stmt_busy(sqlite3_stmt * );
typedef struct  Mem   sqlite3_value;
typedef struct  sqlite3_context   sqlite3_context;
int sqlite3_bind_blob(sqlite3_stmt * , int , const  void * , int n , void ( *)(void * ) );
int sqlite3_bind_double(sqlite3_stmt * , int , double );
int sqlite3_bind_int(sqlite3_stmt * , int , int );
int sqlite3_bind_int64(sqlite3_stmt * , int , sqlite3_int64 );
int sqlite3_bind_null(sqlite3_stmt * , int );
int sqlite3_bind_text(sqlite3_stmt * , int , const  char * , int n , void ( *)(void * ) );
int sqlite3_bind_text16(sqlite3_stmt * , int , const  void * , int , void ( *)(void * ) );
int sqlite3_bind_value(sqlite3_stmt * , int , const  sqlite3_value * );
int sqlite3_bind_zeroblob(sqlite3_stmt * , int , int n );
int sqlite3_bind_parameter_count(sqlite3_stmt * );
const char *sqlite3_bind_parameter_name(sqlite3_stmt * , int );
int sqlite3_bind_parameter_index(sqlite3_stmt * , const  char *zName );
int sqlite3_clear_bindings(sqlite3_stmt * );
int sqlite3_column_count(sqlite3_stmt *pStmt );
const char *sqlite3_column_name(sqlite3_stmt * , int N );
const void *sqlite3_column_name16(sqlite3_stmt * , int N );
const char *sqlite3_column_database_name(sqlite3_stmt * , int );
const void *sqlite3_column_database_name16(sqlite3_stmt * , int );
const char *sqlite3_column_table_name(sqlite3_stmt * , int );
const void *sqlite3_column_table_name16(sqlite3_stmt * , int );
const char *sqlite3_column_origin_name(sqlite3_stmt * , int );
const void *sqlite3_column_origin_name16(sqlite3_stmt * , int );
const char *sqlite3_column_decltype(sqlite3_stmt * , int );
const void *sqlite3_column_decltype16(sqlite3_stmt * , int );
int sqlite3_step(sqlite3_stmt * );
int sqlite3_data_count(sqlite3_stmt *pStmt );
const void *sqlite3_column_blob(sqlite3_stmt * , int iCol );
int sqlite3_column_bytes(sqlite3_stmt * , int iCol );
int sqlite3_column_bytes16(sqlite3_stmt * , int iCol );
double sqlite3_column_double(sqlite3_stmt * , int iCol );
int sqlite3_column_int(sqlite3_stmt * , int iCol );
sqlite3_int64 sqlite3_column_int64(sqlite3_stmt * , int iCol );
const unsigned char *sqlite3_column_text(sqlite3_stmt * , int iCol );
const void *sqlite3_column_text16(sqlite3_stmt * , int iCol );
int sqlite3_column_type(sqlite3_stmt * , int iCol );
sqlite3_value *sqlite3_column_value(sqlite3_stmt * , int iCol );
int sqlite3_finalize(sqlite3_stmt *pStmt );
int sqlite3_reset(sqlite3_stmt *pStmt );
int sqlite3_create_function(sqlite3 *db , const  char *zFunctionName , int nArg , int eTextRep , void *pApp , void ( *xFunc)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xStep)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xFinal)(sqlite3_context * ) );
int sqlite3_create_function16(sqlite3 *db , const  void *zFunctionName , int nArg , int eTextRep , void *pApp , void ( *xFunc)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xStep)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xFinal)(sqlite3_context * ) );
int sqlite3_create_function_v2(sqlite3 *db , const  char *zFunctionName , int nArg , int eTextRep , void *pApp , void ( *xFunc)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xStep)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xFinal)(sqlite3_context * ) , void ( *xDestroy)(void * ) );
int sqlite3_aggregate_count(sqlite3_context * );
int sqlite3_expired(sqlite3_stmt * );
int sqlite3_transfer_bindings(sqlite3_stmt * , sqlite3_stmt * );
int sqlite3_global_recover(void );
void sqlite3_thread_cleanup(void );
int sqlite3_memory_alarm(void ( *)(void * , sqlite3_int64 , int ) , void * , sqlite3_int64 );
const void *sqlite3_value_blob(sqlite3_value * );
int sqlite3_value_bytes(sqlite3_value * );
int sqlite3_value_bytes16(sqlite3_value * );
double sqlite3_value_double(sqlite3_value * );
int sqlite3_value_int(sqlite3_value * );
sqlite3_int64 sqlite3_value_int64(sqlite3_value * );
const unsigned char *sqlite3_value_text(sqlite3_value * );
const void *sqlite3_value_text16(sqlite3_value * );
const void *sqlite3_value_text16le(sqlite3_value * );
const void *sqlite3_value_text16be(sqlite3_value * );
int sqlite3_value_type(sqlite3_value * );
int sqlite3_value_numeric_type(sqlite3_value * );
void *sqlite3_aggregate_context(sqlite3_context * , int nBytes );
void *sqlite3_user_data(sqlite3_context * );
sqlite3 *sqlite3_context_db_handle(sqlite3_context * );
void *sqlite3_get_auxdata(sqlite3_context * , int N );
void sqlite3_set_auxdata(sqlite3_context * , int N , void * , void ( *)(void * ) );
typedef void ( *sqlite3_destructor_type)(void * );
void sqlite3_result_blob(sqlite3_context * , const  void * , int , void ( *)(void * ) );
void sqlite3_result_double(sqlite3_context * , double );
void sqlite3_result_error(sqlite3_context * , const  char * , int );
void sqlite3_result_error16(sqlite3_context * , const  void * , int );
void sqlite3_result_error_toobig(sqlite3_context * );
void sqlite3_result_error_nomem(sqlite3_context * );
void sqlite3_result_error_code(sqlite3_context * , int );
void sqlite3_result_int(sqlite3_context * , int );
void sqlite3_result_int64(sqlite3_context * , sqlite3_int64 );
void sqlite3_result_null(sqlite3_context * );
void sqlite3_result_text(sqlite3_context * , const  char * , int , void ( *)(void * ) );
void sqlite3_result_text16(sqlite3_context * , const  void * , int , void ( *)(void * ) );
void sqlite3_result_text16le(sqlite3_context * , const  void * , int , void ( *)(void * ) );
void sqlite3_result_text16be(sqlite3_context * , const  void * , int , void ( *)(void * ) );
void sqlite3_result_value(sqlite3_context * , sqlite3_value * );
void sqlite3_result_zeroblob(sqlite3_context * , int n );
int sqlite3_create_collation(sqlite3 * , const  char *zName , int eTextRep , void *pArg , int ( *xCompare)(void * , int , const  void * , int , const  void * ) );
int sqlite3_create_collation_v2(sqlite3 * , const  char *zName , int eTextRep , void *pArg , int ( *xCompare)(void * , int , const  void * , int , const  void * ) , void ( *xDestroy)(void * ) );
int sqlite3_create_collation16(sqlite3 * , const  void *zName , int eTextRep , void *pArg , int ( *xCompare)(void * , int , const  void * , int , const  void * ) );
int sqlite3_collation_needed(sqlite3 * , void * , void ( *)(void * , sqlite3 * , int eTextRep , const  char * ) );
int sqlite3_collation_needed16(sqlite3 * , void * , void ( *)(void * , sqlite3 * , int eTextRep , const  void * ) );
int sqlite3_sleep(int );
char *sqlite3_temp_directory;
char *sqlite3_data_directory;
int sqlite3_get_autocommit(sqlite3 * );
sqlite3 *sqlite3_db_handle(sqlite3_stmt * );
const char *sqlite3_db_filename(sqlite3 *db , const  char *zDbName );
int sqlite3_db_readonly(sqlite3 *db , const  char *zDbName );
sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb , sqlite3_stmt *pStmt );
void *sqlite3_commit_hook(sqlite3 * , int ( *)(void * ) , void * );
void *sqlite3_rollback_hook(sqlite3 * , void ( *)(void * ) , void * );
void *sqlite3_update_hook(sqlite3 * , void ( *)(void * , int , char  const * , char  const * , sqlite3_int64 ) , void * );
int sqlite3_enable_shared_cache(int );
int sqlite3_release_memory(int );
int sqlite3_db_release_memory(sqlite3 * );
sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N );
void sqlite3_soft_heap_limit(int N );
int sqlite3_table_column_metadata(sqlite3 *db , const  char *zDbName , const  char *zTableName , const  char *zColumnName , char  const **pzDataType , char  const **pzCollSeq , int *pNotNull , int *pPrimaryKey , int *pAutoinc );
int sqlite3_load_extension(sqlite3 *db , const  char *zFile , const  char *zProc , char **pzErrMsg );
int sqlite3_enable_load_extension(sqlite3 *db , int onoff );
int sqlite3_auto_extension(void ( *xEntryPoint)(void ) );
int sqlite3_cancel_auto_extension(void ( *xEntryPoint)(void ) );
void sqlite3_reset_auto_extension(void );
typedef struct  sqlite3_vtab   sqlite3_vtab;
typedef struct  sqlite3_index_info   sqlite3_index_info;
typedef struct  sqlite3_vtab_cursor   sqlite3_vtab_cursor;
typedef struct  sqlite3_module   sqlite3_module;
struct  sqlite3_module {
  int iVersion ;
  int ( *xCreate)(sqlite3 * , void *pAux , int argc , const  char *const *argv , sqlite3_vtab **ppVTab , char ** ) ;
  int ( *xConnect)(sqlite3 * , void *pAux , int argc , const  char *const *argv , sqlite3_vtab **ppVTab , char ** ) ;
  int ( *xBestIndex)(sqlite3_vtab *pVTab , sqlite3_index_info * ) ;
  int ( *xDisconnect)(sqlite3_vtab *pVTab ) ;
  int ( *xDestroy)(sqlite3_vtab *pVTab ) ;
  int ( *xOpen)(sqlite3_vtab *pVTab , sqlite3_vtab_cursor **ppCursor ) ;
  int ( *xClose)(sqlite3_vtab_cursor * ) ;
  int ( *xFilter)(sqlite3_vtab_cursor * , int idxNum , const  char *idxStr , int argc , sqlite3_value **argv ) ;
  int ( *xNext)(sqlite3_vtab_cursor * ) ;
  int ( *xEof)(sqlite3_vtab_cursor * ) ;
  int ( *xColumn)(sqlite3_vtab_cursor * , sqlite3_context * , int ) ;
  int ( *xRowid)(sqlite3_vtab_cursor * , sqlite3_int64 *pRowid ) ;
  int ( *xUpdate)(sqlite3_vtab * , int , sqlite3_value ** , sqlite3_int64 * ) ;
  int ( *xBegin)(sqlite3_vtab *pVTab ) ;
  int ( *xSync)(sqlite3_vtab *pVTab ) ;
  int ( *xCommit)(sqlite3_vtab *pVTab ) ;
  int ( *xRollback)(sqlite3_vtab *pVTab ) ;
  int ( *xFindFunction)(sqlite3_vtab *pVtab , int nArg , const  char *zName , void ( **pxFunc)(sqlite3_context * , int , sqlite3_value ** ) , void **ppArg ) ;
  int ( *xRename)(sqlite3_vtab *pVtab , const  char *zNew ) ;
  int ( *xSavepoint)(sqlite3_vtab *pVTab , int ) ;
  int ( *xRelease)(sqlite3_vtab *pVTab , int ) ;
  int ( *xRollbackTo)(sqlite3_vtab *pVTab , int ) ;
}  ;
struct  sqlite3_index_info {
  int nConstraint ;
  struct  sqlite3_index_constraint {
    int iColumn ;
    unsigned  char op ;
    unsigned  char usable ;
    int iTermOffset ;
  }  *aConstraint ;
  int nOrderBy ;
  struct  sqlite3_index_orderby {
    int iColumn ;
    unsigned  char desc ;
  }  *aOrderBy ;
  struct  sqlite3_index_constraint_usage {
    int argvIndex ;
    unsigned  char omit ;
  }  *aConstraintUsage ;
  int idxNum ;
  char *idxStr ;
  int needToFreeIdxStr ;
  int orderByConsumed ;
  double estimatedCost ;
}  ;
int sqlite3_create_module(sqlite3 *db , const  char *zName , const  sqlite3_module *p , void *pClientData );
int sqlite3_create_module_v2(sqlite3 *db , const  char *zName , const  sqlite3_module *p , void *pClientData , void ( *xDestroy)(void * ) );
struct  sqlite3_vtab {
  const  sqlite3_module *pModule ;
  int nRef ;
  char *zErrMsg ;
}  ;
struct  sqlite3_vtab_cursor {
  sqlite3_vtab *pVtab ;
}  ;
int sqlite3_declare_vtab(sqlite3 * , const  char *zSQL );
int sqlite3_overload_function(sqlite3 * , const  char *zFuncName , int nArg );
typedef struct  sqlite3_blob   sqlite3_blob;
int sqlite3_blob_open(sqlite3 * , const  char *zDb , const  char *zTable , const  char *zColumn , sqlite3_int64 iRow , int flags , sqlite3_blob **ppBlob );
int sqlite3_blob_reopen(sqlite3_blob * , sqlite3_int64 );
int sqlite3_blob_close(sqlite3_blob * );
int sqlite3_blob_bytes(sqlite3_blob * );
int sqlite3_blob_read(sqlite3_blob * , void *Z , int N , int iOffset );
int sqlite3_blob_write(sqlite3_blob * , const  void *z , int n , int iOffset );
sqlite3_vfs *sqlite3_vfs_find(const  char *zVfsName );
int sqlite3_vfs_register(sqlite3_vfs * , int makeDflt );
int sqlite3_vfs_unregister(sqlite3_vfs * );
sqlite3_mutex *sqlite3_mutex_alloc(int );
void sqlite3_mutex_free(sqlite3_mutex * );
void sqlite3_mutex_enter(sqlite3_mutex * );
int sqlite3_mutex_try(sqlite3_mutex * );
void sqlite3_mutex_leave(sqlite3_mutex * );
typedef struct  sqlite3_mutex_methods   sqlite3_mutex_methods;
struct  sqlite3_mutex_methods {
  int ( *xMutexInit)(void ) ;
  int ( *xMutexEnd)(void ) ;
  sqlite3_mutex *( *xMutexAlloc)(int ) ;
  void ( *xMutexFree)(sqlite3_mutex * ) ;
  void ( *xMutexEnter)(sqlite3_mutex * ) ;
  int ( *xMutexTry)(sqlite3_mutex * ) ;
  void ( *xMutexLeave)(sqlite3_mutex * ) ;
  int ( *xMutexHeld)(sqlite3_mutex * ) ;
  int ( *xMutexNotheld)(sqlite3_mutex * ) ;
}  ;
int sqlite3_mutex_held(sqlite3_mutex * );
int sqlite3_mutex_notheld(sqlite3_mutex * );
sqlite3_mutex *sqlite3_db_mutex(sqlite3 * );
int sqlite3_file_control(sqlite3 * , const  char *zDbName , int op , void * );
int sqlite3_test_control(int op , ...);
int sqlite3_status(int op , int *pCurrent , int *pHighwater , int resetFlag );
int sqlite3_db_status(sqlite3 * , int op , int *pCur , int *pHiwtr , int resetFlg );
int sqlite3_stmt_status(sqlite3_stmt * , int op , int resetFlg );
typedef struct  sqlite3_pcache   sqlite3_pcache;
typedef struct  sqlite3_pcache_page   sqlite3_pcache_page;
struct  sqlite3_pcache_page {
  void *pBuf ;
  void *pExtra ;
}  ;
typedef struct  sqlite3_pcache_methods2   sqlite3_pcache_methods2;
struct  sqlite3_pcache_methods2 {
  int iVersion ;
  void *pArg ;
  int ( *xInit)(void * ) ;
  void ( *xShutdown)(void * ) ;
  sqlite3_pcache *( *xCreate)(int szPage , int szExtra , int bPurgeable ) ;
  void ( *xCachesize)(sqlite3_pcache * , int nCachesize ) ;
  int ( *xPagecount)(sqlite3_pcache * ) ;
  sqlite3_pcache_page *( *xFetch)(sqlite3_pcache * , unsigned key , int createFlag ) ;
  void ( *xUnpin)(sqlite3_pcache * , sqlite3_pcache_page * , int discard ) ;
  void ( *xRekey)(sqlite3_pcache * , sqlite3_pcache_page * , unsigned oldKey , unsigned newKey ) ;
  void ( *xTruncate)(sqlite3_pcache * , unsigned iLimit ) ;
  void ( *xDestroy)(sqlite3_pcache * ) ;
  void ( *xShrink)(sqlite3_pcache * ) ;
}  ;
typedef struct  sqlite3_pcache_methods   sqlite3_pcache_methods;
struct  sqlite3_pcache_methods {
  void *pArg ;
  int ( *xInit)(void * ) ;
  void ( *xShutdown)(void * ) ;
  sqlite3_pcache *( *xCreate)(int szPage , int bPurgeable ) ;
  void ( *xCachesize)(sqlite3_pcache * , int nCachesize ) ;
  int ( *xPagecount)(sqlite3_pcache * ) ;
  void *( *xFetch)(sqlite3_pcache * , unsigned key , int createFlag ) ;
  void ( *xUnpin)(sqlite3_pcache * , void * , int discard ) ;
  void ( *xRekey)(sqlite3_pcache * , void * , unsigned oldKey , unsigned newKey ) ;
  void ( *xTruncate)(sqlite3_pcache * , unsigned iLimit ) ;
  void ( *xDestroy)(sqlite3_pcache * ) ;
}  ;
typedef struct  sqlite3_backup   sqlite3_backup;
sqlite3_backup *sqlite3_backup_init(sqlite3 *pDest , const  char *zDestName , sqlite3 *pSource , const  char *zSourceName );
int sqlite3_backup_step(sqlite3_backup *p , int nPage );
int sqlite3_backup_finish(sqlite3_backup *p );
int sqlite3_backup_remaining(sqlite3_backup *p );
int sqlite3_backup_pagecount(sqlite3_backup *p );
int sqlite3_unlock_notify(sqlite3 *pBlocked , void ( *xNotify)(void **apArg , int nArg ) , void *pNotifyArg );
int sqlite3_stricmp(const  char * , const  char * );
int sqlite3_strnicmp(const  char * , const  char * , int );
int sqlite3_strglob(const  char *zGlob , const  char *zStr );
void sqlite3_log(int iErrCode , const  char *zFormat , ...);
void *sqlite3_wal_hook(sqlite3 * , int ( *)(void * , sqlite3 * , const  char * , int ) , void * );
int sqlite3_wal_autocheckpoint(sqlite3 *db , int N );
int sqlite3_wal_checkpoint(sqlite3 *db , const  char *zDb );
int sqlite3_wal_checkpoint_v2(sqlite3 *db , const  char *zDb , int eMode , int *pnLog , int *pnCkpt );
int sqlite3_vtab_config(sqlite3 * , int op , ...);
int sqlite3_vtab_on_conflict(sqlite3 * );
typedef struct  sqlite3_rtree_geometry   sqlite3_rtree_geometry;
int _1264_sqlite3_rtree_geometry_callback(sqlite3 *db , const  char *zGeom , int ( *xGeom)(sqlite3_rtree_geometry * , int n , double *a , int *pRes ) , void *pContext );
int _1265_sqlite3_rtree_geometry_callback(sqlite3 *db , const  char *zGeom , int ( *xGeom)(sqlite3_rtree_geometry * , int n , sqlite3_int64 *a , int *pRes ) , void *pContext );
struct  sqlite3_rtree_geometry {
  void *pContext ;
  int nParam ;
  double *aParam ;
  void *pUser ;
  void ( *xDelUser)(void * ) ;
}  ;
typedef signed char _1266_int8_t;
typedef short int _1266_int16_t;
typedef int _1266_int32_t;
typedef long int _1266_int64_t;
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long int uint64_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long int uint_least64_t;
typedef signed char int_fast8_t;
typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef long int _1266_intptr_t;
typedef unsigned long int uintptr_t;
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
static void sqlite3Coverage(int );
typedef struct  Hash   Hash;
typedef struct  HashElem   HashElem;
struct  Hash {
  unsigned  int htsize ;
  unsigned  int count ;
  HashElem *first ;
  struct  _ht {
    int count ;
    HashElem *chain ;
  }  *ht ;
}  ;
struct  HashElem {
  HashElem *next , *prev ;
  void *data ;
  const  char *pKey ;
  int nKey ;
}  ;
static void sqlite3HashInit(Hash * );
static void *sqlite3HashInsert(Hash * , const  char *pKey , int nKey , void *pData );
static void *sqlite3HashFind(const  Hash * , const  char *pKey , int nKey );
static void sqlite3HashClear(Hash * );
typedef long unsigned int size_t;
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct   {
  int __val[2] ;
}  __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __fsword_t;
typedef long int __ssize_t;
typedef long int __syscall_slong_t;
typedef unsigned long int __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;
struct  _IO_FILE   ;
typedef struct  _IO_FILE   FILE;
typedef struct  _IO_FILE   __FILE;
typedef struct   {
  int __count ;
  union   {
    unsigned  int __wch ;
    char __wchb[4] ;
  }  __value ;
}  __mbstate_t;
typedef struct   {
  __off_t __pos ;
  __mbstate_t __state ;
}  _G_fpos_t;
typedef struct   {
  __off64_t __pos ;
  __mbstate_t __state ;
}  _G_fpos64_t;
struct  _IO_jump_t   ;
struct  _IO_FILE   ;
typedef void _IO_lock_t;
struct  _IO_marker {
  struct  _IO_marker   *_next ;
  struct  _IO_FILE   *_sbuf ;
  int _pos ;
}  ;
enum __codecvt_result {
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
} ;
struct  _IO_FILE {
  int _flags ;
  char *_IO_read_ptr ;
  char *_IO_read_end ;
  char *_IO_read_base ;
  char *_IO_write_base ;
  char *_IO_write_ptr ;
  char *_IO_write_end ;
  char *_IO_buf_base ;
  char *_IO_buf_end ;
  char *_IO_save_base ;
  char *_IO_backup_base ;
  char *_IO_save_end ;
  struct  _IO_marker   *_markers ;
  struct  _IO_FILE   *_chain ;
  int _fileno ;
  int _flags2 ;
  __off_t _old_offset ;
  unsigned  short _cur_column ;
  signed  char _vtable_offset ;
  char _shortbuf[1] ;
  _IO_lock_t *_lock ;
  __off64_t _offset ;
  void *__pad1 ;
  void *__pad2 ;
  void *__pad3 ;
  void *__pad4 ;
  size_t __pad5 ;
  int _mode ;
  char _unused2[((15 * sizeof(int )) - (4 * sizeof(void *)) - sizeof(size_t ))] ;
}  ;
typedef struct  _IO_FILE   _IO_FILE;
struct  _IO_FILE_plus   ;
extern struct  _IO_FILE_plus   _IO_2_1_stdin_;
extern struct  _IO_FILE_plus   _IO_2_1_stdout_;
extern struct  _IO_FILE_plus   _IO_2_1_stderr_;
typedef __ssize_t __io_read_fn(void *__cookie , char *__buf , size_t __nbytes );
typedef __ssize_t __io_write_fn(void *__cookie , const  char *__buf , size_t __n );
typedef int __io_seek_fn(void *__cookie , __off64_t *__pos , int __w );
typedef int __io_close_fn(void *__cookie );
typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;
typedef struct   {
  __io_read_fn *read ;
  __io_write_fn *write ;
  __io_seek_fn *seek ;
  __io_close_fn *close ;
}  _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;
struct  _IO_cookie_file   ;
extern void _IO_cookie_init(struct  _IO_cookie_file   *__cfile , int __read_write , void *__cookie , _IO_cookie_io_functions_t __fns );
extern int __underflow(_IO_FILE * );
extern int __uflow(_IO_FILE * );
extern int __overflow(_IO_FILE * , int );
extern int _IO_getc(_IO_FILE *__fp );
extern int _IO_putc(int __c , _IO_FILE *__fp );
extern int _IO_feof(_IO_FILE *__fp ) __attribute__((__nothrow__));
extern int _IO_ferror(_IO_FILE *__fp ) __attribute__((__nothrow__));
extern int _IO_peekc_locked(_IO_FILE *__fp );
extern void _IO_flockfile(_IO_FILE * ) __attribute__((__nothrow__));
extern void _IO_funlockfile(_IO_FILE * ) __attribute__((__nothrow__));
extern int _IO_ftrylockfile(_IO_FILE * ) __attribute__((__nothrow__));
extern int _IO_vfscanf(_IO_FILE *__restrict  , const  char *__restrict  , __gnuc_va_list , int *__restrict  );
extern int _IO_vfprintf(_IO_FILE *__restrict  , const  char *__restrict  , __gnuc_va_list );
extern __ssize_t _IO_padn(_IO_FILE * , int , __ssize_t );
extern size_t _IO_sgetn(_IO_FILE * , void * , size_t );
extern __off64_t _IO_seekoff(_IO_FILE * , __off64_t , int , int );
extern __off64_t _IO_seekpos(_IO_FILE * , __off64_t , int );
extern void _IO_free_backup_area(_IO_FILE * ) __attribute__((__nothrow__));
typedef __off64_t off_t;
typedef __off64_t off64_t;
typedef __ssize_t ssize_t;
typedef _G_fpos64_t fpos_t;
typedef _G_fpos64_t fpos64_t;
extern struct  _IO_FILE   *stdin;
extern struct  _IO_FILE   *stdout;
extern struct  _IO_FILE   *stderr;
extern int remove(const  char *__filename ) __attribute__((__nothrow__));
extern int rename(const  char *__old , const  char *__new ) __attribute__((__nothrow__));
extern int renameat(int __oldfd , const  char *__old , int __newfd , const  char *__new ) __attribute__((__nothrow__));
extern FILE *tmpfile(void ) __asm__( "" "tmpfile64");
extern FILE *tmpfile64(void );
extern char *tmpnam(char *__s ) __attribute__((__nothrow__));
extern char *tmpnam_r(char *__s ) __attribute__((__nothrow__));
extern char *tempnam(const  char *__dir , const  char *__pfx ) __attribute__((__nothrow__)) __attribute__((__malloc__));
extern int fclose(FILE *__stream );
extern int fflush(FILE *__stream );
extern int fflush_unlocked(FILE *__stream );
extern int fcloseall(void );
extern FILE *fopen(const  char *__restrict __filename , const  char *__restrict __modes ) __asm__( "" "fopen64");
extern FILE *freopen(const  char *__restrict __filename , const  char *__restrict __modes , FILE *__restrict __stream ) __asm__( "" "freopen64");
extern FILE *fopen64(const  char *__restrict __filename , const  char *__restrict __modes );
extern FILE *freopen64(const  char *__restrict __filename , const  char *__restrict __modes , FILE *__restrict __stream );
extern FILE *fdopen(int __fd , const  char *__modes ) __attribute__((__nothrow__));
extern FILE *fopencookie(void *__restrict __magic_cookie , const  char *__restrict __modes , _IO_cookie_io_functions_t __io_funcs ) __attribute__((__nothrow__));
extern FILE *fmemopen(void *__s , size_t __len , const  char *__modes ) __attribute__((__nothrow__));
extern FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) __attribute__((__nothrow__));
extern void setbuf(FILE *__restrict __stream , char *__restrict __buf ) __attribute__((__nothrow__));
extern int setvbuf(FILE *__restrict __stream , char *__restrict __buf , int __modes , size_t __n ) __attribute__((__nothrow__));
extern void setbuffer(FILE *__restrict __stream , char *__restrict __buf , size_t __size ) __attribute__((__nothrow__));
extern void setlinebuf(FILE *__stream ) __attribute__((__nothrow__));
extern int fprintf(FILE *__restrict __stream , const  char *__restrict __format , ...);
extern int printf(const  char *__restrict __format , ...);
extern int sprintf(char *__restrict __s , const  char *__restrict __format , ...) __attribute__((__nothrow__));
extern int vfprintf(FILE *__restrict __s , const  char *__restrict __format , __gnuc_va_list __arg );
extern int vprintf(const  char *__restrict __format , __gnuc_va_list __arg );
extern int vsprintf(char *__restrict __s , const  char *__restrict __format , __gnuc_va_list __arg ) __attribute__((__nothrow__));
extern int snprintf(char *__restrict __s , size_t __maxlen , const  char *__restrict __format , ...) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 3, 4)));
extern int vsnprintf(char *__restrict __s , size_t __maxlen , const  char *__restrict __format , __gnuc_va_list __arg ) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 3, 0)));
extern int vasprintf(char **__restrict __ptr , const  char *__restrict __f , __gnuc_va_list __arg ) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 2, 0)));
extern int __asprintf(char **__restrict __ptr , const  char *__restrict __fmt , ...) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 2, 3)));
extern int asprintf(char **__restrict __ptr , const  char *__restrict __fmt , ...) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 2, 3)));
extern int vdprintf(int __fd , const  char *__restrict __fmt , __gnuc_va_list __arg ) __attribute__((__format__ (__printf__, 2, 0)));
extern int dprintf(int __fd , const  char *__restrict __fmt , ...) __attribute__((__format__ (__printf__, 2, 3)));
extern int fscanf(FILE *__restrict __stream , const  char *__restrict __format , ...);
extern int scanf(const  char *__restrict __format , ...);
extern int sscanf(const  char *__restrict __s , const  char *__restrict __format , ...) __attribute__((__nothrow__));
extern int vfscanf(FILE *__restrict __s , const  char *__restrict __format , __gnuc_va_list __arg ) __attribute__((__format__ (__scanf__, 2, 0)));
extern int vscanf(const  char *__restrict __format , __gnuc_va_list __arg ) __attribute__((__format__ (__scanf__, 1, 0)));
extern int vsscanf(const  char *__restrict __s , const  char *__restrict __format , __gnuc_va_list __arg ) __attribute__((__nothrow__)) __attribute__((__format__ (__scanf__, 2, 0)));
extern int fgetc(FILE *__stream );
extern int getc(FILE *__stream );
extern int getchar(void );
extern int getc_unlocked(FILE *__stream );
extern int getchar_unlocked(void );
extern int fgetc_unlocked(FILE *__stream );
extern int fputc(int __c , FILE *__stream );
extern int putc(int __c , FILE *__stream );
extern int putchar(int __c );
extern int fputc_unlocked(int __c , FILE *__stream );
extern int putc_unlocked(int __c , FILE *__stream );
extern int putchar_unlocked(int __c );
extern int getw(FILE *__stream );
extern int putw(int __w , FILE *__stream );
extern char *fgets(char *__restrict __s , int __n , FILE *__restrict __stream );
extern char *fgets_unlocked(char *__restrict __s , int __n , FILE *__restrict __stream );
extern __ssize_t __getdelim(char **__restrict __lineptr , size_t *__restrict __n , int __delimiter , FILE *__restrict __stream );
extern __ssize_t getdelim(char **__restrict __lineptr , size_t *__restrict __n , int __delimiter , FILE *__restrict __stream );
extern __ssize_t getline(char **__restrict __lineptr , size_t *__restrict __n , FILE *__restrict __stream );
extern int fputs(const  char *__restrict __s , FILE *__restrict __stream );
extern int puts(const  char *__s );
extern int ungetc(int __c , FILE *__stream );
extern size_t fread(void *__restrict __ptr , size_t __size , size_t __n , FILE *__restrict __stream );
extern size_t fwrite(const  void *__restrict __ptr , size_t __size , size_t __n , FILE *__restrict __s );
extern int fputs_unlocked(const  char *__restrict __s , FILE *__restrict __stream );
extern size_t fread_unlocked(void *__restrict __ptr , size_t __size , size_t __n , FILE *__restrict __stream );
extern size_t fwrite_unlocked(const  void *__restrict __ptr , size_t __size , size_t __n , FILE *__restrict __stream );
extern int fseek(FILE *__stream , long  int __off , int __whence );
extern long int ftell(FILE *__stream );
extern void rewind(FILE *__stream );
extern int fseeko(FILE *__stream , __off64_t __off , int __whence ) __asm__( "" "fseeko64");
extern __off64_t ftello(FILE *__stream ) __asm__( "" "ftello64");
extern int fgetpos(FILE *__restrict __stream , fpos_t *__restrict __pos ) __asm__( "" "fgetpos64");
extern int fsetpos(FILE *__stream , const  fpos_t *__pos ) __asm__( "" "fsetpos64");
extern int fseeko64(FILE *__stream , __off64_t __off , int __whence );
extern __off64_t ftello64(FILE *__stream );
extern int fgetpos64(FILE *__restrict __stream , fpos64_t *__restrict __pos );
extern int fsetpos64(FILE *__stream , const  fpos64_t *__pos );
extern void clearerr(FILE *__stream ) __attribute__((__nothrow__));
extern int feof(FILE *__stream ) __attribute__((__nothrow__));
extern int ferror(FILE *__stream ) __attribute__((__nothrow__));
extern void clearerr_unlocked(FILE *__stream ) __attribute__((__nothrow__));
extern int feof_unlocked(FILE *__stream ) __attribute__((__nothrow__));
extern int ferror_unlocked(FILE *__stream ) __attribute__((__nothrow__));
extern void perror(const  char *__s );
extern int sys_nerr;
extern const char *const sys_errlist[];
extern int _sys_nerr;
extern const char *const _sys_errlist[];
extern int fileno(FILE *__stream ) __attribute__((__nothrow__));
extern int fileno_unlocked(FILE *__stream ) __attribute__((__nothrow__));
extern FILE *popen(const  char *__command , const  char *__modes );
extern int pclose(FILE *__stream );
extern char *ctermid(char *__s ) __attribute__((__nothrow__));
extern char *cuserid(char *__s );
struct  obstack   ;
extern int obstack_printf(struct  obstack   *__restrict __obstack , const  char *__restrict __format , ...) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf(struct  obstack   *__restrict __obstack , const  char *__restrict __format , __gnuc_va_list __args ) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 2, 0)));
extern void flockfile(FILE *__stream ) __attribute__((__nothrow__));
extern int ftrylockfile(FILE *__stream ) __attribute__((__nothrow__));
extern void funlockfile(FILE *__stream ) __attribute__((__nothrow__));
typedef int wchar_t;
typedef enum  {
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
static  inline  unsigned  int __bswap_32(unsigned  int __bsx )  {
  return __builtin_bswap32(__bsx);
}
static  inline  __uint64_t __bswap_64(__uint64_t __bsx )  {
  return __builtin_bswap64(__bsx);
}
union  wait {
  int w_status ;
  struct   {
    unsigned  int __w_termsig: 7 ;
    unsigned  int __w_coredump: 1 ;
    unsigned  int __w_retcode: 8 ;
    unsigned  int : 16 ;
  }  __wait_terminated ;
  struct   {
    unsigned  int __w_stopval: 8 ;
    unsigned  int __w_stopsig: 8 ;
    unsigned  int : 16 ;
  }  __wait_stopped ;
}  ;
typedef union   {
  union  wait   *__uptr ;
  int *__iptr ;
}  __WAIT_STATUS __attribute__((__transparent_union__));
typedef struct   {
  int quot ;
  int rem ;
}  div_t;
typedef struct   {
  long  int quot ;
  long  int rem ;
}  ldiv_t;
typedef struct   {
  long  long  int quot ;
  long  long  int rem ;
}  lldiv_t;
extern size_t __ctype_get_mb_cur_max(void ) __attribute__((__nothrow__));
extern double atof(const  char *__nptr ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern int atoi(const  char *__nptr ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern long int atol(const  char *__nptr ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern long long int atoll(const  char *__nptr ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern double strtod(const  char *__restrict __nptr , char **__restrict __endptr ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern float strtof(const  char *__restrict __nptr , char **__restrict __endptr ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long double strtold(const  char *__restrict __nptr , char **__restrict __endptr ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long int strtol(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern unsigned long int strtoul(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long long int strtoq(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern unsigned long long int strtouq(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long long int strtoll(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern unsigned long long int strtoull(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
typedef struct  __locale_struct {
  struct  __locale_data   *__locales[13] ;
  const  unsigned  short  int *__ctype_b ;
  const  int *__ctype_tolower ;
  const  int *__ctype_toupper ;
  const  char *__names[13] ;
}  *__locale_t;
typedef __locale_t locale_t;
extern long int strtol_l(const  char *__restrict __nptr , char **__restrict __endptr , int __base , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 4)));
extern unsigned long int strtoul_l(const  char *__restrict __nptr , char **__restrict __endptr , int __base , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 4)));
extern long long int strtoll_l(const  char *__restrict __nptr , char **__restrict __endptr , int __base , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 4)));
extern unsigned long long int strtoull_l(const  char *__restrict __nptr , char **__restrict __endptr , int __base , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 4)));
extern double strtod_l(const  char *__restrict __nptr , char **__restrict __endptr , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 3)));
extern float strtof_l(const  char *__restrict __nptr , char **__restrict __endptr , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 3)));
extern long double strtold_l(const  char *__restrict __nptr , char **__restrict __endptr , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 3)));
extern char *l64a(long  int __n ) __attribute__((__nothrow__));
extern long int a64l(const  char *__s ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
typedef __loff_t loff_t;
typedef __ino64_t ino_t;
typedef __ino64_t ino64_t;
typedef __dev_t dev_t;
typedef __gid_t gid_t;
typedef __mode_t mode_t;
typedef __nlink_t nlink_t;
typedef __uid_t uid_t;
typedef __pid_t pid_t;
typedef __id_t id_t;
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
typedef __key_t key_t;
typedef __clock_t clock_t;
typedef __time_t time_t;
typedef __clockid_t clockid_t;
typedef __timer_t timer_t;
typedef __useconds_t useconds_t;
typedef __suseconds_t suseconds_t;
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
typedef int _1268_int8_t __attribute__((__mode__ (__QI__)));
typedef int _1268_int16_t __attribute__((__mode__ (__HI__)));
typedef int _1268_int32_t __attribute__((__mode__ (__SI__)));
typedef int _1268_int64_t __attribute__((__mode__ (__DI__)));
typedef unsigned int u_int8_t __attribute__((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__((__mode__ (__DI__)));
typedef int register_t __attribute__((__mode__ (__word__)));
typedef int __sig_atomic_t;
typedef struct   {
  unsigned  long  int __val[(1024 / (8 * sizeof(unsigned  long  int )))] ;
}  __sigset_t;
typedef __sigset_t sigset_t;
struct  timespec {
  __time_t tv_sec ;
  __syscall_slong_t tv_nsec ;
}  ;
struct  timeval {
  __time_t tv_sec ;
  __suseconds_t tv_usec ;
}  ;
typedef long int __fd_mask;
typedef struct   {
  __fd_mask fds_bits[(1024 / (8 * ((int ) sizeof(__fd_mask ))))] ;
}  fd_set;
typedef __fd_mask fd_mask;
extern int select(int __nfds , fd_set *__restrict __readfds , fd_set *__restrict __writefds , fd_set *__restrict __exceptfds , struct  timeval   *__restrict __timeout );
extern int pselect(int __nfds , fd_set *__restrict __readfds , fd_set *__restrict __writefds , fd_set *__restrict __exceptfds , const  struct  timespec   *__restrict __timeout , const  __sigset_t *__restrict __sigmask );
extern unsigned int gnu_dev_major(unsigned  long  long  int __dev ) __attribute__((__nothrow__)) __attribute__((__const__));
extern unsigned int gnu_dev_minor(unsigned  long  long  int __dev ) __attribute__((__nothrow__)) __attribute__((__const__));
extern unsigned long long int gnu_dev_makedev(unsigned  int __major , unsigned  int __minor ) __attribute__((__nothrow__)) __attribute__((__const__));
typedef __blksize_t blksize_t;
typedef __blkcnt64_t blkcnt_t;
typedef __fsblkcnt64_t fsblkcnt_t;
typedef __fsfilcnt64_t fsfilcnt_t;
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
typedef unsigned long int pthread_t;
union  pthread_attr_t {
  char __size[56] ;
  long  int __align ;
}  ;
typedef union  pthread_attr_t   pthread_attr_t;
typedef struct  __pthread_internal_list {
  struct  __pthread_internal_list   *__prev ;
  struct  __pthread_internal_list   *__next ;
}  __pthread_list_t;
typedef union   {
  struct  __pthread_mutex_s {
    int __lock ;
    unsigned  int __count ;
    int __owner ;
    unsigned  int __nusers ;
    int __kind ;
    short __spins ;
    short __elision ;
    __pthread_list_t __list ;
  }  __data ;
  char __size[40] ;
  long  int __align ;
}  pthread_mutex_t;
typedef union   {
  char __size[4] ;
  int __align ;
}  pthread_mutexattr_t;
typedef union   {
  struct   {
    int __lock ;
    unsigned  int __futex ;
    unsigned  long  long  int __total_seq ;
    unsigned  long  long  int __wakeup_seq ;
    unsigned  long  long  int __woken_seq ;
    void *__mutex ;
    unsigned  int __nwaiters ;
    unsigned  int __broadcast_seq ;
  }  __data ;
  char __size[48] ;
  long  long  int __align ;
}  pthread_cond_t;
typedef union   {
  char __size[4] ;
  int __align ;
}  pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
typedef union   {
  struct   {
    int __lock ;
    unsigned  int __nr_readers ;
    unsigned  int __readers_wakeup ;
    unsigned  int __writer_wakeup ;
    unsigned  int __nr_readers_queued ;
    unsigned  int __nr_writers_queued ;
    int __writer ;
    int __shared ;
    unsigned  long  int __pad1 ;
    unsigned  long  int __pad2 ;
    unsigned  int __flags ;
  }  __data ;
  char __size[56] ;
  long  int __align ;
}  pthread_rwlock_t;
typedef union   {
  char __size[8] ;
  long  int __align ;
}  pthread_rwlockattr_t;
typedef volatile int pthread_spinlock_t;
typedef union   {
  char __size[32] ;
  long  int __align ;
}  pthread_barrier_t;
typedef union   {
  char __size[4] ;
  int __align ;
}  pthread_barrierattr_t;
extern long int random(void ) __attribute__((__nothrow__));
extern void srandom(unsigned  int __seed ) __attribute__((__nothrow__));
extern char *initstate(unsigned  int __seed , char *__statebuf , size_t __statelen ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern char *setstate(char *__statebuf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
struct  random_data {
  _1266_int32_t *_1266_fptr ;
  _1268_int32_t *_1268_fptr ;
  _1266_int32_t *_1266_rptr ;
  _1268_int32_t *_1268_rptr ;
  _1266_int32_t *_1266_state ;
  _1268_int32_t *_1268_state ;
  int rand_type ;
  int rand_deg ;
  int rand_sep ;
  _1266_int32_t *_1266_end_ptr ;
  _1268_int32_t *_1268_end_ptr ;
}  ;
extern int random_r(struct  random_data   *__restrict __buf , _1266_int32_t *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
/*id2i.remove: removed unused variant for the following declaration: extern int random_r(struct  random_data   *__restrict __buf , _1268_int32_t *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));*/
extern int srandom_r(unsigned  int __seed , struct  random_data   *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int initstate_r(unsigned  int __seed , char *__restrict __statebuf , size_t __statelen , struct  random_data   *__restrict __buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 4)));
extern int setstate_r(char *__restrict __statebuf , struct  random_data   *__restrict __buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int rand(void ) __attribute__((__nothrow__));
extern void srand(unsigned  int __seed ) __attribute__((__nothrow__));
extern int rand_r(unsigned  int *__seed ) __attribute__((__nothrow__));
extern double drand48(void ) __attribute__((__nothrow__));
extern double erand48(unsigned  short  int __xsubi[3] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long int lrand48(void ) __attribute__((__nothrow__));
extern long int nrand48(unsigned  short  int __xsubi[3] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long int mrand48(void ) __attribute__((__nothrow__));
extern long int jrand48(unsigned  short  int __xsubi[3] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void srand48(long  int __seedval ) __attribute__((__nothrow__));
extern unsigned short int *seed48(unsigned  short  int __seed16v[3] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void lcong48(unsigned  short  int __param[7] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
struct  drand48_data {
  unsigned  short  int __x[3] ;
  unsigned  short  int __old_x[3] ;
  unsigned  short  int __c ;
  unsigned  short  int __init ;
  unsigned  long  long  int __a ;
}  ;
extern int drand48_r(struct  drand48_data   *__restrict __buffer , double *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int erand48_r(unsigned  short  int __xsubi[3] , struct  drand48_data   *__restrict __buffer , double *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int lrand48_r(struct  drand48_data   *__restrict __buffer , long  int *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int nrand48_r(unsigned  short  int __xsubi[3] , struct  drand48_data   *__restrict __buffer , long  int *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int mrand48_r(struct  drand48_data   *__restrict __buffer , long  int *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int jrand48_r(unsigned  short  int __xsubi[3] , struct  drand48_data   *__restrict __buffer , long  int *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int srand48_r(long  int __seedval , struct  drand48_data   *__buffer ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int seed48_r(unsigned  short  int __seed16v[3] , struct  drand48_data   *__buffer ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int lcong48_r(unsigned  short  int __param[7] , struct  drand48_data   *__buffer ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void *malloc(size_t __size ) __attribute__((__nothrow__)) __attribute__((__malloc__));
extern void *calloc(size_t __nmemb , size_t __size ) __attribute__((__nothrow__)) __attribute__((__malloc__));
extern void *realloc(void *__ptr , size_t __size ) __attribute__((__nothrow__)) __attribute__((__warn_unused_result__));
extern void free(void *__ptr ) __attribute__((__nothrow__));
extern void cfree(void *__ptr ) __attribute__((__nothrow__));
extern void *alloca(size_t __size ) __attribute__((__nothrow__));
extern void *valloc(size_t __size ) __attribute__((__nothrow__)) __attribute__((__malloc__));
extern int posix_memalign(void **__memptr , size_t __alignment , size_t __size ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void *aligned_alloc(size_t __alignment , size_t __size ) __attribute__((__nothrow__)) __attribute__((__malloc__)) __attribute__((__alloc_size__ (2)));
extern void abort(void ) __attribute__((__nothrow__)) __attribute__((__noreturn__));
extern int atexit(void ( *__func)(void ) ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int at_quick_exit(void ( *__func)(void ) ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int on_exit(void ( *__func)(int __status , void *__arg ) , void *__arg ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void exit(int __status ) __attribute__((__nothrow__)) __attribute__((__noreturn__));
extern void quick_exit(int __status ) __attribute__((__nothrow__)) __attribute__((__noreturn__));
extern void _Exit(int __status ) __attribute__((__nothrow__)) __attribute__((__noreturn__));
extern char *getenv(const  char *__name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern char *secure_getenv(const  char *__name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int putenv(char *__string ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int setenv(const  char *__name , const  char *__value , int __replace ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int unsetenv(const  char *__name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int clearenv(void ) __attribute__((__nothrow__));
extern char *mktemp(char *__template ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int mkstemp(char *__template ) __asm__( "" "mkstemp64") __attribute__((__nonnull__ (1)));
extern int mkstemp64(char *__template ) __attribute__((__nonnull__ (1)));
extern int mkstemps(char *__template , int __suffixlen ) __asm__( "" "mkstemps64") __attribute__((__nonnull__ (1)));
extern int mkstemps64(char *__template , int __suffixlen ) __attribute__((__nonnull__ (1)));
extern char *mkdtemp(char *__template ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int mkostemp(char *__template , int __flags ) __asm__( "" "mkostemp64") __attribute__((__nonnull__ (1)));
extern int mkostemp64(char *__template , int __flags ) __attribute__((__nonnull__ (1)));
extern int mkostemps(char *__template , int __suffixlen , int __flags ) __asm__( "" "mkostemps64") __attribute__((__nonnull__ (1)));
extern int mkostemps64(char *__template , int __suffixlen , int __flags ) __attribute__((__nonnull__ (1)));
extern int system(const  char *__command );
extern char *canonicalize_file_name(const  char *__name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern char *realpath(const  char *__restrict __name , char *__restrict __resolved ) __attribute__((__nothrow__));
typedef int ( *__compar_fn_t)(const  void * , const  void * );
typedef __compar_fn_t comparison_fn_t;
typedef int ( *__compar_d_fn_t)(const  void * , const  void * , void * );
extern void *bsearch(const  void *__key , const  void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) __attribute__((__nonnull__ (1, 2, 5)));
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) __attribute__((__nonnull__ (1, 4)));
extern void qsort_r(void *__base , size_t __nmemb , size_t __size , __compar_d_fn_t __compar , void *__arg ) __attribute__((__nonnull__ (1, 4)));
extern int abs(int __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long int labs(long  int __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long long int llabs(long  long  int __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern div_t div(int __numer , int __denom ) __attribute__((__nothrow__)) __attribute__((__const__));
extern ldiv_t ldiv(long  int __numer , long  int __denom ) __attribute__((__nothrow__)) __attribute__((__const__));
extern lldiv_t lldiv(long  long  int __numer , long  long  int __denom ) __attribute__((__nothrow__)) __attribute__((__const__));
extern char *ecvt(double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4)));
extern char *fcvt(double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4)));
extern char *gcvt(double __value , int __ndigit , char *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3)));
extern char *qecvt(long  double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4)));
extern char *qfcvt(long  double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4)));
extern char *qgcvt(long  double __value , int __ndigit , char *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3)));
extern int ecvt_r(double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign , char *__restrict __buf , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4, 5)));
extern int fcvt_r(double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign , char *__restrict __buf , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4, 5)));
extern int qecvt_r(long  double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign , char *__restrict __buf , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4, 5)));
extern int qfcvt_r(long  double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign , char *__restrict __buf , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4, 5)));
extern int mblen(const  char *__s , size_t __n ) __attribute__((__nothrow__));
extern int mbtowc(wchar_t *__restrict __pwc , const  char *__restrict __s , size_t __n ) __attribute__((__nothrow__));
extern int wctomb(char *__s , wchar_t __wchar ) __attribute__((__nothrow__));
extern size_t mbstowcs(wchar_t *__restrict __pwcs , const  char *__restrict __s , size_t __n ) __attribute__((__nothrow__));
extern size_t wcstombs(char *__restrict __s , const  wchar_t *__restrict __pwcs , size_t __n ) __attribute__((__nothrow__));
extern int rpmatch(const  char *__response ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int getsubopt(char **__restrict __optionp , char *const *__restrict __tokens , char **__restrict __valuep ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2, 3)));
extern void setkey(const  char *__key ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int posix_openpt(int __oflag );
extern int grantpt(int __fd ) __attribute__((__nothrow__));
extern int unlockpt(int __fd ) __attribute__((__nothrow__));
extern char *ptsname(int __fd ) __attribute__((__nothrow__));
extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int getpt(void );
extern int getloadavg(double __loadavg[] , int __nelem ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void *memcpy(void *__restrict __dest , const  void *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void *memmove(void *__dest , const  void *__src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void *memccpy(void *__restrict __dest , const  void *__restrict __src , int __c , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void *memset(void *__s , int __c , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int memcmp(const  void *__s1 , const  void *__s2 , size_t __n ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern void *memchr(const  void *__s , int __c , size_t __n ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern void *rawmemchr(const  void *__s , int __c ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern void *memrchr(const  void *__s , int __c , size_t __n ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern char *strcpy(char *__restrict __dest , const  char *__restrict __src ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *strncpy(char *__restrict __dest , const  char *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *strcat(char *__restrict __dest , const  char *__restrict __src ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *strncat(char *__restrict __dest , const  char *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int strcmp(const  char *__s1 , const  char *__s2 ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern int strncmp(const  char *__s1 , const  char *__s2 , size_t __n ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern int strcoll(const  char *__s1 , const  char *__s2 ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern size_t strxfrm(char *__restrict __dest , const  char *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int strcoll_l(const  char *__s1 , const  char *__s2 , __locale_t __l ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2, 3)));
extern size_t strxfrm_l(char *__dest , const  char *__src , size_t __n , __locale_t __l ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 4)));
extern char *strdup(const  char *__s ) __attribute__((__nothrow__)) __attribute__((__malloc__)) __attribute__((__nonnull__ (1)));
extern char *strndup(const  char *__string , size_t __n ) __attribute__((__nothrow__)) __attribute__((__malloc__)) __attribute__((__nonnull__ (1)));
extern char *strchr(const  char *__s , int __c ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern char *strrchr(const  char *__s , int __c ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern char *strchrnul(const  char *__s , int __c ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern size_t strcspn(const  char *__s , const  char *__reject ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern size_t strspn(const  char *__s , const  char *__accept ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern char *strpbrk(const  char *__s , const  char *__accept ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern char *strstr(const  char *__haystack , const  char *__needle ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern char *strtok(char *__restrict __s , const  char *__restrict __delim ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern char *__strtok_r(char *__restrict __s , const  char *__restrict __delim , char **__restrict __save_ptr ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern char *strtok_r(char *__restrict __s , const  char *__restrict __delim , char **__restrict __save_ptr ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern char *strcasestr(const  char *__haystack , const  char *__needle ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern void *memmem(const  void *__haystack , size_t __haystacklen , const  void *__needle , size_t __needlelen ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 3)));
extern void *__mempcpy(void *__restrict __dest , const  void *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void *mempcpy(void *__restrict __dest , const  void *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern size_t strlen(const  char *__s ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern size_t strnlen(const  char *__string , size_t __maxlen ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern char *strerror(int __errnum ) __attribute__((__nothrow__));
extern char *strerror_r(int __errnum , char *__buf , size_t __buflen ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern char *strerror_l(int __errnum , __locale_t __l ) __attribute__((__nothrow__));
extern void __bzero(void *__s , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void bcopy(const  void *__src , void *__dest , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void bzero(void *__s , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int bcmp(const  void *__s1 , const  void *__s2 , size_t __n ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern char *index(const  char *__s , int __c ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern char *rindex(const  char *__s , int __c ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern int ffs(int __i ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int ffsl(long  int __l ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int ffsll(long  long  int __ll ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int strcasecmp(const  char *__s1 , const  char *__s2 ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern int strncasecmp(const  char *__s1 , const  char *__s2 , size_t __n ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern int strcasecmp_l(const  char *__s1 , const  char *__s2 , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2, 3)));
extern int strncasecmp_l(const  char *__s1 , const  char *__s2 , size_t __n , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2, 4)));
extern char *strsep(char **__restrict __stringp , const  char *__restrict __delim ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *strsignal(int __sig ) __attribute__((__nothrow__));
extern char *__stpcpy(char *__restrict __dest , const  char *__restrict __src ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *stpcpy(char *__restrict __dest , const  char *__restrict __src ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *__stpncpy(char *__restrict __dest , const  char *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *stpncpy(char *__restrict __dest , const  char *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int strverscmp(const  char *__s1 , const  char *__s2 ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern char *strfry(char *__string ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void *memfrob(void *__s , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern char *basename(const  char *__filename ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
typedef long int ptrdiff_t;
typedef sqlite_int64 i64;
typedef sqlite_uint64 u64;
typedef unsigned int u32;
typedef unsigned short int u16;
typedef short int i16;
typedef unsigned char u8;
typedef signed char i8;
typedef u32 tRowcnt;
typedef short int LogEst;
static const int sqlite3one =  1;
typedef struct  BusyHandler   BusyHandler;
struct  BusyHandler {
  int ( *xFunc)(void * , int ) ;
  void *pArg ;
  int nBusy ;
}  ;
typedef struct  AggInfo   AggInfo;
typedef struct  AuthContext   AuthContext;
typedef struct  AutoincInfo   AutoincInfo;
typedef struct  Bitvec   Bitvec;
typedef struct  CollSeq   CollSeq;
typedef struct  Column   Column;
typedef struct  Db   Db;
typedef struct  Schema   Schema;
typedef struct  Expr   Expr;
typedef struct  ExprList   ExprList;
typedef struct  ExprSpan   ExprSpan;
typedef struct  FKey   FKey;
typedef struct  FuncDestructor   FuncDestructor;
typedef struct  FuncDef   FuncDef;
typedef struct  FuncDefHash   FuncDefHash;
typedef struct  IdList   IdList;
typedef struct  Index   Index;
typedef struct  IndexSample   IndexSample;
typedef struct  KeyClass   KeyClass;
typedef struct  KeyInfo   KeyInfo;
typedef struct  Lookaside   Lookaside;
typedef struct  LookasideSlot   LookasideSlot;
typedef struct  Module   Module;
typedef struct  NameContext   NameContext;
typedef struct  Parse   Parse;
typedef struct  RowSet   RowSet;
typedef struct  Savepoint   Savepoint;
typedef struct  Select   Select;
typedef struct  SelectDest   SelectDest;
typedef struct  SrcList   SrcList;
typedef struct  StrAccum   StrAccum;
typedef struct  Table   Table;
typedef struct  TableLock   TableLock;
typedef struct  Token   Token;
typedef struct  Trigger   Trigger;
typedef struct  TriggerPrg   TriggerPrg;
typedef struct  TriggerStep   TriggerStep;
typedef struct  UnpackedRecord   UnpackedRecord;
typedef struct  VTable   VTable;
typedef struct  VtabCtx   VtabCtx;
typedef struct  Walker   Walker;
typedef struct  WhereInfo   WhereInfo;
typedef struct  Btree   Btree;
typedef struct  BtCursor   BtCursor;
typedef struct  BtShared   BtShared;
static int sqlite3BtreeOpen(sqlite3_vfs *pVfs , const  char *zFilename , sqlite3 *db , Btree **ppBtree , int flags , int vfsFlags );
static int sqlite3BtreeClose(Btree * );
static int sqlite3BtreeSetCacheSize(Btree * , int );
static int sqlite3BtreeSetMmapLimit(Btree * , sqlite3_int64 );
static int sqlite3BtreeSetPagerFlags(Btree * , unsigned );
static int sqlite3BtreeSyncDisabled(Btree * );
static int sqlite3BtreeSetPageSize(Btree *p , int nPagesize , int nReserve , int eFix );
static int sqlite3BtreeGetPageSize(Btree * );
static int sqlite3BtreeMaxPageCount(Btree * , int );
static u32 sqlite3BtreeLastPage(Btree * );
static int sqlite3BtreeSecureDelete(Btree * , int );
static int sqlite3BtreeGetReserve(Btree * );
static int sqlite3BtreeSetAutoVacuum(Btree * , int );
static int sqlite3BtreeGetAutoVacuum(Btree * );
static int sqlite3BtreeBeginTrans(Btree * , int );
static int sqlite3BtreeCommitPhaseOne(Btree * , const  char *zMaster );
static int sqlite3BtreeCommitPhaseTwo(Btree * , int );
static int sqlite3BtreeCommit(Btree * );
static int sqlite3BtreeRollback(Btree * , int );
static int sqlite3BtreeBeginStmt(Btree * , int );
static int sqlite3BtreeCreateTable(Btree * , int * , int flags );
static int sqlite3BtreeIsInTrans(Btree * );
static int sqlite3BtreeIsInReadTrans(Btree * );
static int sqlite3BtreeIsInBackup(Btree * );
static void *sqlite3BtreeSchema(Btree * , int , void ( *)(void * ) );
static int sqlite3BtreeSchemaLocked(Btree *pBtree );
static int sqlite3BtreeLockTable(Btree *pBtree , int iTab , u8 isWriteLock );
static int sqlite3BtreeSavepoint(Btree * , int , int );
static const char *sqlite3BtreeGetFilename(Btree * );
static const char *sqlite3BtreeGetJournalname(Btree * );
static int sqlite3BtreeCopyFile(Btree * , Btree * );
static int sqlite3BtreeIncrVacuum(Btree * );
static int sqlite3BtreeDropTable(Btree * , int , int * );
static int sqlite3BtreeClearTable(Btree * , int , int * );
static void sqlite3BtreeTripAllCursors(Btree * , int );
static void sqlite3BtreeGetMeta(Btree *pBtree , int idx , u32 *pValue );
static int sqlite3BtreeUpdateMeta(Btree * , int idx , u32 value );
static int sqlite3BtreeNewDb(Btree *p );
static int sqlite3BtreeCursor(Btree * , int iTable , int wrFlag , struct  KeyInfo   * , BtCursor *pCursor );
static int sqlite3BtreeCursorSize(void );
static void sqlite3BtreeCursorZero(BtCursor * );
static int sqlite3BtreeCloseCursor(BtCursor * );
static int sqlite3BtreeMovetoUnpacked(BtCursor * , UnpackedRecord *pUnKey , i64 intKey , int bias , int *pRes );
static int sqlite3BtreeCursorHasMoved(BtCursor * , int * );
static int sqlite3BtreeDelete(BtCursor * );
static int sqlite3BtreeInsert(BtCursor * , const  void *pKey , i64 nKey , const  void *pData , int nData , int nZero , int bias , int seekResult );
static int sqlite3BtreeFirst(BtCursor * , int *pRes );
static int sqlite3BtreeLast(BtCursor * , int *pRes );
static int sqlite3BtreeNext(BtCursor * , int *pRes );
static int sqlite3BtreeEof(BtCursor * );
static int sqlite3BtreePrevious(BtCursor * , int *pRes );
static int sqlite3BtreeKeySize(BtCursor * , i64 *pSize );
static int sqlite3BtreeKey(BtCursor * , u32 offset , u32 amt , void * );
static const void *sqlite3BtreeKeyFetch(BtCursor * , int *pAmt );
static const void *sqlite3BtreeDataFetch(BtCursor * , int *pAmt );
static int sqlite3BtreeDataSize(BtCursor * , u32 *pSize );
static int sqlite3BtreeData(BtCursor * , u32 offset , u32 amt , void * );
static void sqlite3BtreeSetCachedRowid(BtCursor * , sqlite3_int64 );
static sqlite3_int64 sqlite3BtreeGetCachedRowid(BtCursor * );
static char *sqlite3BtreeIntegrityCheck(Btree * , int *aRoot , int nRoot , int , int * );
static struct  Pager   *sqlite3BtreePager(Btree * );
static int sqlite3BtreePutData(BtCursor * , u32 offset , u32 amt , void * );
static void sqlite3BtreeCacheOverflow(BtCursor * );
static void sqlite3BtreeClearCursor(BtCursor * );
static int sqlite3BtreeSetVersion(Btree *pBt , int iVersion );
static void sqlite3BtreeCursorHints(BtCursor * , unsigned  int mask );
static int sqlite3BtreeCount(BtCursor * , i64 * );
static int sqlite3BtreeCheckpoint(Btree * , int , int * , int * );
static void sqlite3BtreeEnter(Btree * );
static void sqlite3BtreeEnterAll(sqlite3 * );
typedef struct  Vdbe   Vdbe;
typedef struct  Mem   Mem;
typedef struct  SubProgram   SubProgram;
struct  VdbeOp {
  u8 opcode ;
  signed  char p4type ;
  u8 opflags ;
  u8 p5 ;
  int p1 ;
  int p2 ;
  int p3 ;
  union   {
    int i ;
    void *p ;
    char *z ;
    i64 *pI64 ;
    double *pReal ;
    FuncDef *pFunc ;
    CollSeq *pColl ;
    Mem *pMem ;
    VTable *pVtab ;
    KeyInfo *pKeyInfo ;
    int *ai ;
    SubProgram *pProgram ;
    int ( *xAdvance)(BtCursor * , int * ) ;
  }  p4 ;
  int _1269_cnt ;
  u64 _1269_cycles ;
}  ;
typedef struct  VdbeOp   VdbeOp;
struct  SubProgram {
  VdbeOp *aOp ;
  int nOp ;
  int nMem ;
  int nCsr ;
  int nOnce ;
  void *token ;
  SubProgram *pNext ;
}  ;
struct  VdbeOpList {
  u8 opcode ;
  signed  char p1 ;
  signed  char p2 ;
  signed  char p3 ;
}  ;
typedef struct  VdbeOpList   VdbeOpList;
static Vdbe *sqlite3VdbeCreate(sqlite3 * );
static int sqlite3VdbeAddOp0(Vdbe * , int );
static int sqlite3VdbeAddOp1(Vdbe * , int , int );
static int sqlite3VdbeAddOp2(Vdbe * , int , int , int );
static int sqlite3VdbeAddOp3(Vdbe * , int , int , int , int );
static int sqlite3VdbeAddOp4(Vdbe * , int , int , int , int , const  char *zP4 , int );
static int sqlite3VdbeAddOp4Int(Vdbe * , int , int , int , int , int );
static int sqlite3VdbeAddOpList(Vdbe * , int nOp , VdbeOpList  const *aOp );
static void sqlite3VdbeAddParseSchemaOp(Vdbe * , int , char * );
static void sqlite3VdbeChangeP1(Vdbe * , u32 addr , int P1 );
static void sqlite3VdbeChangeP2(Vdbe * , u32 addr , int P2 );
static void sqlite3VdbeChangeP3(Vdbe * , u32 addr , int P3 );
static void sqlite3VdbeChangeP5(Vdbe * , u8 P5 );
static void sqlite3VdbeJumpHere(Vdbe * , int addr );
static void sqlite3VdbeChangeToNoop(Vdbe * , int addr );
static void sqlite3VdbeChangeP4(Vdbe * , int addr , const  char *zP4 , int N );
static void sqlite3VdbeUsesBtree(Vdbe * , int );
static VdbeOp *sqlite3VdbeGetOp(Vdbe * , int );
static int sqlite3VdbeMakeLabel(Vdbe * );
static void sqlite3VdbeRunOnlyOnce(Vdbe * );
static void sqlite3VdbeDelete(Vdbe * );
static void sqlite3VdbeClearObject(sqlite3 * , Vdbe * );
static void sqlite3VdbeMakeReady(Vdbe * , Parse * );
static int sqlite3VdbeFinalize(Vdbe * );
static void sqlite3VdbeResolveLabel(Vdbe * , int );
static int sqlite3VdbeCurrentAddr(Vdbe * );
static void sqlite3VdbeResetStepResult(Vdbe * );
static void sqlite3VdbeRewind(Vdbe * );
static int sqlite3VdbeReset(Vdbe * );
static void sqlite3VdbeSetNumCols(Vdbe * , int );
static int sqlite3VdbeSetColName(Vdbe * , int , int , const  char * , void ( *)(void * ) );
static void sqlite3VdbeCountChanges(Vdbe * );
static sqlite3 *sqlite3VdbeDb(Vdbe * );
static void sqlite3VdbeSetSql(Vdbe * , const  char *z , int n , int );
static void sqlite3VdbeSwap(Vdbe * , Vdbe * );
static VdbeOp *sqlite3VdbeTakeOpArray(Vdbe * , int * , int * );
static sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe * , int , u8 );
static void sqlite3VdbeSetVarmask(Vdbe * , int );
static char *sqlite3VdbeExpandSql(Vdbe * , const  char * );
static void sqlite3VdbeRecordUnpack(KeyInfo * , int , const  void * , UnpackedRecord * );
static int sqlite3VdbeRecordCompare(int , const  void * , UnpackedRecord * );
static UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(KeyInfo * , char * , int , char ** );
static void sqlite3VdbeLinkSubProgram(Vdbe * , SubProgram * );
typedef u32 Pgno;
typedef struct  Pager   Pager;
typedef struct  PgHdr   DbPage;
static int sqlite3PagerOpen(sqlite3_vfs * , Pager **ppPager , const  char * , int , int , int , void ( *)(DbPage * ) );
static int sqlite3PagerClose(Pager *pPager );
static int sqlite3PagerReadFileheader(Pager * , int , unsigned  char * );
static void sqlite3PagerSetBusyhandler(Pager * , int ( *)(void * ) , void * );
static int sqlite3PagerSetPagesize(Pager * , u32 * , int );
static int sqlite3PagerMaxPageCount(Pager * , int );
static void sqlite3PagerSetCachesize(Pager * , int );
static void sqlite3PagerSetMmapLimit(Pager * , sqlite3_int64 );
static void sqlite3PagerShrink(Pager * );
static void sqlite3PagerSetFlags(Pager * , unsigned );
static int sqlite3PagerLockingMode(Pager * , int );
static int sqlite3PagerSetJournalMode(Pager * , int );
static int sqlite3PagerGetJournalMode(Pager * );
static int sqlite3PagerOkToChangeJournalMode(Pager * );
static i64 sqlite3PagerJournalSizeLimit(Pager * , i64 );
static sqlite3_backup **sqlite3PagerBackupPtr(Pager * );
static int sqlite3PagerAcquire(Pager *pPager , Pgno pgno , DbPage **ppPage , int clrFlag );
static DbPage *sqlite3PagerLookup(Pager *pPager , Pgno pgno );
static void sqlite3PagerRef(DbPage * );
static void sqlite3PagerUnref(DbPage * );
static int sqlite3PagerWrite(DbPage * );
static void sqlite3PagerDontWrite(DbPage * );
static int sqlite3PagerMovepage(Pager * , DbPage * , Pgno , int );
static int sqlite3PagerPageRefcount(DbPage * );
static void *sqlite3PagerGetData(DbPage * );
static void *sqlite3PagerGetExtra(DbPage * );
static void sqlite3PagerPagecount(Pager * , int * );
static int sqlite3PagerBegin(Pager * , int exFlag , int );
static int sqlite3PagerCommitPhaseOne(Pager * , const  char *zMaster , int );
static int sqlite3PagerExclusiveLock(Pager * );
static int sqlite3PagerSync(Pager *pPager );
static int sqlite3PagerCommitPhaseTwo(Pager * );
static int sqlite3PagerRollback(Pager * );
static int sqlite3PagerOpenSavepoint(Pager *pPager , int n );
static int sqlite3PagerSavepoint(Pager *pPager , int op , int iSavepoint );
static int sqlite3PagerSharedLock(Pager *pPager );
static int sqlite3PagerCheckpoint(Pager *pPager , int , int * , int * );
static int sqlite3PagerWalSupported(Pager *pPager );
static int sqlite3PagerWalCallback(Pager *pPager );
static int sqlite3PagerOpenWal(Pager *pPager , int *pisOpen );
static int sqlite3PagerCloseWal(Pager *pPager );
static u8 sqlite3PagerIsreadonly(Pager * );
static int sqlite3PagerRefcount(Pager * );
static int sqlite3PagerMemUsed(Pager * );
static const char *sqlite3PagerFilename(Pager * , int );
static const sqlite3_vfs *sqlite3PagerVfs(Pager * );
static sqlite3_file *sqlite3PagerFile(Pager * );
static const char *sqlite3PagerJournalname(Pager * );
static int sqlite3PagerNosync(Pager * );
static void *sqlite3PagerTempSpace(Pager * );
static int sqlite3PagerIsMemdb(Pager * );
static void sqlite3PagerCacheStat(Pager * , int , int , int * );
static void sqlite3PagerClearCache(Pager * );
static int sqlite3SectorSize(sqlite3_file * );
static void sqlite3PagerTruncateImage(Pager * , Pgno );
typedef struct  PgHdr   PgHdr;
typedef struct  PCache   PCache;
struct  PgHdr {
  sqlite3_pcache_page *pPage ;
  void *pData ;
  void *pExtra ;
  PgHdr *pDirty ;
  Pager *pPager ;
  Pgno pgno ;
  u32 _1270_pageHash ;
  u16 flags ;
  i16 nRef ;
  PCache *pCache ;
  PgHdr *pDirtyNext ;
  PgHdr *pDirtyPrev ;
}  ;
static int sqlite3PcacheInitialize(void );
static void sqlite3PcacheShutdown(void );
static void sqlite3PCacheBufferSetup(void * , int sz , int n );
static void sqlite3PcacheOpen(int szPage , int szExtra , int bPurgeable , int ( *xStress)(void * , PgHdr * ) , void *pStress , PCache *pToInit );
static void sqlite3PcacheSetPageSize(PCache * , int );
static int sqlite3PcacheSize(void );
static int sqlite3PcacheFetch(PCache * , Pgno , int createFlag , PgHdr ** );
static void sqlite3PcacheRelease(PgHdr * );
static void sqlite3PcacheDrop(PgHdr * );
static void sqlite3PcacheMakeDirty(PgHdr * );
static void sqlite3PcacheMakeClean(PgHdr * );
static void sqlite3PcacheCleanAll(PCache * );
static void sqlite3PcacheMove(PgHdr * , Pgno );
static void sqlite3PcacheTruncate(PCache * , Pgno x );
static PgHdr *sqlite3PcacheDirtyList(PCache * );
static void sqlite3PcacheClose(PCache * );
static void sqlite3PcacheClearSyncFlags(PCache * );
static void sqlite3PcacheClear(PCache * );
static int sqlite3PcacheRefCount(PCache * );
static void sqlite3PcacheRef(PgHdr * );
static int sqlite3PcachePageRefcount(PgHdr * );
static int sqlite3PcachePagecount(PCache * );
static void sqlite3PcacheIterateDirty(PCache *pCache , void ( *xIter)(PgHdr * ) );
static void sqlite3PcacheSetCachesize(PCache * , int );
static void sqlite3PcacheShrink(PCache * );
static int sqlite3PcacheReleaseMemory(int );
static void sqlite3PCacheSetDefault(void );
static int sqlite3OsInit(void );
static int sqlite3OsClose(sqlite3_file * );
static int sqlite3OsRead(sqlite3_file * , void * , int amt , i64 offset );
static int sqlite3OsWrite(sqlite3_file * , const  void * , int amt , i64 offset );
static int sqlite3OsTruncate(sqlite3_file * , i64 size );
static int sqlite3OsSync(sqlite3_file * , int );
static int sqlite3OsFileSize(sqlite3_file * , i64 *pSize );
static int sqlite3OsLock(sqlite3_file * , int );
static int sqlite3OsUnlock(sqlite3_file * , int );
static int sqlite3OsCheckReservedLock(sqlite3_file *id , int *pResOut );
static int sqlite3OsFileControl(sqlite3_file * , int , void * );
static void sqlite3OsFileControlHint(sqlite3_file * , int , void * );
static int sqlite3OsSectorSize(sqlite3_file *id );
static int sqlite3OsDeviceCharacteristics(sqlite3_file *id );
static int sqlite3OsShmMap(sqlite3_file * , int , int , int , void  volatile ** );
static int sqlite3OsShmLock(sqlite3_file *id , int , int , int );
static void sqlite3OsShmBarrier(sqlite3_file *id );
static int sqlite3OsShmUnmap(sqlite3_file *id , int );
static int sqlite3OsFetch(sqlite3_file *id , i64 , int , void ** );
static int sqlite3OsUnfetch(sqlite3_file * , i64 , void * );
static int sqlite3OsOpen(sqlite3_vfs * , const  char * , sqlite3_file * , int , int * );
static int sqlite3OsDelete(sqlite3_vfs * , const  char * , int );
static int sqlite3OsAccess(sqlite3_vfs * , const  char * , int , int *pResOut );
static int sqlite3OsFullPathname(sqlite3_vfs * , const  char * , int , char * );
static int sqlite3OsRandomness(sqlite3_vfs * , int , char * );
static int sqlite3OsSleep(sqlite3_vfs * , int );
static int sqlite3OsCurrentTimeInt64(sqlite3_vfs * , sqlite3_int64 * );
static int sqlite3OsOpenMalloc(sqlite3_vfs * , const  char * , sqlite3_file ** , int , int * );
static int sqlite3OsCloseFree(sqlite3_file * );
struct  Db {
  char *zName ;
  Btree *pBt ;
  u8 safety_level ;
  Schema *pSchema ;
}  ;
struct  Schema {
  int schema_cookie ;
  int iGeneration ;
  Hash tblHash ;
  Hash idxHash ;
  Hash trigHash ;
  Hash fkeyHash ;
  Table *pSeqTab ;
  u8 file_format ;
  u8 enc ;
  u16 flags ;
  int cache_size ;
}  ;
struct  Lookaside {
  u16 sz ;
  u8 bEnabled ;
  u8 bMalloced ;
  int nOut ;
  int mxOut ;
  int anStat[3] ;
  LookasideSlot *pFree ;
  void *pStart ;
  void *pEnd ;
}  ;
struct  LookasideSlot {
  LookasideSlot *pNext ;
}  ;
struct  FuncDefHash {
  FuncDef *a[23] ;
}  ;
struct  sqlite3 {
  sqlite3_vfs *pVfs ;
  struct  Vdbe   *pVdbe ;
  CollSeq *pDfltColl ;
  sqlite3_mutex *mutex ;
  Db *aDb ;
  int nDb ;
  int flags ;
  i64 lastRowid ;
  i64 szMmap ;
  unsigned  int openFlags ;
  int errCode ;
  int errMask ;
  u16 dbOptFlags ;
  u8 autoCommit ;
  u8 temp_store ;
  u8 mallocFailed ;
  u8 dfltLockMode ;
  signed  char nextAutovac ;
  u8 suppressErr ;
  u8 vtabOnConflict ;
  u8 isTransactionSavepoint ;
  int nextPagesize ;
  u32 magic ;
  int nChange ;
  int nTotalChange ;
  int aLimit[(10 + 1)] ;
  struct  sqlite3InitInfo {
    int newTnum ;
    u8 iDb ;
    u8 busy ;
    u8 orphanTrigger ;
  }  init ;
  int nVdbeActive ;
  int nVdbeRead ;
  int nVdbeWrite ;
  int nVdbeExec ;
  int nExtension ;
  void **aExtension ;
  void ( *xTrace)(void * , const  char * ) ;
  void *pTraceArg ;
  void ( *xProfile)(void * , const  char * , u64 ) ;
  void *pProfileArg ;
  void *pCommitArg ;
  int ( *xCommitCallback)(void * ) ;
  void *pRollbackArg ;
  void ( *xRollbackCallback)(void * ) ;
  void *pUpdateArg ;
  void ( *xUpdateCallback)(void * , int , const  char * , const  char * , sqlite_int64 ) ;
  int ( *xWalCallback)(void * , sqlite3 * , const  char * , int ) ;
  void *pWalArg ;
  void ( *xCollNeeded)(void * , sqlite3 * , int eTextRep , const  char * ) ;
  void ( *xCollNeeded16)(void * , sqlite3 * , int eTextRep , const  void * ) ;
  void *pCollNeededArg ;
  sqlite3_value *pErr ;
  union   {
    volatile  int isInterrupted ;
    double notUsed1 ;
  }  u1 ;
  Lookaside lookaside ;
  int ( *xAuth)(void * , int , const  char * , const  char * , const  char * , const  char * ) ;
  void *pAuthArg ;
  int ( *xProgress)(void * ) ;
  void *pProgressArg ;
  unsigned nProgressOps ;
  int nVTrans ;
  Hash aModule ;
  VtabCtx *pVtabCtx ;
  VTable **aVTrans ;
  VTable *pDisconnect ;
  FuncDefHash aFunc ;
  Hash aCollSeq ;
  BusyHandler busyHandler ;
  Db aDbStatic[2] ;
  Savepoint *pSavepoint ;
  int busyTimeout ;
  int nSavepoint ;
  int nStatement ;
  i64 nDeferredCons ;
  i64 nDeferredImmCons ;
  int *pnBytesFreed ;
}  ;
struct  FuncDef {
  i16 nArg ;
  u16 funcFlags ;
  void *pUserData ;
  FuncDef *pNext ;
  void ( *xFunc)(sqlite3_context * , int , sqlite3_value ** ) ;
  void ( *xStep)(sqlite3_context * , int , sqlite3_value ** ) ;
  void ( *xFinalize)(sqlite3_context * ) ;
  char *zName ;
  FuncDef *pHash ;
  FuncDestructor *pDestructor ;
}  ;
struct  FuncDestructor {
  int nRef ;
  void ( *xDestroy)(void * ) ;
  void *pUserData ;
}  ;
struct  Savepoint {
  char *zName ;
  i64 nDeferredCons ;
  i64 nDeferredImmCons ;
  Savepoint *pNext ;
}  ;
struct  Module {
  const  sqlite3_module *pModule ;
  const  char *zName ;
  void *pAux ;
  void ( *xDestroy)(void * ) ;
}  ;
struct  Column {
  char *zName ;
  Expr *pDflt ;
  char *zDflt ;
  char *zType ;
  char *zColl ;
  u8 notNull ;
  char affinity ;
  u8 szEst ;
  u8 colFlags ;
}  ;
struct  CollSeq {
  char *zName ;
  u8 enc ;
  void *pUser ;
  int ( *xCmp)(void * , int , const  void * , int , const  void * ) ;
  void ( *xDel)(void * ) ;
}  ;
struct  VTable {
  sqlite3 *db ;
  Module *pMod ;
  sqlite3_vtab *pVtab ;
  int nRef ;
  u8 bConstraint ;
  int iSavepoint ;
  VTable *pNext ;
}  ;
struct  Table {
  char *zName ;
  Column *aCol ;
  Index *pIndex ;
  Select *pSelect ;
  FKey *pFKey ;
  char *zColAff ;
  ExprList *pCheck ;
  tRowcnt nRowEst ;
  int tnum ;
  i16 iPKey ;
  i16 nCol ;
  u16 nRef ;
  LogEst szTabRow ;
  u8 tabFlags ;
  u8 keyConf ;
  int addColOffset ;
  int nModuleArg ;
  char **azModuleArg ;
  VTable *pVTable ;
  Trigger *pTrigger ;
  Schema *pSchema ;
  Table *pNextZombie ;
}  ;
struct  FKey {
  Table *pFrom ;
  FKey *pNextFrom ;
  char *zTo ;
  FKey *pNextTo ;
  FKey *pPrevTo ;
  int nCol ;
  u8 isDeferred ;
  u8 aAction[2] ;
  Trigger *apTrigger[2] ;
  struct  sColMap {
    int iFrom ;
    char *zCol ;
  }  aCol[1] ;
}  ;
struct  KeyInfo {
  sqlite3 *db ;
  u8 enc ;
  u16 nField ;
  u8 *aSortOrder ;
  CollSeq *aColl[1] ;
}  ;
struct  UnpackedRecord {
  KeyInfo *pKeyInfo ;
  u16 nField ;
  u8 flags ;
  i64 rowid ;
  Mem *aMem ;
}  ;
struct  Index {
  char *zName ;
  int *aiColumn ;
  tRowcnt *aiRowEst ;
  Table *pTable ;
  char *zColAff ;
  Index *pNext ;
  Schema *pSchema ;
  u8 *aSortOrder ;
  char **azColl ;
  Expr *pPartIdxWhere ;
  int tnum ;
  LogEst szIdxRow ;
  u16 nColumn ;
  u8 onError ;
  unsigned autoIndex: 2 ;
  unsigned bUnordered: 1 ;
  unsigned uniqNotNull: 1 ;
}  ;
struct  IndexSample {
  void *p ;
  int n ;
  tRowcnt *anEq ;
  tRowcnt *anLt ;
  tRowcnt *anDLt ;
}  ;
struct  Token {
  const  char *z ;
  unsigned  int n ;
}  ;
struct  AggInfo {
  u8 directMode ;
  u8 useSortingIdx ;
  int sortingIdx ;
  int sortingIdxPTab ;
  int nSortingColumn ;
  ExprList *pGroupBy ;
  struct  AggInfo_col {
    Table *pTab ;
    int iTable ;
    int iColumn ;
    int iSorterColumn ;
    int iMem ;
    Expr *pExpr ;
  }  *aCol ;
  int nColumn ;
  int nAccumulator ;
  struct  AggInfo_func {
    Expr *pExpr ;
    FuncDef *pFunc ;
    int iMem ;
    int iDistinct ;
  }  *aFunc ;
  int nFunc ;
}  ;
typedef i16 ynVar;
struct  Expr {
  u8 op ;
  char affinity ;
  u32 flags ;
  union   {
    char *zToken ;
    int iValue ;
  }  u ;
  Expr *pLeft ;
  Expr *pRight ;
  union   {
    ExprList *pList ;
    Select *pSelect ;
  }  x ;
  int nHeight ;
  int iTable ;
  ynVar iColumn ;
  i16 iAgg ;
  i16 iRightJoinTable ;
  u8 op2 ;
  AggInfo *pAggInfo ;
  Table *pTab ;
}  ;
struct  ExprList {
  int nExpr ;
  int iECursor ;
  struct  ExprList_item {
    Expr *pExpr ;
    char *zName ;
    char *zSpan ;
    u8 sortOrder ;
    unsigned done: 1 ;
    unsigned bSpanIsTab: 1 ;
    u16 iOrderByCol ;
    u16 iAlias ;
  }  *a ;
}  ;
struct  ExprSpan {
  Expr *pExpr ;
  const  char *zStart ;
  const  char *zEnd ;
}  ;
struct  IdList {
  struct  IdList_item {
    char *zName ;
    int idx ;
  }  *a ;
  int nId ;
}  ;
typedef u64 Bitmask;
struct  SrcList {
  u8 nSrc ;
  u8 nAlloc ;
  struct  SrcList_item {
    Schema *pSchema ;
    char *zDatabase ;
    char *zName ;
    char *zAlias ;
    Table *pTab ;
    Select *pSelect ;
    int addrFillSub ;
    int regReturn ;
    u8 jointype ;
    unsigned notIndexed: 1 ;
    unsigned isCorrelated: 1 ;
    unsigned viaCoroutine: 1 ;
    u8 _1272_iSelectId ;
    int iCursor ;
    Expr *pOn ;
    IdList *pUsing ;
    Bitmask colUsed ;
    char *zIndex ;
    Index *pIndex ;
  }  a[1] ;
}  ;
struct  NameContext {
  Parse *pParse ;
  SrcList *pSrcList ;
  ExprList *pEList ;
  AggInfo *pAggInfo ;
  NameContext *pNext ;
  int nRef ;
  int nErr ;
  u8 ncFlags ;
}  ;
struct  Select {
  ExprList *pEList ;
  u8 op ;
  u16 selFlags ;
  int iLimit , iOffset ;
  int addrOpenEphm[3] ;
  u64 nSelectRow ;
  SrcList *pSrc ;
  Expr *pWhere ;
  ExprList *pGroupBy ;
  Expr *pHaving ;
  ExprList *pOrderBy ;
  Select *pPrior ;
  Select *pNext ;
  Select *pRightmost ;
  Expr *pLimit ;
  Expr *pOffset ;
}  ;
struct  SelectDest {
  u8 eDest ;
  char affSdst ;
  int iSDParm ;
  int iSdst ;
  int nSdst ;
}  ;
struct  AutoincInfo {
  AutoincInfo *pNext ;
  Table *pTab ;
  int iDb ;
  int regCtr ;
}  ;
struct  TriggerPrg {
  Trigger *pTrigger ;
  TriggerPrg *pNext ;
  SubProgram *pProgram ;
  int orconf ;
  u32 aColmask[2] ;
}  ;
typedef unsigned int yDbMask;
struct  Parse {
  sqlite3 *db ;
  char *zErrMsg ;
  Vdbe *pVdbe ;
  int rc ;
  u8 colNamesSet ;
  u8 checkSchema ;
  u8 nested ;
  u8 nTempReg ;
  u8 nTempInUse ;
  u8 nColCache ;
  u8 iColCache ;
  u8 isMultiWrite ;
  u8 mayAbort ;
  u8 hasCompound ;
  int aTempReg[8] ;
  int nRangeReg ;
  int iRangeReg ;
  int nErr ;
  int nTab ;
  int nMem ;
  int nSet ;
  int nOnce ;
  int ckBase ;
  int iPartIdxTab ;
  int iCacheLevel ;
  int iCacheCnt ;
  struct  yColCache {
    int iTable ;
    int iColumn ;
    u8 tempReg ;
    int iLevel ;
    int iReg ;
    int lru ;
  }  aColCache[10] ;
  yDbMask writeMask ;
  yDbMask cookieMask ;
  int cookieGoto ;
  int cookieValue[(10 + 2)] ;
  int regRowid ;
  int regRoot ;
  int nMaxArg ;
  Token constraintName ;
  int nTableLock ;
  TableLock *aTableLock ;
  AutoincInfo *pAinc ;
  Parse *pToplevel ;
  Table *pTriggerTab ;
  u32 nQueryLoop ;
  u32 oldmask ;
  u32 newmask ;
  u8 eTriggerOp ;
  u8 eOrconf ;
  u8 disableTriggers ;
  int nVar ;
  int nzVar ;
  u8 explain ;
  u8 declareVtab ;
  int nVtabLock ;
  int nAlias ;
  int nHeight ;
  int _1272_iSelectId ;
  int _1272_iNextSelectId ;
  char **azVar ;
  Vdbe *pReprepare ;
  int *aAlias ;
  const  char *zTail ;
  Table *pNewTable ;
  Trigger *pNewTrigger ;
  const  char *zAuthContext ;
  Token sNameToken ;
  Token sLastToken ;
  Token sArg ;
  Table **apVtabLock ;
  Table *pZombieTab ;
  TriggerPrg *pTriggerPrg ;
}  ;
struct  AuthContext {
  const  char *zAuthContext ;
  Parse *pParse ;
}  ;
struct  Trigger {
  char *zName ;
  char *table ;
  u8 op ;
  u8 tr_tm ;
  Expr *pWhen ;
  IdList *pColumns ;
  Schema *pSchema ;
  Schema *pTabSchema ;
  TriggerStep *step_list ;
  Trigger *pNext ;
}  ;
struct  TriggerStep {
  u8 op ;
  u8 orconf ;
  Trigger *pTrig ;
  Select *pSelect ;
  Token target ;
  Expr *pWhere ;
  ExprList *pExprList ;
  IdList *pIdList ;
  TriggerStep *pNext ;
  TriggerStep *pLast ;
}  ;
typedef struct  DbFixer   DbFixer;
struct  DbFixer {
  Parse *pParse ;
  Schema *pSchema ;
  int bVarOnly ;
  const  char *zDb ;
  const  char *zType ;
  const  Token *pName ;
}  ;
struct  StrAccum {
  sqlite3 *db ;
  char *zBase ;
  char *zText ;
  int nChar ;
  int nAlloc ;
  int mxAlloc ;
  u8 useMalloc ;
  u8 accError ;
}  ;
typedef struct   {
  sqlite3 *db ;
  char **pzErrMsg ;
  int iDb ;
  int rc ;
}  InitData;
struct  Sqlite3Config {
  int bMemstat ;
  int bCoreMutex ;
  int bFullMutex ;
  int bOpenUri ;
  int bUseCis ;
  int mxStrlen ;
  int szLookaside ;
  int nLookaside ;
  sqlite3_mem_methods m ;
  sqlite3_mutex_methods mutex ;
  sqlite3_pcache_methods2 pcache2 ;
  void *pHeap ;
  int nHeap ;
  int mnReq , mxReq ;
  sqlite3_int64 szMmap ;
  sqlite3_int64 mxMmap ;
  void *pScratch ;
  int szScratch ;
  int nScratch ;
  void *pPage ;
  int szPage ;
  int nPage ;
  int mxParserStack ;
  int sharedCacheEnabled ;
  int isInit ;
  int inProgress ;
  int isMutexInit ;
  int isMallocInit ;
  int isPCacheInit ;
  sqlite3_mutex *pInitMutex ;
  int nRefInitMutex ;
  void ( *xLog)(void * , int , const  char * ) ;
  void *pLogArg ;
  int bLocaltimeFault ;
}  ;
struct  Walker {
  int ( *xExprCallback)(Walker * , Expr * ) ;
  int ( *xSelectCallback)(Walker * , Select * ) ;
  Parse *pParse ;
  int walkerDepth ;
  u8 bSelectDepthFirst ;
  union   {
    NameContext *pNC ;
    int i ;
    SrcList *pSrcList ;
    struct  SrcCount   *pSrcCount ;
  }  u ;
}  ;
static int sqlite3WalkExpr(Walker * , Expr * );
static int sqlite3WalkExprList(Walker * , ExprList * );
static int sqlite3WalkSelect(Walker * , Select * );
static int sqlite3WalkSelectExpr(Walker * , Select * );
static int sqlite3WalkSelectFrom(Walker * , Select * );
static int sqlite3CorruptError(int );
static int sqlite3MisuseError(int );
static int sqlite3CantopenError(int );
enum  {
  _1273__ISupper = ((0 < 8) ? ((1 << 0) << 8) : ((1 << 0) >> 8)),
  _1273__ISlower = ((1 < 8) ? ((1 << 1) << 8) : ((1 << 1) >> 8)),
  _1273__ISalpha = ((2 < 8) ? ((1 << 2) << 8) : ((1 << 2) >> 8)),
  _1273__ISdigit = ((3 < 8) ? ((1 << 3) << 8) : ((1 << 3) >> 8)),
  _1273__ISxdigit = ((4 < 8) ? ((1 << 4) << 8) : ((1 << 4) >> 8)),
  _1273__ISspace = ((5 < 8) ? ((1 << 5) << 8) : ((1 << 5) >> 8)),
  _1273__ISprint = ((6 < 8) ? ((1 << 6) << 8) : ((1 << 6) >> 8)),
  _1273__ISgraph = ((7 < 8) ? ((1 << 7) << 8) : ((1 << 7) >> 8)),
  _1273__ISblank = ((8 < 8) ? ((1 << 8) << 8) : ((1 << 8) >> 8)),
  _1273__IScntrl = ((9 < 8) ? ((1 << 9) << 8) : ((1 << 9) >> 8)),
  _1273__ISpunct = ((10 < 8) ? ((1 << 10) << 8) : ((1 << 10) >> 8)),
  _1273__ISalnum = ((11 < 8) ? ((1 << 11) << 8) : ((1 << 11) >> 8))
} ;
extern const unsigned short int **__ctype_b_loc(void ) __attribute__((__nothrow__)) __attribute__((__const__));
extern const __int32_t **__ctype_tolower_loc(void ) __attribute__((__nothrow__)) __attribute__((__const__));
extern const __int32_t **__ctype_toupper_loc(void ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int isalnum(int ) __attribute__((__nothrow__));
extern int isalpha(int ) __attribute__((__nothrow__));
extern int iscntrl(int ) __attribute__((__nothrow__));
extern int isdigit(int ) __attribute__((__nothrow__));
extern int islower(int ) __attribute__((__nothrow__));
extern int isgraph(int ) __attribute__((__nothrow__));
extern int isprint(int ) __attribute__((__nothrow__));
extern int ispunct(int ) __attribute__((__nothrow__));
extern int isspace(int ) __attribute__((__nothrow__));
extern int isupper(int ) __attribute__((__nothrow__));
extern int isxdigit(int ) __attribute__((__nothrow__));
extern int tolower(int __c ) __attribute__((__nothrow__));
extern int toupper(int __c ) __attribute__((__nothrow__));
extern int isblank(int ) __attribute__((__nothrow__));
extern int isctype(int __c , int __mask ) __attribute__((__nothrow__));
extern int isascii(int __c ) __attribute__((__nothrow__));
extern int toascii(int __c ) __attribute__((__nothrow__));
extern int _toupper(int ) __attribute__((__nothrow__));
extern int _tolower(int ) __attribute__((__nothrow__));
extern int isalnum_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isalpha_l(int , __locale_t ) __attribute__((__nothrow__));
extern int iscntrl_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isdigit_l(int , __locale_t ) __attribute__((__nothrow__));
extern int islower_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isgraph_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isprint_l(int , __locale_t ) __attribute__((__nothrow__));
extern int ispunct_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isspace_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isupper_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isxdigit_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isblank_l(int , __locale_t ) __attribute__((__nothrow__));
extern int __tolower_l(int __c , __locale_t __l ) __attribute__((__nothrow__));
extern int tolower_l(int __c , __locale_t __l ) __attribute__((__nothrow__));
extern int __toupper_l(int __c , __locale_t __l ) __attribute__((__nothrow__));
extern int toupper_l(int __c , __locale_t __l ) __attribute__((__nothrow__));
static int sqlite3Strlen30(const  char * );
static int sqlite3MallocInit(void );
static void sqlite3MallocEnd(void );
static void *sqlite3Malloc(int );
static void *sqlite3MallocZero(int );
static void *sqlite3DbMallocZero(sqlite3 * , int );
static void *sqlite3DbMallocRaw(sqlite3 * , int );
static char *sqlite3DbStrDup(sqlite3 * , const  char * );
static char *sqlite3DbStrNDup(sqlite3 * , const  char * , int );
static void *sqlite3Realloc(void * , int );
static void *sqlite3DbReallocOrFree(sqlite3 * , void * , int );
static void *sqlite3DbRealloc(sqlite3 * , void * , int );
static void sqlite3DbFree(sqlite3 * , void * );
static int sqlite3MallocSize(void * );
static int sqlite3DbMallocSize(sqlite3 * , void * );
static void *sqlite3ScratchMalloc(int );
static void sqlite3ScratchFree(void * );
static void *sqlite3PageMalloc(int );
static void sqlite3PageFree(void * );
static void sqlite3MemSetDefault(void );
static void sqlite3BenignMallocHooks(void ( *)(void ) , void ( *)(void ) );
static int sqlite3HeapNearlyFull(void );
static const sqlite3_mem_methods *sqlite3MemGetMemsys3(void );
static const sqlite3_mem_methods *sqlite3MemGetMemsys5(void );
static int sqlite3StatusValue(int );
static void sqlite3StatusAdd(int , int );
static void sqlite3StatusSet(int , int );
static int sqlite3IsNaN(double );
static void sqlite3VXPrintf(StrAccum * , int , const  char * , va_list );
static void sqlite3XPrintf(StrAccum * , const  char * , ...);
static char *sqlite3MPrintf(sqlite3 * , const  char * , ...);
static char *sqlite3VMPrintf(sqlite3 * , const  char * , va_list );
static char *sqlite3MAppendf(sqlite3 * , char * , const  char * , ...);
static void sqlite3ExplainBegin(Vdbe * );
static void sqlite3ExplainPrintf(Vdbe * , const  char * , ...);
static void sqlite3ExplainNL(Vdbe * );
static void sqlite3ExplainPush(Vdbe * );
static void sqlite3ExplainPop(Vdbe * );
static void sqlite3ExplainFinish(Vdbe * );
static void sqlite3ExplainSelect(Vdbe * , Select * );
static void sqlite3ExplainExpr(Vdbe * , Expr * );
static void sqlite3ExplainExprList(Vdbe * , ExprList * );
static const char *sqlite3VdbeExplanation(Vdbe * );
static void sqlite3SetString(char ** , sqlite3 * , const  char * , ...);
static void sqlite3ErrorMsg(Parse * , const  char * , ...);
static int sqlite3Dequote(char * );
static int sqlite3KeywordCode(const  unsigned  char * , int );
static int sqlite3RunParser(Parse * , const  char * , char ** );
static void sqlite3FinishCoding(Parse * );
static int sqlite3GetTempReg(Parse * );
static void sqlite3ReleaseTempReg(Parse * , int );
static int sqlite3GetTempRange(Parse * , int );
static void sqlite3ReleaseTempRange(Parse * , int , int );
static void sqlite3ClearTempRegCache(Parse * );
static Expr *sqlite3ExprAlloc(sqlite3 * , int , const  Token * , int );
static Expr *sqlite3Expr(sqlite3 * , int , const  char * );
static void sqlite3ExprAttachSubtrees(sqlite3 * , Expr * , Expr * , Expr * );
static Expr *sqlite3PExpr(Parse * , int , Expr * , Expr * , const  Token * );
static Expr *sqlite3ExprAnd(sqlite3 * , Expr * , Expr * );
static Expr *sqlite3ExprFunction(Parse * , ExprList * , Token * );
static void sqlite3ExprAssignVarNumber(Parse * , Expr * );
static void sqlite3ExprDelete(sqlite3 * , Expr * );
static ExprList *sqlite3ExprListAppend(Parse * , ExprList * , Expr * );
static void sqlite3ExprListSetName(Parse * , ExprList * , Token * , int );
static void sqlite3ExprListSetSpan(Parse * , ExprList * , ExprSpan * );
static void sqlite3ExprListDelete(sqlite3 * , ExprList * );
static int sqlite3Init(sqlite3 * , char ** );
static int sqlite3InitCallback(void * , int , char ** , char ** );
static void sqlite3Pragma(Parse * , Token * , Token * , Token * , int );
static void sqlite3ResetAllSchemasOfConnection(sqlite3 * );
static void sqlite3ResetOneSchema(sqlite3 * , int );
static void sqlite3CollapseDatabaseArray(sqlite3 * );
static void sqlite3BeginParse(Parse * , int );
static void sqlite3CommitInternalChanges(sqlite3 * );
static Table *sqlite3ResultSetOfSelect(Parse * , Select * );
static void sqlite3OpenMasterTable(Parse * , int );
static void sqlite3StartTable(Parse * , Token * , Token * , int , int , int , int );
static void sqlite3AddColumn(Parse * , Token * );
static void sqlite3AddNotNull(Parse * , int );
static void sqlite3AddPrimaryKey(Parse * , ExprList * , int , int , int );
static void sqlite3AddCheckConstraint(Parse * , Expr * );
static void sqlite3AddColumnType(Parse * , Token * );
static void sqlite3AddDefaultValue(Parse * , ExprSpan * );
static void sqlite3AddCollateType(Parse * , Token * );
static void sqlite3EndTable(Parse * , Token * , Token * , Select * );
static int sqlite3ParseUri(const  char * , const  char * , unsigned  int * , sqlite3_vfs ** , char ** , char ** );
static Btree *sqlite3DbNameToBtree(sqlite3 * , const  char * );
static int sqlite3CodeOnce(Parse * );
static Bitvec *sqlite3BitvecCreate(u32 );
static int sqlite3BitvecTest(Bitvec * , u32 );
static int sqlite3BitvecSet(Bitvec * , u32 );
static void sqlite3BitvecClear(Bitvec * , u32 , void * );
static void sqlite3BitvecDestroy(Bitvec * );
static u32 sqlite3BitvecSize(Bitvec * );
static int sqlite3BitvecBuiltinTest(int , int * );
static RowSet *sqlite3RowSetInit(sqlite3 * , void * , unsigned  int );
static void sqlite3RowSetClear(RowSet * );
static void sqlite3RowSetInsert(RowSet * , i64 );
static int sqlite3RowSetTest(RowSet * , u8 iBatch , i64 );
static int sqlite3RowSetNext(RowSet * , i64 * );
static void sqlite3CreateView(Parse * , Token * , Token * , Token * , Select * , int , int );
static int sqlite3ViewGetColumnNames(Parse * , Table * );
static void sqlite3DropTable(Parse * , SrcList * , int , int );
static void sqlite3CodeDropTable(Parse * , Table * , int , int );
static void sqlite3DeleteTable(sqlite3 * , Table * );
static void sqlite3AutoincrementBegin(Parse *pParse );
static void sqlite3AutoincrementEnd(Parse *pParse );
static int sqlite3CodeCoroutine(Parse * , Select * , SelectDest * );
static void sqlite3Insert(Parse * , SrcList * , ExprList * , Select * , IdList * , int );
static void *sqlite3ArrayAllocate(sqlite3 * , void * , int , int * , int * );
static IdList *sqlite3IdListAppend(sqlite3 * , IdList * , Token * );
static int sqlite3IdListIndex(IdList * , const  char * );
static SrcList *sqlite3SrcListEnlarge(sqlite3 * , SrcList * , int , int );
static SrcList *sqlite3SrcListAppend(sqlite3 * , SrcList * , Token * , Token * );
static SrcList *sqlite3SrcListAppendFromTerm(Parse * , SrcList * , Token * , Token * , Token * , Select * , Expr * , IdList * );
static void sqlite3SrcListIndexedBy(Parse * , SrcList * , Token * );
static int sqlite3IndexedByLookup(Parse * , struct  SrcList_item   * );
static void sqlite3SrcListShiftJoinType(SrcList * );
static void sqlite3SrcListAssignCursors(Parse * , SrcList * );
static void sqlite3IdListDelete(sqlite3 * , IdList * );
static void sqlite3SrcListDelete(sqlite3 * , SrcList * );
static Index *sqlite3CreateIndex(Parse * , Token * , Token * , SrcList * , ExprList * , int , Token * , Expr * , int , int );
static void sqlite3DropIndex(Parse * , SrcList * , int );
static int sqlite3Select(Parse * , Select * , SelectDest * );
static Select *sqlite3SelectNew(Parse * , ExprList * , SrcList * , Expr * , ExprList * , Expr * , ExprList * , u16 , Expr * , Expr * );
static void sqlite3SelectDelete(sqlite3 * , Select * );
static Table *sqlite3SrcListLookup(Parse * , SrcList * );
static int sqlite3IsReadOnly(Parse * , Table * , int );
static void sqlite3OpenTable(Parse * , int iCur , int iDb , Table * , int );
static void sqlite3DeleteFrom(Parse * , SrcList * , Expr * );
static void sqlite3Update(Parse * , SrcList * , ExprList * , Expr * , int );
static WhereInfo *sqlite3WhereBegin(Parse * , SrcList * , Expr * , ExprList * , ExprList * , u16 , int );
static void sqlite3WhereEnd(WhereInfo * );
static u64 sqlite3WhereOutputRowCount(WhereInfo * );
static int sqlite3WhereIsDistinct(WhereInfo * );
static int sqlite3WhereIsOrdered(WhereInfo * );
static int sqlite3WhereContinueLabel(WhereInfo * );
static int sqlite3WhereBreakLabel(WhereInfo * );
static int sqlite3WhereOkOnePass(WhereInfo * );
static int sqlite3ExprCodeGetColumn(Parse * , Table * , int , int , int , u8 );
static void sqlite3ExprCodeGetColumnOfTable(Vdbe * , Table * , int , int , int );
static void sqlite3ExprCodeMove(Parse * , int , int , int );
static void sqlite3ExprCacheStore(Parse * , int , int , int );
static void sqlite3ExprCachePush(Parse * );
static void sqlite3ExprCachePop(Parse * , int );
static void sqlite3ExprCacheRemove(Parse * , int , int );
static void sqlite3ExprCacheClear(Parse * );
static void sqlite3ExprCacheAffinityChange(Parse * , int , int );
static int sqlite3ExprCode(Parse * , Expr * , int );
static int sqlite3ExprCodeTemp(Parse * , Expr * , int * );
static int sqlite3ExprCodeTarget(Parse * , Expr * , int );
static int sqlite3ExprCodeAndCache(Parse * , Expr * , int );
static void sqlite3ExprCodeConstants(Parse * , Expr * );
static int sqlite3ExprCodeExprList(Parse * , ExprList * , int , int );
static void sqlite3ExprIfTrue(Parse * , Expr * , int , int );
static void sqlite3ExprIfFalse(Parse * , Expr * , int , int );
static Table *sqlite3FindTable(sqlite3 * , const  char * , const  char * );
static Table *sqlite3LocateTable(Parse * , int isView , const  char * , const  char * );
static Table *sqlite3LocateTableItem(Parse * , int isView , struct  SrcList_item   * );
static Index *sqlite3FindIndex(sqlite3 * , const  char * , const  char * );
static void sqlite3UnlinkAndDeleteTable(sqlite3 * , int , const  char * );
static void sqlite3UnlinkAndDeleteIndex(sqlite3 * , int , const  char * );
static void sqlite3Vacuum(Parse * );
static int sqlite3RunVacuum(char ** , sqlite3 * );
static char *sqlite3NameFromToken(sqlite3 * , Token * );
static int sqlite3ExprCompare(Expr * , Expr * , int );
static int sqlite3ExprListCompare(ExprList * , ExprList * , int );
static int sqlite3ExprImpliesExpr(Expr * , Expr * , int );
static void sqlite3ExprAnalyzeAggregates(NameContext * , Expr * );
static void sqlite3ExprAnalyzeAggList(NameContext * , ExprList * );
static int sqlite3FunctionUsesThisSrc(Expr * , SrcList * );
static Vdbe *sqlite3GetVdbe(Parse * );
static void sqlite3PrngSaveState(void );
static void sqlite3PrngRestoreState(void );
static void sqlite3PrngResetState(void );
static void sqlite3RollbackAll(sqlite3 * , int );
static void sqlite3CodeVerifySchema(Parse * , int );
static void sqlite3CodeVerifyNamedSchema(Parse * , const  char *zDb );
static void sqlite3BeginTransaction(Parse * , int );
static void sqlite3CommitTransaction(Parse * );
static void sqlite3RollbackTransaction(Parse * );
static void sqlite3Savepoint(Parse * , int , Token * );
static void sqlite3CloseSavepoints(sqlite3 * );
static void sqlite3LeaveMutexAndCloseZombie(sqlite3 * );
static int sqlite3ExprIsConstant(Expr * );
static int sqlite3ExprIsConstantNotJoin(Expr * );
static int sqlite3ExprIsConstantOrFunction(Expr * );
static int sqlite3ExprIsInteger(Expr * , int * );
static int sqlite3ExprCanBeNull(const  Expr * );
static void sqlite3ExprCodeIsNullJump(Vdbe * , const  Expr * , int , int );
static int sqlite3ExprNeedsNoAffinityChange(const  Expr * , char );
static int sqlite3IsRowid(const  char * );
static void sqlite3GenerateRowDelete(Parse * , Table * , int , int , int , Trigger * , int );
static void sqlite3GenerateRowIndexDelete(Parse * , Table * , int , int * );
static int sqlite3GenerateIndexKey(Parse * , Index * , int , int , int , int * );
static void sqlite3GenerateConstraintChecks(Parse * , Table * , int , int , int * , int , int , int , int , int * );
static void sqlite3CompleteInsertion(Parse * , Table * , int , int , int * , int , int , int );
static int sqlite3OpenTableAndIndices(Parse * , Table * , int , int );
static void sqlite3BeginWriteOperation(Parse * , int , int );
static void sqlite3MultiWrite(Parse * );
static void sqlite3MayAbort(Parse * );
static void sqlite3HaltConstraint(Parse * , int , int , char * , int );
static Expr *sqlite3ExprDup(sqlite3 * , Expr * , int );
static ExprList *sqlite3ExprListDup(sqlite3 * , ExprList * , int );
static SrcList *sqlite3SrcListDup(sqlite3 * , SrcList * , int );
static IdList *sqlite3IdListDup(sqlite3 * , IdList * );
static Select *sqlite3SelectDup(sqlite3 * , Select * , int );
static void sqlite3FuncDefInsert(FuncDefHash * , FuncDef * );
static FuncDef *sqlite3FindFunction(sqlite3 * , const  char * , int , int , u8 , u8 );
static void sqlite3RegisterBuiltinFunctions(sqlite3 * );
static void sqlite3RegisterDateTimeFunctions(void );
static void sqlite3RegisterGlobalFunctions(void );
static int sqlite3SafetyCheckOk(sqlite3 * );
static int sqlite3SafetyCheckSickOrOk(sqlite3 * );
static void sqlite3ChangeCookie(Parse * , int );
static void sqlite3MaterializeView(Parse * , Table * , Expr * , int );
static void sqlite3BeginTrigger(Parse * , Token * , Token * , int , int , IdList * , SrcList * , Expr * , int , int );
static void sqlite3FinishTrigger(Parse * , TriggerStep * , Token * );
static void sqlite3DropTrigger(Parse * , SrcList * , int );
static void sqlite3DropTriggerPtr(Parse * , Trigger * );
static Trigger *sqlite3TriggersExist(Parse * , Table * , int , ExprList * , int *pMask );
static Trigger *sqlite3TriggerList(Parse * , Table * );
static void sqlite3CodeRowTrigger(Parse * , Trigger * , int , ExprList * , int , Table * , int , int , int );
static void sqlite3CodeRowTriggerDirect(Parse * , Trigger * , Table * , int , int , int );
void sqliteViewTriggers(Parse * , Table * , Expr * , int , ExprList * );
static void sqlite3DeleteTriggerStep(sqlite3 * , TriggerStep * );
static TriggerStep *sqlite3TriggerSelectStep(sqlite3 * , Select * );
static TriggerStep *sqlite3TriggerInsertStep(sqlite3 * , Token * , IdList * , ExprList * , Select * , u8 );
static TriggerStep *sqlite3TriggerUpdateStep(sqlite3 * , Token * , ExprList * , Expr * , u8 );
static TriggerStep *sqlite3TriggerDeleteStep(sqlite3 * , Token * , Expr * );
static void sqlite3DeleteTrigger(sqlite3 * , Trigger * );
static void sqlite3UnlinkAndDeleteTrigger(sqlite3 * , int , const  char * );
static u32 sqlite3TriggerColmask(Parse * , Trigger * , ExprList * , int , int , Table * , int );
static int sqlite3JoinType(Parse * , Token * , Token * , Token * );
static void sqlite3CreateForeignKey(Parse * , ExprList * , Token * , ExprList * , int );
static void sqlite3DeferForeignKey(Parse * , int );
static void sqlite3AuthRead(Parse * , Expr * , Schema * , SrcList * );
static int sqlite3AuthCheck(Parse * , int , const  char * , const  char * , const  char * );
static void sqlite3AuthContextPush(Parse * , AuthContext * , const  char * );
static void sqlite3AuthContextPop(AuthContext * );
static int sqlite3AuthReadCol(Parse * , const  char * , const  char * , int );
static void sqlite3Attach(Parse * , Expr * , Expr * , Expr * );
static void sqlite3Detach(Parse * , Expr * );
static void sqlite3FixInit(DbFixer * , Parse * , int , const  char * , const  Token * );
static int sqlite3FixSrcList(DbFixer * , SrcList * );
static int sqlite3FixSelect(DbFixer * , Select * );
static int sqlite3FixExpr(DbFixer * , Expr * );
static int sqlite3FixExprList(DbFixer * , ExprList * );
static int sqlite3FixTriggerStep(DbFixer * , TriggerStep * );
static int sqlite3AtoF(const  char *z , double * , int , u8 );
static int sqlite3GetInt32(const  char * , int * );
static int sqlite3Atoi(const  char * );
static int sqlite3Utf16ByteLen(const  void *pData , int nChar );
static int sqlite3Utf8CharLen(const  char *pData , int nByte );
static u32 sqlite3Utf8Read(const  u8 ** );
static LogEst sqlite3LogEst(u64 );
static LogEst sqlite3LogEstAdd(LogEst , LogEst );
static LogEst sqlite3LogEstFromDouble(double );
static u64 sqlite3LogEstToInt(LogEst );
static int sqlite3PutVarint(unsigned  char * , u64 );
static int sqlite3PutVarint32(unsigned  char * , u32 );
static u8 sqlite3GetVarint(const  unsigned  char * , u64 * );
static u8 sqlite3GetVarint32(const  unsigned  char * , u32 * );
static int sqlite3VarintLen(u64 v );
static const char *sqlite3IndexAffinityStr(Vdbe * , Index * );
static void sqlite3TableAffinityStr(Vdbe * , Table * );
static char sqlite3CompareAffinity(Expr *pExpr , char aff2 );
static int sqlite3IndexAffinityOk(Expr *pExpr , char idx_affinity );
static char sqlite3ExprAffinity(Expr *pExpr );
static int sqlite3Atoi64(const  char * , i64 * , int , u8 );
static void sqlite3Error(sqlite3 * , int , const  char * , ...);
static void *sqlite3HexToBlob(sqlite3 * , const  char *z , int n );
static u8 sqlite3HexToInt(int h );
static int sqlite3TwoPartName(Parse * , Token * , Token * , Token ** );
static const char *sqlite3ErrStr(int );
static int sqlite3ReadSchema(Parse *pParse );
static CollSeq *sqlite3FindCollSeq(sqlite3 * , u8 enc , const  char * , int );
static CollSeq *sqlite3LocateCollSeq(Parse *pParse , const  char *zName );
static CollSeq *sqlite3ExprCollSeq(Parse *pParse , Expr *pExpr );
static Expr *sqlite3ExprAddCollateToken(Parse *pParse , Expr * , Token * );
static Expr *sqlite3ExprAddCollateString(Parse * , Expr * , const  char * );
static Expr *sqlite3ExprSkipCollate(Expr * );
static int sqlite3CheckCollSeq(Parse * , CollSeq * );
static int sqlite3CheckObjectName(Parse * , const  char * );
static void sqlite3VdbeSetChanges(sqlite3 * , int );
static int sqlite3AddInt64(i64 * , i64 );
static int sqlite3SubInt64(i64 * , i64 );
static int sqlite3MulInt64(i64 * , i64 );
static int sqlite3AbsInt32(int );
static u8 sqlite3GetBoolean(const  char *z , int );
static const void *sqlite3ValueText(sqlite3_value * , u8 );
static int sqlite3ValueBytes(sqlite3_value * , u8 );
static void sqlite3ValueSetStr(sqlite3_value * , int , const  void * , u8 , void ( *)(void * ) );
static void sqlite3ValueFree(sqlite3_value * );
static sqlite3_value *sqlite3ValueNew(sqlite3 * );
static char *sqlite3Utf16to8(sqlite3 * , const  void * , int , u8 );
static int sqlite3ValueFromExpr(sqlite3 * , Expr * , u8 , u8 , sqlite3_value ** );
static void sqlite3ValueApplyAffinity(sqlite3_value * , u8 , u8 );
static void sqlite3RootPageMoved(sqlite3 * , int , int , int );
static void sqlite3Reindex(Parse * , Token * , Token * );
static void sqlite3AlterFunctions(void );
static void sqlite3AlterRenameTable(Parse * , SrcList * , Token * );
static int sqlite3GetToken(const  unsigned  char * , int * );
static void sqlite3NestedParse(Parse * , const  char * , ...);
static void sqlite3ExpirePreparedStatements(sqlite3 * );
static int sqlite3CodeSubselect(Parse * , Expr * , int , int );
static void sqlite3SelectPrep(Parse * , Select * , NameContext * );
static int sqlite3MatchSpanName(const  char * , const  char * , const  char * , const  char * );
static int sqlite3ResolveExprNames(NameContext * , Expr * );
static void sqlite3ResolveSelectNames(Parse * , Select * , NameContext * );
static void sqlite3ResolveSelfReference(Parse * , Table * , int , Expr * , ExprList * );
static int sqlite3ResolveOrderGroupBy(Parse * , Select * , ExprList * , const  char * );
static void sqlite3ColumnDefault(Vdbe * , Table * , int , int );
static void sqlite3AlterFinishAddColumn(Parse * , Token * );
static void sqlite3AlterBeginAddColumn(Parse * , SrcList * );
static CollSeq *sqlite3GetCollSeq(Parse * , u8 , CollSeq * , const  char * );
static char sqlite3AffinityType(const  char * , u8 * );
static void sqlite3Analyze(Parse * , Token * , Token * );
static int sqlite3InvokeBusyHandler(BusyHandler * );
static int sqlite3FindDb(sqlite3 * , Token * );
static int sqlite3FindDbName(sqlite3 * , const  char * );
static int sqlite3AnalysisLoad(sqlite3 * , int iDB );
static void sqlite3DeleteIndexSamples(sqlite3 * , Index * );
static void sqlite3DefaultRowEst(Index * );
static void sqlite3RegisterLikeFunctions(sqlite3 * , int );
static int sqlite3IsLikeFunction(sqlite3 * , Expr * , int * , char * );
static void sqlite3MinimumFileFormat(Parse * , int , int );
static void sqlite3SchemaClear(void * );
static Schema *sqlite3SchemaGet(sqlite3 * , Btree * );
static int sqlite3SchemaToIndex(sqlite3 *db , Schema * );
static KeyInfo *sqlite3KeyInfoAlloc(sqlite3 * , int );
static KeyInfo *sqlite3IndexKeyinfo(Parse * , Index * );
static int sqlite3CreateFunc(sqlite3 * , const  char * , int , int , void * , void ( *)(sqlite3_context * , int , sqlite3_value ** ) , void ( *)(sqlite3_context * , int , sqlite3_value ** ) , void ( *)(sqlite3_context * ) , FuncDestructor *pDestructor );
static int sqlite3ApiExit(sqlite3 *db , int );
static int sqlite3OpenTempDatabase(Parse * );
static void sqlite3StrAccumInit(StrAccum * , char * , int , int );
static void sqlite3StrAccumAppend(StrAccum * , const  char * , int );
static void sqlite3AppendSpace(StrAccum * , int );
static char *sqlite3StrAccumFinish(StrAccum * );
static void sqlite3StrAccumReset(StrAccum * );
static void sqlite3SelectDestInit(SelectDest * , int , int );
static Expr *sqlite3CreateColumnExpr(sqlite3 * , SrcList * , int , int );
static void sqlite3BackupRestart(sqlite3_backup * );
static void sqlite3BackupUpdate(sqlite3_backup * , Pgno , const  u8 * );
static void *sqlite3ParserAlloc(void *( *)(size_t ) );
static void sqlite3ParserFree(void * , void ( *)(void * ) );
static void sqlite3Parser(void * , int , Token , Parse * );
static void sqlite3AutoLoadExtensions(sqlite3 * );
static void sqlite3TableLock(Parse * , int , int , u8 , const  char * );
static void sqlite3VtabClear(sqlite3 *db , Table * );
static void sqlite3VtabDisconnect(sqlite3 *db , Table *p );
static int sqlite3VtabSync(sqlite3 *db , Vdbe * );
static int sqlite3VtabRollback(sqlite3 *db );
static int sqlite3VtabCommit(sqlite3 *db );
static void sqlite3VtabLock(VTable * );
static void sqlite3VtabUnlock(VTable * );
static void sqlite3VtabUnlockList(sqlite3 * );
static int sqlite3VtabSavepoint(sqlite3 * , int , int );
static void sqlite3VtabImportErrmsg(Vdbe * , sqlite3_vtab * );
static VTable *sqlite3GetVTable(sqlite3 * , Table * );
static void sqlite3VtabMakeWritable(Parse * , Table * );
static void sqlite3VtabBeginParse(Parse * , Token * , Token * , Token * , int );
static void sqlite3VtabFinishParse(Parse * , Token * );
static void sqlite3VtabArgInit(Parse * );
static void sqlite3VtabArgExtend(Parse * , Token * );
static int sqlite3VtabCallCreate(sqlite3 * , int , const  char * , char ** );
static int sqlite3VtabCallConnect(Parse * , Table * );
static int sqlite3VtabCallDestroy(sqlite3 * , int , const  char * );
static int sqlite3VtabBegin(sqlite3 * , VTable * );
static FuncDef *sqlite3VtabOverloadFunction(sqlite3 * , FuncDef * , int nArg , Expr * );
static void sqlite3InvalidFunction(sqlite3_context * , int , sqlite3_value ** );
static sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context * );
static int sqlite3VdbeParameterIndex(Vdbe * , const  char * , int );
static int sqlite3TransferBindings(sqlite3_stmt * , sqlite3_stmt * );
static int sqlite3Reprepare(Vdbe * );
static void sqlite3ExprListCheckLength(Parse * , ExprList * , const  char * );
static CollSeq *sqlite3BinaryCompareCollSeq(Parse * , Expr * , Expr * );
static int sqlite3TempInMemory(const  sqlite3 * );
static const char *sqlite3JournalModename(int );
static int sqlite3Checkpoint(sqlite3 * , int , int , int * , int * );
static int sqlite3WalDefaultHook(void * , sqlite3 * , const  char * , int );
static void sqlite3FkCheck(Parse * , Table * , int , int , int * , int );
static void sqlite3FkDropTable(Parse * , SrcList * , Table * );
static void sqlite3FkActions(Parse * , Table * , ExprList * , int , int * , int );
static int sqlite3FkRequired(Parse * , Table * , int * , int );
static u32 sqlite3FkOldmask(Parse * , Table * );
static FKey *sqlite3FkReferences(Table * );
static void sqlite3FkDelete(sqlite3 * , Table * );
static int sqlite3FkLocateIndex(Parse * , Table * , FKey * , Index ** , int ** );
static void sqlite3BeginBenignMalloc(void );
static void sqlite3EndBenignMalloc(void );
static int sqlite3FindInIndex(Parse * , Expr * , int * );
static void sqlite3MemJournalOpen(sqlite3_file * );
static int sqlite3MemJournalSize(void );
static int sqlite3IsMemJournal(sqlite3_file * );
static void sqlite3ExprSetHeight(Parse *pParse , Expr *p );
static int sqlite3SelectExprHeight(Select * );
static int sqlite3ExprCheckHeight(Parse * , int );
static u32 sqlite3Get4byte(const  u8 * );
static void sqlite3Put4byte(u8 * , u32 );
static void sqlite3VdbeIOTraceSql(Vdbe * );
static void ( *_1280_sqlite3IoTrace)(const  char * , ...);
static const unsigned char _1281_sqlite3UpperToLower[] =  { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  97,  98,  99,  100,  101,  102,  103,  104,  105,  106,  107,  108,  109,  110,  111,  112,  113,  114,  115,  116,  117,  118,  119,  120,  121,  122,  91,  92,  93,  94,  95,  96,  97,  98,  99,  100,  101,  102,  103,  104,  105,  106,  107,  108,  109,  110,  111,  112,  113,  114,  115,  116,  117,  118,  119,  120,  121,  122,  123,  124,  125,  126,  127,  128,  129,  130,  131,  132,  133,  134,  135,  136,  137,  138,  139,  140,  141,  142,  143,  144,  145,  146,  147,  148,  149,  150,  151,  152,  153,  154,  155,  156,  157,  158,  159,  160,  161,  162,  163,  164,  165,  166,  167,  168,  169,  170,  171,  172,  173,  174,  175,  176,  177,  178,  179,  180,  181,  182,  183,  184,  185,  186,  187,  188,  189,  190,  191,  192,  193,  194,  195,  196,  197,  198,  199,  200,  201,  202,  203,  204,  205,  206,  207,  208,  209,  210,  211,  212,  213,  214,  215,  216,  217,  218,  219,  220,  221,  222,  223,  224,  225,  226,  227,  228,  229,  230,  231,  232,  233,  234,  235,  236,  237,  238,  239,  240,  241,  242,  243,  244,  245,  246,  247,  248,  249,  250,  251,  252,  253,  254,  255};
static const unsigned char _1282_sqlite3UpperToLower[] =  { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  97,  98,  99,  100,  101,  102,  103,  104,  105,  106,  107,  108,  109,  110,  111,  112,  113,  114,  115,  116,  117,  118,  119,  120,  121,  122,  91,  92,  93,  94,  95,  96,  97,  98,  99,  100,  101,  102,  103,  104,  105,  106,  107,  108,  109,  110,  111,  112,  113,  114,  115,  116,  117,  118,  119,  120,  121,  122,  123,  124,  125,  126,  127,  128,  129,  130,  131,  132,  133,  134,  135,  136,  137,  138,  139,  140,  141,  142,  143,  144,  145,  146,  147,  148,  149,  150,  151,  152,  153,  154,  155,  156,  157,  158,  159,  160,  161,  162,  163,  164,  165,  166,  167,  168,  169,  170,  171,  172,  173,  174,  175,  176,  177,  178,  179,  180,  181,  182,  183,  184,  185,  186,  187,  188,  189,  190,  191,  192,  193,  194,  195,  196,  197,  198,  199,  200,  201,  202,  203,  204,  205,  206,  207,  208,  209,  210,  211,  212,  213,  214,  215,  216,  217,  218,  219,  220,  221,  222,  223,  224,  225,  226,  227,  228,  229,  230,  231,  232,  233,  234,  235,  236,  237,  238,  239,  240,  241,  242,  243,  244,  245,  246,  247,  248,  249,  250,  251,  252,  253,  254,  255,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  66,  67,  68,  69,  70,  71,  72,  73,  106,  107,  108,  109,  110,  111,  112,  81,  82,  83,  84,  85,  86,  87,  88,  89,  122,  123,  124,  125,  126,  127,  128,  129,  130,  131,  132,  133,  134,  135,  136,  137,  138,  139,  140,  141,  142,  143,  144,  145,  146,  147,  148,  149,  150,  151,  152,  153,  154,  155,  156,  157,  156,  159,  160,  161,  162,  163,  164,  165,  166,  167,  168,  169,  170,  171,  140,  141,  142,  175,  176,  177,  178,  179,  180,  181,  182,  183,  184,  185,  186,  187,  188,  189,  190,  191,  192,  129,  130,  131,  132,  133,  134,  135,  136,  137,  202,  203,  204,  205,  206,  207,  208,  145,  146,  147,  148,  149,  150,  151,  152,  153,  218,  219,  220,  221,  222,  223,  224,  225,  162,  163,  164,  165,  166,  167,  168,  169,  232,  203,  204,  205,  206,  207,  239,  240,  241,  242,  243,  244,  245,  246,  247,  248,  249,  219,  220,  221,  222,  255};
static const unsigned char sqlite3CtypeMap[256] =  { 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x01,  0x01,  0x01,  0x01,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x40,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x0c,  0x0c,  0x0c,  0x0c,  0x0c,  0x0c,  0x0c,  0x0c,  0x0c,  0x0c,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x00,  0x00,  0x00,  0x00,  0x40,  0x00,  0x2a,  0x2a,  0x2a,  0x2a,  0x2a,  0x2a,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x22,  0x00,  0x00,  0x00,  0x00,  0x00,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40,  0x40};
static struct  Sqlite3Config   _1283_sqlite3Config =  { 0,  1,  (0 == 1),  0,  1,  0x7ffffffe,  128,  500,  { 0,  0,  0,  0,  0,  0,  0,  0},  { 0,  0,  0,  0,  0,  0,  0,  0,  0},  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  ((void *) 0),  0,  0,  0,  0,  0,  ((void *) 0),  0,  0,  ((void *) 0),  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0};
static struct  Sqlite3Config   _1284_sqlite3Config =  { 1,  1,  (0 == 1),  0,  1,  0x7ffffffe,  128,  500,  { 0,  0,  0,  0,  0,  0,  0,  0},  { 0,  0,  0,  0,  0,  0,  0,  0,  0},  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  ((void *) 0),  0,  0,  0,  0,  0,  ((void *) 0),  0,  0,  ((void *) 0),  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0};
static FuncDefHash sqlite3GlobalFunctions;
static const Token sqlite3IntTokens[] =  { { "0",  1},  { "1",  1}};
static int sqlite3PendingByte =  0x40000000;
static const unsigned char sqlite3OpcodeProperty[] =  { 0x00,  0x00,  0x00,  0x00,  0x00,  0x01,  0x01,  0x01,  0x00,  0x00,  0x02,  0x00,  0x01,  0x00,  0x01,  0x01,  0x04,  0x04,  0x10,  0x24,  0x00,  0x02,  0x02,  0x02,  0x02,  0x02,  0x02,  0x00,  0x00,  0x24,  0x00,  0x00,  0x04,  0x05,  0x04,  0x00,  0x00,  0x01,  0x01,  0x05,  0x05,  0x00,  0x00,  0x00,  0x02,  0x02,  0x10,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x11,  0x11,  0x11,  0x11,  0x08,  0x11,  0x11,  0x11,  0x11,  0x02,  0x02,  0x00,  0x00,  0x4c,  0x4c,  0x00,  0x00,  0x00,  0x05,  0x05,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x00,  0x4c,  0x4c,  0x4c,  0x4c,  0x4c,  0x4c,  0x4c,  0x4c,  0x4c,  0x4c,  0x00,  0x24,  0x02,  0x00,  0x02,  0x00,  0x01,  0x01,  0x01,  0x01,  0x08,  0x08,  0x00,  0x02,  0x01,  0x01,  0x02,  0x00,  0x02,  0x02,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x0c,  0x45,  0x15,  0x01,  0x02,  0x00,  0x01,  0x08,  0x05,  0x05,  0x05,  0x00,  0x02,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x01,  0x00,  0x04,  0x04,  0x04,  0x04,  0x04,  0x02,  0x02,  0x00,  0x00,  0x00};
char **azCompileOpt;
void init_azCompileOpt()  {
  int elements =  0;
  (azCompileOpt = ((char **) malloc((39 * sizeof(char *)))));
  if (((id2i_sqlite_check_pages ) )) {
    (azCompileOpt[elements] = "CHECK_PAGES");
  }  
  if (((id2i_sqlite_check_pages ) )) {
    elements++;
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    (azCompileOpt[elements] = "COVERAGE_TEST");
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    elements++;
  }  
  if (((id2i_sqlite_enable_column_metadata ) )) {
    (azCompileOpt[elements] = "ENABLE_COLUMN_METADATA");
  }  
  if (((id2i_sqlite_enable_column_metadata ) )) {
    elements++;
  }  
  if (((id2i_sqlite_enable_expensive_assert ) )) {
    (azCompileOpt[elements] = "ENABLE_EXPENSIVE_ASSERT");
  }  
  if (((id2i_sqlite_enable_expensive_assert ) )) {
    elements++;
  }  
  if ((((! id2i_sqlite_enable_fts4) && id2i_sqlite_enable_fts3) || (id2i_sqlite_enable_fts4 ))) {
    (azCompileOpt[elements] = "ENABLE_FTS3");
  }  
  if ((((! id2i_sqlite_enable_fts4) && id2i_sqlite_enable_fts3) || (id2i_sqlite_enable_fts4 ))) {
    elements++;
  }  
  if (((id2i_sqlite_enable_fts4 ) )) {
    (azCompileOpt[elements] = "ENABLE_FTS4");
  }  
  if (((id2i_sqlite_enable_fts4 ) )) {
    elements++;
  }  
  if (((id2i_sqlite_enable_iotrace ) )) {
    (azCompileOpt[elements] = "ENABLE_IOTRACE");
  }  
  if (((id2i_sqlite_enable_iotrace ) )) {
    elements++;
  }  
  (azCompileOpt[elements] = "ENABLE_LOCKING_STYLE=SQLITE_ENABLE_LOCKING_STYLE");
  elements++;
  if (((id2i_sqlite_enable_memory_management ) )) {
    (azCompileOpt[elements] = "ENABLE_MEMORY_MANAGEMENT");
  }  
  if (((id2i_sqlite_enable_memory_management ) )) {
    elements++;
  }  
  if (((id2i_sqlite_enable_memsys3 ) )) {
    (azCompileOpt[elements] = "ENABLE_MEMSYS3");
  }  
  if (((id2i_sqlite_enable_memsys3 ) )) {
    elements++;
  }  
  if (((id2i_sqlite_enable_memsys5 ) )) {
    (azCompileOpt[elements] = "ENABLE_MEMSYS5");
  }  
  if (((id2i_sqlite_enable_memsys5 ) )) {
    elements++;
  }  
  if (((id2i_sqlite_enable_oversize_cell_check ) )) {
    (azCompileOpt[elements] = "ENABLE_OVERSIZE_CELL_CHECK");
  }  
  if (((id2i_sqlite_enable_oversize_cell_check ) )) {
    elements++;
  }  
  if (((id2i_sqlite_have_isnan ) )) {
    (azCompileOpt[elements] = "HAVE_ISNAN");
  }  
  if (((id2i_sqlite_have_isnan ) )) {
    elements++;
  }  
  if (((id2i_sqlite_homegrown_recursive_mutex ) )) {
    (azCompileOpt[elements] = "HOMEGROWN_RECURSIVE_MUTEX");
  }  
  if (((id2i_sqlite_homegrown_recursive_mutex ) )) {
    elements++;
  }  
  (azCompileOpt[elements] = "MAX_MMAP_SIZE=" "0");
  elements++;
  if (((id2i_sqlite_no_sync ) )) {
    (azCompileOpt[elements] = "NO_SYNC");
  }  
  if (((id2i_sqlite_no_sync ) )) {
    elements++;
  }  
  if (((id2i_sqlite_omit_analyze ) )) {
    (azCompileOpt[elements] = "OMIT_ANALYZE");
  }  
  if (((id2i_sqlite_omit_analyze ) )) {
    elements++;
  }  
  if (((id2i_sqlite_omit_autovacuum ) )) {
    (azCompileOpt[elements] = "OMIT_AUTOVACUUM");
  }  
  if (((id2i_sqlite_omit_autovacuum ) )) {
    elements++;
  }  
  if (((id2i_sqlite_omit_blob_literal ) )) {
    (azCompileOpt[elements] = "OMIT_BLOB_LITERAL");
  }  
  if (((id2i_sqlite_omit_blob_literal ) )) {
    elements++;
  }  
  if (((id2i_sqlite_omit_builtin_test ) )) {
    (azCompileOpt[elements] = "OMIT_BUILTIN_TEST");
  }  
  if (((id2i_sqlite_omit_builtin_test ) )) {
    elements++;
  }  
  if (((id2i_sqlite_omit_cast ) )) {
    (azCompileOpt[elements] = "OMIT_CAST");
  }  
  if (((id2i_sqlite_omit_cast ) )) {
    elements++;
  }  
  if (((id2i_sqlite_omit_decltype ) )) {
    (azCompileOpt[elements] = "OMIT_DECLTYPE");
  }  
  if (((id2i_sqlite_omit_decltype ) )) {
    elements++;
  }  
  if (((id2i_sqlite_omit_deprecated ) )) {
    (azCompileOpt[elements] = "OMIT_DEPRECATED");
  }  
  if (((id2i_sqlite_omit_deprecated ) )) {
    elements++;
  }  
  if (((id2i_sqlite_omit_explain ) )) {
    (azCompileOpt[elements] = "OMIT_EXPLAIN");
  }  
  if (((id2i_sqlite_omit_explain ) )) {
    elements++;
  }  
  if (((id2i_sqlite_omit_foreign_key ) )) {
    (azCompileOpt[elements] = "OMIT_FOREIGN_KEY");
  }  
  if (((id2i_sqlite_omit_foreign_key ) )) {
    elements++;
  }  
  (azCompileOpt[elements] = "OMIT_LOAD_EXTENSION");
  elements++;
  if (((id2i_sqlite_omit_or_optimization ) )) {
    (azCompileOpt[elements] = "OMIT_OR_OPTIMIZATION");
  }  
  if (((id2i_sqlite_omit_or_optimization ) )) {
    elements++;
  }  
  if (((id2i_sqlite_omit_pager_pragmas ) )) {
    (azCompileOpt[elements] = "OMIT_PAGER_PRAGMAS");
  }  
  if (((id2i_sqlite_omit_pager_pragmas ) )) {
    elements++;
  }  
  if (((id2i_sqlite_omit_subquery ) )) {
    (azCompileOpt[elements] = "OMIT_SUBQUERY");
  }  
  if (((id2i_sqlite_omit_subquery ) )) {
    elements++;
  }  
  if (((id2i_sqlite_omit_view ) )) {
    (azCompileOpt[elements] = "OMIT_VIEW");
  }  
  if (((id2i_sqlite_omit_view ) )) {
    elements++;
  }  
  if (((id2i_sqlite_rtree_int_only ) )) {
    (azCompileOpt[elements] = "RTREE_INT_ONLY");
  }  
  if (((id2i_sqlite_rtree_int_only ) )) {
    elements++;
  }  
  if (((id2i_sqlite_small_stack ) )) {
    (azCompileOpt[elements] = "SMALL_STACK");
  }  
  if (((id2i_sqlite_small_stack ) )) {
    elements++;
  }  
  (azCompileOpt[elements] = "THREADSAFE=" "1");
  elements++;
  (azCompileOpt = ((char **) realloc(azCompileOpt, (elements * sizeof(char *)))));
}
int sqlite3_compileoption_used(const  char *zOptName )  {
  int i, n;
  if ((sqlite3_strnicmp(zOptName, "SQLITE_", 7) == 0)) {
    (zOptName += 7);
  }  
  (n = sqlite3Strlen30(zOptName));
  for ((i = 0); (i < ((int ) (sizeof(azCompileOpt) / sizeof(azCompileOpt[0])))); i++) {
    if (((sqlite3_strnicmp(zOptName, azCompileOpt[i], n) == 0) && (sqlite3CtypeMap[((unsigned  char ) azCompileOpt[i][n])] == 0))) {
      return 1;
    }  
  }
  return 0;
}
const  char *sqlite3_compileoption_get(int N )  {
  if (((N >= 0) && (N < ((int ) (sizeof(azCompileOpt) / sizeof(azCompileOpt[0])))))) {
    return azCompileOpt[N];
  }  
  return 0;
}
typedef struct  VdbeOp   Op;
typedef unsigned char Bool;
typedef struct  VdbeSorter   VdbeSorter;
typedef struct  Explain   Explain;
typedef struct  AuxData   AuxData;
struct  VdbeCursor {
  BtCursor *pCursor ;
  Btree *pBt ;
  KeyInfo *pKeyInfo ;
  int iDb ;
  int pseudoTableReg ;
  int nField ;
  Bool zeroed ;
  Bool rowidIsValid ;
  Bool atFirst ;
  Bool useRandomRowid ;
  Bool nullRow ;
  Bool deferredMoveto ;
  Bool isTable ;
  Bool isIndex ;
  Bool isOrdered ;
  Bool isSorter ;
  Bool multiPseudo ;
  sqlite3_vtab_cursor *pVtabCursor ;
  const  sqlite3_module *pModule ;
  i64 seqCount ;
  i64 movetoTarget ;
  i64 lastRowid ;
  VdbeSorter *pSorter ;
  int seekResult ;
  u32 cacheStatus ;
  int payloadSize ;
  u32 *aType ;
  u32 *aOffset ;
  u8 *aRow ;
}  ;
typedef struct  VdbeCursor   VdbeCursor;
typedef struct  VdbeFrame   VdbeFrame;
struct  VdbeFrame {
  Vdbe *v ;
  VdbeFrame *pParent ;
  Op *aOp ;
  Mem *aMem ;
  u8 *aOnceFlag ;
  VdbeCursor **apCsr ;
  void *token ;
  i64 lastRowid ;
  int nCursor ;
  int pc ;
  int nOp ;
  int nMem ;
  int nOnceFlag ;
  int nChildMem ;
  int nChildCsr ;
  int nChange ;
}  ;
struct  Mem {
  sqlite3 *db ;
  char *z ;
  double r ;
  union   {
    i64 i ;
    int nZero ;
    FuncDef *pDef ;
    RowSet *pRowSet ;
    VdbeFrame *pFrame ;
  }  u ;
  int n ;
  u16 flags ;
  u8 type ;
  u8 enc ;
  void ( *xDel)(void * ) ;
  char *zMalloc ;
}  ;
struct  AuxData {
  int iOp ;
  int iArg ;
  void *pAux ;
  void ( *xDelete)(void * ) ;
  AuxData *pNext ;
}  ;
struct  sqlite3_context {
  FuncDef *pFunc ;
  Mem s ;
  Mem *pMem ;
  CollSeq *pColl ;
  Vdbe *pVdbe ;
  int iOp ;
  int isError ;
  u8 skipFlag ;
  u8 fErrorOrAux ;
}  ;
struct  Explain {
  Vdbe *pVdbe ;
  StrAccum str ;
  int nIndent ;
  u16 aIndent[100] ;
  char zBase[100] ;
}  ;
typedef unsigned bft;
struct  Vdbe {
  sqlite3 *db ;
  Op *aOp ;
  Mem *aMem ;
  Mem **apArg ;
  Mem *aColName ;
  Mem *pResultSet ;
  int nMem ;
  int nOp ;
  int nOpAlloc ;
  int nLabel ;
  int *aLabel ;
  u16 nResColumn ;
  int nCursor ;
  u32 magic ;
  char *zErrMsg ;
  Vdbe *pPrev , *pNext ;
  VdbeCursor **apCsr ;
  Mem *aVar ;
  char **azVar ;
  ynVar nVar ;
  ynVar nzVar ;
  u32 cacheCtr ;
  int pc ;
  int rc ;
  u8 errorAction ;
  u8 minWriteFileFormat ;
  bft explain: 2 ;
  bft inVtabMethod: 2 ;
  bft changeCntOn: 1 ;
  bft expired: 1 ;
  bft runOnlyOnce: 1 ;
  bft usesStmtJournal: 1 ;
  bft readOnly: 1 ;
  bft bIsReader: 1 ;
  bft isPrepareV2: 1 ;
  bft doingRerun: 1 ;
  int nChange ;
  yDbMask btreeMask ;
  yDbMask lockMask ;
  int iStatement ;
  u32 aCounter[5] ;
  i64 startTime ;
  i64 iCurrentTime ;
  i64 nFkConstraint ;
  i64 nStmtDefCons ;
  i64 nStmtDefImmCons ;
  char *zSql ;
  void *pFree ;
  Explain *_1276_pExplain ;
  char *_1276_zExplain ;
  VdbeFrame *pFrame ;
  VdbeFrame *pDelFrame ;
  int nFrame ;
  u32 expmask ;
  SubProgram *pProgram ;
  int nOnceFlag ;
  u8 *aOnceFlag ;
  AuxData *pAuxData ;
}  ;
static void sqlite3VdbeFreeCursor(Vdbe * , VdbeCursor * );
void sqliteVdbePopStack(Vdbe * , int );
static int sqlite3VdbeCursorMoveto(VdbeCursor * );
static void sqlite3VdbePrintOp(FILE * , int , Op * );
static u32 sqlite3VdbeSerialTypeLen(u32 );
static u32 sqlite3VdbeSerialType(Mem * , int );
static u32 sqlite3VdbeSerialPut(unsigned  char * , int , Mem * , int );
static u32 sqlite3VdbeSerialGet(const  unsigned  char * , u32 , Mem * );
static void sqlite3VdbeDeleteAuxData(Vdbe * , int , int );
int sqlite2BtreeKeyCompare(BtCursor * , const  void * , int , int , int * );
static int sqlite3VdbeIdxKeyCompare(VdbeCursor * , UnpackedRecord * , int * );
static int sqlite3VdbeIdxRowid(sqlite3 * , BtCursor * , i64 * );
static int sqlite3MemCompare(const  Mem * , const  Mem * , const  CollSeq * );
static int _1319_sqlite3VdbeExec(Vdbe * );
static int _1269_sqlite3VdbeExec(Vdbe * );
static int sqlite3VdbeList(Vdbe * );
static int sqlite3VdbeHalt(Vdbe * );
static int sqlite3VdbeChangeEncoding(Mem * , int );
static int sqlite3VdbeMemTooBig(Mem * );
static int sqlite3VdbeMemCopy(Mem * , const  Mem * );
static void sqlite3VdbeMemShallowCopy(Mem * , const  Mem * , int );
static void sqlite3VdbeMemMove(Mem * , Mem * );
static int sqlite3VdbeMemNulTerminate(Mem * );
static int sqlite3VdbeMemSetStr(Mem * , const  char * , int , u8 , void ( *)(void * ) );
static void sqlite3VdbeMemSetInt64(Mem * , i64 );
static void sqlite3VdbeMemSetDouble(Mem * , double );
static void sqlite3VdbeMemSetNull(Mem * );
static void sqlite3VdbeMemSetZeroBlob(Mem * , int );
static void sqlite3VdbeMemSetRowSet(Mem * );
static int sqlite3VdbeMemMakeWriteable(Mem * );
static int sqlite3VdbeMemStringify(Mem * , int );
static i64 sqlite3VdbeIntValue(Mem * );
static int sqlite3VdbeMemIntegerify(Mem * );
static double sqlite3VdbeRealValue(Mem * );
static void sqlite3VdbeIntegerAffinity(Mem * );
static int sqlite3VdbeMemRealify(Mem * );
static int sqlite3VdbeMemNumerify(Mem * );
static int sqlite3VdbeMemFromBtree(BtCursor * , int , int , int , Mem * );
static void sqlite3VdbeMemRelease(Mem *p );
static void sqlite3VdbeMemReleaseExternal(Mem *p );
static int sqlite3VdbeMemFinalize(Mem * , FuncDef * );
static const char *sqlite3OpcodeName(int );
static int sqlite3VdbeMemGrow(Mem *pMem , int n , int preserve );
static int sqlite3VdbeCloseStatement(Vdbe * , int );
static void sqlite3VdbeFrameDelete(VdbeFrame * );
static int sqlite3VdbeFrameRestore(VdbeFrame * );
static void sqlite3VdbeMemStoreType(Mem *pMem );
static int sqlite3VdbeTransferError(Vdbe *p );
static int sqlite3VdbeSorterInit(sqlite3 * , VdbeCursor * );
static void sqlite3VdbeSorterClose(sqlite3 * , VdbeCursor * );
static int sqlite3VdbeSorterRowkey(const  VdbeCursor * , Mem * );
static int sqlite3VdbeSorterNext(sqlite3 * , const  VdbeCursor * , int * );
static int sqlite3VdbeSorterRewind(sqlite3 * , const  VdbeCursor * , int * );
static int sqlite3VdbeSorterWrite(sqlite3 * , const  VdbeCursor * , Mem * );
static int sqlite3VdbeSorterCompare(const  VdbeCursor * , Mem * , int * );
static int sqlite3VdbeCheckFk(Vdbe * , int );
static int sqlite3VdbeMemTranslate(Mem * , u8 );
static int sqlite3VdbeMemHandleBom(Mem *pMem );
static int sqlite3VdbeMemExpandBlob(Mem * );
typedef struct  sqlite3StatType   sqlite3StatType;
static struct  sqlite3StatType {
  int nowValue[10] ;
  int mxValue[10] ;
}  sqlite3Stat =  { { 0},  { 0}};
static  int sqlite3StatusValue(int op )  {
  ((void ) 0);
  return sqlite3Stat.nowValue[op];
}
static  void sqlite3StatusAdd(int op , int N )  {
  ((void ) 0);
  (sqlite3Stat.nowValue[op] += N);
  if ((sqlite3Stat.nowValue[op] > sqlite3Stat.mxValue[op])) {
    (sqlite3Stat.mxValue[op] = sqlite3Stat.nowValue[op]);
  }  
}
static  void sqlite3StatusSet(int op , int X )  {
  ((void ) 0);
  (sqlite3Stat.nowValue[op] = X);
  if ((sqlite3Stat.nowValue[op] > sqlite3Stat.mxValue[op])) {
    (sqlite3Stat.mxValue[op] = sqlite3Stat.nowValue[op]);
  }  
}
int sqlite3_status(int op , int *pCurrent , int *pHighwater , int resetFlag )  {
  if (((op < 0) || (op >= ((int ) (sizeof(sqlite3Stat.nowValue) / sizeof(sqlite3Stat.nowValue[0])))))) {
    return sqlite3MisuseError(13663);
  }  
  ((*pCurrent) = sqlite3Stat.nowValue[op]);
  ((*pHighwater) = sqlite3Stat.mxValue[op]);
  if (resetFlag) {
    (sqlite3Stat.mxValue[op] = sqlite3Stat.nowValue[op]);
  }  
  return 0;
}
int sqlite3_db_status(sqlite3 *db , int op , int *pCurrent , int *pHighwater , int resetFlag )  {
  int rc =  0;
  switch (op) {
    case 0:
    {
      ((*pCurrent) = db->lookaside.nOut);
      ((*pHighwater) = db->lookaside.mxOut);
      if (resetFlag) {
        (db->lookaside.mxOut = db->lookaside.nOut);
      }  
      break;
    }
    case 4:
    case 5:
    case 6:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 4)) {
          sqlite3Coverage(13698);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 5)) {
          sqlite3Coverage(13699);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 6)) {
          sqlite3Coverage(13700);
        }  
      }  
      ((void ) 0);
      ((void ) 0);
      ((*pCurrent) = 0);
      ((*pHighwater) = db->lookaside.anStat[(op - 4)]);
      if (resetFlag) {
        (db->lookaside.anStat[(op - 4)] = 0);
      }  
      break;
    }
    case 1:
    {
      int totalUsed =  0;
      int i;
      sqlite3BtreeEnterAll(db);
      for ((i = 0); (i < db->nDb); i++) {
        Btree *pBt =  db->aDb[i].pBt;
        if (pBt) {
          Pager *pPager =  sqlite3BtreePager(pBt);
          (totalUsed += sqlite3PagerMemUsed(pPager));
        }  
      }
      ((*pCurrent) = totalUsed);
      ((*pHighwater) = 0);
      break;
    }
    case 2:
    {
      int i;
      int nByte =  0;
      sqlite3BtreeEnterAll(db);
      (db->pnBytesFreed = (&nByte));
      for ((i = 0); (i < db->nDb); i++) {
        Schema *pSchema =  db->aDb[i].pSchema;
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            HashElem *p;
            if ((((! id2i_sqlite_default_memstatus) ) )) {
              (nByte += (_1283_sqlite3Config.m.xRoundup(sizeof(HashElem )) * (pSchema->tblHash.count + pSchema->trigHash.count + pSchema->idxHash.count + pSchema->fkeyHash.count)));
            }  
            if (((id2i_sqlite_default_memstatus ) )) {
              (nByte += (_1284_sqlite3Config.m.xRoundup(sizeof(HashElem )) * (pSchema->tblHash.count + pSchema->trigHash.count + pSchema->idxHash.count + pSchema->fkeyHash.count)));
            }  
            (nByte += sqlite3MallocSize(pSchema->tblHash.ht));
            (nByte += sqlite3MallocSize(pSchema->trigHash.ht));
            (nByte += sqlite3MallocSize(pSchema->idxHash.ht));
            (nByte += sqlite3MallocSize(pSchema->fkeyHash.ht));
            for ((p = (&pSchema->trigHash)->first); p; (p = p->next)) {
              sqlite3DeleteTrigger(db, ((Trigger *) p->data));
            }
            for ((p = (&pSchema->tblHash)->first); p; (p = p->next)) {
              sqlite3DeleteTable(db, ((Table *) p->data));
            }
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((pSchema != 0)) {
            HashElem *p;
            if ((((! id2i_sqlite_default_memstatus) ) )) {
              (nByte += (_1283_sqlite3Config.m.xRoundup(sizeof(HashElem )) * (pSchema->tblHash.count + pSchema->trigHash.count + pSchema->idxHash.count + pSchema->fkeyHash.count)));
            }  
            if (((id2i_sqlite_default_memstatus ) )) {
              (nByte += (_1284_sqlite3Config.m.xRoundup(sizeof(HashElem )) * (pSchema->tblHash.count + pSchema->trigHash.count + pSchema->idxHash.count + pSchema->fkeyHash.count)));
            }  
            (nByte += sqlite3MallocSize(pSchema->tblHash.ht));
            (nByte += sqlite3MallocSize(pSchema->trigHash.ht));
            (nByte += sqlite3MallocSize(pSchema->idxHash.ht));
            (nByte += sqlite3MallocSize(pSchema->fkeyHash.ht));
            for ((p = (&pSchema->trigHash)->first); p; (p = p->next)) {
              sqlite3DeleteTrigger(db, ((Trigger *) p->data));
            }
            for ((p = (&pSchema->tblHash)->first); p; (p = p->next)) {
              sqlite3DeleteTable(db, ((Table *) p->data));
            }
          }  
        }  
      }
      (db->pnBytesFreed = 0);
      ((*pHighwater) = 0);
      ((*pCurrent) = nByte);
      break;
    }
    case 3:
    {
      struct  Vdbe   *pVdbe;
      int nByte =  0;
      (db->pnBytesFreed = (&nByte));
      for ((pVdbe = db->pVdbe); pVdbe; (pVdbe = pVdbe->pNext)) {
        sqlite3VdbeClearObject(db, pVdbe);
        sqlite3DbFree(db, pVdbe);
      }
      (db->pnBytesFreed = 0);
      ((*pHighwater) = 0);
      ((*pCurrent) = nByte);
      break;
    }
    case 7:
    case 8:
    case 9:
    {
      int i;
      int nRet =  0;
      ((void ) 0);
      ((void ) 0);
      for ((i = 0); (i < db->nDb); i++) {
        if (db->aDb[i].pBt) {
          Pager *pPager =  sqlite3BtreePager(db->aDb[i].pBt);
          sqlite3PagerCacheStat(pPager, op, resetFlag, (&nRet));
        }  
      }
      ((*pHighwater) = 0);
      ((*pCurrent) = nRet);
      break;
    }
    case 10:
    {
      ((*pHighwater) = 0);
      ((*pCurrent) = ((db->nDeferredImmCons > 0) || (db->nDeferredCons > 0)));
      break;
    }
    id2i_label_1:
    default:
    {
      (rc = 1);
    }
  }
  return rc;
}
struct  timex {
  unsigned  int modes ;
  __syscall_slong_t offset ;
  __syscall_slong_t freq ;
  __syscall_slong_t maxerror ;
  __syscall_slong_t esterror ;
  int status ;
  __syscall_slong_t constant ;
  __syscall_slong_t precision ;
  __syscall_slong_t tolerance ;
  struct  timeval   time ;
  __syscall_slong_t tick ;
  __syscall_slong_t ppsfreq ;
  __syscall_slong_t jitter ;
  int shift ;
  __syscall_slong_t stabil ;
  __syscall_slong_t jitcnt ;
  __syscall_slong_t calcnt ;
  __syscall_slong_t errcnt ;
  __syscall_slong_t stbcnt ;
  int tai ;
  int : 32 ;
  int : 32 ;
  int : 32 ;
  int : 32 ;
  int : 32 ;
  int : 32 ;
  int : 32 ;
  int : 32 ;
  int : 32 ;
  int : 32 ;
  int : 32 ;
}  ;
extern int clock_adjtime(__clockid_t __clock_id , struct  timex   *__utx ) __attribute__((__nothrow__));
struct  tm {
  int tm_sec ;
  int tm_min ;
  int tm_hour ;
  int tm_mday ;
  int tm_mon ;
  int tm_year ;
  int tm_wday ;
  int tm_yday ;
  int tm_isdst ;
  long  int tm_gmtoff ;
  const  char *tm_zone ;
}  ;
struct  itimerspec {
  struct  timespec   it_interval ;
  struct  timespec   it_value ;
}  ;
struct  sigevent   ;
extern clock_t clock(void ) __attribute__((__nothrow__));
extern time_t time(time_t *__timer ) __attribute__((__nothrow__));
extern double difftime(time_t __time1 , time_t __time0 ) __attribute__((__nothrow__)) __attribute__((__const__));
extern time_t mktime(struct  tm   *__tp ) __attribute__((__nothrow__));
extern size_t strftime(char *__restrict __s , size_t __maxsize , const  char *__restrict __format , const  struct  tm   *__restrict __tp ) __attribute__((__nothrow__));
extern char *strptime(const  char *__restrict __s , const  char *__restrict __fmt , struct  tm   *__tp ) __attribute__((__nothrow__));
extern size_t strftime_l(char *__restrict __s , size_t __maxsize , const  char *__restrict __format , const  struct  tm   *__restrict __tp , __locale_t __loc ) __attribute__((__nothrow__));
extern char *strptime_l(const  char *__restrict __s , const  char *__restrict __fmt , struct  tm   *__tp , __locale_t __loc ) __attribute__((__nothrow__));
extern struct  tm   *gmtime(const  time_t *__timer ) __attribute__((__nothrow__));
extern struct  tm   *localtime(const  time_t *__timer ) __attribute__((__nothrow__));
extern struct  tm   *gmtime_r(const  time_t *__restrict __timer , struct  tm   *__restrict __tp ) __attribute__((__nothrow__));
extern struct  tm   *localtime_r(const  time_t *__restrict __timer , struct  tm   *__restrict __tp ) __attribute__((__nothrow__));
extern char *asctime(const  struct  tm   *__tp ) __attribute__((__nothrow__));
extern char *ctime(const  time_t *__timer ) __attribute__((__nothrow__));
extern char *asctime_r(const  struct  tm   *__restrict __tp , char *__restrict __buf ) __attribute__((__nothrow__));
extern char *ctime_r(const  time_t *__restrict __timer , char *__restrict __buf ) __attribute__((__nothrow__));
extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;
extern char *tzname[2];
extern void tzset(void ) __attribute__((__nothrow__));
extern int daylight;
extern long int timezone;
extern int stime(const  time_t *__when ) __attribute__((__nothrow__));
extern time_t timegm(struct  tm   *__tp ) __attribute__((__nothrow__));
extern time_t timelocal(struct  tm   *__tp ) __attribute__((__nothrow__));
extern int dysize(int __year ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int nanosleep(const  struct  timespec   *__requested_time , struct  timespec   *__remaining );
extern int clock_getres(clockid_t __clock_id , struct  timespec   *__res ) __attribute__((__nothrow__));
extern int clock_gettime(clockid_t __clock_id , struct  timespec   *__tp ) __attribute__((__nothrow__));
extern int clock_settime(clockid_t __clock_id , const  struct  timespec   *__tp ) __attribute__((__nothrow__));
extern int clock_nanosleep(clockid_t __clock_id , int __flags , const  struct  timespec   *__req , struct  timespec   *__rem );
extern int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) __attribute__((__nothrow__));
extern int timer_create(clockid_t __clock_id , struct  sigevent   *__restrict __evp , timer_t *__restrict __timerid ) __attribute__((__nothrow__));
extern int timer_delete(timer_t __timerid ) __attribute__((__nothrow__));
extern int timer_settime(timer_t __timerid , int __flags , const  struct  itimerspec   *__restrict __value , struct  itimerspec   *__restrict __ovalue ) __attribute__((__nothrow__));
extern int timer_gettime(timer_t __timerid , struct  itimerspec   *__value ) __attribute__((__nothrow__));
extern int timer_getoverrun(timer_t __timerid ) __attribute__((__nothrow__));
extern int timespec_get(struct  timespec   *__ts , int __base ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int getdate_err;
extern struct  tm   *getdate(const  char *__string );
extern int getdate_r(const  char *__restrict __string , struct  tm   *__restrict __resbufp );
typedef struct  DateTime   DateTime;
struct  DateTime {
  sqlite3_int64 iJD ;
  int Y , M , D ;
  int h , m ;
  int tz ;
  double s ;
  char validYMD ;
  char validHMS ;
  char validJD ;
  char validTZ ;
}  ;
static  int getDigits(const  char *zDate , ...)  {
  va_list ap;
  int val;
  int N;
  int min;
  int max;
  int nextC;
  int *pVal;
  int cnt =  0;
  __builtin_va_start(ap, zDate);
  do {
    (N = __builtin_va_arg(ap, int ));
    (min = __builtin_va_arg(ap, int ));
    (max = __builtin_va_arg(ap, int ));
    (nextC = __builtin_va_arg(ap, int ));
    (pVal = __builtin_va_arg(ap, int *));
    (val = 0);
    while (N--) {
      if ((! (sqlite3CtypeMap[((unsigned  char ) (*zDate))] & 0x04))) {
        goto end_getDigits;
      }  
      (val = ((val * 10) + (*zDate) - '0'));
      zDate++;
    }
    if (((val < min) || (val > max) || ((nextC != 0) && (nextC != (*zDate))))) {
      goto end_getDigits;
    }  
    ((*pVal) = val);
    zDate++;
    cnt++;
  } while (nextC);
  end_getDigits:
  __builtin_va_end(ap);
  return cnt;
}
static  int parseTimezone(const  char *zDate , DateTime *p )  {
  int sgn =  0;
  int nHr, nMn;
  int c;
  while ((sqlite3CtypeMap[((unsigned  char ) (*zDate))] & 0x01)) {
    zDate++;
  }
  (p->tz = 0);
  (c = (*zDate));
  if ((c == '-')) {
    (sgn = (- 1));
  } 
  else if ((c == '+')) {
    (sgn = (+ 1));
  }
  
  else if (((c == 'Z') || (c == 'z'))) {
    zDate++;
    goto zulu_time;
  } 
  else {
    return (c != 0);
  }
  zDate++;
  if ((getDigits(zDate, 2, 0, 14, ':', (&nHr), 2, 0, 59, 0, (&nMn)) != 2)) {
    return 1;
  }  
  (zDate += 5);
  (p->tz = (sgn * (nMn + (nHr * 60))));
  zulu_time:
  while ((sqlite3CtypeMap[((unsigned  char ) (*zDate))] & 0x01)) {
    zDate++;
  }
  return ((*zDate) != 0);
}
static  int parseHhMmSs(const  char *zDate , DateTime *p )  {
  int h, m, s;
  double ms =  0.0;
  if ((getDigits(zDate, 2, 0, 24, ':', (&h), 2, 0, 59, 0, (&m)) != 2)) {
    return 1;
  }  
  (zDate += 5);
  if (((*zDate) == ':')) {
    zDate++;
    if ((getDigits(zDate, 2, 0, 59, 0, (&s)) != 1)) {
      return 1;
    }  
    (zDate += 2);
    if ((((*zDate) == '.') && (sqlite3CtypeMap[((unsigned  char ) zDate[1])] & 0x04))) {
      double rScale =  1.0;
      zDate++;
      while ((sqlite3CtypeMap[((unsigned  char ) (*zDate))] & 0x04)) {
        (ms = ((ms * 10.0) + (*zDate) - '0'));
        (rScale *= 10.0);
        zDate++;
      }
      (ms /= rScale);
    }  
  }  
  else {
    (s = 0);
  }
  (p->validJD = 0);
  (p->validHMS = 1);
  (p->h = h);
  (p->m = m);
  (p->s = (s + ms));
  if (parseTimezone(zDate, p)) {
    return 1;
  }  
  (p->validTZ = ((p->tz != 0) ? 1 : 0));
  return 0;
}
static  void computeJD(DateTime *p )  {
  int Y, M, D, A, B, X1, X2;
  if (p->validJD) {
    return;
  }  
  if (p->validYMD) {
    (Y = p->Y);
    (M = p->M);
    (D = p->D);
  }  
  else {
    (Y = 2000);
    (M = 1);
    (D = 1);
  }
  if ((M <= 2)) {
    Y--;
    (M += 12);
  }  
  (A = (Y / 100));
  (B = (2 - A + (A / 4)));
  (X1 = (36525 * (Y + 4716) / 100));
  (X2 = (306001 * (M + 1) / 10000));
  (p->iJD = ((sqlite3_int64 ) ((X1 + X2 + D + B - 1524.5) * 86400000)));
  (p->validJD = 1);
  if (p->validHMS) {
    (p->iJD += ((p->h * 3600000) + (p->m * 60000) + ((sqlite3_int64 ) (p->s * 1000))));
    if (p->validTZ) {
      (p->iJD -= (p->tz * 60000));
      (p->validYMD = 0);
      (p->validHMS = 0);
      (p->validTZ = 0);
    }  
  }  
}
static  int parseYyyyMmDd(const  char *zDate , DateTime *p )  {
  int Y, M, D, neg;
  if ((zDate[0] == '-')) {
    zDate++;
    (neg = 1);
  }  
  else {
    (neg = 0);
  }
  if ((getDigits(zDate, 4, 0, 9999, '-', (&Y), 2, 1, 12, '-', (&M), 2, 1, 31, 0, (&D)) != 3)) {
    return 1;
  }  
  (zDate += 10);
  while (((sqlite3CtypeMap[((unsigned  char ) (*zDate))] & 0x01) || ('T' == (*((u8 *) zDate))))) {
    zDate++;
  }
  if ((parseHhMmSs(zDate, p) == 0)) {
    
  } 
  else if (((*zDate) == 0)) {
    (p->validHMS = 0);
  } 
  else {
    return 1;
  }
  (p->validJD = 0);
  (p->validYMD = 1);
  (p->Y = (neg ? (- Y) : Y));
  (p->M = M);
  (p->D = D);
  if (p->validTZ) {
    computeJD(p);
  }  
  return 0;
}
static  int setDateTimeToCurrent(sqlite3_context *context , DateTime *p )  {
  (p->iJD = sqlite3StmtCurrentTime(context));
  if ((p->iJD > 0)) {
    (p->validJD = 1);
    return 0;
  }  
  else {
    return 1;
  }
}
static  int parseDateOrTime(sqlite3_context *context , const  char *zDate , DateTime *p )  {
  double r;
  if ((parseYyyyMmDd(zDate, p) == 0)) {
    return 0;
  } 
  else if ((parseHhMmSs(zDate, p) == 0)) {
    return 0;
  }
  
  else if ((sqlite3_stricmp(zDate, "now") == 0)) {
    return setDateTimeToCurrent(context, p);
  }
  
  else if (sqlite3AtoF(zDate, (&r), sqlite3Strlen30(zDate), 1)) {
    (p->iJD = ((sqlite3_int64 ) ((r * 86400000.0) + 0.5)));
    (p->validJD = 1);
    return 0;
  } 
  return 1;
}
static  void computeYMD(DateTime *p )  {
  int Z, A, B, C, D, E, X1;
  if (p->validYMD) {
    return;
  }  
  if ((! p->validJD)) {
    (p->Y = 2000);
    (p->M = 1);
    (p->D = 1);
  }  
  else {
    (Z = ((int ) ((p->iJD + 43200000) / 86400000)));
    (A = ((int ) ((Z - 1867216.25) / 36524.25)));
    (A = (Z + 1 + A - (A / 4)));
    (B = (A + 1524));
    (C = ((int ) ((B - 122.1) / 365.25)));
    (D = ((36525 * C) / 100));
    (E = ((int ) ((B - D) / 30.6001)));
    (X1 = ((int ) (30.6001 * E)));
    (p->D = (B - D - X1));
    (p->M = ((E < 14) ? (E - 1) : (E - 13)));
    (p->Y = ((p->M > 2) ? (C - 4716) : (C - 4715)));
  }
  (p->validYMD = 1);
}
static  void computeHMS(DateTime *p )  {
  int s;
  if (p->validHMS) {
    return;
  }  
  computeJD(p);
  (s = ((int ) ((p->iJD + 43200000) % 86400000)));
  (p->s = (s / 1000.0));
  (s = ((int ) p->s));
  (p->s -= s);
  (p->h = (s / 3600));
  (s -= (p->h * 3600));
  (p->m = (s / 60));
  (p->s += (s - (p->m * 60)));
  (p->validHMS = 1);
}
static  void computeYMD_HMS(DateTime *p )  {
  computeYMD(p);
  computeHMS(p);
}
static  void clearYMD_HMS_TZ(DateTime *p )  {
  (p->validYMD = 0);
  (p->validHMS = 0);
  (p->validTZ = 0);
}
static  int osLocaltime(time_t *t , struct  tm   *pTm )  {
  int rc;
  struct  tm   *pX;
  (pX = localtime(t));
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      if (_1283_sqlite3Config.bLocaltimeFault) {
        (pX = 0);
      }  
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      if (_1284_sqlite3Config.bLocaltimeFault) {
        (pX = 0);
      }  
    }  
  }  
  if (pX) {
    ((*pTm) = (*pX));
  }  
  (rc = (pX == 0));
  return rc;
}
static  sqlite3_int64 localtimeOffset(DateTime *p , sqlite3_context *pCtx , int *pRc )  {
  DateTime x, y;
  time_t t;
  struct  tm   sLocal;
  memset((&sLocal), 0, sizeof(sLocal));
  (x = (*p));
  computeYMD_HMS((&x));
  if (((x.Y < 1971) || (x.Y >= 2038))) {
    (x.Y = 2000);
    (x.M = 1);
    (x.D = 1);
    (x.h = 0);
    (x.m = 0);
    (x.s = 0.0);
  }  
  else {
    int s =  ((int ) (x.s + 0.5));
    (x.s = s);
  }
  (x.tz = 0);
  (x.validJD = 0);
  computeJD((&x));
  (t = ((time_t ) ((x.iJD / 1000) - (21086676 * ((i64 ) 10000)))));
  if (osLocaltime((&t), (&sLocal))) {
    sqlite3_result_error(pCtx, "local time unavailable", (- 1));
    ((*pRc) = 1);
    return 0;
  }  
  (y.Y = (sLocal.tm_year + 1900));
  (y.M = (sLocal.tm_mon + 1));
  (y.D = sLocal.tm_mday);
  (y.h = sLocal.tm_hour);
  (y.m = sLocal.tm_min);
  (y.s = sLocal.tm_sec);
  (y.validYMD = 1);
  (y.validHMS = 1);
  (y.validJD = 0);
  (y.validTZ = 0);
  computeJD((&y));
  ((*pRc) = 0);
  return (y.iJD - x.iJD);
}
static  int parseModifier(sqlite3_context *pCtx , const  char *zMod , DateTime *p )  {
  int rc =  1;
  int n;
  double r;
  char *z, zBuf[30];
  (z = zBuf);
  for ((n = 0); ((n < (((int ) (sizeof(zBuf) / sizeof(zBuf[0]))) - 1)) && zMod[n]); n++) {
    if ((((! id2i_sqlite_ebcdic) ) )) {
      (z[n] = ((char ) _1281_sqlite3UpperToLower[((u8 ) zMod[n])]));
    }  
    if (((id2i_sqlite_ebcdic ) )) {
      (z[n] = ((char ) _1282_sqlite3UpperToLower[((u8 ) zMod[n])]));
    }  
  }
  (z[n] = 0);
  switch (z[0]) {
    case 'l':
    {
      if ((strcmp(z, "localtime") == 0)) {
        computeJD(p);
        (p->iJD += localtimeOffset(p, pCtx, (&rc)));
        clearYMD_HMS_TZ(p);
      }  
      break;
    }
    case 'u':
    {
      if (((strcmp(z, "unixepoch") == 0) && p->validJD)) {
        (p->iJD = (((p->iJD + 43200) / 86400) + (21086676 * ((i64 ) 10000000))));
        clearYMD_HMS_TZ(p);
        (rc = 0);
      } 
      else if ((strcmp(z, "utc") == 0)) {
        sqlite3_int64 c1;
        computeJD(p);
        (c1 = localtimeOffset(p, pCtx, (&rc)));
        if ((rc == 0)) {
          (p->iJD -= c1);
          clearYMD_HMS_TZ(p);
          (p->iJD += (c1 - localtimeOffset(p, pCtx, (&rc))));
        }  
      } 
      break;
    }
    case 'w':
    {
      if (((strncmp(z, "weekday ", 8) == 0) && sqlite3AtoF((&z[8]), (&r), sqlite3Strlen30((&z[8])), 1) && ((n = ((int ) r)) == r) && (n >= 0) && (r < 7))) {
        sqlite3_int64 Z;
        computeYMD_HMS(p);
        (p->validTZ = 0);
        (p->validJD = 0);
        computeJD(p);
        (Z = (((p->iJD + 129600000) / 86400000) % 7));
        if ((Z > n)) {
          (Z -= 7);
        }  
        (p->iJD += ((n - Z) * 86400000));
        clearYMD_HMS_TZ(p);
        (rc = 0);
      }  
      break;
    }
    case 's':
    {
      if ((strncmp(z, "start of ", 9) != 0)) {
        break;
      }  
      (z += 9);
      computeYMD(p);
      (p->validHMS = 1);
      (p->h = (p->m = 0));
      (p->s = 0.0);
      (p->validTZ = 0);
      (p->validJD = 0);
      if ((strcmp(z, "month") == 0)) {
        (p->D = 1);
        (rc = 0);
      } 
      else if ((strcmp(z, "year") == 0)) {
        computeYMD(p);
        (p->M = 1);
        (p->D = 1);
        (rc = 0);
      }
      
      else if ((strcmp(z, "day") == 0)) {
        (rc = 0);
      } 
      break;
    }
    case '+':
    case '-':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
      double rRounder;
      for ((n = 1); (z[n] && (z[n] != ':') && (! (sqlite3CtypeMap[((unsigned  char ) z[n])] & 0x01))); n++) {
        
      }
      if ((! sqlite3AtoF(z, (&r), n, 1))) {
        (rc = 1);
        break;
      }  
      if ((z[n] == ':')) {
        const char *z2 =  z;
        DateTime tx;
        sqlite3_int64 day;
        if ((! (sqlite3CtypeMap[((unsigned  char ) (*z2))] & 0x04))) {
          z2++;
        }  
        memset((&tx), 0, sizeof(tx));
        if (parseHhMmSs(z2, (&tx))) {
          break;
        }  
        computeJD((&tx));
        (tx.iJD -= 43200000);
        (day = (tx.iJD / 86400000));
        (tx.iJD -= (day * 86400000));
        if ((z[0] == '-')) {
          (tx.iJD = (- tx.iJD));
        }  
        computeJD(p);
        clearYMD_HMS_TZ(p);
        (p->iJD += tx.iJD);
        (rc = 0);
        break;
      }  
      (z += n);
      while ((sqlite3CtypeMap[((unsigned  char ) (*z))] & 0x01)) {
        z++;
      }
      (n = sqlite3Strlen30(z));
      if (((n > 10) || (n < 3))) {
        break;
      }  
      if ((z[(n - 1)] == 's')) {
        (z[(n - 1)] = 0);
        n--;
      }  
      computeJD(p);
      (rc = 0);
      (rRounder = ((r < 0) ? (- 0.5) : (+ 0.5)));
      if (((n == 3) && (strcmp(z, "day") == 0))) {
        (p->iJD += ((sqlite3_int64 ) ((r * 86400000.0) + rRounder)));
      } 
      else if (((n == 4) && (strcmp(z, "hour") == 0))) {
        (p->iJD += ((sqlite3_int64 ) ((r * (86400000.0 / 24.0)) + rRounder)));
      }
      
      else if (((n == 6) && (strcmp(z, "minute") == 0))) {
        (p->iJD += ((sqlite3_int64 ) ((r * (86400000.0 / (24.0 * 60.0))) + rRounder)));
      }
      
      else if (((n == 6) && (strcmp(z, "second") == 0))) {
        (p->iJD += ((sqlite3_int64 ) ((r * (86400000.0 / (24.0 * 60.0 * 60.0))) + rRounder)));
      }
      
      else if (((n == 5) && (strcmp(z, "month") == 0))) {
        int x, y;
        computeYMD_HMS(p);
        (p->M += ((int ) r));
        (x = ((p->M > 0) ? ((p->M - 1) / 12) : ((p->M - 12) / 12)));
        (p->Y += x);
        (p->M -= (x * 12));
        (p->validJD = 0);
        computeJD(p);
        (y = ((int ) r));
        if ((y != r)) {
          (p->iJD += ((sqlite3_int64 ) (((r - y) * 30.0 * 86400000.0) + rRounder)));
        }  
      }
      
      else if (((n == 4) && (strcmp(z, "year") == 0))) {
        int y =  ((int ) r);
        computeYMD_HMS(p);
        (p->Y += y);
        (p->validJD = 0);
        computeJD(p);
        if ((y != r)) {
          (p->iJD += ((sqlite3_int64 ) (((r - y) * 365.0 * 86400000.0) + rRounder)));
        }  
      } 
      else {
        (rc = 1);
      }
      clearYMD_HMS_TZ(p);
      break;
    }
    id2i_label_1:
    default:
    {
      break;
    }
  }
  return rc;
}
static  int isDate(sqlite3_context *context , int argc , sqlite3_value **argv , DateTime *p )  {
  int i;
  const unsigned char *z;
  int eType;
  memset(p, 0, sizeof((*p)));
  if ((argc == 0)) {
    return setDateTimeToCurrent(context, p);
  }  
  if ((((eType = sqlite3_value_type(argv[0])) == 2) || (eType == 1))) {
    (p->iJD = ((sqlite3_int64 ) ((sqlite3_value_double(argv[0]) * 86400000.0) + 0.5)));
    (p->validJD = 1);
  }  
  else {
    (z = sqlite3_value_text(argv[0]));
    if (((! z) || parseDateOrTime(context, ((char *) z), p))) {
      return 1;
    }  
  }
  for ((i = 1); (i < argc); i++) {
    (z = sqlite3_value_text(argv[i]));
    if (((z == 0) || parseModifier(context, ((char *) z), p))) {
      return 1;
    }  
  }
  return 0;
}
static  void juliandayFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  DateTime x;
  if ((isDate(context, argc, argv, (&x)) == 0)) {
    computeJD((&x));
    sqlite3_result_double(context, (x.iJD / 86400000.0));
  }  
}
static  void datetimeFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  DateTime x;
  if ((isDate(context, argc, argv, (&x)) == 0)) {
    char zBuf[100];
    computeYMD_HMS((&x));
    sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d %02d:%02d:%02d", x.Y, x.M, x.D, x.h, x.m, ((int ) x.s));
    sqlite3_result_text(context, zBuf, (- 1), ((sqlite3_destructor_type ) (- 1)));
  }  
}
static  void timeFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  DateTime x;
  if ((isDate(context, argc, argv, (&x)) == 0)) {
    char zBuf[100];
    computeHMS((&x));
    sqlite3_snprintf(sizeof(zBuf), zBuf, "%02d:%02d:%02d", x.h, x.m, ((int ) x.s));
    sqlite3_result_text(context, zBuf, (- 1), ((sqlite3_destructor_type ) (- 1)));
  }  
}
static  void dateFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  DateTime x;
  if ((isDate(context, argc, argv, (&x)) == 0)) {
    char zBuf[100];
    computeYMD((&x));
    sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d", x.Y, x.M, x.D);
    sqlite3_result_text(context, zBuf, (- 1), ((sqlite3_destructor_type ) (- 1)));
  }  
}
static  void strftimeFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  DateTime x;
  u64 n;
  size_t i, j;
  char *z;
  sqlite3 *db;
  const char *zFmt =  ((const  char *) sqlite3_value_text(argv[0]));
  char zBuf[100];
  if (((zFmt == 0) || isDate(context, (argc - 1), (argv + 1), (&x)))) {
    return;
  }  
  (db = sqlite3_context_db_handle(context));
  for ((i = 0), (n = 1); zFmt[i]; i++, n++) {
    if ((zFmt[i] == '%')) {
      switch (zFmt[(i + 1)]) {
        case 'd':
        case 'H':
        case 'm':
        case 'M':
        case 'S':
        case 'W':
        n++;
        case 'w':
        case '%':
        break;
        case 'f':
        (n += 8);
        break;
        case 'j':
        (n += 3);
        break;
        case 'Y':
        (n += 8);
        break;
        case 's':
        case 'J':
        (n += 50);
        break;
        id2i_label_1:
        default:
        return;
      }
      i++;
    }  
  }
  if (((id2i_sqlite_coverage_test ) )) {
    if ((n == (sizeof(zBuf) - 1))) {
      sqlite3Coverage(14775);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((n == sizeof(zBuf))) {
      sqlite3Coverage(14776);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((n == (((u64 ) db->aLimit[0]) + 1))) {
      sqlite3Coverage(14777);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((n == ((u64 ) db->aLimit[0]))) {
      sqlite3Coverage(14778);
    }  
  }  
  if ((n < sizeof(zBuf))) {
    (z = zBuf);
  } 
  else if ((n > ((u64 ) db->aLimit[0]))) {
    sqlite3_result_error_toobig(context);
    return;
  } 
  else {
    (z = sqlite3DbMallocRaw(db, ((int ) n)));
    if ((z == 0)) {
      sqlite3_result_error_nomem(context);
      return;
    }  
  }
  computeJD((&x));
  computeYMD_HMS((&x));
  for ((i = (j = 0)); zFmt[i]; i++) {
    if ((zFmt[i] != '%')) {
      (z[j++] = zFmt[i]);
    }  
    else {
      i++;
      switch (zFmt[i]) {
        case 'd':
        sqlite3_snprintf(3, (&z[j]), "%02d", x.D);
        (j += 2);
        break;
        case 'f':
        {
          double s =  x.s;
          if ((s > 59.999)) {
            (s = 59.999);
          }  
          sqlite3_snprintf(7, (&z[j]), "%06.3f", s);
          (j += sqlite3Strlen30((&z[j])));
          break;
        }
        case 'H':
        sqlite3_snprintf(3, (&z[j]), "%02d", x.h);
        (j += 2);
        break;
        case 'W':
        case 'j':
        {
          int nDay;
          DateTime y =  x;
          (y.validJD = 0);
          (y.M = 1);
          (y.D = 1);
          computeJD((&y));
          (nDay = ((int ) ((x.iJD - y.iJD + 43200000) / 86400000)));
          if ((zFmt[i] == 'W')) {
            int wd;
            (wd = ((int ) (((x.iJD + 43200000) / 86400000) % 7)));
            sqlite3_snprintf(3, (&z[j]), "%02d", ((nDay + 7 - wd) / 7));
            (j += 2);
          }  
          else {
            sqlite3_snprintf(4, (&z[j]), "%03d", (nDay + 1));
            (j += 3);
          }
          break;
        }
        case 'J':
        {
          sqlite3_snprintf(20, (&z[j]), "%.16g", (x.iJD / 86400000.0));
          (j += sqlite3Strlen30((&z[j])));
          break;
        }
        case 'm':
        sqlite3_snprintf(3, (&z[j]), "%02d", x.M);
        (j += 2);
        break;
        case 'M':
        sqlite3_snprintf(3, (&z[j]), "%02d", x.m);
        (j += 2);
        break;
        case 's':
        {
          sqlite3_snprintf(30, (&z[j]), "%lld", ((i64 ) ((x.iJD / 1000) - (21086676 * ((i64 ) 10000)))));
          (j += sqlite3Strlen30((&z[j])));
          break;
        }
        case 'S':
        sqlite3_snprintf(3, (&z[j]), "%02d", ((int ) x.s));
        (j += 2);
        break;
        case 'w':
        {
          (z[j++] = (((char ) (((x.iJD + 129600000) / 86400000) % 7)) + '0'));
          break;
        }
        case 'Y':
        {
          sqlite3_snprintf(5, (&z[j]), "%04d", x.Y);
          (j += sqlite3Strlen30((&z[j])));
          break;
        }
        id2i_label_2:
        default:
        (z[j++] = '%');
        break;
      }
    }
  }
  (z[j] = 0);
  sqlite3_result_text(context, z, (- 1), ((z == zBuf) ? ((sqlite3_destructor_type ) (- 1)) : ((sqlite3_destructor_type ) sqlite3MallocSize)));
}
static  void ctimeFunc(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 )  {
  ((void ) NotUsed), ((void ) NotUsed2);
  timeFunc(context, 0, 0);
}
static  void cdateFunc(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 )  {
  ((void ) NotUsed), ((void ) NotUsed2);
  dateFunc(context, 0, 0);
}
static  void ctimestampFunc(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 )  {
  ((void ) NotUsed), ((void ) NotUsed2);
  datetimeFunc(context, 0, 0);
}
static  void sqlite3RegisterDateTimeFunctions(void )  {
  static FuncDef aDateTimeFuncs[] =  { { (- 1),  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  juliandayFunc,  0,  0,  "julianday",  0,  0},  { (- 1),  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  dateFunc,  0,  0,  "date",  0,  0},  { (- 1),  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  timeFunc,  0,  0,  "time",  0,  0},  { (- 1),  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  datetimeFunc,  0,  0,  "datetime",  0,  0},  { (- 1),  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  strftimeFunc,  0,  0,  "strftime",  0,  0},  { 0,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  ctimeFunc,  0,  0,  "current_time",  0,  0},  { 0,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  ctimestampFunc,  0,  0,  "current_timestamp",  0,  0},  { 0,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  cdateFunc,  0,  0,  "current_date",  0,  0}};
  int i;
  FuncDefHash *pHash =  (&sqlite3GlobalFunctions);
  FuncDef *aFunc =  ((FuncDef *) (&aDateTimeFuncs));
  for ((i = 0); (i < ((int ) (sizeof(aDateTimeFuncs) / sizeof(aDateTimeFuncs[0])))); i++) {
    sqlite3FuncDefInsert(pHash, (&aFunc[i]));
  }
}
static  int sqlite3OsClose(sqlite3_file *pId )  {
  int rc =  0;
  if (pId->pMethods) {
    (rc = pId->pMethods->xClose(pId));
    (pId->pMethods = 0);
  }  
  return rc;
}
static  int sqlite3OsRead(sqlite3_file *id , void *pBuf , int amt , i64 offset )  {
  return id->pMethods->xRead(id, pBuf, amt, offset);
}
static  int sqlite3OsWrite(sqlite3_file *id , const  void *pBuf , int amt , i64 offset )  {
  return id->pMethods->xWrite(id, pBuf, amt, offset);
}
static  int sqlite3OsTruncate(sqlite3_file *id , i64 size )  {
  return id->pMethods->xTruncate(id, size);
}
static  int sqlite3OsSync(sqlite3_file *id , int flags )  {
  return id->pMethods->xSync(id, flags);
}
static  int sqlite3OsFileSize(sqlite3_file *id , i64 *pSize )  {
  return id->pMethods->xFileSize(id, pSize);
}
static  int sqlite3OsLock(sqlite3_file *id , int lockType )  {
  return id->pMethods->xLock(id, lockType);
}
static  int sqlite3OsUnlock(sqlite3_file *id , int lockType )  {
  return id->pMethods->xUnlock(id, lockType);
}
static  int sqlite3OsCheckReservedLock(sqlite3_file *id , int *pResOut )  {
  return id->pMethods->xCheckReservedLock(id, pResOut);
}
static  int sqlite3OsFileControl(sqlite3_file *id , int op , void *pArg )  {
  return id->pMethods->xFileControl(id, op, pArg);
}
static  void sqlite3OsFileControlHint(sqlite3_file *id , int op , void *pArg )  {
  ((void ) id->pMethods->xFileControl(id, op, pArg));
}
static  int sqlite3OsSectorSize(sqlite3_file *id )  {
  int ( *xSectorSize)(sqlite3_file * ) =  id->pMethods->xSectorSize;
  return (xSectorSize ? xSectorSize(id) : 4096);
}
static  int sqlite3OsDeviceCharacteristics(sqlite3_file *id )  {
  return id->pMethods->xDeviceCharacteristics(id);
}
static  int sqlite3OsShmLock(sqlite3_file *id , int offset , int n , int flags )  {
  return id->pMethods->xShmLock(id, offset, n, flags);
}
static  void sqlite3OsShmBarrier(sqlite3_file *id )  {
  id->pMethods->xShmBarrier(id);
}
static  int sqlite3OsShmUnmap(sqlite3_file *id , int deleteFlag )  {
  return id->pMethods->xShmUnmap(id, deleteFlag);
}
static  int sqlite3OsShmMap(sqlite3_file *id , int iPage , int pgsz , int bExtend , void  volatile **pp )  {
  return id->pMethods->xShmMap(id, iPage, pgsz, bExtend, pp);
}
static  int sqlite3OsFetch(sqlite3_file *id , i64 iOff , int iAmt , void **pp )  {
  ((*pp) = 0);
  return 0;
}
static  int sqlite3OsUnfetch(sqlite3_file *id , i64 iOff , void *p )  {
  return 0;
}
static  int sqlite3OsOpen(sqlite3_vfs *pVfs , const  char *zPath , sqlite3_file *pFile , int flags , int *pFlagsOut )  {
  int rc;
  (rc = pVfs->xOpen(pVfs, zPath, pFile, (flags & 0x87f7f), pFlagsOut));
  ((void ) 0);
  return rc;
}
static  int sqlite3OsDelete(sqlite3_vfs *pVfs , const  char *zPath , int dirSync )  {
  ((void ) 0);
  return pVfs->xDelete(pVfs, zPath, dirSync);
}
static  int sqlite3OsAccess(sqlite3_vfs *pVfs , const  char *zPath , int flags , int *pResOut )  {
  return pVfs->xAccess(pVfs, zPath, flags, pResOut);
}
static  int sqlite3OsFullPathname(sqlite3_vfs *pVfs , const  char *zPath , int nPathOut , char *zPathOut )  {
  (zPathOut[0] = 0);
  return pVfs->xFullPathname(pVfs, zPath, nPathOut, zPathOut);
}
static  int sqlite3OsRandomness(sqlite3_vfs *pVfs , int nByte , char *zBufOut )  {
  return pVfs->xRandomness(pVfs, nByte, zBufOut);
}
static  int sqlite3OsSleep(sqlite3_vfs *pVfs , int nMicro )  {
  return pVfs->xSleep(pVfs, nMicro);
}
static  int sqlite3OsCurrentTimeInt64(sqlite3_vfs *pVfs , sqlite3_int64 *pTimeOut )  {
  int rc;
  if (((pVfs->iVersion >= 2) && pVfs->xCurrentTimeInt64)) {
    (rc = pVfs->xCurrentTimeInt64(pVfs, pTimeOut));
  }  
  else {
    double r;
    (rc = pVfs->xCurrentTime(pVfs, (&r)));
    ((*pTimeOut) = ((sqlite3_int64 ) (r * 86400000.0)));
  }
  return rc;
}
static  int sqlite3OsOpenMalloc(sqlite3_vfs *pVfs , const  char *zFile , sqlite3_file **ppFile , int flags , int *pOutFlags )  {
  int rc =  7;
  sqlite3_file *pFile;
  (pFile = ((sqlite3_file *) sqlite3MallocZero(pVfs->szOsFile)));
  if (pFile) {
    (rc = sqlite3OsOpen(pVfs, zFile, pFile, flags, pOutFlags));
    if ((rc != 0)) {
      sqlite3_free(pFile);
    }  
    else {
      ((*ppFile) = pFile);
    }
  }  
  return rc;
}
static  int sqlite3OsCloseFree(sqlite3_file *pFile )  {
  int rc =  0;
  ((void ) 0);
  (rc = sqlite3OsClose(pFile));
  sqlite3_free(pFile);
  return rc;
}
static  int sqlite3OsInit(void )  {
  void *p =  sqlite3_malloc(10);
  if ((p == 0)) {
    return 7;
  }  
  sqlite3_free(p);
  return sqlite3_os_init();
}
static sqlite3_vfs *vfsList =  0;
sqlite3_vfs *sqlite3_vfs_find(const  char *zVfs )  {
  sqlite3_vfs *pVfs =  0;
  int rc =  sqlite3_initialize();
  if (rc) {
    return 0;
  }  
  for ((pVfs = vfsList); pVfs; (pVfs = pVfs->pNext)) {
    if ((zVfs == 0)) {
      break;
    }  
    if ((strcmp(zVfs, pVfs->zName) == 0)) {
      break;
    }  
  }
  return pVfs;
}
static  void vfsUnlink(sqlite3_vfs *pVfs )  {
  ((void ) 0);
  if ((pVfs == 0)) {
    
  } 
  else if ((vfsList == pVfs)) {
    (vfsList = pVfs->pNext);
  }
  
  else if (vfsList) {
    sqlite3_vfs *p =  vfsList;
    while ((p->pNext && (p->pNext != pVfs))) {
      (p = p->pNext);
    }
    if ((p->pNext == pVfs)) {
      (p->pNext = pVfs->pNext);
    }  
  } 
}
int sqlite3_vfs_register(sqlite3_vfs *pVfs , int makeDflt )  {
  int rc =  sqlite3_initialize();
  if (rc) {
    return rc;
  }  
  vfsUnlink(pVfs);
  if ((makeDflt || (vfsList == 0))) {
    (pVfs->pNext = vfsList);
    (vfsList = pVfs);
  }  
  else {
    (pVfs->pNext = vfsList->pNext);
    (vfsList->pNext = pVfs);
  }
  ((void ) 0);
  return 0;
}
int sqlite3_vfs_unregister(sqlite3_vfs *pVfs )  {
  vfsUnlink(pVfs);
  return 0;
}
typedef struct  _1279_BenignMallocHooks   _1279_BenignMallocHooks;
static struct  _1279_BenignMallocHooks {
  void ( *xBenignBegin)(void ) ;
  void ( *xBenignEnd)(void ) ;
}  sqlite3Hooks =  { 0,  0};
static  void sqlite3BenignMallocHooks(void ( *xBenignBegin)(void ) , void ( *xBenignEnd)(void ) )  {
  (sqlite3Hooks.xBenignBegin = xBenignBegin);
  (sqlite3Hooks.xBenignEnd = xBenignEnd);
}
static  void sqlite3BeginBenignMalloc(void )  {
  if (sqlite3Hooks.xBenignBegin) {
    sqlite3Hooks.xBenignBegin();
  }  
}
static  void sqlite3EndBenignMalloc(void )  {
  if (sqlite3Hooks.xBenignEnd) {
    sqlite3Hooks.xBenignEnd();
  }  
}
extern void *malloc(size_t __size ) __attribute__((__nothrow__)) __attribute__((__malloc__));
extern void *calloc(size_t __nmemb , size_t __size ) __attribute__((__nothrow__)) __attribute__((__malloc__));
extern void *realloc(void *__ptr , size_t __size ) __attribute__((__nothrow__)) __attribute__((__warn_unused_result__));
extern void free(void *__ptr ) __attribute__((__nothrow__));
extern void cfree(void *__ptr ) __attribute__((__nothrow__));
extern void *memalign(size_t __alignment , size_t __size ) __attribute__((__nothrow__)) __attribute__((__malloc__));
extern void *valloc(size_t __size ) __attribute__((__nothrow__)) __attribute__((__malloc__));
extern void *pvalloc(size_t __size ) __attribute__((__nothrow__)) __attribute__((__malloc__));
extern void *( *__morecore)(ptrdiff_t __size );
extern void *__default_morecore(ptrdiff_t __size ) __attribute__((__nothrow__)) __attribute__((__malloc__));
struct  mallinfo {
  int arena ;
  int ordblks ;
  int smblks ;
  int hblks ;
  int hblkhd ;
  int usmblks ;
  int fsmblks ;
  int uordblks ;
  int fordblks ;
  int keepcost ;
}  ;
extern struct  mallinfo   mallinfo(void ) __attribute__((__nothrow__));
extern int mallopt(int __param , int __val ) __attribute__((__nothrow__));
extern int malloc_trim(size_t __pad ) __attribute__((__nothrow__));
extern size_t malloc_usable_size(void *__ptr ) __attribute__((__nothrow__));
extern void malloc_stats(void ) __attribute__((__nothrow__));
extern int malloc_info(int __options , FILE *__fp ) __attribute__((__nothrow__));
extern void *malloc_get_state(void ) __attribute__((__nothrow__));
extern int malloc_set_state(void *__ptr ) __attribute__((__nothrow__));
extern void ( *volatile __malloc_initialize_hook)(void ) __attribute__((__deprecated__));
extern void ( *volatile __free_hook)(void *__ptr , const  void * ) __attribute__((__deprecated__));
extern void *( *volatile __malloc_hook)(size_t __size , const  void * ) __attribute__((__deprecated__));
extern void *( *volatile __realloc_hook)(void *__ptr , size_t __size , const  void * ) __attribute__((__deprecated__));
extern void *( *volatile __memalign_hook)(size_t __alignment , size_t __size , const  void * ) __attribute__((__deprecated__));
extern void ( *volatile __after_morecore_hook)(void );
extern void __malloc_check_init(void ) __attribute__((__nothrow__)) __attribute__((__deprecated__));
static  void *sqlite3MemMalloc(int nByte )  {
  void *p =  malloc(nByte);
  if ((p == 0)) {
    if (((id2i_sqlite_coverage_test ) )) {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        if ((_1283_sqlite3Config.xLog != 0)) {
          sqlite3Coverage(15621);
        }  
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        if ((_1284_sqlite3Config.xLog != 0)) {
          sqlite3Coverage(15621);
        }  
      }  
    }  
    sqlite3_log(7, "failed to allocate %u bytes of memory", nByte);
  }  
  return p;
}
static  void sqlite3MemFree(void *pPrior )  {
  free(pPrior);
}
static  int sqlite3MemSize(void *pPrior )  {
  return (pPrior ? ((int ) malloc_usable_size(pPrior)) : 0);
}
static  void *sqlite3MemRealloc(void *pPrior , int nByte )  {
  void *p =  realloc(pPrior, nByte);
  if ((p == 0)) {
    if (((id2i_sqlite_coverage_test ) )) {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        if ((_1283_sqlite3Config.xLog != 0)) {
          sqlite3Coverage(15690);
        }  
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        if ((_1284_sqlite3Config.xLog != 0)) {
          sqlite3Coverage(15690);
        }  
      }  
    }  
    sqlite3_log(7, "failed memory resize %u to %u bytes", malloc_usable_size(pPrior), nByte);
  }  
  return p;
}
static  int sqlite3MemRoundup(int n )  {
  return ((n + 7) & (~ 7));
}
static  int sqlite3MemInit(void *NotUsed )  {
  ((void ) NotUsed);
  return 0;
}
static  void sqlite3MemShutdown(void *NotUsed )  {
  ((void ) NotUsed);
  return;
}
static  void sqlite3MemSetDefault(void )  {
  static const sqlite3_mem_methods defaultMethods =  { sqlite3MemMalloc,  sqlite3MemFree,  sqlite3MemRealloc,  sqlite3MemSize,  sqlite3MemRoundup,  sqlite3MemInit,  sqlite3MemShutdown,  0};
  sqlite3_config(4, (&defaultMethods));
}
typedef struct  _1274_Mem3Block   _1274_Mem3Block;
struct  _1274_Mem3Block {
  union   {
    struct   {
      u32 prevSize ;
      u32 size4x ;
    }  hdr ;
    struct   {
      u32 next ;
      u32 prev ;
    }  list ;
  }  u ;
}  ;
static struct  _1274_Mem3Global {
  u32 nPool ;
  _1274_Mem3Block *aPool ;
  int alarmBusy ;
  sqlite3_mutex *mutex ;
  u32 mnMaster ;
  u32 iMaster ;
  u32 szMaster ;
  u32 aiSmall[(10 - 1)] ;
  u32 aiHash[61] ;
}  mem3 =  { 97535575};
static  void memsys3UnlinkFromList(u32 i , u32 *pRoot )  {
  u32 next =  mem3.aPool[i].u.list.next;
  u32 prev =  mem3.aPool[i].u.list.prev;
  ((void ) 0);
  if ((prev == 0)) {
    ((*pRoot) = next);
  }  
  else {
    (mem3.aPool[prev].u.list.next = next);
  }
  if (next) {
    (mem3.aPool[next].u.list.prev = prev);
  }  
  (mem3.aPool[i].u.list.next = 0);
  (mem3.aPool[i].u.list.prev = 0);
}
static  void memsys3Unlink(u32 i )  {
  u32 size, hash;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (size = (mem3.aPool[(i - 1)].u.hdr.size4x / 4));
  ((void ) 0);
  ((void ) 0);
  if ((size <= 10)) {
    memsys3UnlinkFromList(i, (&mem3.aiSmall[(size - 2)]));
  }  
  else {
    (hash = (size % 61));
    memsys3UnlinkFromList(i, (&mem3.aiHash[hash]));
  }
}
static  void memsys3LinkIntoList(u32 i , u32 *pRoot )  {
  ((void ) 0);
  (mem3.aPool[i].u.list.next = (*pRoot));
  (mem3.aPool[i].u.list.prev = 0);
  if ((*pRoot)) {
    (mem3.aPool[(*pRoot)].u.list.prev = i);
  }  
  ((*pRoot) = i);
}
static  void memsys3Link(u32 i )  {
  u32 size, hash;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (size = (mem3.aPool[(i - 1)].u.hdr.size4x / 4));
  ((void ) 0);
  ((void ) 0);
  if ((size <= 10)) {
    memsys3LinkIntoList(i, (&mem3.aiSmall[(size - 2)]));
  }  
  else {
    (hash = (size % 61));
    memsys3LinkIntoList(i, (&mem3.aiHash[hash]));
  }
}
static  void memsys3Enter(void )  {
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (((_1283_sqlite3Config.bMemstat == 0) && (mem3.mutex == 0))) {
      (mem3.mutex = ((sqlite3_mutex *) 8));
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (((_1284_sqlite3Config.bMemstat == 0) && (mem3.mutex == 0))) {
      (mem3.mutex = ((sqlite3_mutex *) 8));
    }  
  }  
}
static  void memsys3Leave(void )  {
  
}
static  void memsys3OutOfMemory(int nByte )  {
  if ((! mem3.alarmBusy)) {
    (mem3.alarmBusy = 1);
    ((void ) 0);
    sqlite3_release_memory(nByte);
    (mem3.alarmBusy = 0);
  }  
}
static  void *memsys3Checkout(u32 i , u32 nBlock )  {
  u32 x;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (x = mem3.aPool[(i - 1)].u.hdr.size4x);
  (mem3.aPool[(i - 1)].u.hdr.size4x = ((nBlock * 4) | 1 | (x & 2)));
  (mem3.aPool[(i + nBlock - 1)].u.hdr.prevSize = nBlock);
  (mem3.aPool[(i + nBlock - 1)].u.hdr.size4x |= 2);
  return (&mem3.aPool[i]);
}
static  void *memsys3FromMaster(u32 nBlock )  {
  ((void ) 0);
  ((void ) 0);
  if ((nBlock >= (mem3.szMaster - 1))) {
    void *p =  memsys3Checkout(mem3.iMaster, mem3.szMaster);
    (mem3.iMaster = 0);
    (mem3.szMaster = 0);
    (mem3.mnMaster = 0);
    return p;
  }  
  else {
    u32 newi, x;
    (newi = (mem3.iMaster + mem3.szMaster - nBlock));
    ((void ) 0);
    (mem3.aPool[(mem3.iMaster + mem3.szMaster - 1)].u.hdr.prevSize = nBlock);
    (mem3.aPool[(mem3.iMaster + mem3.szMaster - 1)].u.hdr.size4x |= 2);
    (mem3.aPool[(newi - 1)].u.hdr.size4x = ((nBlock * 4) + 1));
    (mem3.szMaster -= nBlock);
    (mem3.aPool[(newi - 1)].u.hdr.prevSize = mem3.szMaster);
    (x = (mem3.aPool[(mem3.iMaster - 1)].u.hdr.size4x & 2));
    (mem3.aPool[(mem3.iMaster - 1)].u.hdr.size4x = ((mem3.szMaster * 4) | x));
    if ((mem3.szMaster < mem3.mnMaster)) {
      (mem3.mnMaster = mem3.szMaster);
    }  
    return ((void *) (&mem3.aPool[newi]));
  }
}
static  void memsys3Merge(u32 *pRoot )  {
  u32 iNext, prev, size, i, x;
  ((void ) 0);
  for ((i = (*pRoot)); (i > 0); (i = iNext)) {
    (iNext = mem3.aPool[i].u.list.next);
    (size = mem3.aPool[(i - 1)].u.hdr.size4x);
    ((void ) 0);
    if (((size & 2) == 0)) {
      memsys3UnlinkFromList(i, pRoot);
      ((void ) 0);
      (prev = (i - mem3.aPool[(i - 1)].u.hdr.prevSize));
      if ((prev == iNext)) {
        (iNext = mem3.aPool[prev].u.list.next);
      }  
      memsys3Unlink(prev);
      (size = (i + (size / 4) - prev));
      (x = (mem3.aPool[(prev - 1)].u.hdr.size4x & 2));
      (mem3.aPool[(prev - 1)].u.hdr.size4x = ((size * 4) | x));
      (mem3.aPool[(prev + size - 1)].u.hdr.prevSize = size);
      memsys3Link(prev);
      (i = prev);
    }  
    else {
      (size /= 4);
    }
    if ((size > mem3.szMaster)) {
      (mem3.iMaster = i);
      (mem3.szMaster = size);
    }  
  }
}
static  void *memsys3MallocUnsafe(int nByte )  {
  u32 i;
  u32 nBlock;
  u32 toFree;
  ((void ) 0);
  ((void ) 0);
  if ((nByte <= 12)) {
    (nBlock = 2);
  }  
  else {
    (nBlock = ((nByte + 11) / 8));
  }
  ((void ) 0);
  if ((nBlock <= 10)) {
    (i = mem3.aiSmall[(nBlock - 2)]);
    if ((i > 0)) {
      memsys3UnlinkFromList(i, (&mem3.aiSmall[(nBlock - 2)]));
      return memsys3Checkout(i, nBlock);
    }  
  }  
  else {
    int hash =  (nBlock % 61);
    for ((i = mem3.aiHash[hash]); (i > 0); (i = mem3.aPool[i].u.list.next)) {
      if (((mem3.aPool[(i - 1)].u.hdr.size4x / 4) == nBlock)) {
        memsys3UnlinkFromList(i, (&mem3.aiHash[hash]));
        return memsys3Checkout(i, nBlock);
      }  
    }
  }
  if ((mem3.szMaster >= nBlock)) {
    return memsys3FromMaster(nBlock);
  }  
  for ((toFree = (nBlock * 16)); (toFree < (mem3.nPool * 16)); (toFree *= 2)) {
    memsys3OutOfMemory(toFree);
    if (mem3.iMaster) {
      memsys3Link(mem3.iMaster);
      (mem3.iMaster = 0);
      (mem3.szMaster = 0);
    }  
    for ((i = 0); (i < 61); i++) {
      memsys3Merge((&mem3.aiHash[i]));
    }
    for ((i = 0); (i < (10 - 1)); i++) {
      memsys3Merge((&mem3.aiSmall[i]));
    }
    if (mem3.szMaster) {
      memsys3Unlink(mem3.iMaster);
      if ((mem3.szMaster >= nBlock)) {
        return memsys3FromMaster(nBlock);
      }  
    }  
  }
  return 0;
}
static  void memsys3FreeUnsafe(void *pOld )  {
  _1274_Mem3Block *p =  ((_1274_Mem3Block *) pOld);
  int i;
  u32 size, x;
  ((void ) 0);
  ((void ) 0);
  (i = (p - mem3.aPool));
  ((void ) 0);
  (size = (mem3.aPool[(i - 1)].u.hdr.size4x / 4));
  ((void ) 0);
  (mem3.aPool[(i - 1)].u.hdr.size4x &= (~ 1));
  (mem3.aPool[(i + size - 1)].u.hdr.prevSize = size);
  (mem3.aPool[(i + size - 1)].u.hdr.size4x &= (~ 2));
  memsys3Link(i);
  if (mem3.iMaster) {
    while (((mem3.aPool[(mem3.iMaster - 1)].u.hdr.size4x & 2) == 0)) {
      (size = mem3.aPool[(mem3.iMaster - 1)].u.hdr.prevSize);
      (mem3.iMaster -= size);
      (mem3.szMaster += size);
      memsys3Unlink(mem3.iMaster);
      (x = (mem3.aPool[(mem3.iMaster - 1)].u.hdr.size4x & 2));
      (mem3.aPool[(mem3.iMaster - 1)].u.hdr.size4x = ((mem3.szMaster * 4) | x));
      (mem3.aPool[(mem3.iMaster + mem3.szMaster - 1)].u.hdr.prevSize = mem3.szMaster);
    }
    (x = (mem3.aPool[(mem3.iMaster - 1)].u.hdr.size4x & 2));
    while (((mem3.aPool[(mem3.iMaster + mem3.szMaster - 1)].u.hdr.size4x & 1) == 0)) {
      memsys3Unlink((mem3.iMaster + mem3.szMaster));
      (mem3.szMaster += (mem3.aPool[(mem3.iMaster + mem3.szMaster - 1)].u.hdr.size4x / 4));
      (mem3.aPool[(mem3.iMaster - 1)].u.hdr.size4x = ((mem3.szMaster * 4) | x));
      (mem3.aPool[(mem3.iMaster + mem3.szMaster - 1)].u.hdr.prevSize = mem3.szMaster);
    }
  }  
}
static  int memsys3Size(void *p )  {
  _1274_Mem3Block *pBlock;
  if ((p == 0)) {
    return 0;
  }  
  (pBlock = ((_1274_Mem3Block *) p));
  ((void ) 0);
  return (((pBlock[(- 1)].u.hdr.size4x & (~ 3)) * 2) - 4);
}
static  int memsys3Roundup(int n )  {
  if ((n <= 12)) {
    return 12;
  }  
  else {
    return (((n + 11) & (~ 7)) - 4);
  }
}
static  void *memsys3Malloc(int nBytes )  {
  sqlite3_int64 *p;
  ((void ) 0);
  memsys3Enter();
  (p = memsys3MallocUnsafe(nBytes));
  memsys3Leave();
  return ((void *) p);
}
static  void memsys3Free(void *pPrior )  {
  ((void ) 0);
  memsys3Enter();
  memsys3FreeUnsafe(pPrior);
  memsys3Leave();
}
static  void *memsys3Realloc(void *pPrior , int nBytes )  {
  int nOld;
  void *p;
  if ((pPrior == 0)) {
    return sqlite3_malloc(nBytes);
  }  
  if ((nBytes <= 0)) {
    sqlite3_free(pPrior);
    return 0;
  }  
  (nOld = memsys3Size(pPrior));
  if (((nBytes <= nOld) && (nBytes >= (nOld - 128)))) {
    return pPrior;
  }  
  memsys3Enter();
  (p = memsys3MallocUnsafe(nBytes));
  if (p) {
    if ((nOld < nBytes)) {
      memcpy(p, pPrior, nOld);
    }  
    else {
      memcpy(p, pPrior, nBytes);
    }
    memsys3FreeUnsafe(pPrior);
  }  
  memsys3Leave();
  return p;
}
static  int memsys3Init(void *NotUsed )  {
  ((void ) NotUsed);
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if ((! _1283_sqlite3Config.pHeap)) {
      return 1;
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if ((! _1284_sqlite3Config.pHeap)) {
      return 1;
    }  
  }  
  ((void ) 0);
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    (mem3.aPool = ((_1274_Mem3Block *) _1283_sqlite3Config.pHeap));
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    (mem3.aPool = ((_1274_Mem3Block *) _1284_sqlite3Config.pHeap));
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    (mem3.nPool = ((_1283_sqlite3Config.nHeap / sizeof(_1274_Mem3Block )) - 2));
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    (mem3.nPool = ((_1284_sqlite3Config.nHeap / sizeof(_1274_Mem3Block )) - 2));
  }  
  (mem3.szMaster = mem3.nPool);
  (mem3.mnMaster = mem3.szMaster);
  (mem3.iMaster = 1);
  (mem3.aPool[0].u.hdr.size4x = ((mem3.szMaster << 2) + 2));
  (mem3.aPool[mem3.nPool].u.hdr.prevSize = mem3.nPool);
  (mem3.aPool[mem3.nPool].u.hdr.size4x = 1);
  return 0;
}
static  void memsys3Shutdown(void *NotUsed )  {
  ((void ) NotUsed);
  (mem3.mutex = 0);
  return;
}
static  void sqlite3Memsys3Dump(const  char *zFilename )  {
  ((void ) zFilename);
}
static  const  sqlite3_mem_methods *sqlite3MemGetMemsys3(void )  {
  static const sqlite3_mem_methods mempoolMethods =  { memsys3Malloc,  memsys3Free,  memsys3Realloc,  memsys3Size,  memsys3Roundup,  memsys3Init,  memsys3Shutdown,  0};
  return (&mempoolMethods);
}
typedef struct  _1275_Mem5Link   _1275_Mem5Link;
struct  _1275_Mem5Link {
  int next ;
  int prev ;
}  ;
static struct  _1275_Mem5Global {
  int szAtom ;
  int nBlock ;
  u8 *zPool ;
  sqlite3_mutex *mutex ;
  u64 nAlloc ;
  u64 totalAlloc ;
  u64 totalExcess ;
  u32 currentOut ;
  u32 currentCount ;
  u32 maxOut ;
  u32 maxCount ;
  u32 maxRequest ;
  int aiFreelist[(30 + 1)] ;
  u8 *aCtrl ;
}  mem5;
static  void memsys5Unlink(int i , int iLogsize )  {
  int next, prev;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (next = ((_1275_Mem5Link *) (&mem5.zPool[(i * mem5.szAtom)]))->next);
  (prev = ((_1275_Mem5Link *) (&mem5.zPool[(i * mem5.szAtom)]))->prev);
  if ((prev < 0)) {
    (mem5.aiFreelist[iLogsize] = next);
  }  
  else {
    (((_1275_Mem5Link *) (&mem5.zPool[(prev * mem5.szAtom)]))->next = next);
  }
  if ((next >= 0)) {
    (((_1275_Mem5Link *) (&mem5.zPool[(next * mem5.szAtom)]))->prev = prev);
  }  
}
static  void memsys5Link(int i , int iLogsize )  {
  int x;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (x = (((_1275_Mem5Link *) (&mem5.zPool[(i * mem5.szAtom)]))->next = mem5.aiFreelist[iLogsize]));
  (((_1275_Mem5Link *) (&mem5.zPool[(i * mem5.szAtom)]))->prev = (- 1));
  if ((x >= 0)) {
    ((void ) 0);
    (((_1275_Mem5Link *) (&mem5.zPool[(x * mem5.szAtom)]))->prev = i);
  }  
  (mem5.aiFreelist[iLogsize] = i);
}
static  void memsys5Enter(void )  {
  
}
static  void memsys5Leave(void )  {
  
}
static  int memsys5Size(void *p )  {
  int iSize =  0;
  if (p) {
    int i =  ((((u8 *) p) - mem5.zPool) / mem5.szAtom);
    ((void ) 0);
    (iSize = (mem5.szAtom * (1 << (mem5.aCtrl[i] & 0x1f))));
  }  
  return iSize;
}
static  int memsys5UnlinkFirst(int iLogsize )  {
  int i;
  int iFirst;
  ((void ) 0);
  (i = (iFirst = mem5.aiFreelist[iLogsize]));
  ((void ) 0);
  while ((i > 0)) {
    if ((i < iFirst)) {
      (iFirst = i);
    }  
    (i = ((_1275_Mem5Link *) (&mem5.zPool[(i * mem5.szAtom)]))->next);
  }
  memsys5Unlink(iFirst, iLogsize);
  return iFirst;
}
static  void *memsys5MallocUnsafe(int nByte )  {
  int i;
  int iBin;
  int iFullSz;
  int iLogsize;
  ((void ) 0);
  if ((((u32 ) nByte) > mem5.maxRequest)) {
    (mem5.maxRequest = nByte);
  }  
  if ((nByte > 0x40000000)) {
    return 0;
  }  
  for ((iFullSz = mem5.szAtom), (iLogsize = 0); (iFullSz < nByte); (iFullSz *= 2), iLogsize++) {
    
  }
  for ((iBin = iLogsize); ((mem5.aiFreelist[iBin] < 0) && (iBin <= 30)); iBin++) {
    
  }
  if ((iBin > 30)) {
    if (((id2i_sqlite_coverage_test ) )) {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        if ((_1283_sqlite3Config.xLog != 0)) {
          sqlite3Coverage(17279);
        }  
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        if ((_1284_sqlite3Config.xLog != 0)) {
          sqlite3Coverage(17279);
        }  
      }  
    }  
    sqlite3_log(7, "failed to allocate %u bytes", nByte);
    return 0;
  }  
  (i = memsys5UnlinkFirst(iBin));
  while ((iBin > iLogsize)) {
    int newSize;
    iBin--;
    (newSize = (1 << iBin));
    (mem5.aCtrl[(i + newSize)] = (0x20 | iBin));
    memsys5Link((i + newSize), iBin);
  }
  (mem5.aCtrl[i] = iLogsize);
  mem5.nAlloc++;
  (mem5.totalAlloc += iFullSz);
  (mem5.totalExcess += (iFullSz - nByte));
  mem5.currentCount++;
  (mem5.currentOut += iFullSz);
  if ((mem5.maxCount < mem5.currentCount)) {
    (mem5.maxCount = mem5.currentCount);
  }  
  if ((mem5.maxOut < mem5.currentOut)) {
    (mem5.maxOut = mem5.currentOut);
  }  
  return ((void *) (&mem5.zPool[(i * mem5.szAtom)]));
}
static  void memsys5FreeUnsafe(void *pOld )  {
  u32 size, iLogsize;
  int iBlock;
  (iBlock = ((((u8 *) pOld) - mem5.zPool) / mem5.szAtom));
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (iLogsize = (mem5.aCtrl[iBlock] & 0x1f));
  (size = (1 << iLogsize));
  ((void ) 0);
  (mem5.aCtrl[iBlock] |= 0x20);
  (mem5.aCtrl[(iBlock + size - 1)] |= 0x20);
  ((void ) 0);
  ((void ) 0);
  mem5.currentCount--;
  (mem5.currentOut -= (size * mem5.szAtom));
  ((void ) 0);
  ((void ) 0);
  (mem5.aCtrl[iBlock] = (0x20 | iLogsize));
  if (((id2i_sqlite_coverage_test ) )) {
    while (1) {
      int iBuddy;
      if (((iBlock >> iLogsize) & 1)) {
        (iBuddy = (iBlock - size));
      }  
      else {
        (iBuddy = (iBlock + size));
      }
      ((void ) 0);
      if (((iBuddy + (1 << iLogsize)) > mem5.nBlock)) {
        break;
      }  
      if ((mem5.aCtrl[iBuddy] != (0x20 | iLogsize))) {
        break;
      }  
      memsys5Unlink(iBuddy, iLogsize);
      iLogsize++;
      if ((iBuddy < iBlock)) {
        (mem5.aCtrl[iBuddy] = (0x20 | iLogsize));
        (mem5.aCtrl[iBlock] = 0);
        (iBlock = iBuddy);
      }  
      else {
        (mem5.aCtrl[iBlock] = (0x20 | iLogsize));
        (mem5.aCtrl[iBuddy] = 0);
      }
      (size *= 2);
    }
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    while ((iLogsize < 30)) {
      int iBuddy;
      if (((iBlock >> iLogsize) & 1)) {
        (iBuddy = (iBlock - size));
      }  
      else {
        (iBuddy = (iBlock + size));
      }
      ((void ) 0);
      if (((iBuddy + (1 << iLogsize)) > mem5.nBlock)) {
        break;
      }  
      if ((mem5.aCtrl[iBuddy] != (0x20 | iLogsize))) {
        break;
      }  
      memsys5Unlink(iBuddy, iLogsize);
      iLogsize++;
      if ((iBuddy < iBlock)) {
        (mem5.aCtrl[iBuddy] = (0x20 | iLogsize));
        (mem5.aCtrl[iBlock] = 0);
        (iBlock = iBuddy);
      }  
      else {
        (mem5.aCtrl[iBlock] = (0x20 | iLogsize));
        (mem5.aCtrl[iBuddy] = 0);
      }
      (size *= 2);
    }
  }  
  memsys5Link(iBlock, iLogsize);
}
static  void *memsys5Malloc(int nBytes )  {
  sqlite3_int64 *p =  0;
  if ((nBytes > 0)) {
    memsys5Enter();
    (p = memsys5MallocUnsafe(nBytes));
    memsys5Leave();
  }  
  return ((void *) p);
}
static  void memsys5Free(void *pPrior )  {
  ((void ) 0);
  memsys5Enter();
  memsys5FreeUnsafe(pPrior);
  memsys5Leave();
}
static  void *memsys5Realloc(void *pPrior , int nBytes )  {
  int nOld;
  void *p;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((nBytes == 0)) {
    return 0;
  }  
  (nOld = memsys5Size(pPrior));
  if ((nBytes <= nOld)) {
    return pPrior;
  }  
  memsys5Enter();
  (p = memsys5MallocUnsafe(nBytes));
  if (p) {
    memcpy(p, pPrior, nOld);
    memsys5FreeUnsafe(pPrior);
  }  
  memsys5Leave();
  return p;
}
static  int memsys5Roundup(int n )  {
  int iFullSz;
  if ((n > 0x40000000)) {
    return 0;
  }  
  for ((iFullSz = mem5.szAtom); (iFullSz < n); (iFullSz *= 2)) {
    
  }
  return iFullSz;
}
static  int memsys5Log(int iValue )  {
  int iLog;
  for ((iLog = 0); ((iLog < ((int ) ((sizeof(int ) * 8) - 1))) && ((1 << iLog) < iValue)); iLog++) {
    
  }
  return iLog;
}
static  int memsys5Init(void *NotUsed )  {
  int ii;
  int nByte;
  u8 *zByte;
  int nMinLog;
  int iOffset;
  ((void ) NotUsed);
  (mem5.mutex = 0);
  ((void ) 0);
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    (nByte = _1283_sqlite3Config.nHeap);
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    (nByte = _1284_sqlite3Config.nHeap);
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    (zByte = ((u8 *) _1283_sqlite3Config.pHeap));
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    (zByte = ((u8 *) _1284_sqlite3Config.pHeap));
  }  
  ((void ) 0);
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    (nMinLog = memsys5Log(_1283_sqlite3Config.mnReq));
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    (nMinLog = memsys5Log(_1284_sqlite3Config.mnReq));
  }  
  (mem5.szAtom = (1 << nMinLog));
  while ((((int ) sizeof(_1275_Mem5Link )) > mem5.szAtom)) {
    (mem5.szAtom = (mem5.szAtom << 1));
  }
  (mem5.nBlock = (nByte / (mem5.szAtom + sizeof(u8 ))));
  (mem5.zPool = zByte);
  (mem5.aCtrl = ((u8 *) (&mem5.zPool[(mem5.nBlock * mem5.szAtom)])));
  for ((ii = 0); (ii <= 30); ii++) {
    (mem5.aiFreelist[ii] = (- 1));
  }
  (iOffset = 0);
  for ((ii = 30); (ii >= 0); ii--) {
    int nAlloc =  (1 << ii);
    if (((iOffset + nAlloc) <= mem5.nBlock)) {
      (mem5.aCtrl[iOffset] = (ii | 0x20));
      memsys5Link(iOffset, ii);
      (iOffset += nAlloc);
    }  
    ((void ) 0);
  }
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if ((_1283_sqlite3Config.bMemstat == 0)) {
      (mem5.mutex = ((sqlite3_mutex *) 8));
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if ((_1284_sqlite3Config.bMemstat == 0)) {
      (mem5.mutex = ((sqlite3_mutex *) 8));
    }  
  }  
  return 0;
}
static  void memsys5Shutdown(void *NotUsed )  {
  ((void ) NotUsed);
  (mem5.mutex = 0);
  return;
}
static  const  sqlite3_mem_methods *sqlite3MemGetMemsys5(void )  {
  static const sqlite3_mem_methods memsys5Methods =  { memsys5Malloc,  memsys5Free,  memsys5Realloc,  memsys5Size,  memsys5Roundup,  memsys5Init,  memsys5Shutdown,  0};
  return (&memsys5Methods);
}
int sqlite3_release_memory(int n )  {
  if (((id2i_sqlite_enable_memory_management ) )) {
    return sqlite3PcacheReleaseMemory(n);
  }  
  if ((((! id2i_sqlite_enable_memory_management) ) )) {
    ((void ) n);
  }  
  if ((((! id2i_sqlite_enable_memory_management) ) )) {
    return 0;
  }  
}
typedef struct  ScratchFreeslot {
  struct  ScratchFreeslot   *pNext ;
}  ScratchFreeslot;
static struct  Mem0Global {
  sqlite3_mutex *mutex ;
  sqlite3_int64 alarmThreshold ;
  void ( *alarmCallback)(void * , sqlite3_int64 , int ) ;
  void *alarmArg ;
  void *pScratchEnd ;
  ScratchFreeslot *pScratchFree ;
  u32 nScratchFree ;
  int nearlyFull ;
}  mem0 =  { 0,  0,  0,  0,  0,  0,  0,  0};
static  void softHeapLimitEnforcer(void *NotUsed , sqlite3_int64 NotUsed2 , int allocSize )  {
  ((void ) NotUsed), ((void ) NotUsed2);
  sqlite3_release_memory(allocSize);
}
static  int sqlite3MemoryAlarm(void ( *xCallback)(void *pArg , sqlite3_int64 used , int N ) , void *pArg , sqlite3_int64 iThreshold )  {
  int nUsed;
  (mem0.alarmCallback = xCallback);
  (mem0.alarmArg = pArg);
  (mem0.alarmThreshold = iThreshold);
  (nUsed = sqlite3StatusValue(0));
  (mem0.nearlyFull = ((iThreshold > 0) && (iThreshold <= nUsed)));
  return 0;
}
int sqlite3_memory_alarm(void ( *xCallback)(void *pArg , sqlite3_int64 used , int N ) , void *pArg , sqlite3_int64 iThreshold )  {
  return sqlite3MemoryAlarm(xCallback, pArg, iThreshold);
}
sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n )  {
  sqlite3_int64 priorLimit;
  sqlite3_int64 excess;
  int rc =  sqlite3_initialize();
  if (rc) {
    return (- 1);
  }  
  (priorLimit = mem0.alarmThreshold);
  if ((n < 0)) {
    return priorLimit;
  }  
  if ((n > 0)) {
    sqlite3MemoryAlarm(softHeapLimitEnforcer, 0, n);
  }  
  else {
    sqlite3MemoryAlarm(0, 0, 0);
  }
  (excess = (sqlite3_memory_used() - n));
  if ((excess > 0)) {
    sqlite3_release_memory(((int ) (excess & 0x7fffffff)));
  }  
  return priorLimit;
}
void sqlite3_soft_heap_limit(int n )  {
  if ((n < 0)) {
    (n = 0);
  }  
  sqlite3_soft_heap_limit64(n);
}
static  int sqlite3MallocInit(void )  {
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if ((_1283_sqlite3Config.m.xMalloc == 0)) {
      sqlite3MemSetDefault();
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if ((_1284_sqlite3Config.m.xMalloc == 0)) {
      sqlite3MemSetDefault();
    }  
  }  
  memset((&mem0), 0, sizeof(mem0));
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (_1283_sqlite3Config.bCoreMutex) {
      (mem0.mutex = ((sqlite3_mutex *) 8));
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (_1284_sqlite3Config.bCoreMutex) {
      (mem0.mutex = ((sqlite3_mutex *) 8));
    }  
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if ((_1283_sqlite3Config.pScratch && (_1283_sqlite3Config.szScratch >= 100) && (_1283_sqlite3Config.nScratch > 0))) {
      int i, n, sz;
      ScratchFreeslot *pSlot;
      (sz = (_1283_sqlite3Config.szScratch & (~ 7)));
      (_1283_sqlite3Config.szScratch = sz);
      (pSlot = ((ScratchFreeslot *) _1283_sqlite3Config.pScratch));
      (n = _1283_sqlite3Config.nScratch);
      (mem0.pScratchFree = pSlot);
      (mem0.nScratchFree = n);
      for ((i = 0); (i < (n - 1)); i++) {
        (pSlot->pNext = ((ScratchFreeslot *) (sz + ((char *) pSlot))));
        (pSlot = pSlot->pNext);
      }
      (pSlot->pNext = 0);
      (mem0.pScratchEnd = ((void *) (&pSlot[1])));
    }  
    else {
      (mem0.pScratchEnd = 0);
      (_1283_sqlite3Config.pScratch = 0);
      (_1283_sqlite3Config.szScratch = 0);
      (_1283_sqlite3Config.nScratch = 0);
    }
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if ((_1284_sqlite3Config.pScratch && (_1284_sqlite3Config.szScratch >= 100) && (_1284_sqlite3Config.nScratch > 0))) {
      int i, n, sz;
      ScratchFreeslot *pSlot;
      (sz = (_1284_sqlite3Config.szScratch & (~ 7)));
      (_1284_sqlite3Config.szScratch = sz);
      (pSlot = ((ScratchFreeslot *) _1284_sqlite3Config.pScratch));
      (n = _1284_sqlite3Config.nScratch);
      (mem0.pScratchFree = pSlot);
      (mem0.nScratchFree = n);
      for ((i = 0); (i < (n - 1)); i++) {
        (pSlot->pNext = ((ScratchFreeslot *) (sz + ((char *) pSlot))));
        (pSlot = pSlot->pNext);
      }
      (pSlot->pNext = 0);
      (mem0.pScratchEnd = ((void *) (&pSlot[1])));
    }  
    else {
      (mem0.pScratchEnd = 0);
      (_1284_sqlite3Config.pScratch = 0);
      (_1284_sqlite3Config.szScratch = 0);
      (_1284_sqlite3Config.nScratch = 0);
    }
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (((_1283_sqlite3Config.pPage == 0) || (_1283_sqlite3Config.szPage < 512) || (_1283_sqlite3Config.nPage < 1))) {
      (_1283_sqlite3Config.pPage = 0);
      (_1283_sqlite3Config.szPage = 0);
      (_1283_sqlite3Config.nPage = 0);
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (((_1284_sqlite3Config.pPage == 0) || (_1284_sqlite3Config.szPage < 512) || (_1284_sqlite3Config.nPage < 1))) {
      (_1284_sqlite3Config.pPage = 0);
      (_1284_sqlite3Config.szPage = 0);
      (_1284_sqlite3Config.nPage = 0);
    }  
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    return _1283_sqlite3Config.m.xInit(_1283_sqlite3Config.m.pAppData);
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    return _1284_sqlite3Config.m.xInit(_1284_sqlite3Config.m.pAppData);
  }  
}
static  int sqlite3HeapNearlyFull(void )  {
  return mem0.nearlyFull;
}
static  void sqlite3MallocEnd(void )  {
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (_1283_sqlite3Config.m.xShutdown) {
      _1283_sqlite3Config.m.xShutdown(_1283_sqlite3Config.m.pAppData);
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (_1284_sqlite3Config.m.xShutdown) {
      _1284_sqlite3Config.m.xShutdown(_1284_sqlite3Config.m.pAppData);
    }  
  }  
  memset((&mem0), 0, sizeof(mem0));
}
sqlite3_int64 sqlite3_memory_used(void )  {
  int n, mx;
  sqlite3_int64 res;
  sqlite3_status(0, (&n), (&mx), 0);
  (res = ((sqlite3_int64 ) n));
  return res;
}
sqlite3_int64 sqlite3_memory_highwater(int resetFlag )  {
  int n, mx;
  sqlite3_int64 res;
  sqlite3_status(0, (&n), (&mx), resetFlag);
  (res = ((sqlite3_int64 ) mx));
  return res;
}
static  void sqlite3MallocAlarm(int nByte )  {
  void ( *xCallback)(void * , sqlite3_int64 , int );
  sqlite3_int64 nowUsed;
  void *pArg;
  if ((mem0.alarmCallback == 0)) {
    return;
  }  
  (xCallback = mem0.alarmCallback);
  (nowUsed = sqlite3StatusValue(0));
  (pArg = mem0.alarmArg);
  (mem0.alarmCallback = 0);
  xCallback(pArg, nowUsed, nByte);
  (mem0.alarmCallback = xCallback);
  (mem0.alarmArg = pArg);
}
static  int mallocWithAlarm(int n , void **pp )  {
  int nFull;
  void *p;
  ((void ) 0);
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    (nFull = _1283_sqlite3Config.m.xRoundup(n));
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    (nFull = _1284_sqlite3Config.m.xRoundup(n));
  }  
  sqlite3StatusSet(5, n);
  if ((mem0.alarmCallback != 0)) {
    int nUsed =  sqlite3StatusValue(0);
    if ((nUsed >= (mem0.alarmThreshold - nFull))) {
      (mem0.nearlyFull = 1);
      sqlite3MallocAlarm(nFull);
    }  
    else {
      (mem0.nearlyFull = 0);
    }
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    (p = _1283_sqlite3Config.m.xMalloc(nFull));
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    (p = _1284_sqlite3Config.m.xMalloc(nFull));
  }  
  if (((id2i_sqlite_enable_memory_management ) )) {
    if (((p == 0) && mem0.alarmCallback)) {
      sqlite3MallocAlarm(nFull);
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (p = _1283_sqlite3Config.m.xMalloc(nFull));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (p = _1284_sqlite3Config.m.xMalloc(nFull));
      }  
    }  
  }  
  if (p) {
    (nFull = sqlite3MallocSize(p));
    sqlite3StatusAdd(0, nFull);
    sqlite3StatusAdd(9, 1);
  }  
  ((*pp) = p);
  return nFull;
}
static  void *sqlite3Malloc(int n )  {
  void *p;
  if (((n <= 0) || (n >= 0x7fffff00))) {
    (p = 0);
  } 
  else if (((((! id2i_sqlite_default_memstatus) ) ) && _1283_sqlite3Config.bMemstat)) {
    mallocWithAlarm(n, (&p));
  }
  
  else if ((((id2i_sqlite_default_memstatus ) ) && _1284_sqlite3Config.bMemstat)) {
    mallocWithAlarm(n, (&p));
  } 
  else {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      (p = _1283_sqlite3Config.m.xMalloc(n));
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      (p = _1284_sqlite3Config.m.xMalloc(n));
    }  
  }
  ((void ) 0);
  return p;
}
void *sqlite3_malloc(int n )  {
  if (sqlite3_initialize()) {
    return 0;
  }  
  return sqlite3Malloc(n);
}
static  void *sqlite3ScratchMalloc(int n )  {
  void *p;
  ((void ) 0);
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if ((mem0.nScratchFree && (_1283_sqlite3Config.szScratch >= n))) {
      (p = mem0.pScratchFree);
      (mem0.pScratchFree = mem0.pScratchFree->pNext);
      mem0.nScratchFree--;
      sqlite3StatusAdd(3, 1);
      sqlite3StatusSet(8, n);
    }  
    else {
      if (_1283_sqlite3Config.bMemstat) {
        sqlite3StatusSet(8, n);
        (n = mallocWithAlarm(n, (&p)));
        if (p) {
          sqlite3StatusAdd(4, n);
        }  
      }  
      else {
        (p = _1283_sqlite3Config.m.xMalloc(n));
      }
    }
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if ((mem0.nScratchFree && (_1284_sqlite3Config.szScratch >= n))) {
      (p = mem0.pScratchFree);
      (mem0.pScratchFree = mem0.pScratchFree->pNext);
      mem0.nScratchFree--;
      sqlite3StatusAdd(3, 1);
      sqlite3StatusSet(8, n);
    }  
    else {
      if (_1284_sqlite3Config.bMemstat) {
        sqlite3StatusSet(8, n);
        (n = mallocWithAlarm(n, (&p)));
        if (p) {
          sqlite3StatusAdd(4, n);
        }  
      }  
      else {
        (p = _1284_sqlite3Config.m.xMalloc(n));
      }
    }
  }  
  ((void ) 0);
  return p;
}
static  void sqlite3ScratchFree(void *p )  {
  if (p) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      if (((p >= _1283_sqlite3Config.pScratch) && (p < mem0.pScratchEnd))) {
        ScratchFreeslot *pSlot;
        (pSlot = ((ScratchFreeslot *) p));
        (pSlot->pNext = mem0.pScratchFree);
        (mem0.pScratchFree = pSlot);
        mem0.nScratchFree++;
        ((void ) 0);
        sqlite3StatusAdd(3, (- 1));
      }  
      else {
        ((void ) 0);
        ((void ) 0);
        if (_1283_sqlite3Config.bMemstat) {
          int iSize =  sqlite3MallocSize(p);
          sqlite3StatusAdd(4, (- iSize));
          sqlite3StatusAdd(0, (- iSize));
          sqlite3StatusAdd(9, (- 1));
          _1283_sqlite3Config.m.xFree(p);
        }  
        else {
          _1283_sqlite3Config.m.xFree(p);
        }
      }
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      if (((p >= _1284_sqlite3Config.pScratch) && (p < mem0.pScratchEnd))) {
        ScratchFreeslot *pSlot;
        (pSlot = ((ScratchFreeslot *) p));
        (pSlot->pNext = mem0.pScratchFree);
        (mem0.pScratchFree = pSlot);
        mem0.nScratchFree++;
        ((void ) 0);
        sqlite3StatusAdd(3, (- 1));
      }  
      else {
        ((void ) 0);
        ((void ) 0);
        if (_1284_sqlite3Config.bMemstat) {
          int iSize =  sqlite3MallocSize(p);
          sqlite3StatusAdd(4, (- iSize));
          sqlite3StatusAdd(0, (- iSize));
          sqlite3StatusAdd(9, (- 1));
          _1284_sqlite3Config.m.xFree(p);
        }  
        else {
          _1284_sqlite3Config.m.xFree(p);
        }
      }
    }  
  }  
}
static  int isLookaside(sqlite3 *db , void *p )  {
  return (p && (p >= db->lookaside.pStart) && (p < db->lookaside.pEnd));
}
static  int sqlite3MallocSize(void *p )  {
  ((void ) 0);
  ((void ) 0);
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    return _1283_sqlite3Config.m.xSize(p);
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    return _1284_sqlite3Config.m.xSize(p);
  }  
}
static  int sqlite3DbMallocSize(sqlite3 *db , void *p )  {
  ((void ) 0);
  if ((db && isLookaside(db, p))) {
    return db->lookaside.sz;
  }  
  else {
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      return _1283_sqlite3Config.m.xSize(p);
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      return _1284_sqlite3Config.m.xSize(p);
    }  
  }
}
void sqlite3_free(void *p )  {
  if ((p == 0)) {
    return;
  }  
  ((void ) 0);
  ((void ) 0);
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (_1283_sqlite3Config.bMemstat) {
      sqlite3StatusAdd(0, (- sqlite3MallocSize(p)));
      sqlite3StatusAdd(9, (- 1));
      _1283_sqlite3Config.m.xFree(p);
    }  
    else {
      _1283_sqlite3Config.m.xFree(p);
    }
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (_1284_sqlite3Config.bMemstat) {
      sqlite3StatusAdd(0, (- sqlite3MallocSize(p)));
      sqlite3StatusAdd(9, (- 1));
      _1284_sqlite3Config.m.xFree(p);
    }  
    else {
      _1284_sqlite3Config.m.xFree(p);
    }
  }  
}
static  void sqlite3DbFree(sqlite3 *db , void *p )  {
  ((void ) 0);
  if ((p == 0)) {
    return;
  }  
  if (db) {
    if (db->pnBytesFreed) {
      ((*db->pnBytesFreed) += sqlite3DbMallocSize(db, p));
      return;
    }  
    if (isLookaside(db, p)) {
      LookasideSlot *pBuf =  ((LookasideSlot *) p);
      (pBuf->pNext = db->lookaside.pFree);
      (db->lookaside.pFree = pBuf);
      db->lookaside.nOut--;
      return;
    }  
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  sqlite3_free(p);
}
static  void *sqlite3Realloc(void *pOld , int nBytes )  {
  int nOld, nNew, nDiff;
  void *pNew;
  if ((pOld == 0)) {
    return sqlite3Malloc(nBytes);
  }  
  if ((nBytes <= 0)) {
    sqlite3_free(pOld);
    return 0;
  }  
  if ((nBytes >= 0x7fffff00)) {
    return 0;
  }  
  (nOld = sqlite3MallocSize(pOld));
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    (nNew = _1283_sqlite3Config.m.xRoundup(nBytes));
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    (nNew = _1284_sqlite3Config.m.xRoundup(nBytes));
  }  
  if ((nOld == nNew)) {
    (pNew = pOld);
  } 
  else if (((((! id2i_sqlite_default_memstatus) ) ) && _1283_sqlite3Config.bMemstat)) {
    sqlite3StatusSet(5, nBytes);
    (nDiff = (nNew - nOld));
    if ((sqlite3StatusValue(0) >= (mem0.alarmThreshold - nDiff))) {
      sqlite3MallocAlarm(nDiff);
    }  
    ((void ) 0);
    ((void ) 0);
    (pNew = _1283_sqlite3Config.m.xRealloc(pOld, nNew));
    if (((pNew == 0) && mem0.alarmCallback)) {
      sqlite3MallocAlarm(nBytes);
      (pNew = _1283_sqlite3Config.m.xRealloc(pOld, nNew));
    }  
    if (pNew) {
      (nNew = sqlite3MallocSize(pNew));
      sqlite3StatusAdd(0, (nNew - nOld));
    }  
  }
  
  else if ((((id2i_sqlite_default_memstatus ) ) && _1284_sqlite3Config.bMemstat)) {
    sqlite3StatusSet(5, nBytes);
    (nDiff = (nNew - nOld));
    if ((sqlite3StatusValue(0) >= (mem0.alarmThreshold - nDiff))) {
      sqlite3MallocAlarm(nDiff);
    }  
    ((void ) 0);
    ((void ) 0);
    (pNew = _1284_sqlite3Config.m.xRealloc(pOld, nNew));
    if (((pNew == 0) && mem0.alarmCallback)) {
      sqlite3MallocAlarm(nBytes);
      (pNew = _1284_sqlite3Config.m.xRealloc(pOld, nNew));
    }  
    if (pNew) {
      (nNew = sqlite3MallocSize(pNew));
      sqlite3StatusAdd(0, (nNew - nOld));
    }  
  } 
  else {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      (pNew = _1283_sqlite3Config.m.xRealloc(pOld, nNew));
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      (pNew = _1284_sqlite3Config.m.xRealloc(pOld, nNew));
    }  
  }
  ((void ) 0);
  return pNew;
}
void *sqlite3_realloc(void *pOld , int n )  {
  if (sqlite3_initialize()) {
    return 0;
  }  
  return sqlite3Realloc(pOld, n);
}
static  void *sqlite3MallocZero(int n )  {
  void *p =  sqlite3Malloc(n);
  if (p) {
    memset(p, 0, n);
  }  
  return p;
}
static  void *sqlite3DbMallocZero(sqlite3 *db , int n )  {
  void *p =  sqlite3DbMallocRaw(db, n);
  if (p) {
    memset(p, 0, n);
  }  
  return p;
}
static  void *sqlite3DbMallocRaw(sqlite3 *db , int n )  {
  void *p;
  ((void ) 0);
  ((void ) 0);
  if (db) {
    LookasideSlot *pBuf;
    if (db->mallocFailed) {
      return 0;
    }  
    if (db->lookaside.bEnabled) {
      if ((n > db->lookaside.sz)) {
        db->lookaside.anStat[1]++;
      } 
      else if (((pBuf = db->lookaside.pFree) == 0)) {
        db->lookaside.anStat[2]++;
      } 
      else {
        (db->lookaside.pFree = pBuf->pNext);
        db->lookaside.nOut++;
        db->lookaside.anStat[0]++;
        if ((db->lookaside.nOut > db->lookaside.mxOut)) {
          (db->lookaside.mxOut = db->lookaside.nOut);
        }  
        return ((void *) pBuf);
      }
    }  
  }  
  (p = sqlite3Malloc(n));
  if (((! p) && db)) {
    (db->mallocFailed = 1);
  }  
  return p;
}
static  void *sqlite3DbRealloc(sqlite3 *db , void *p , int n )  {
  void *pNew =  0;
  ((void ) 0);
  ((void ) 0);
  if ((db->mallocFailed == 0)) {
    if ((p == 0)) {
      return sqlite3DbMallocRaw(db, n);
    }  
    if (isLookaside(db, p)) {
      if ((n <= db->lookaside.sz)) {
        return p;
      }  
      (pNew = sqlite3DbMallocRaw(db, n));
      if (pNew) {
        memcpy(pNew, p, db->lookaside.sz);
        sqlite3DbFree(db, p);
      }  
    }  
    else {
      ((void ) 0);
      ((void ) 0);
      (pNew = sqlite3_realloc(p, n));
      if ((! pNew)) {
        (db->mallocFailed = 1);
      }  
    }
  }  
  return pNew;
}
static  void *sqlite3DbReallocOrFree(sqlite3 *db , void *p , int n )  {
  void *pNew;
  (pNew = sqlite3DbRealloc(db, p, n));
  if ((! pNew)) {
    sqlite3DbFree(db, p);
  }  
  return pNew;
}
static  char *sqlite3DbStrDup(sqlite3 *db , const  char *z )  {
  char *zNew;
  size_t n;
  if ((z == 0)) {
    return 0;
  }  
  (n = (sqlite3Strlen30(z) + 1));
  ((void ) 0);
  (zNew = sqlite3DbMallocRaw(db, ((int ) n)));
  if (zNew) {
    memcpy(zNew, z, n);
  }  
  return zNew;
}
static  char *sqlite3DbStrNDup(sqlite3 *db , const  char *z , int n )  {
  char *zNew;
  if ((z == 0)) {
    return 0;
  }  
  ((void ) 0);
  (zNew = sqlite3DbMallocRaw(db, (n + 1)));
  if (zNew) {
    memcpy(zNew, z, n);
    (zNew[n] = 0);
  }  
  return zNew;
}
static  void sqlite3SetString(char **pz , sqlite3 *db , const  char *zFormat , ...)  {
  va_list ap;
  char *z;
  __builtin_va_start(ap, zFormat);
  (z = sqlite3VMPrintf(db, zFormat, ap));
  __builtin_va_end(ap);
  sqlite3DbFree(db, (*pz));
  ((*pz) = z);
}
static  int sqlite3ApiExit(sqlite3 *db , int rc )  {
  ((void ) 0);
  if ((db && (db->mallocFailed || (rc == (10 | (12 << 8)))))) {
    sqlite3Error(db, 7, 0);
    (db->mallocFailed = 0);
    (rc = 7);
  }  
  return (rc & (db ? db->errMask : 0xff));
}
typedef unsigned char etByte;
typedef struct  et_info {
  char fmttype ;
  etByte base ;
  etByte flags ;
  etByte type ;
  etByte charset ;
  etByte prefix ;
}  et_info;
static const char aDigits[] =  "0123456789ABCDEF0123456789abcdef";
static const char aPrefix[] =  "-x0\000X0";
static const et_info fmtinfo[] =  { { 'd',  10,  1,  1,  0,  0},  { 's',  0,  4,  6,  0,  0},  { 'g',  0,  1,  4,  30,  0},  { 'z',  0,  4,  7,  0,  0},  { 'q',  0,  4,  10,  0,  0},  { 'Q',  0,  4,  11,  0,  0},  { 'w',  0,  4,  15,  0,  0},  { 'c',  0,  0,  9,  0,  0},  { 'o',  8,  0,  1,  0,  2},  { 'u',  10,  0,  1,  0,  0},  { 'x',  16,  0,  1,  16,  1},  { 'X',  16,  0,  1,  0,  4},  { 'f',  0,  1,  2,  0,  0},  { 'e',  0,  1,  3,  30,  0},  { 'E',  0,  1,  3,  14,  0},  { 'G',  0,  1,  4,  14,  0},  { 'i',  10,  1,  1,  0,  0},  { 'n',  0,  0,  5,  0,  0},  { '%',  0,  0,  8,  0,  0},  { 'p',  16,  0,  14,  0,  1},  { 'T',  0,  2,  12,  0,  0},  { 'S',  0,  2,  13,  0,  0},  { 'r',  10,  3,  16,  0,  0}};
static  char et_getdigit(long  double *val , int *cnt )  {
  int digit;
  long double d;
  if (((*cnt) <= 0)) {
    return '0';
  }  
  (*cnt)--;
  (digit = ((int ) (*val)));
  (d = digit);
  (digit += '0');
  ((*val) = (((*val) - d) * 10.0));
  return ((char ) digit);
}
static  void sqlite3AppendSpace(StrAccum *pAccum , int N )  {
  static const char zSpaces[] =  "                             ";
  while ((N >= (((int ) sizeof(zSpaces)) - 1))) {
    sqlite3StrAccumAppend(pAccum, zSpaces, (sizeof(zSpaces) - 1));
    (N -= (sizeof(zSpaces) - 1));
  }
  if ((N > 0)) {
    sqlite3StrAccumAppend(pAccum, zSpaces, N);
  }  
}
static  void sqlite3VXPrintf(StrAccum *pAccum , int useExtended , const  char *fmt , va_list ap )  {
  int c;
  char *bufpt;
  int precision;
  int length;
  int idx;
  int width;
  etByte flag_leftjustify;
  etByte flag_plussign;
  etByte flag_blanksign;
  etByte flag_alternateform;
  etByte flag_altform2;
  etByte flag_zeropad;
  etByte flag_long;
  etByte flag_longlong;
  etByte done;
  etByte xtype =  0;
  char prefix;
  sqlite_uint64 longvalue;
  long double realvalue;
  const et_info *infop;
  char *zOut;
  int nOut;
  char *zExtra;
  int exp, e2;
  int nsd;
  double rounder;
  etByte flag_dp;
  etByte flag_rtz;
  char buf[70];
  (bufpt = 0);
  for (; ((c = (*fmt)) != 0); ++fmt) {
    if ((c != '%')) {
      int amt;
      (bufpt = ((char *) fmt));
      (amt = 1);
      while ((((c = (*++fmt)) != '%') && (c != 0))) {
        amt++;
      }
      sqlite3StrAccumAppend(pAccum, bufpt, amt);
      if ((c == 0)) {
        break;
      }  
    }  
    if (((c = (*++fmt)) == 0)) {
      sqlite3StrAccumAppend(pAccum, "%", 1);
      break;
    }  
    (flag_leftjustify = (flag_plussign = (flag_blanksign = (flag_alternateform = (flag_altform2 = (flag_zeropad = 0))))));
    (done = 0);
    do {
      switch (c) {
        case '-':
        (flag_leftjustify = 1);
        break;
        case '+':
        (flag_plussign = 1);
        break;
        case ' ':
        (flag_blanksign = 1);
        break;
        case '#':
        (flag_alternateform = 1);
        break;
        case '!':
        (flag_altform2 = 1);
        break;
        case '0':
        (flag_zeropad = 1);
        break;
        id2i_label_1:
        default:
        (done = 1);
        break;
      }
    } while (((! done) && ((c = (*++fmt)) != 0)));
    (width = 0);
    if ((c == '*')) {
      (width = __builtin_va_arg(ap, int ));
      if ((width < 0)) {
        (flag_leftjustify = 1);
        (width = (- width));
      }  
      (c = (*++fmt));
    }  
    else {
      while (((c >= '0') && (c <= '9'))) {
        (width = ((width * 10) + c - '0'));
        (c = (*++fmt));
      }
    }
    if ((c == '.')) {
      (precision = 0);
      (c = (*++fmt));
      if ((c == '*')) {
        (precision = __builtin_va_arg(ap, int ));
        if ((precision < 0)) {
          (precision = (- precision));
        }  
        (c = (*++fmt));
      }  
      else {
        while (((c >= '0') && (c <= '9'))) {
          (precision = ((precision * 10) + c - '0'));
          (c = (*++fmt));
        }
      }
    }  
    else {
      (precision = (- 1));
    }
    if ((c == 'l')) {
      (flag_long = 1);
      (c = (*++fmt));
      if ((c == 'l')) {
        (flag_longlong = 1);
        (c = (*++fmt));
      }  
      else {
        (flag_longlong = 0);
      }
    }  
    else {
      (flag_long = (flag_longlong = 0));
    }
    (infop = (&fmtinfo[0]));
    (xtype = 0);
    for ((idx = 0); (idx < ((int ) (sizeof(fmtinfo) / sizeof(fmtinfo[0])))); idx++) {
      if ((c == fmtinfo[idx].fmttype)) {
        (infop = (&fmtinfo[idx]));
        if ((useExtended || ((infop->flags & 2) == 0))) {
          (xtype = infop->type);
        }  
        else {
          return;
        }
        break;
      }  
    }
    (zExtra = 0);
    switch (xtype) {
      case 14:
      (flag_longlong = (sizeof(char *) == sizeof(i64 )));
      (flag_long = (sizeof(char *) == sizeof(long  int )));
      case 16:
      case 1:
      if ((infop->flags & 1)) {
        i64 v;
        if (flag_longlong) {
          (v = __builtin_va_arg(ap, i64 ));
        } 
        else if (flag_long) {
          (v = __builtin_va_arg(ap, long  int ));
        } 
        else {
          (v = __builtin_va_arg(ap, int ));
        }
        if ((v < 0)) {
          if ((v == (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32))))) {
            (longvalue = (((u64 ) 1) << 63));
          }  
          else {
            (longvalue = (- v));
          }
          (prefix = '-');
        }  
        else {
          (longvalue = v);
          if (flag_plussign) {
            (prefix = '+');
          } 
          else if (flag_blanksign) {
            (prefix = ' ');
          } 
          else {
            (prefix = 0);
          }
        }
      }  
      else {
        if (flag_longlong) {
          (longvalue = __builtin_va_arg(ap, u64 ));
        } 
        else if (flag_long) {
          (longvalue = __builtin_va_arg(ap, unsigned  long  int ));
        } 
        else {
          (longvalue = __builtin_va_arg(ap, unsigned  int ));
        }
        (prefix = 0);
      }
      if ((longvalue == 0)) {
        (flag_alternateform = 0);
      }  
      if ((flag_zeropad && (precision < (width - (prefix != 0))))) {
        (precision = (width - (prefix != 0)));
      }  
      if ((precision < (70 - 10))) {
        (nOut = 70);
        (zOut = buf);
      }  
      else {
        (nOut = (precision + 10));
        (zOut = (zExtra = sqlite3Malloc(nOut)));
        if ((zOut == 0)) {
          (pAccum->accError = 1);
          return;
        }  
      }
      (bufpt = (&zOut[(nOut - 1)]));
      if ((xtype == 16)) {
        static const char zOrd[] =  "thstndrd";
        int x =  ((int ) (longvalue % 10));
        if (((x >= 4) || (((longvalue / 10) % 10) == 1))) {
          (x = 0);
        }  
        ((*--bufpt) = zOrd[((x * 2) + 1)]);
        ((*--bufpt) = zOrd[(x * 2)]);
      }  
      {
        register const char *cset;
        register int base;
        (cset = (&aDigits[infop->charset]));
        (base = infop->base);
        do {
          ((*--bufpt) = cset[(longvalue % base)]);
          (longvalue = (longvalue / base));
        } while ((longvalue > 0));
      }
      (length = ((int ) ((&zOut[(nOut - 1)]) - bufpt)));
      for ((idx = (precision - length)); (idx > 0); idx--) {
        ((*--bufpt) = '0');
      }
      if (prefix) {
        ((*--bufpt) = prefix);
      }  
      if ((flag_alternateform && infop->prefix)) {
        const char *pre;
        char x;
        (pre = (&aPrefix[infop->prefix]));
        for (; ((x = (*pre)) != 0); pre++) {
          ((*--bufpt) = x);
        }
      }  
      (length = ((int ) ((&zOut[(nOut - 1)]) - bufpt)));
      break;
      case 2:
      case 3:
      case 4:
      (realvalue = __builtin_va_arg(ap, double ));
      if ((precision < 0)) {
        (precision = 6);
      }  
      if ((realvalue < 0.0)) {
        (realvalue = (- realvalue));
        (prefix = '-');
      }  
      else {
        if (flag_plussign) {
          (prefix = '+');
        } 
        else if (flag_blanksign) {
          (prefix = ' ');
        } 
        else {
          (prefix = 0);
        }
      }
      if (((xtype == 4) && (precision > 0))) {
        precision--;
      }  
      for ((idx = precision), (rounder = 0.5); (idx > 0); idx--, (rounder *= 0.1)) {
        
      }
      if ((xtype == 2)) {
        (realvalue += rounder);
      }  
      (exp = 0);
      if (sqlite3IsNaN(((double ) realvalue))) {
        (bufpt = "NaN");
        (length = 3);
        break;
      }  
      if ((realvalue > 0.0)) {
        long double scale =  1.0;
        while (((realvalue >= (1e100 * scale)) && (exp <= 350))) {
          (scale *= 1e100);
          (exp += 100);
        }
        while (((realvalue >= (1e64 * scale)) && (exp <= 350))) {
          (scale *= 1e64);
          (exp += 64);
        }
        while (((realvalue >= (1e8 * scale)) && (exp <= 350))) {
          (scale *= 1e8);
          (exp += 8);
        }
        while (((realvalue >= (10.0 * scale)) && (exp <= 350))) {
          (scale *= 10.0);
          exp++;
        }
        (realvalue /= scale);
        while ((realvalue < 1e-8)) {
          (realvalue *= 1e8);
          (exp -= 8);
        }
        while ((realvalue < 1.0)) {
          (realvalue *= 10.0);
          exp--;
        }
        if ((exp > 350)) {
          if ((prefix == '-')) {
            (bufpt = "-Inf");
          } 
          else if ((prefix == '+')) {
            (bufpt = "+Inf");
          } 
          else {
            (bufpt = "Inf");
          }
          (length = sqlite3Strlen30(bufpt));
          break;
        }  
      }  
      (bufpt = buf);
      if ((xtype != 2)) {
        (realvalue += rounder);
        if ((realvalue >= 10.0)) {
          (realvalue *= 0.1);
          exp++;
        }  
      }  
      if ((xtype == 4)) {
        (flag_rtz = (! flag_alternateform));
        if (((exp < (- 4)) || (exp > precision))) {
          (xtype = 3);
        }  
        else {
          (precision = (precision - exp));
          (xtype = 2);
        }
      }  
      else {
        (flag_rtz = flag_altform2);
      }
      if ((xtype == 3)) {
        (e2 = 0);
      }  
      else {
        (e2 = exp);
      }
      if (((((e2 > 0) ? e2 : 0) + precision + width) > (70 - 15))) {
        (bufpt = (zExtra = sqlite3Malloc((((e2 > 0) ? e2 : 0) + precision + width + 15))));
        if ((bufpt == 0)) {
          (pAccum->accError = 1);
          return;
        }  
      }  
      (zOut = bufpt);
      (nsd = (16 + (flag_altform2 * 10)));
      (flag_dp = (((precision > 0) ? 1 : 0) | flag_alternateform | flag_altform2));
      if (prefix) {
        ((*bufpt++) = prefix);
      }  
      if ((e2 < 0)) {
        ((*bufpt++) = '0');
      }  
      else {
        for (; (e2 >= 0); e2--) {
          ((*bufpt++) = et_getdigit((&realvalue), (&nsd)));
        }
      }
      if (flag_dp) {
        ((*bufpt++) = '.');
      }  
      for (e2++; (e2 < 0); precision--, e2++) {
        ((void ) 0);
        ((*bufpt++) = '0');
      }
      while ((precision-- > 0)) {
        ((*bufpt++) = et_getdigit((&realvalue), (&nsd)));
      }
      if ((flag_rtz && flag_dp)) {
        while ((bufpt[(- 1)] == '0')) {
          ((*--bufpt) = 0);
        }
        ((void ) 0);
        if ((bufpt[(- 1)] == '.')) {
          if (flag_altform2) {
            ((*bufpt++) = '0');
          }  
          else {
            ((*--bufpt) = 0);
          }
        }  
      }  
      if ((xtype == 3)) {
        ((*bufpt++) = aDigits[infop->charset]);
        if ((exp < 0)) {
          ((*bufpt++) = '-');
          (exp = (- exp));
        }  
        else {
          ((*bufpt++) = '+');
        }
        if ((exp >= 100)) {
          ((*bufpt++) = ((char ) ((exp / 100) + '0')));
          (exp %= 100);
        }  
        ((*bufpt++) = ((char ) ((exp / 10) + '0')));
        ((*bufpt++) = ((char ) ((exp % 10) + '0')));
      }  
      ((*bufpt) = 0);
      (length = ((int ) (bufpt - zOut)));
      (bufpt = zOut);
      if ((flag_zeropad && (! flag_leftjustify) && (length < width))) {
        int i;
        int nPad =  (width - length);
        for ((i = width); (i >= nPad); i--) {
          (bufpt[i] = bufpt[(i - nPad)]);
        }
        (i = (prefix != 0));
        while (nPad--) {
          (bufpt[i++] = '0');
        }
        (length = width);
      }  
      break;
      case 5:
      ((*__builtin_va_arg(ap, int *)) = pAccum->nChar);
      (length = (width = 0));
      break;
      case 8:
      (buf[0] = '%');
      (bufpt = buf);
      (length = 1);
      break;
      case 9:
      (c = __builtin_va_arg(ap, int ));
      (buf[0] = ((char ) c));
      if ((precision >= 0)) {
        for ((idx = 1); (idx < precision); idx++) {
          (buf[idx] = ((char ) c));
        }
        (length = precision);
      }  
      else {
        (length = 1);
      }
      (bufpt = buf);
      break;
      case 6:
      case 7:
      (bufpt = __builtin_va_arg(ap, char *));
      if ((bufpt == 0)) {
        (bufpt = "");
      } 
      else if ((xtype == 7)) {
        (zExtra = bufpt);
      } 
      if ((precision >= 0)) {
        for ((length = 0); ((length < precision) && bufpt[length]); length++) {
          
        }
      }  
      else {
        (length = sqlite3Strlen30(bufpt));
      }
      break;
      case 10:
      case 11:
      case 15:
      {
        int i, j, k, n, isnull;
        int needQuote;
        char ch;
        char q =  ((xtype == 15) ? '"' : '\'');
        char *escarg =  __builtin_va_arg(ap, char *);
        (isnull = (escarg == 0));
        if (isnull) {
          (escarg = ((xtype == 11) ? "NULL" : "(NULL)"));
        }  
        (k = precision);
        for ((i = (n = 0)); ((k != 0) && ((ch = escarg[i]) != 0)); i++, k--) {
          if ((ch == q)) {
            n++;
          }  
        }
        (needQuote = ((! isnull) && (xtype == 11)));
        (n += (i + 1 + (needQuote * 2)));
        if ((n > 70)) {
          (bufpt = (zExtra = sqlite3Malloc(n)));
          if ((bufpt == 0)) {
            (pAccum->accError = 1);
            return;
          }  
        }  
        else {
          (bufpt = buf);
        }
        (j = 0);
        if (needQuote) {
          (bufpt[j++] = q);
        }  
        (k = i);
        for ((i = 0); (i < k); i++) {
          (bufpt[j++] = (ch = escarg[i]));
          if ((ch == q)) {
            (bufpt[j++] = ch);
          }  
        }
        if (needQuote) {
          (bufpt[j++] = q);
        }  
        (bufpt[j] = 0);
        (length = j);
        break;
      }
      case 12:
      {
        Token *pToken =  __builtin_va_arg(ap, Token *);
        if (pToken) {
          sqlite3StrAccumAppend(pAccum, ((const  char *) pToken->z), pToken->n);
        }  
        (length = (width = 0));
        break;
      }
      case 13:
      {
        SrcList *pSrc =  __builtin_va_arg(ap, SrcList *);
        int k =  __builtin_va_arg(ap, int );
        struct  SrcList_item   *pItem =  (&pSrc->a[k]);
        ((void ) 0);
        if (pItem->zDatabase) {
          sqlite3StrAccumAppend(pAccum, pItem->zDatabase, (- 1));
          sqlite3StrAccumAppend(pAccum, ".", 1);
        }  
        sqlite3StrAccumAppend(pAccum, pItem->zName, (- 1));
        (length = (width = 0));
        break;
      }
      id2i_label_2:
      default:
      {
        ((void ) 0);
        return;
      }
    }
    if ((! flag_leftjustify)) {
      register int nspace;
      (nspace = (width - length));
      if ((nspace > 0)) {
        sqlite3AppendSpace(pAccum, nspace);
      }  
    }  
    if ((length > 0)) {
      sqlite3StrAccumAppend(pAccum, bufpt, length);
    }  
    if (flag_leftjustify) {
      register int nspace;
      (nspace = (width - length));
      if ((nspace > 0)) {
        sqlite3AppendSpace(pAccum, nspace);
      }  
    }  
    sqlite3_free(zExtra);
  }
}
static  void sqlite3StrAccumAppend(StrAccum *p , const  char *z , int N )  {
  ((void ) 0);
  if (p->accError) {
    if (((id2i_sqlite_coverage_test ) )) {
      if ((p->accError == 2)) {
        sqlite3Coverage(20123);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((p->accError == 1)) {
        sqlite3Coverage(20124);
      }  
    }  
    return;
  }  
  ((void ) 0);
  if ((N <= 0)) {
    if (((N == 0) || (z[0] == 0))) {
      return;
    }  
    (N = sqlite3Strlen30(z));
  }  
  if (((p->nChar + N) >= p->nAlloc)) {
    char *zNew;
    if ((! p->useMalloc)) {
      (p->accError = 2);
      (N = (p->nAlloc - p->nChar - 1));
      if ((N <= 0)) {
        return;
      }  
    }  
    else {
      char *zOld =  ((p->zText == p->zBase) ? 0 : p->zText);
      i64 szNew =  p->nChar;
      (szNew += (N + 1));
      if ((szNew > p->mxAlloc)) {
        sqlite3StrAccumReset(p);
        (p->accError = 2);
        return;
      }  
      else {
        (p->nAlloc = ((int ) szNew));
      }
      if ((p->useMalloc == 1)) {
        (zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc));
      }  
      else {
        (zNew = sqlite3_realloc(zOld, p->nAlloc));
      }
      if (zNew) {
        if (((zOld == 0) && (p->nChar > 0))) {
          memcpy(zNew, p->zText, p->nChar);
        }  
        (p->zText = zNew);
      }  
      else {
        (p->accError = 1);
        sqlite3StrAccumReset(p);
        return;
      }
    }
  }  
  ((void ) 0);
  memcpy((&p->zText[p->nChar]), z, N);
  (p->nChar += N);
}
static  char *sqlite3StrAccumFinish(StrAccum *p )  {
  if (p->zText) {
    (p->zText[p->nChar] = 0);
    if ((p->useMalloc && (p->zText == p->zBase))) {
      if ((p->useMalloc == 1)) {
        (p->zText = sqlite3DbMallocRaw(p->db, (p->nChar + 1)));
      }  
      else {
        (p->zText = sqlite3_malloc((p->nChar + 1)));
      }
      if (p->zText) {
        memcpy(p->zText, p->zBase, (p->nChar + 1));
      }  
      else {
        (p->accError = 1);
      }
    }  
  }  
  return p->zText;
}
static  void sqlite3StrAccumReset(StrAccum *p )  {
  if ((p->zText != p->zBase)) {
    if ((p->useMalloc == 1)) {
      sqlite3DbFree(p->db, p->zText);
    }  
    else {
      sqlite3_free(p->zText);
    }
  }  
  (p->zText = 0);
}
static  void sqlite3StrAccumInit(StrAccum *p , char *zBase , int n , int mx )  {
  (p->zText = (p->zBase = zBase));
  (p->db = 0);
  (p->nChar = 0);
  (p->nAlloc = n);
  (p->mxAlloc = mx);
  (p->useMalloc = 1);
  (p->accError = 0);
}
static  char *sqlite3VMPrintf(sqlite3 *db , const  char *zFormat , va_list ap )  {
  char *z;
  char zBase[70];
  StrAccum acc;
  ((void ) 0);
  sqlite3StrAccumInit((&acc), zBase, sizeof(zBase), db->aLimit[0]);
  (acc.db = db);
  sqlite3VXPrintf((&acc), 1, zFormat, ap);
  (z = sqlite3StrAccumFinish((&acc)));
  if ((acc.accError == 1)) {
    (db->mallocFailed = 1);
  }  
  return z;
}
static  char *sqlite3MPrintf(sqlite3 *db , const  char *zFormat , ...)  {
  va_list ap;
  char *z;
  __builtin_va_start(ap, zFormat);
  (z = sqlite3VMPrintf(db, zFormat, ap));
  __builtin_va_end(ap);
  return z;
}
static  char *sqlite3MAppendf(sqlite3 *db , char *zStr , const  char *zFormat , ...)  {
  va_list ap;
  char *z;
  __builtin_va_start(ap, zFormat);
  (z = sqlite3VMPrintf(db, zFormat, ap));
  __builtin_va_end(ap);
  sqlite3DbFree(db, zStr);
  return z;
}
char *sqlite3_vmprintf(const  char *zFormat , va_list ap )  {
  char *z;
  char zBase[70];
  StrAccum acc;
  if (sqlite3_initialize()) {
    return 0;
  }  
  sqlite3StrAccumInit((&acc), zBase, sizeof(zBase), 1000000000);
  (acc.useMalloc = 2);
  sqlite3VXPrintf((&acc), 0, zFormat, ap);
  (z = sqlite3StrAccumFinish((&acc)));
  return z;
}
char *sqlite3_mprintf(const  char *zFormat , ...)  {
  va_list ap;
  char *z;
  if (sqlite3_initialize()) {
    return 0;
  }  
  __builtin_va_start(ap, zFormat);
  (z = sqlite3_vmprintf(zFormat, ap));
  __builtin_va_end(ap);
  return z;
}
char *sqlite3_vsnprintf(int n , char *zBuf , const  char *zFormat , va_list ap )  {
  StrAccum acc;
  if ((n <= 0)) {
    return zBuf;
  }  
  sqlite3StrAccumInit((&acc), zBuf, n, 0);
  (acc.useMalloc = 0);
  sqlite3VXPrintf((&acc), 0, zFormat, ap);
  return sqlite3StrAccumFinish((&acc));
}
char *sqlite3_snprintf(int n , char *zBuf , const  char *zFormat , ...)  {
  char *z;
  va_list ap;
  __builtin_va_start(ap, zFormat);
  (z = sqlite3_vsnprintf(n, zBuf, zFormat, ap));
  __builtin_va_end(ap);
  return z;
}
static  void renderLogMsg(int iErrCode , const  char *zFormat , va_list ap )  {
  StrAccum acc;
  char zMsg[(70 * 3)];
  sqlite3StrAccumInit((&acc), zMsg, sizeof(zMsg), 0);
  (acc.useMalloc = 0);
  sqlite3VXPrintf((&acc), 0, zFormat, ap);
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    _1283_sqlite3Config.xLog(_1283_sqlite3Config.pLogArg, iErrCode, sqlite3StrAccumFinish((&acc)));
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    _1284_sqlite3Config.xLog(_1284_sqlite3Config.pLogArg, iErrCode, sqlite3StrAccumFinish((&acc)));
  }  
}
void sqlite3_log(int iErrCode , const  char *zFormat , ...)  {
  va_list ap;
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (_1283_sqlite3Config.xLog) {
      __builtin_va_start(ap, zFormat);
      renderLogMsg(iErrCode, zFormat, ap);
      __builtin_va_end(ap);
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (_1284_sqlite3Config.xLog) {
      __builtin_va_start(ap, zFormat);
      renderLogMsg(iErrCode, zFormat, ap);
      __builtin_va_end(ap);
    }  
  }  
}
static  void sqlite3XPrintf(StrAccum *p , const  char *zFormat , ...)  {
  va_list ap;
  __builtin_va_start(ap, zFormat);
  sqlite3VXPrintf(p, 1, zFormat, ap);
  __builtin_va_end(ap);
}
static struct  sqlite3PrngType {
  unsigned  char isInit ;
  unsigned  char i , j ;
  unsigned  char s[256] ;
}  sqlite3Prng;
void sqlite3_randomness(int N , void *pBuf )  {
  unsigned char t;
  unsigned char *zBuf =  pBuf;
  if ((! sqlite3Prng.isInit)) {
    int i;
    char k[256];
    (sqlite3Prng.j = 0);
    (sqlite3Prng.i = 0);
    sqlite3OsRandomness(sqlite3_vfs_find(0), 256, k);
    for ((i = 0); (i < 256); i++) {
      (sqlite3Prng.s[i] = ((u8 ) i));
    }
    for ((i = 0); (i < 256); i++) {
      (sqlite3Prng.j += (sqlite3Prng.s[i] + k[i]));
      (t = sqlite3Prng.s[sqlite3Prng.j]);
      (sqlite3Prng.s[sqlite3Prng.j] = sqlite3Prng.s[i]);
      (sqlite3Prng.s[i] = t);
    }
    (sqlite3Prng.isInit = 1);
  }  
  while (N--) {
    sqlite3Prng.i++;
    (t = sqlite3Prng.s[sqlite3Prng.i]);
    (sqlite3Prng.j += t);
    (sqlite3Prng.s[sqlite3Prng.i] = sqlite3Prng.s[sqlite3Prng.j]);
    (sqlite3Prng.s[sqlite3Prng.j] = t);
    (t += sqlite3Prng.s[sqlite3Prng.i]);
    ((*zBuf++) = sqlite3Prng.s[t]);
  }
}
static struct  sqlite3PrngType   sqlite3SavedPrng;
static  void sqlite3PrngSaveState(void )  {
  memcpy((&sqlite3SavedPrng), (&sqlite3Prng), sizeof(sqlite3Prng));
}
static  void sqlite3PrngRestoreState(void )  {
  memcpy((&sqlite3Prng), (&sqlite3SavedPrng), sizeof(sqlite3Prng));
}
static  void sqlite3PrngResetState(void )  {
  (sqlite3Prng.isInit = 0);
}
static const unsigned char sqlite3Utf8Trans1[] =  { 0x00,  0x01,  0x02,  0x03,  0x04,  0x05,  0x06,  0x07,  0x08,  0x09,  0x0a,  0x0b,  0x0c,  0x0d,  0x0e,  0x0f,  0x10,  0x11,  0x12,  0x13,  0x14,  0x15,  0x16,  0x17,  0x18,  0x19,  0x1a,  0x1b,  0x1c,  0x1d,  0x1e,  0x1f,  0x00,  0x01,  0x02,  0x03,  0x04,  0x05,  0x06,  0x07,  0x08,  0x09,  0x0a,  0x0b,  0x0c,  0x0d,  0x0e,  0x0f,  0x00,  0x01,  0x02,  0x03,  0x04,  0x05,  0x06,  0x07,  0x00,  0x01,  0x02,  0x03,  0x00,  0x01,  0x00,  0x00};
static  u32 sqlite3Utf8Read(const  unsigned  char **pz )  {
  unsigned int c;
  (c = (*(*pz)++));
  if ((c >= 0xc0)) {
    (c = sqlite3Utf8Trans1[(c - 0xc0)]);
    while ((((*(*pz)) & 0xc0) == 0x80)) {
      (c = ((c << 6) + (0x3f & (*(*pz)++))));
    }
    if (((c < 0x80) || ((c & 0xFFFFF800) == 0xD800) || ((c & 0xFFFFFFFE) == 0xFFFE))) {
      (c = 0xFFFD);
    }  
  }  
  return c;
}
static  int sqlite3VdbeMemTranslate(Mem *pMem , u8 desiredEnc )  {
  int len;
  unsigned char *zOut;
  unsigned char *zIn;
  unsigned char *zTerm;
  unsigned char *z;
  unsigned int c;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((pMem->enc != 1) && (desiredEnc != 1))) {
    u8 temp;
    int rc;
    (rc = sqlite3VdbeMemMakeWriteable(pMem));
    if ((rc != 0)) {
      ((void ) 0);
      return 7;
    }  
    (zIn = ((u8 *) pMem->z));
    (zTerm = (&zIn[(pMem->n & (~ 1))]));
    while ((zIn < zTerm)) {
      (temp = (*zIn));
      ((*zIn) = (*(zIn + 1)));
      zIn++;
      ((*zIn++) = temp);
    }
    (pMem->enc = desiredEnc);
    goto translate_out;
  }  
  if ((desiredEnc == 1)) {
    (pMem->n &= (~ 1));
    (len = ((pMem->n * 2) + 1));
  }  
  else {
    (len = ((pMem->n * 2) + 2));
  }
  (zIn = ((u8 *) pMem->z));
  (zTerm = (&zIn[pMem->n]));
  (zOut = sqlite3DbMallocRaw(pMem->db, len));
  if ((! zOut)) {
    return 7;
  }  
  (z = zOut);
  if ((pMem->enc == 1)) {
    if ((desiredEnc == 2)) {
      while ((zIn < zTerm)) {
        (c = (*zIn++));
        if ((c >= 0xc0)) {
          (c = sqlite3Utf8Trans1[(c - 0xc0)]);
          while (((zIn != zTerm) && (((*zIn) & 0xc0) == 0x80))) {
            (c = ((c << 6) + (0x3f & (*zIn++))));
          }
          if (((c < 0x80) || ((c & 0xFFFFF800) == 0xD800) || ((c & 0xFFFFFFFE) == 0xFFFE))) {
            (c = 0xFFFD);
          }  
        }  
        {
          if ((c <= 0xFFFF)) {
            ((*z++) = ((u8 ) (c & 0x00FF)));
            ((*z++) = ((u8 ) ((c >> 8) & 0x00FF)));
          }  
          else {
            ((*z++) = ((u8 ) (((c >> 10) & 0x003F) + (((c - 0x10000) >> 10) & 0x00C0))));
            ((*z++) = ((u8 ) (0x00D8 + (((c - 0x10000) >> 18) & 0x03))));
            ((*z++) = ((u8 ) (c & 0x00FF)));
            ((*z++) = ((u8 ) (0x00DC + ((c >> 8) & 0x03))));
          }
        }
      }
    }  
    else {
      ((void ) 0);
      while ((zIn < zTerm)) {
        (c = (*zIn++));
        if ((c >= 0xc0)) {
          (c = sqlite3Utf8Trans1[(c - 0xc0)]);
          while (((zIn != zTerm) && (((*zIn) & 0xc0) == 0x80))) {
            (c = ((c << 6) + (0x3f & (*zIn++))));
          }
          if (((c < 0x80) || ((c & 0xFFFFF800) == 0xD800) || ((c & 0xFFFFFFFE) == 0xFFFE))) {
            (c = 0xFFFD);
          }  
        }  
        {
          if ((c <= 0xFFFF)) {
            ((*z++) = ((u8 ) ((c >> 8) & 0x00FF)));
            ((*z++) = ((u8 ) (c & 0x00FF)));
          }  
          else {
            ((*z++) = ((u8 ) (0x00D8 + (((c - 0x10000) >> 18) & 0x03))));
            ((*z++) = ((u8 ) (((c >> 10) & 0x003F) + (((c - 0x10000) >> 10) & 0x00C0))));
            ((*z++) = ((u8 ) (0x00DC + ((c >> 8) & 0x03))));
            ((*z++) = ((u8 ) (c & 0x00FF)));
          }
        }
      }
    }
    (pMem->n = ((int ) (z - zOut)));
    ((*z++) = 0);
  }  
  else {
    ((void ) 0);
    if ((pMem->enc == 2)) {
      while ((zIn < zTerm)) {
        {
          (c = (*zIn++));
          (c += ((*zIn++) << 8));
          if (((c >= 0xD800) && (c < 0xE000) && (zIn < zTerm))) {
            int c2 =  (*zIn++);
            (c2 += ((*zIn++) << 8));
            (c = ((c2 & 0x03FF) + ((c & 0x003F) << 10) + (((c & 0x03C0) + 0x0040) << 10)));
          }  
        }
        {
          if ((c < 0x00080)) {
            ((*z++) = ((u8 ) (c & 0xFF)));
          } 
          else if ((c < 0x00800)) {
            ((*z++) = (0xC0 + ((u8 ) ((c >> 6) & 0x1F))));
            ((*z++) = (0x80 + ((u8 ) (c & 0x3F))));
          }
          
          else if ((c < 0x10000)) {
            ((*z++) = (0xE0 + ((u8 ) ((c >> 12) & 0x0F))));
            ((*z++) = (0x80 + ((u8 ) ((c >> 6) & 0x3F))));
            ((*z++) = (0x80 + ((u8 ) (c & 0x3F))));
          } 
          else {
            ((*z++) = (0xF0 + ((u8 ) ((c >> 18) & 0x07))));
            ((*z++) = (0x80 + ((u8 ) ((c >> 12) & 0x3F))));
            ((*z++) = (0x80 + ((u8 ) ((c >> 6) & 0x3F))));
            ((*z++) = (0x80 + ((u8 ) (c & 0x3F))));
          }
        }
      }
    }  
    else {
      while ((zIn < zTerm)) {
        {
          (c = ((*zIn++) << 8));
          (c += (*zIn++));
          if (((c >= 0xD800) && (c < 0xE000) && (zIn < zTerm))) {
            int c2 =  ((*zIn++) << 8);
            (c2 += (*zIn++));
            (c = ((c2 & 0x03FF) + ((c & 0x003F) << 10) + (((c & 0x03C0) + 0x0040) << 10)));
          }  
        }
        {
          if ((c < 0x00080)) {
            ((*z++) = ((u8 ) (c & 0xFF)));
          } 
          else if ((c < 0x00800)) {
            ((*z++) = (0xC0 + ((u8 ) ((c >> 6) & 0x1F))));
            ((*z++) = (0x80 + ((u8 ) (c & 0x3F))));
          }
          
          else if ((c < 0x10000)) {
            ((*z++) = (0xE0 + ((u8 ) ((c >> 12) & 0x0F))));
            ((*z++) = (0x80 + ((u8 ) ((c >> 6) & 0x3F))));
            ((*z++) = (0x80 + ((u8 ) (c & 0x3F))));
          } 
          else {
            ((*z++) = (0xF0 + ((u8 ) ((c >> 18) & 0x07))));
            ((*z++) = (0x80 + ((u8 ) ((c >> 12) & 0x3F))));
            ((*z++) = (0x80 + ((u8 ) ((c >> 6) & 0x3F))));
            ((*z++) = (0x80 + ((u8 ) (c & 0x3F))));
          }
        }
      }
    }
    (pMem->n = ((int ) (z - zOut)));
  }
  ((*z) = 0);
  ((void ) 0);
  sqlite3VdbeMemRelease(pMem);
  (pMem->flags &= (~ (0x0800 | 0x0400 | 0x1000)));
  (pMem->enc = desiredEnc);
  (pMem->flags |= (0x0200 | 0x0400));
  (pMem->z = ((char *) zOut));
  (pMem->zMalloc = pMem->z);
  translate_out:
  return 0;
}
static  int sqlite3VdbeMemHandleBom(Mem *pMem )  {
  int rc =  0;
  u8 bom =  0;
  ((void ) 0);
  if ((pMem->n > 1)) {
    u8 b1 =  (*((u8 *) pMem->z));
    u8 b2 =  (*(((u8 *) pMem->z) + 1));
    if (((b1 == 0xFE) && (b2 == 0xFF))) {
      (bom = 3);
    }  
    if (((b1 == 0xFF) && (b2 == 0xFE))) {
      (bom = 2);
    }  
  }  
  if (bom) {
    (rc = sqlite3VdbeMemMakeWriteable(pMem));
    if ((rc == 0)) {
      (pMem->n -= 2);
      memmove(pMem->z, (&pMem->z[2]), pMem->n);
      (pMem->z[pMem->n] = '\0');
      (pMem->z[(pMem->n + 1)] = '\0');
      (pMem->flags |= 0x0200);
      (pMem->enc = bom);
    }  
  }  
  return rc;
}
static  int sqlite3Utf8CharLen(const  char *zIn , int nByte )  {
  int r =  0;
  const u8 *z =  ((const  u8 *) zIn);
  const u8 *zTerm;
  if ((nByte >= 0)) {
    (zTerm = (&z[nByte]));
  }  
  else {
    (zTerm = ((const  u8 *) (- 1)));
  }
  ((void ) 0);
  while ((((*z) != 0) && (z < zTerm))) {
    {
      if (((*z++) >= 0xc0)) {
        while ((((*z) & 0xc0) == 0x80)) {
          z++;
        }
      }  
    }
    r++;
  }
  return r;
}
static  char *sqlite3Utf16to8(sqlite3 *db , const  void *z , int nByte , u8 enc )  {
  Mem m;
  memset((&m), 0, sizeof(m));
  (m.db = db);
  sqlite3VdbeMemSetStr((&m), z, nByte, enc, ((sqlite3_destructor_type ) 0));
  sqlite3VdbeChangeEncoding((&m), 1);
  if (db->mallocFailed) {
    sqlite3VdbeMemRelease((&m));
    (m.z = 0);
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  return m.z;
}
static  int sqlite3Utf16ByteLen(const  void *zIn , int nChar )  {
  int c;
  unsigned char const *z =  zIn;
  int n =  0;
  if ((2 == 3)) {
    while ((n < nChar)) {
      {
        (c = ((*z++) << 8));
        (c += (*z++));
        if (((c >= 0xD800) && (c < 0xE000) && 1)) {
          int c2 =  ((*z++) << 8);
          (c2 += (*z++));
          (c = ((c2 & 0x03FF) + ((c & 0x003F) << 10) + (((c & 0x03C0) + 0x0040) << 10)));
        }  
      }
      n++;
    }
  }  
  else {
    while ((n < nChar)) {
      {
        (c = (*z++));
        (c += ((*z++) << 8));
        if (((c >= 0xD800) && (c < 0xE000) && 1)) {
          int c2 =  (*z++);
          (c2 += ((*z++) << 8));
          (c = ((c2 & 0x03FF) + ((c & 0x003F) << 10) + (((c & 0x03C0) + 0x0040) << 10)));
        }  
      }
      n++;
    }
  }
  return ((int ) (z - ((unsigned  char  const *) zIn)));
}
typedef float float_t;
typedef double double_t;
extern double acos(double __x ) __attribute__((__nothrow__));
extern double __acos(double __x ) __attribute__((__nothrow__));
extern double asin(double __x ) __attribute__((__nothrow__));
extern double __asin(double __x ) __attribute__((__nothrow__));
extern double atan(double __x ) __attribute__((__nothrow__));
extern double __atan(double __x ) __attribute__((__nothrow__));
extern double atan2(double __y , double __x ) __attribute__((__nothrow__));
extern double __atan2(double __y , double __x ) __attribute__((__nothrow__));
extern double cos(double __x ) __attribute__((__nothrow__));
extern double __cos(double __x ) __attribute__((__nothrow__));
extern double sin(double __x ) __attribute__((__nothrow__));
extern double __sin(double __x ) __attribute__((__nothrow__));
extern double tan(double __x ) __attribute__((__nothrow__));
extern double __tan(double __x ) __attribute__((__nothrow__));
extern double cosh(double __x ) __attribute__((__nothrow__));
extern double __cosh(double __x ) __attribute__((__nothrow__));
extern double sinh(double __x ) __attribute__((__nothrow__));
extern double __sinh(double __x ) __attribute__((__nothrow__));
extern double tanh(double __x ) __attribute__((__nothrow__));
extern double __tanh(double __x ) __attribute__((__nothrow__));
extern void sincos(double __x , double *__sinx , double *__cosx ) __attribute__((__nothrow__));
extern void __sincos(double __x , double *__sinx , double *__cosx ) __attribute__((__nothrow__));
extern double acosh(double __x ) __attribute__((__nothrow__));
extern double __acosh(double __x ) __attribute__((__nothrow__));
extern double asinh(double __x ) __attribute__((__nothrow__));
extern double __asinh(double __x ) __attribute__((__nothrow__));
extern double atanh(double __x ) __attribute__((__nothrow__));
extern double __atanh(double __x ) __attribute__((__nothrow__));
extern double exp(double __x ) __attribute__((__nothrow__));
extern double __exp(double __x ) __attribute__((__nothrow__));
extern double frexp(double __x , int *__exponent ) __attribute__((__nothrow__));
extern double __frexp(double __x , int *__exponent ) __attribute__((__nothrow__));
extern double ldexp(double __x , int __exponent ) __attribute__((__nothrow__));
extern double __ldexp(double __x , int __exponent ) __attribute__((__nothrow__));
extern double log(double __x ) __attribute__((__nothrow__));
extern double __log(double __x ) __attribute__((__nothrow__));
extern double log10(double __x ) __attribute__((__nothrow__));
extern double __log10(double __x ) __attribute__((__nothrow__));
extern double modf(double __x , double *__iptr ) __attribute__((__nothrow__));
extern double __modf(double __x , double *__iptr ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern double exp10(double __x ) __attribute__((__nothrow__));
extern double __exp10(double __x ) __attribute__((__nothrow__));
extern double pow10(double __x ) __attribute__((__nothrow__));
extern double __pow10(double __x ) __attribute__((__nothrow__));
extern double expm1(double __x ) __attribute__((__nothrow__));
extern double __expm1(double __x ) __attribute__((__nothrow__));
extern double log1p(double __x ) __attribute__((__nothrow__));
extern double __log1p(double __x ) __attribute__((__nothrow__));
extern double logb(double __x ) __attribute__((__nothrow__));
extern double __logb(double __x ) __attribute__((__nothrow__));
extern double exp2(double __x ) __attribute__((__nothrow__));
extern double __exp2(double __x ) __attribute__((__nothrow__));
extern double log2(double __x ) __attribute__((__nothrow__));
extern double __log2(double __x ) __attribute__((__nothrow__));
extern double pow(double __x , double __y ) __attribute__((__nothrow__));
extern double __pow(double __x , double __y ) __attribute__((__nothrow__));
extern double sqrt(double __x ) __attribute__((__nothrow__));
extern double __sqrt(double __x ) __attribute__((__nothrow__));
extern double hypot(double __x , double __y ) __attribute__((__nothrow__));
extern double __hypot(double __x , double __y ) __attribute__((__nothrow__));
extern double cbrt(double __x ) __attribute__((__nothrow__));
extern double __cbrt(double __x ) __attribute__((__nothrow__));
extern double ceil(double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double __ceil(double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double fabs(double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double __fabs(double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double floor(double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double __floor(double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double fmod(double __x , double __y ) __attribute__((__nothrow__));
extern double __fmod(double __x , double __y ) __attribute__((__nothrow__));
extern int __isinf(double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int __finite(double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int isinf(double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int finite(double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double drem(double __x , double __y ) __attribute__((__nothrow__));
extern double __drem(double __x , double __y ) __attribute__((__nothrow__));
extern double significand(double __x ) __attribute__((__nothrow__));
extern double __significand(double __x ) __attribute__((__nothrow__));
extern double copysign(double __x , double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double __copysign(double __x , double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double nan(const  char *__tagb ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double __nan(const  char *__tagb ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int __isnan(double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int isnan(double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double j0(double ) __attribute__((__nothrow__));
extern double __j0(double ) __attribute__((__nothrow__));
extern double j1(double ) __attribute__((__nothrow__));
extern double __j1(double ) __attribute__((__nothrow__));
extern double jn(int , double ) __attribute__((__nothrow__));
extern double __jn(int , double ) __attribute__((__nothrow__));
extern double y0(double ) __attribute__((__nothrow__));
extern double __y0(double ) __attribute__((__nothrow__));
extern double y1(double ) __attribute__((__nothrow__));
extern double __y1(double ) __attribute__((__nothrow__));
extern double yn(int , double ) __attribute__((__nothrow__));
extern double __yn(int , double ) __attribute__((__nothrow__));
extern double erf(double ) __attribute__((__nothrow__));
extern double __erf(double ) __attribute__((__nothrow__));
extern double erfc(double ) __attribute__((__nothrow__));
extern double __erfc(double ) __attribute__((__nothrow__));
extern double lgamma(double ) __attribute__((__nothrow__));
extern double __lgamma(double ) __attribute__((__nothrow__));
extern double tgamma(double ) __attribute__((__nothrow__));
extern double __tgamma(double ) __attribute__((__nothrow__));
extern double gamma(double ) __attribute__((__nothrow__));
extern double __gamma(double ) __attribute__((__nothrow__));
extern double lgamma_r(double , int *__signgamp ) __attribute__((__nothrow__));
extern double __lgamma_r(double , int *__signgamp ) __attribute__((__nothrow__));
extern double rint(double __x ) __attribute__((__nothrow__));
extern double __rint(double __x ) __attribute__((__nothrow__));
extern double nextafter(double __x , double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double __nextafter(double __x , double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double nexttoward(double __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double __nexttoward(double __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double remainder(double __x , double __y ) __attribute__((__nothrow__));
extern double __remainder(double __x , double __y ) __attribute__((__nothrow__));
extern double scalbn(double __x , int __n ) __attribute__((__nothrow__));
extern double __scalbn(double __x , int __n ) __attribute__((__nothrow__));
extern int ilogb(double __x ) __attribute__((__nothrow__));
extern int __ilogb(double __x ) __attribute__((__nothrow__));
extern double scalbln(double __x , long  int __n ) __attribute__((__nothrow__));
extern double __scalbln(double __x , long  int __n ) __attribute__((__nothrow__));
extern double nearbyint(double __x ) __attribute__((__nothrow__));
extern double __nearbyint(double __x ) __attribute__((__nothrow__));
extern double round(double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double __round(double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double trunc(double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double __trunc(double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double remquo(double __x , double __y , int *__quo ) __attribute__((__nothrow__));
extern double __remquo(double __x , double __y , int *__quo ) __attribute__((__nothrow__));
extern long int lrint(double __x ) __attribute__((__nothrow__));
extern long int __lrint(double __x ) __attribute__((__nothrow__));
extern long long int llrint(double __x ) __attribute__((__nothrow__));
extern long long int __llrint(double __x ) __attribute__((__nothrow__));
extern long int lround(double __x ) __attribute__((__nothrow__));
extern long int __lround(double __x ) __attribute__((__nothrow__));
extern long long int llround(double __x ) __attribute__((__nothrow__));
extern long long int __llround(double __x ) __attribute__((__nothrow__));
extern double fdim(double __x , double __y ) __attribute__((__nothrow__));
extern double __fdim(double __x , double __y ) __attribute__((__nothrow__));
extern double fmax(double __x , double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double __fmax(double __x , double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double fmin(double __x , double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double __fmin(double __x , double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int __fpclassify(double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int __signbit(double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double fma(double __x , double __y , double __z ) __attribute__((__nothrow__));
extern double __fma(double __x , double __y , double __z ) __attribute__((__nothrow__));
extern int __issignaling(double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern double scalb(double __x , double __n ) __attribute__((__nothrow__));
extern double __scalb(double __x , double __n ) __attribute__((__nothrow__));
extern float acosf(float __x ) __attribute__((__nothrow__));
extern float __acosf(float __x ) __attribute__((__nothrow__));
extern float asinf(float __x ) __attribute__((__nothrow__));
extern float __asinf(float __x ) __attribute__((__nothrow__));
extern float atanf(float __x ) __attribute__((__nothrow__));
extern float __atanf(float __x ) __attribute__((__nothrow__));
extern float atan2f(float __y , float __x ) __attribute__((__nothrow__));
extern float __atan2f(float __y , float __x ) __attribute__((__nothrow__));
extern float cosf(float __x ) __attribute__((__nothrow__));
extern float __cosf(float __x ) __attribute__((__nothrow__));
extern float sinf(float __x ) __attribute__((__nothrow__));
extern float __sinf(float __x ) __attribute__((__nothrow__));
extern float tanf(float __x ) __attribute__((__nothrow__));
extern float __tanf(float __x ) __attribute__((__nothrow__));
extern float coshf(float __x ) __attribute__((__nothrow__));
extern float __coshf(float __x ) __attribute__((__nothrow__));
extern float sinhf(float __x ) __attribute__((__nothrow__));
extern float __sinhf(float __x ) __attribute__((__nothrow__));
extern float tanhf(float __x ) __attribute__((__nothrow__));
extern float __tanhf(float __x ) __attribute__((__nothrow__));
extern void sincosf(float __x , float *__sinx , float *__cosx ) __attribute__((__nothrow__));
extern void __sincosf(float __x , float *__sinx , float *__cosx ) __attribute__((__nothrow__));
extern float acoshf(float __x ) __attribute__((__nothrow__));
extern float __acoshf(float __x ) __attribute__((__nothrow__));
extern float asinhf(float __x ) __attribute__((__nothrow__));
extern float __asinhf(float __x ) __attribute__((__nothrow__));
extern float atanhf(float __x ) __attribute__((__nothrow__));
extern float __atanhf(float __x ) __attribute__((__nothrow__));
extern float expf(float __x ) __attribute__((__nothrow__));
extern float __expf(float __x ) __attribute__((__nothrow__));
extern float frexpf(float __x , int *__exponent ) __attribute__((__nothrow__));
extern float __frexpf(float __x , int *__exponent ) __attribute__((__nothrow__));
extern float ldexpf(float __x , int __exponent ) __attribute__((__nothrow__));
extern float __ldexpf(float __x , int __exponent ) __attribute__((__nothrow__));
extern float logf(float __x ) __attribute__((__nothrow__));
extern float __logf(float __x ) __attribute__((__nothrow__));
extern float log10f(float __x ) __attribute__((__nothrow__));
extern float __log10f(float __x ) __attribute__((__nothrow__));
extern float modff(float __x , float *__iptr ) __attribute__((__nothrow__));
extern float __modff(float __x , float *__iptr ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern float exp10f(float __x ) __attribute__((__nothrow__));
extern float __exp10f(float __x ) __attribute__((__nothrow__));
extern float pow10f(float __x ) __attribute__((__nothrow__));
extern float __pow10f(float __x ) __attribute__((__nothrow__));
extern float expm1f(float __x ) __attribute__((__nothrow__));
extern float __expm1f(float __x ) __attribute__((__nothrow__));
extern float log1pf(float __x ) __attribute__((__nothrow__));
extern float __log1pf(float __x ) __attribute__((__nothrow__));
extern float logbf(float __x ) __attribute__((__nothrow__));
extern float __logbf(float __x ) __attribute__((__nothrow__));
extern float exp2f(float __x ) __attribute__((__nothrow__));
extern float __exp2f(float __x ) __attribute__((__nothrow__));
extern float log2f(float __x ) __attribute__((__nothrow__));
extern float __log2f(float __x ) __attribute__((__nothrow__));
extern float powf(float __x , float __y ) __attribute__((__nothrow__));
extern float __powf(float __x , float __y ) __attribute__((__nothrow__));
extern float sqrtf(float __x ) __attribute__((__nothrow__));
extern float __sqrtf(float __x ) __attribute__((__nothrow__));
extern float hypotf(float __x , float __y ) __attribute__((__nothrow__));
extern float __hypotf(float __x , float __y ) __attribute__((__nothrow__));
extern float cbrtf(float __x ) __attribute__((__nothrow__));
extern float __cbrtf(float __x ) __attribute__((__nothrow__));
extern float ceilf(float __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float __ceilf(float __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float fabsf(float __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float __fabsf(float __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float floorf(float __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float __floorf(float __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float fmodf(float __x , float __y ) __attribute__((__nothrow__));
extern float __fmodf(float __x , float __y ) __attribute__((__nothrow__));
extern int __isinff(float __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int __finitef(float __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int isinff(float __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int finitef(float __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float dremf(float __x , float __y ) __attribute__((__nothrow__));
extern float __dremf(float __x , float __y ) __attribute__((__nothrow__));
extern float significandf(float __x ) __attribute__((__nothrow__));
extern float __significandf(float __x ) __attribute__((__nothrow__));
extern float copysignf(float __x , float __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float __copysignf(float __x , float __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float nanf(const  char *__tagb ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float __nanf(const  char *__tagb ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int __isnanf(float __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int isnanf(float __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float j0f(float ) __attribute__((__nothrow__));
extern float __j0f(float ) __attribute__((__nothrow__));
extern float j1f(float ) __attribute__((__nothrow__));
extern float __j1f(float ) __attribute__((__nothrow__));
extern float jnf(int , float ) __attribute__((__nothrow__));
extern float __jnf(int , float ) __attribute__((__nothrow__));
extern float y0f(float ) __attribute__((__nothrow__));
extern float __y0f(float ) __attribute__((__nothrow__));
extern float y1f(float ) __attribute__((__nothrow__));
extern float __y1f(float ) __attribute__((__nothrow__));
extern float ynf(int , float ) __attribute__((__nothrow__));
extern float __ynf(int , float ) __attribute__((__nothrow__));
extern float erff(float ) __attribute__((__nothrow__));
extern float __erff(float ) __attribute__((__nothrow__));
extern float erfcf(float ) __attribute__((__nothrow__));
extern float __erfcf(float ) __attribute__((__nothrow__));
extern float lgammaf(float ) __attribute__((__nothrow__));
extern float __lgammaf(float ) __attribute__((__nothrow__));
extern float tgammaf(float ) __attribute__((__nothrow__));
extern float __tgammaf(float ) __attribute__((__nothrow__));
extern float gammaf(float ) __attribute__((__nothrow__));
extern float __gammaf(float ) __attribute__((__nothrow__));
extern float lgammaf_r(float , int *__signgamp ) __attribute__((__nothrow__));
extern float __lgammaf_r(float , int *__signgamp ) __attribute__((__nothrow__));
extern float rintf(float __x ) __attribute__((__nothrow__));
extern float __rintf(float __x ) __attribute__((__nothrow__));
extern float nextafterf(float __x , float __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float __nextafterf(float __x , float __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float nexttowardf(float __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float __nexttowardf(float __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float remainderf(float __x , float __y ) __attribute__((__nothrow__));
extern float __remainderf(float __x , float __y ) __attribute__((__nothrow__));
extern float scalbnf(float __x , int __n ) __attribute__((__nothrow__));
extern float __scalbnf(float __x , int __n ) __attribute__((__nothrow__));
extern int ilogbf(float __x ) __attribute__((__nothrow__));
extern int __ilogbf(float __x ) __attribute__((__nothrow__));
extern float scalblnf(float __x , long  int __n ) __attribute__((__nothrow__));
extern float __scalblnf(float __x , long  int __n ) __attribute__((__nothrow__));
extern float nearbyintf(float __x ) __attribute__((__nothrow__));
extern float __nearbyintf(float __x ) __attribute__((__nothrow__));
extern float roundf(float __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float __roundf(float __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float truncf(float __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float __truncf(float __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float remquof(float __x , float __y , int *__quo ) __attribute__((__nothrow__));
extern float __remquof(float __x , float __y , int *__quo ) __attribute__((__nothrow__));
extern long int lrintf(float __x ) __attribute__((__nothrow__));
extern long int __lrintf(float __x ) __attribute__((__nothrow__));
extern long long int llrintf(float __x ) __attribute__((__nothrow__));
extern long long int __llrintf(float __x ) __attribute__((__nothrow__));
extern long int lroundf(float __x ) __attribute__((__nothrow__));
extern long int __lroundf(float __x ) __attribute__((__nothrow__));
extern long long int llroundf(float __x ) __attribute__((__nothrow__));
extern long long int __llroundf(float __x ) __attribute__((__nothrow__));
extern float fdimf(float __x , float __y ) __attribute__((__nothrow__));
extern float __fdimf(float __x , float __y ) __attribute__((__nothrow__));
extern float fmaxf(float __x , float __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float __fmaxf(float __x , float __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float fminf(float __x , float __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float __fminf(float __x , float __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int __fpclassifyf(float __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int __signbitf(float __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float fmaf(float __x , float __y , float __z ) __attribute__((__nothrow__));
extern float __fmaf(float __x , float __y , float __z ) __attribute__((__nothrow__));
extern int __issignalingf(float __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern float scalbf(float __x , float __n ) __attribute__((__nothrow__));
extern float __scalbf(float __x , float __n ) __attribute__((__nothrow__));
extern long double acosl(long  double __x ) __attribute__((__nothrow__));
extern long double __acosl(long  double __x ) __attribute__((__nothrow__));
extern long double asinl(long  double __x ) __attribute__((__nothrow__));
extern long double __asinl(long  double __x ) __attribute__((__nothrow__));
extern long double atanl(long  double __x ) __attribute__((__nothrow__));
extern long double __atanl(long  double __x ) __attribute__((__nothrow__));
extern long double atan2l(long  double __y , long  double __x ) __attribute__((__nothrow__));
extern long double __atan2l(long  double __y , long  double __x ) __attribute__((__nothrow__));
extern long double cosl(long  double __x ) __attribute__((__nothrow__));
extern long double __cosl(long  double __x ) __attribute__((__nothrow__));
extern long double sinl(long  double __x ) __attribute__((__nothrow__));
extern long double __sinl(long  double __x ) __attribute__((__nothrow__));
extern long double tanl(long  double __x ) __attribute__((__nothrow__));
extern long double __tanl(long  double __x ) __attribute__((__nothrow__));
extern long double coshl(long  double __x ) __attribute__((__nothrow__));
extern long double __coshl(long  double __x ) __attribute__((__nothrow__));
extern long double sinhl(long  double __x ) __attribute__((__nothrow__));
extern long double __sinhl(long  double __x ) __attribute__((__nothrow__));
extern long double tanhl(long  double __x ) __attribute__((__nothrow__));
extern long double __tanhl(long  double __x ) __attribute__((__nothrow__));
extern void sincosl(long  double __x , long  double *__sinx , long  double *__cosx ) __attribute__((__nothrow__));
extern void __sincosl(long  double __x , long  double *__sinx , long  double *__cosx ) __attribute__((__nothrow__));
extern long double acoshl(long  double __x ) __attribute__((__nothrow__));
extern long double __acoshl(long  double __x ) __attribute__((__nothrow__));
extern long double asinhl(long  double __x ) __attribute__((__nothrow__));
extern long double __asinhl(long  double __x ) __attribute__((__nothrow__));
extern long double atanhl(long  double __x ) __attribute__((__nothrow__));
extern long double __atanhl(long  double __x ) __attribute__((__nothrow__));
extern long double expl(long  double __x ) __attribute__((__nothrow__));
extern long double __expl(long  double __x ) __attribute__((__nothrow__));
extern long double frexpl(long  double __x , int *__exponent ) __attribute__((__nothrow__));
extern long double __frexpl(long  double __x , int *__exponent ) __attribute__((__nothrow__));
extern long double ldexpl(long  double __x , int __exponent ) __attribute__((__nothrow__));
extern long double __ldexpl(long  double __x , int __exponent ) __attribute__((__nothrow__));
extern long double logl(long  double __x ) __attribute__((__nothrow__));
extern long double __logl(long  double __x ) __attribute__((__nothrow__));
extern long double log10l(long  double __x ) __attribute__((__nothrow__));
extern long double __log10l(long  double __x ) __attribute__((__nothrow__));
extern long double modfl(long  double __x , long  double *__iptr ) __attribute__((__nothrow__));
extern long double __modfl(long  double __x , long  double *__iptr ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern long double exp10l(long  double __x ) __attribute__((__nothrow__));
extern long double __exp10l(long  double __x ) __attribute__((__nothrow__));
extern long double pow10l(long  double __x ) __attribute__((__nothrow__));
extern long double __pow10l(long  double __x ) __attribute__((__nothrow__));
extern long double expm1l(long  double __x ) __attribute__((__nothrow__));
extern long double __expm1l(long  double __x ) __attribute__((__nothrow__));
extern long double log1pl(long  double __x ) __attribute__((__nothrow__));
extern long double __log1pl(long  double __x ) __attribute__((__nothrow__));
extern long double logbl(long  double __x ) __attribute__((__nothrow__));
extern long double __logbl(long  double __x ) __attribute__((__nothrow__));
extern long double exp2l(long  double __x ) __attribute__((__nothrow__));
extern long double __exp2l(long  double __x ) __attribute__((__nothrow__));
extern long double log2l(long  double __x ) __attribute__((__nothrow__));
extern long double __log2l(long  double __x ) __attribute__((__nothrow__));
extern long double powl(long  double __x , long  double __y ) __attribute__((__nothrow__));
extern long double __powl(long  double __x , long  double __y ) __attribute__((__nothrow__));
extern long double sqrtl(long  double __x ) __attribute__((__nothrow__));
extern long double __sqrtl(long  double __x ) __attribute__((__nothrow__));
extern long double hypotl(long  double __x , long  double __y ) __attribute__((__nothrow__));
extern long double __hypotl(long  double __x , long  double __y ) __attribute__((__nothrow__));
extern long double cbrtl(long  double __x ) __attribute__((__nothrow__));
extern long double __cbrtl(long  double __x ) __attribute__((__nothrow__));
extern long double ceill(long  double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double __ceill(long  double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double fabsl(long  double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double __fabsl(long  double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double floorl(long  double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double __floorl(long  double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double fmodl(long  double __x , long  double __y ) __attribute__((__nothrow__));
extern long double __fmodl(long  double __x , long  double __y ) __attribute__((__nothrow__));
extern int __isinfl(long  double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int __finitel(long  double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int isinfl(long  double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int finitel(long  double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double dreml(long  double __x , long  double __y ) __attribute__((__nothrow__));
extern long double __dreml(long  double __x , long  double __y ) __attribute__((__nothrow__));
extern long double significandl(long  double __x ) __attribute__((__nothrow__));
extern long double __significandl(long  double __x ) __attribute__((__nothrow__));
extern long double copysignl(long  double __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double __copysignl(long  double __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double nanl(const  char *__tagb ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double __nanl(const  char *__tagb ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int __isnanl(long  double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int isnanl(long  double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double j0l(long  double ) __attribute__((__nothrow__));
extern long double __j0l(long  double ) __attribute__((__nothrow__));
extern long double j1l(long  double ) __attribute__((__nothrow__));
extern long double __j1l(long  double ) __attribute__((__nothrow__));
extern long double jnl(int , long  double ) __attribute__((__nothrow__));
extern long double __jnl(int , long  double ) __attribute__((__nothrow__));
extern long double y0l(long  double ) __attribute__((__nothrow__));
extern long double __y0l(long  double ) __attribute__((__nothrow__));
extern long double y1l(long  double ) __attribute__((__nothrow__));
extern long double __y1l(long  double ) __attribute__((__nothrow__));
extern long double ynl(int , long  double ) __attribute__((__nothrow__));
extern long double __ynl(int , long  double ) __attribute__((__nothrow__));
extern long double erfl(long  double ) __attribute__((__nothrow__));
extern long double __erfl(long  double ) __attribute__((__nothrow__));
extern long double erfcl(long  double ) __attribute__((__nothrow__));
extern long double __erfcl(long  double ) __attribute__((__nothrow__));
extern long double lgammal(long  double ) __attribute__((__nothrow__));
extern long double __lgammal(long  double ) __attribute__((__nothrow__));
extern long double tgammal(long  double ) __attribute__((__nothrow__));
extern long double __tgammal(long  double ) __attribute__((__nothrow__));
extern long double gammal(long  double ) __attribute__((__nothrow__));
extern long double __gammal(long  double ) __attribute__((__nothrow__));
extern long double lgammal_r(long  double , int *__signgamp ) __attribute__((__nothrow__));
extern long double __lgammal_r(long  double , int *__signgamp ) __attribute__((__nothrow__));
extern long double rintl(long  double __x ) __attribute__((__nothrow__));
extern long double __rintl(long  double __x ) __attribute__((__nothrow__));
extern long double nextafterl(long  double __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double __nextafterl(long  double __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double nexttowardl(long  double __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double __nexttowardl(long  double __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double remainderl(long  double __x , long  double __y ) __attribute__((__nothrow__));
extern long double __remainderl(long  double __x , long  double __y ) __attribute__((__nothrow__));
extern long double scalbnl(long  double __x , int __n ) __attribute__((__nothrow__));
extern long double __scalbnl(long  double __x , int __n ) __attribute__((__nothrow__));
extern int ilogbl(long  double __x ) __attribute__((__nothrow__));
extern int __ilogbl(long  double __x ) __attribute__((__nothrow__));
extern long double scalblnl(long  double __x , long  int __n ) __attribute__((__nothrow__));
extern long double __scalblnl(long  double __x , long  int __n ) __attribute__((__nothrow__));
extern long double nearbyintl(long  double __x ) __attribute__((__nothrow__));
extern long double __nearbyintl(long  double __x ) __attribute__((__nothrow__));
extern long double roundl(long  double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double __roundl(long  double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double truncl(long  double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double __truncl(long  double __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double remquol(long  double __x , long  double __y , int *__quo ) __attribute__((__nothrow__));
extern long double __remquol(long  double __x , long  double __y , int *__quo ) __attribute__((__nothrow__));
extern long int lrintl(long  double __x ) __attribute__((__nothrow__));
extern long int __lrintl(long  double __x ) __attribute__((__nothrow__));
extern long long int llrintl(long  double __x ) __attribute__((__nothrow__));
extern long long int __llrintl(long  double __x ) __attribute__((__nothrow__));
extern long int lroundl(long  double __x ) __attribute__((__nothrow__));
extern long int __lroundl(long  double __x ) __attribute__((__nothrow__));
extern long long int llroundl(long  double __x ) __attribute__((__nothrow__));
extern long long int __llroundl(long  double __x ) __attribute__((__nothrow__));
extern long double fdiml(long  double __x , long  double __y ) __attribute__((__nothrow__));
extern long double __fdiml(long  double __x , long  double __y ) __attribute__((__nothrow__));
extern long double fmaxl(long  double __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double __fmaxl(long  double __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double fminl(long  double __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double __fminl(long  double __x , long  double __y ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int __fpclassifyl(long  double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int __signbitl(long  double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double fmal(long  double __x , long  double __y , long  double __z ) __attribute__((__nothrow__));
extern long double __fmal(long  double __x , long  double __y , long  double __z ) __attribute__((__nothrow__));
extern int __issignalingl(long  double __value ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long double scalbl(long  double __x , long  double __n ) __attribute__((__nothrow__));
extern long double __scalbl(long  double __x , long  double __n ) __attribute__((__nothrow__));
extern int signgam;
enum  {
  _1301_FP_NAN = 0,
  _1301_FP_INFINITE = 1,
  _1301_FP_ZERO = 2,
  _1301_FP_SUBNORMAL = 3,
  _1301_FP_NORMAL = 4
} ;
typedef enum  {
  _1301__IEEE_ = (- 1),
  _1301__SVID_,
  _1301__XOPEN_,
  _1301__POSIX_,
  _1301__ISOC_
} _LIB_VERSION_TYPE;
extern _LIB_VERSION_TYPE _LIB_VERSION;
struct  _1301_exception {
  int type ;
  char *name ;
  double arg1 ;
  double arg2 ;
  double retval ;
}  ;
extern int matherr(struct  _1301_exception   *__exc );
static  void sqlite3Coverage(int x )  {
  static unsigned dummy =  0;
  (dummy += ((unsigned ) x));
}
static  int sqlite3IsNaN(double x )  {
  int rc;
  volatile double _1302_y =  x;
  volatile double _1302_z =  _1302_y;
  if ((((! id2i_sqlite_have_isnan) ) )) {
    (rc = (_1302_y != _1302_z));
  }  
  if (((id2i_sqlite_have_isnan ) )) {
    (rc = ((sizeof(x) == sizeof(float )) ? __isnanf(x) : ((sizeof(x) == sizeof(double )) ? __isnan(x) : __isnanl(x))));
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (rc) {
      sqlite3Coverage(21133);
    }  
  }  
  return rc;
}
static  int sqlite3Strlen30(const  char *z )  {
  const char *z2 =  z;
  if ((z == 0)) {
    return 0;
  }  
  while ((*z2)) {
    z2++;
  }
  return (0x3fffffff & ((int ) (z2 - z)));
}
static  void sqlite3Error(sqlite3 *db , int err_code , const  char *zFormat , ...)  {
  if ((db && (db->pErr || ((db->pErr = sqlite3ValueNew(db)) != 0)))) {
    (db->errCode = err_code);
    if (zFormat) {
      char *z;
      va_list ap;
      __builtin_va_start(ap, zFormat);
      (z = sqlite3VMPrintf(db, zFormat, ap));
      __builtin_va_end(ap);
      sqlite3ValueSetStr(db->pErr, (- 1), z, 1, ((sqlite3_destructor_type ) sqlite3MallocSize));
    }  
    else {
      sqlite3ValueSetStr(db->pErr, 0, 0, 1, ((sqlite3_destructor_type ) 0));
    }
  }  
}
static  void sqlite3ErrorMsg(Parse *pParse , const  char *zFormat , ...)  {
  char *zMsg;
  va_list ap;
  sqlite3 *db =  pParse->db;
  __builtin_va_start(ap, zFormat);
  (zMsg = sqlite3VMPrintf(db, zFormat, ap));
  __builtin_va_end(ap);
  if (db->suppressErr) {
    sqlite3DbFree(db, zMsg);
  }  
  else {
    pParse->nErr++;
    sqlite3DbFree(db, pParse->zErrMsg);
    (pParse->zErrMsg = zMsg);
    (pParse->rc = 1);
  }
}
static  int sqlite3Dequote(char *z )  {
  char quote;
  int i, j;
  if ((z == 0)) {
    return (- 1);
  }  
  (quote = z[0]);
  switch (quote) {
    case '\'':
    break;
    case '"':
    break;
    case '`':
    break;
    case '[':
    (quote = ']');
    break;
    id2i_label_1:
    default:
    return (- 1);
  }
  for ((i = 1), (j = 0); ; i++) {
    ((void ) 0);
    if ((z[i] == quote)) {
      if ((z[(i + 1)] == quote)) {
        (z[j++] = quote);
        i++;
      }  
      else {
        break;
      }
    }  
    else {
      (z[j++] = z[i]);
    }
  }
  (z[j] = 0);
  return j;
}
int sqlite3_stricmp(const  char *zLeft , const  char *zRight )  {
  register unsigned char *a, *b;
  (a = ((unsigned  char *) zLeft));
  (b = ((unsigned  char *) zRight));
  while ((((id2i_sqlite_ebcdic ) ) ? (((*a) != 0) && (_1282_sqlite3UpperToLower[(*a)] == _1282_sqlite3UpperToLower[(*b)])) : (((*a) != 0) && (_1281_sqlite3UpperToLower[(*a)] == _1281_sqlite3UpperToLower[(*b)])))) {
    a++;
    b++;
  }
  if ((((! id2i_sqlite_ebcdic) ) )) {
    return (_1281_sqlite3UpperToLower[(*a)] - _1281_sqlite3UpperToLower[(*b)]);
  }  
  if (((id2i_sqlite_ebcdic ) )) {
    return (_1282_sqlite3UpperToLower[(*a)] - _1282_sqlite3UpperToLower[(*b)]);
  }  
}
int sqlite3_strnicmp(const  char *zLeft , const  char *zRight , int N )  {
  register unsigned char *a, *b;
  (a = ((unsigned  char *) zLeft));
  (b = ((unsigned  char *) zRight));
  while ((((id2i_sqlite_ebcdic ) ) ? ((N-- > 0) && ((*a) != 0) && (_1282_sqlite3UpperToLower[(*a)] == _1282_sqlite3UpperToLower[(*b)])) : ((N-- > 0) && ((*a) != 0) && (_1281_sqlite3UpperToLower[(*a)] == _1281_sqlite3UpperToLower[(*b)])))) {
    a++;
    b++;
  }
  if ((((! id2i_sqlite_ebcdic) ) )) {
    return ((N < 0) ? 0 : (_1281_sqlite3UpperToLower[(*a)] - _1281_sqlite3UpperToLower[(*b)]));
  }  
  if (((id2i_sqlite_ebcdic ) )) {
    return ((N < 0) ? 0 : (_1282_sqlite3UpperToLower[(*a)] - _1282_sqlite3UpperToLower[(*b)]));
  }  
}
static  int sqlite3AtoF(const  char *z , double *pResult , int length , u8 enc )  {
  int incr;
  const char *zEnd =  (z + length);
  int sign =  1;
  i64 s =  0;
  int d =  0;
  int esign =  1;
  int e =  0;
  int eValid =  1;
  double result;
  int nDigits =  0;
  int nonNum =  0;
  ((void ) 0);
  ((*pResult) = 0.0);
  if ((enc == 1)) {
    (incr = 1);
  }  
  else {
    int i;
    (incr = 2);
    ((void ) 0);
    for ((i = (3 - enc)); ((i < length) && (z[i] == 0)); (i += 2)) {
      
    }
    (nonNum = (i < length));
    (zEnd = (z + i + enc - 3));
    (z += (enc & 1));
  }
  while (((z < zEnd) && (sqlite3CtypeMap[((unsigned  char ) (*z))] & 0x01))) {
    (z += incr);
  }
  if ((z >= zEnd)) {
    return 0;
  }  
  if (((*z) == '-')) {
    (sign = (- 1));
    (z += incr);
  } 
  else if (((*z) == '+')) {
    (z += incr);
  } 
  while (((z < zEnd) && (z[0] == '0'))) {
    (z += incr), nDigits++;
  }
  while (((z < zEnd) && (sqlite3CtypeMap[((unsigned  char ) (*z))] & 0x04) && (s < (((0xffffffff | (((i64 ) 0x7fffffff) << 32)) - 9) / 10)))) {
    (s = ((s * 10) + ((*z) - '0')));
    (z += incr), nDigits++;
  }
  while (((z < zEnd) && (sqlite3CtypeMap[((unsigned  char ) (*z))] & 0x04))) {
    (z += incr), nDigits++, d++;
  }
  if ((z >= zEnd)) {
    goto do_atof_calc;
  }  
  if (((*z) == '.')) {
    (z += incr);
    while (((z < zEnd) && (sqlite3CtypeMap[((unsigned  char ) (*z))] & 0x04) && (s < (((0xffffffff | (((i64 ) 0x7fffffff) << 32)) - 9) / 10)))) {
      (s = ((s * 10) + ((*z) - '0')));
      (z += incr), nDigits++, d--;
    }
    while (((z < zEnd) && (sqlite3CtypeMap[((unsigned  char ) (*z))] & 0x04))) {
      (z += incr), nDigits++;
    }
  }  
  if ((z >= zEnd)) {
    goto do_atof_calc;
  }  
  if ((((*z) == 'e') || ((*z) == 'E'))) {
    (z += incr);
    (eValid = 0);
    if ((z >= zEnd)) {
      goto do_atof_calc;
    }  
    if (((*z) == '-')) {
      (esign = (- 1));
      (z += incr);
    } 
    else if (((*z) == '+')) {
      (z += incr);
    } 
    while (((z < zEnd) && (sqlite3CtypeMap[((unsigned  char ) (*z))] & 0x04))) {
      (e = ((e < 10000) ? ((e * 10) + ((*z) - '0')) : 10000));
      (z += incr);
      (eValid = 1);
    }
  }  
  if ((nDigits && eValid)) {
    while (((z < zEnd) && (sqlite3CtypeMap[((unsigned  char ) (*z))] & 0x01))) {
      (z += incr);
    }
  }  
  do_atof_calc:
  (e = ((e * esign) + d));
  if ((e < 0)) {
    (esign = (- 1));
    (e *= (- 1));
  }  
  else {
    (esign = 1);
  }
  if ((! s)) {
    (result = (((sign < 0) && nDigits) ? (- ((double ) 0)) : ((double ) 0)));
  }  
  else {
    if ((esign > 0)) {
      while (((s < ((0xffffffff | (((i64 ) 0x7fffffff) << 32)) / 10)) && (e > 0))) {
        e--, (s *= 10);
      }
    }  
    else {
      while (((! (s % 10)) && (e > 0))) {
        e--, (s /= 10);
      }
    }
    (s = ((sign < 0) ? (- s) : s));
    if (e) {
      long double scale =  1.0;
      if (((e > 307) && (e < 342))) {
        while ((e % 308)) {
          (scale *= 1.0e+1);
          (e -= 1);
        }
        if ((esign < 0)) {
          (result = (s / scale));
          (result /= 1.0e+308);
        }  
        else {
          (result = (s * scale));
          (result *= 1.0e+308);
        }
      } 
      else if ((e >= 342)) {
        if ((esign < 0)) {
          (result = (0.0 * s));
        }  
        else {
          (result = (1e308 * 1e308 * s));
        }
      } 
      else {
        while ((e % 22)) {
          (scale *= 1.0e+1);
          (e -= 1);
        }
        while ((e > 0)) {
          (scale *= 1.0e+22);
          (e -= 22);
        }
        if ((esign < 0)) {
          (result = (s / scale));
        }  
        else {
          (result = (s * scale));
        }
      }
    }  
    else {
      (result = ((double ) s));
    }
  }
  ((*pResult) = result);
  return ((z >= zEnd) && (nDigits > 0) && eValid && (nonNum == 0));
}
static  int compare2pow63(const  char *zNum , int incr )  {
  int c =  0;
  int i;
  const char *pow63 =  "922337203685477580";
  for ((i = 0); ((c == 0) && (i < 18)); i++) {
    (c = ((zNum[(i * incr)] - pow63[i]) * 10));
  }
  if ((c == 0)) {
    (c = (zNum[(18 * incr)] - '8'));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((c == (- 1))) {
        sqlite3Coverage(21511);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((c == 0)) {
        sqlite3Coverage(21512);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((c == (+ 1))) {
        sqlite3Coverage(21513);
      }  
    }  
  }  
  return c;
}
static  int sqlite3Atoi64(const  char *zNum , i64 *pNum , int length , u8 enc )  {
  int incr;
  u64 u =  0;
  int neg =  0;
  int i;
  int c =  0;
  int nonNum =  0;
  const char *zStart;
  const char *zEnd =  (zNum + length);
  ((void ) 0);
  if ((enc == 1)) {
    (incr = 1);
  }  
  else {
    (incr = 2);
    ((void ) 0);
    for ((i = (3 - enc)); ((i < length) && (zNum[i] == 0)); (i += 2)) {
      
    }
    (nonNum = (i < length));
    (zEnd = (zNum + i + enc - 3));
    (zNum += (enc & 1));
  }
  while (((zNum < zEnd) && (sqlite3CtypeMap[((unsigned  char ) (*zNum))] & 0x01))) {
    (zNum += incr);
  }
  if ((zNum < zEnd)) {
    if (((*zNum) == '-')) {
      (neg = 1);
      (zNum += incr);
    } 
    else if (((*zNum) == '+')) {
      (zNum += incr);
    } 
  }  
  (zStart = zNum);
  while (((zNum < zEnd) && (zNum[0] == '0'))) {
    (zNum += incr);
  }
  for ((i = 0); (((&zNum[i]) < zEnd) && ((c = zNum[i]) >= '0') && (c <= '9')); (i += incr)) {
    (u = ((u * 10) + c - '0'));
  }
  if ((u > (0xffffffff | (((i64 ) 0x7fffffff) << 32)))) {
    ((*pNum) = (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32))));
  } 
  else if (neg) {
    ((*pNum) = (- ((i64 ) u)));
  } 
  else {
    ((*pNum) = ((i64 ) u));
  }
  if (((id2i_sqlite_coverage_test ) )) {
    if ((i == 18)) {
      sqlite3Coverage(21578);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((i == 19)) {
      sqlite3Coverage(21579);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((i == 20)) {
      sqlite3Coverage(21580);
    }  
  }  
  if ((((c != 0) && ((&zNum[i]) < zEnd)) || ((i == 0) && (zStart == zNum)) || (i > (19 * incr)) || nonNum)) {
    return 1;
  } 
  else if ((i < (19 * incr))) {
    ((void ) 0);
    return 0;
  } 
  else {
    (c = compare2pow63(zNum, incr));
    if ((c < 0)) {
      ((void ) 0);
      return 0;
    } 
    else if ((c > 0)) {
      return 1;
    } 
    else {
      ((void ) 0);
      ((void ) 0);
      return (neg ? 0 : 2);
    }
  }
}
static  int sqlite3GetInt32(const  char *zNum , int *pValue )  {
  sqlite_int64 v =  0;
  int i, c;
  int neg =  0;
  if ((zNum[0] == '-')) {
    (neg = 1);
    zNum++;
  } 
  else if ((zNum[0] == '+')) {
    zNum++;
  } 
  while ((zNum[0] == '0')) {
    zNum++;
  }
  for ((i = 0); ((i < 11) && ((c = (zNum[i] - '0')) >= 0) && (c <= 9)); i++) {
    (v = ((v * 10) + c));
  }
  if (((id2i_sqlite_coverage_test ) )) {
    if ((i == 10)) {
      sqlite3Coverage(21637);
    }  
  }  
  if ((i > 10)) {
    return 0;
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((v - neg) == 2147483647)) {
      sqlite3Coverage(21641);
    }  
  }  
  if (((v - neg) > 2147483647)) {
    return 0;
  }  
  if (neg) {
    (v = (- v));
  }  
  ((*pValue) = ((int ) v));
  return 1;
}
static  int sqlite3Atoi(const  char *z )  {
  int x =  0;
  if (z) {
    sqlite3GetInt32(z, (&x));
  }  
  return x;
}
static  int sqlite3PutVarint(unsigned  char *p , u64 v )  {
  int i, j, n;
  u8 buf[10];
  if ((v & (((u64 ) 0xff000000) << 32))) {
    (p[8] = ((u8 ) v));
    (v >>= 8);
    for ((i = 7); (i >= 0); i--) {
      (p[i] = ((u8 ) ((v & 0x7f) | 0x80)));
      (v >>= 7);
    }
    return 9;
  }  
  (n = 0);
  do {
    (buf[n++] = ((u8 ) ((v & 0x7f) | 0x80)));
    (v >>= 7);
  } while ((v != 0));
  (buf[0] &= 0x7f);
  ((void ) 0);
  for ((i = 0), (j = (n - 1)); (j >= 0); j--, i++) {
    (p[i] = buf[j]);
  }
  return n;
}
static  int sqlite3PutVarint32(unsigned  char *p , u32 v )  {
  if (((v & (~ 0x3fff)) == 0)) {
    (p[0] = ((u8 ) ((v >> 7) | 0x80)));
    (p[1] = ((u8 ) (v & 0x7f)));
    return 2;
  }  
  return sqlite3PutVarint(p, v);
}
static  u8 sqlite3GetVarint(const  unsigned  char *p , u64 *v )  {
  u32 a, b, s;
  (a = (*p));
  if ((! (a & 0x80))) {
    ((*v) = a);
    return 1;
  }  
  p++;
  (b = (*p));
  if ((! (b & 0x80))) {
    (a &= 0x7f);
    (a = (a << 7));
    (a |= b);
    ((*v) = a);
    return 2;
  }  
  ((void ) 0);
  ((void ) 0);
  p++;
  (a = (a << 14));
  (a |= (*p));
  if ((! (a & 0x80))) {
    (a &= 0x001fc07f);
    (b &= 0x7f);
    (b = (b << 7));
    (a |= b);
    ((*v) = a);
    return 3;
  }  
  (a &= 0x001fc07f);
  p++;
  (b = (b << 14));
  (b |= (*p));
  if ((! (b & 0x80))) {
    (b &= 0x001fc07f);
    (a = (a << 7));
    (a |= b);
    ((*v) = a);
    return 4;
  }  
  (b &= 0x001fc07f);
  (s = a);
  p++;
  (a = (a << 14));
  (a |= (*p));
  if ((! (a & 0x80))) {
    (b = (b << 7));
    (a |= b);
    (s = (s >> 18));
    ((*v) = ((((u64 ) s) << 32) | a));
    return 5;
  }  
  (s = (s << 7));
  (s |= b);
  p++;
  (b = (b << 14));
  (b |= (*p));
  if ((! (b & 0x80))) {
    (a &= 0x001fc07f);
    (a = (a << 7));
    (a |= b);
    (s = (s >> 18));
    ((*v) = ((((u64 ) s) << 32) | a));
    return 6;
  }  
  p++;
  (a = (a << 14));
  (a |= (*p));
  if ((! (a & 0x80))) {
    (a &= 0xf01fc07f);
    (b &= 0x001fc07f);
    (b = (b << 7));
    (a |= b);
    (s = (s >> 11));
    ((*v) = ((((u64 ) s) << 32) | a));
    return 7;
  }  
  (a &= 0x001fc07f);
  p++;
  (b = (b << 14));
  (b |= (*p));
  if ((! (b & 0x80))) {
    (b &= 0xf01fc07f);
    (a = (a << 7));
    (a |= b);
    (s = (s >> 4));
    ((*v) = ((((u64 ) s) << 32) | a));
    return 8;
  }  
  p++;
  (a = (a << 15));
  (a |= (*p));
  (b &= 0x001fc07f);
  (b = (b << 8));
  (a |= b);
  (s = (s << 4));
  (b = p[(- 4)]);
  (b &= 0x7f);
  (b = (b >> 3));
  (s |= b);
  ((*v) = ((((u64 ) s) << 32) | a));
  return 9;
}
static  u8 sqlite3GetVarint32(const  unsigned  char *p , u32 *v )  {
  u32 a, b;
  (a = (*p));
  p++;
  (b = (*p));
  if ((! (b & 0x80))) {
    (a &= 0x7f);
    (a = (a << 7));
    ((*v) = (a | b));
    return 2;
  }  
  p++;
  (a = (a << 14));
  (a |= (*p));
  if ((! (a & 0x80))) {
    (a &= ((0x7f << 14) | 0x7f));
    (b &= 0x7f);
    (b = (b << 7));
    ((*v) = (a | b));
    return 3;
  }  
  {
    u64 v64;
    u8 n;
    (p -= 2);
    (n = sqlite3GetVarint(p, (&v64)));
    ((void ) 0);
    if (((v64 & ((((u64 ) 1) << 32) - 1)) != v64)) {
      ((*v) = 0xffffffff);
    }  
    else {
      ((*v) = ((u32 ) v64));
    }
    return n;
  }
}
static  int sqlite3VarintLen(u64 v )  {
  int i =  0;
  do {
    i++;
    (v >>= 7);
  } while ((((id2i_sqlite_coverage_test ) ) ? ((v != 0) && 1) : ((v != 0) && (i < 9))));
  return i;
}
static  u32 sqlite3Get4byte(const  u8 *p )  {
  return ((p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
}
static  void sqlite3Put4byte(unsigned  char *p , u32 v )  {
  (p[0] = ((u8 ) (v >> 24)));
  (p[1] = ((u8 ) (v >> 16)));
  (p[2] = ((u8 ) (v >> 8)));
  (p[3] = ((u8 ) v));
}
static  u8 sqlite3HexToInt(int h )  {
  ((void ) 0);
  (h += (9 * (1 & (h >> 6))));
  if (((id2i_sqlite_ebcdic ) )) {
    (h += (9 * (1 & (~ (h >> 4)))));
  }  
  return ((u8 ) (h & 0xf));
}
static  void *sqlite3HexToBlob(sqlite3 *db , const  char *z , int n )  {
  char *zBlob;
  int i;
  (zBlob = ((char *) sqlite3DbMallocRaw(db, ((n / 2) + 1))));
  n--;
  if (zBlob) {
    for ((i = 0); (i < n); (i += 2)) {
      (zBlob[(i / 2)] = ((sqlite3HexToInt(z[i]) << 4) | sqlite3HexToInt(z[(i + 1)])));
    }
    (zBlob[(i / 2)] = 0);
  }  
  return zBlob;
}
static  void logBadConnection(const  char *zType )  {
  sqlite3_log(21, "API call with %s database connection pointer", zType);
}
static  int sqlite3SafetyCheckOk(sqlite3 *db )  {
  u32 magic;
  if ((db == 0)) {
    logBadConnection("NULL");
    return 0;
  }  
  (magic = db->magic);
  if ((magic != 0xa029a697)) {
    if (sqlite3SafetyCheckSickOrOk(db)) {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((((! id2i_sqlite_default_memstatus) ) )) {
          if ((_1283_sqlite3Config.xLog != 0)) {
            sqlite3Coverage(22148);
          }  
        }  
        if (((id2i_sqlite_default_memstatus ) )) {
          if ((_1284_sqlite3Config.xLog != 0)) {
            sqlite3Coverage(22148);
          }  
        }  
      }  
      logBadConnection("unopened");
    }  
    return 0;
  }  
  else {
    return 1;
  }
}
static  int sqlite3SafetyCheckSickOrOk(sqlite3 *db )  {
  u32 magic;
  (magic = db->magic);
  if (((magic != 0x4b771290) && (magic != 0xa029a697) && (magic != 0xf03b7906))) {
    if (((id2i_sqlite_coverage_test ) )) {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        if ((_1283_sqlite3Config.xLog != 0)) {
          sqlite3Coverage(22162);
        }  
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        if ((_1284_sqlite3Config.xLog != 0)) {
          sqlite3Coverage(22162);
        }  
      }  
    }  
    logBadConnection("invalid");
    return 0;
  }  
  else {
    return 1;
  }
}
static  int sqlite3AddInt64(i64 *pA , i64 iB )  {
  i64 iA =  (*pA);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((iA == 0)) {
      sqlite3Coverage(22178);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((iA == 1)) {
      sqlite3Coverage(22178);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((iB == (- 1))) {
      sqlite3Coverage(22179);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((iB == 0)) {
      sqlite3Coverage(22179);
    }  
  }  
  if ((iB >= 0)) {
    if (((id2i_sqlite_coverage_test ) )) {
      if (((iA > 0) && (((0xffffffff | (((i64 ) 0x7fffffff) << 32)) - iA) == iB))) {
        sqlite3Coverage(22181);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if (((iA > 0) && (((0xffffffff | (((i64 ) 0x7fffffff) << 32)) - iA) == (iB - 1)))) {
        sqlite3Coverage(22182);
      }  
    }  
    if (((iA > 0) && (((0xffffffff | (((i64 ) 0x7fffffff) << 32)) - iA) < iB))) {
      return 1;
    }  
    ((*pA) += iB);
  }  
  else {
    if (((id2i_sqlite_coverage_test ) )) {
      if (((iA < 0) && ((- (iA + (0xffffffff | (((i64 ) 0x7fffffff) << 32)))) == (iB + 1)))) {
        sqlite3Coverage(22186);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if (((iA < 0) && ((- (iA + (0xffffffff | (((i64 ) 0x7fffffff) << 32)))) == (iB + 2)))) {
        sqlite3Coverage(22187);
      }  
    }  
    if (((iA < 0) && ((- (iA + (0xffffffff | (((i64 ) 0x7fffffff) << 32)))) > (iB + 1)))) {
      return 1;
    }  
    ((*pA) += iB);
  }
  return 0;
}
static  int sqlite3SubInt64(i64 *pA , i64 iB )  {
  if (((id2i_sqlite_coverage_test ) )) {
    if ((iB == ((((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32))) + 1))) {
      sqlite3Coverage(22194);
    }  
  }  
  if ((iB == (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32))))) {
    if (((id2i_sqlite_coverage_test ) )) {
      if (((*pA) == (- 1))) {
        sqlite3Coverage(22196);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if (((*pA) == 0)) {
        sqlite3Coverage(22196);
      }  
    }  
    if (((*pA) >= 0)) {
      return 1;
    }  
    ((*pA) -= iB);
    return 0;
  }  
  else {
    return sqlite3AddInt64(pA, (- iB));
  }
}
static  int sqlite3MulInt64(i64 *pA , i64 iB )  {
  i64 iA =  (*pA);
  i64 iA1, iA0, iB1, iB0, r;
  (iA1 = (iA / (((i64 ) 1) << 32)));
  (iA0 = (iA % (((i64 ) 1) << 32)));
  (iB1 = (iB / (((i64 ) 1) << 32)));
  (iB0 = (iB % (((i64 ) 1) << 32)));
  if (((iA1 * iB1) != 0)) {
    return 1;
  }  
  ((void ) 0);
  (r = ((iA1 * iB0) + (iA0 * iB1)));
  if (((id2i_sqlite_coverage_test ) )) {
    if ((r == ((- (((i64 ) 1) << 31)) - 1))) {
      sqlite3Coverage(22217);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((r == (- (((i64 ) 1) << 31)))) {
      sqlite3Coverage(22218);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((r == (((i64 ) 1) << 31))) {
      sqlite3Coverage(22219);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((r == ((((i64 ) 1) << 31) - 1))) {
      sqlite3Coverage(22220);
    }  
  }  
  if (((r < (- (((i64 ) 1) << 31))) || (r >= (((i64 ) 1) << 31)))) {
    return 1;
  }  
  (r *= (((i64 ) 1) << 32));
  if (sqlite3AddInt64((&r), (iA0 * iB0))) {
    return 1;
  }  
  ((*pA) = r);
  return 0;
}
static  int sqlite3AbsInt32(int x )  {
  if ((x >= 0)) {
    return x;
  }  
  if ((x == ((int ) 0x80000000))) {
    return 0x7fffffff;
  }  
  return (- x);
}
static  LogEst sqlite3LogEstAdd(LogEst a , LogEst b )  {
  static const unsigned char x[] =  { 10,  10,  9,  9,  8,  8,  7,  7,  7,  6,  6,  6,  5,  5,  5,  4,  4,  4,  4,  3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,  2};
  if ((a >= b)) {
    if ((a > (b + 49))) {
      return a;
    }  
    if ((a > (b + 31))) {
      return (a + 1);
    }  
    return (a + x[(a - b)]);
  }  
  else {
    if ((b > (a + 49))) {
      return b;
    }  
    if ((b > (a + 31))) {
      return (b + 1);
    }  
    return (b + x[(b - a)]);
  }
}
static  LogEst sqlite3LogEst(u64 x )  {
  static LogEst a[] =  { 0,  2,  3,  5,  6,  7,  8,  9};
  LogEst y =  40;
  if ((x < 8)) {
    if ((x < 2)) {
      return 0;
    }  
    while ((x < 8)) {
      (y -= 10);
      (x <<= 1);
    }
  }  
  else {
    while ((x > 255)) {
      (y += 40);
      (x >>= 4);
    }
    while ((x > 15)) {
      (y += 10);
      (x >>= 1);
    }
  }
  return (a[(x & 7)] + y - 10);
}
static  LogEst sqlite3LogEstFromDouble(double x )  {
  u64 a;
  LogEst e;
  ((void ) 0);
  if ((x <= 1)) {
    return 0;
  }  
  if ((x <= 2000000000)) {
    return sqlite3LogEst(((u64 ) x));
  }  
  memcpy((&a), (&x), 8);
  (e = ((a >> 52) - 1022));
  return (e * 10);
}
static  u64 sqlite3LogEstToInt(LogEst x )  {
  u64 n;
  if ((x < 10)) {
    return 1;
  }  
  (n = (x % 10));
  (x /= 10);
  if ((n >= 5)) {
    (n -= 2);
  } 
  else if ((n >= 1)) {
    (n -= 1);
  } 
  if ((x >= 3)) {
    return ((n + 8) << (x - 3));
  }  
  return ((n + 8) >> (3 - x));
}
static  void sqlite3HashInit(Hash *pNew )  {
  ((void ) 0);
  (pNew->first = 0);
  (pNew->count = 0);
  (pNew->htsize = 0);
  (pNew->ht = 0);
}
static  void sqlite3HashClear(Hash *pH )  {
  HashElem *elem;
  ((void ) 0);
  (elem = pH->first);
  (pH->first = 0);
  sqlite3_free(pH->ht);
  (pH->ht = 0);
  (pH->htsize = 0);
  while (elem) {
    HashElem *next_elem =  elem->next;
    sqlite3_free(elem);
    (elem = next_elem);
  }
  (pH->count = 0);
}
static  unsigned  int strHash(const  char *z , int nKey )  {
  int h =  0;
  ((void ) 0);
  while ((nKey > 0)) {
    if ((((! id2i_sqlite_ebcdic) ) )) {
      (h = ((h << 3) ^ h ^ _1281_sqlite3UpperToLower[((unsigned  char ) (*z++))]));
    }  
    if (((id2i_sqlite_ebcdic ) )) {
      (h = ((h << 3) ^ h ^ _1282_sqlite3UpperToLower[((unsigned  char ) (*z++))]));
    }  
    nKey--;
  }
  return h;
}
static  void insertElement(Hash *pH , struct  _ht   *pEntry , HashElem *pNew )  {
  HashElem *pHead;
  if (pEntry) {
    (pHead = (pEntry->count ? pEntry->chain : 0));
    pEntry->count++;
    (pEntry->chain = pNew);
  }  
  else {
    (pHead = 0);
  }
  if (pHead) {
    (pNew->next = pHead);
    (pNew->prev = pHead->prev);
    if (pHead->prev) {
      (pHead->prev->next = pNew);
    }  
    else {
      (pH->first = pNew);
    }
    (pHead->prev = pNew);
  }  
  else {
    (pNew->next = pH->first);
    if (pH->first) {
      (pH->first->prev = pNew);
    }  
    (pNew->prev = 0);
    (pH->first = pNew);
  }
}
static  int rehash(Hash *pH , unsigned  int new_size )  {
  struct  _ht   *new_ht;
  HashElem *elem, *next_elem;
  if (((new_size * sizeof(struct  _ht   )) > 1024)) {
    (new_size = (1024 / sizeof(struct  _ht   )));
  }  
  if ((new_size == pH->htsize)) {
    return 0;
  }  
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    sqlite3BeginBenignMalloc();
  }  
  (new_ht = ((struct  _ht   *) sqlite3Malloc((new_size * sizeof(struct  _ht   )))));
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    sqlite3EndBenignMalloc();
  }  
  if ((new_ht == 0)) {
    return 0;
  }  
  sqlite3_free(pH->ht);
  (pH->ht = new_ht);
  (pH->htsize = (new_size = (sqlite3MallocSize(new_ht) / sizeof(struct  _ht   ))));
  memset(new_ht, 0, (new_size * sizeof(struct  _ht   )));
  for ((elem = pH->first), (pH->first = 0); elem; (elem = next_elem)) {
    unsigned int h =  (strHash(elem->pKey, elem->nKey) % new_size);
    (next_elem = elem->next);
    insertElement(pH, (&new_ht[h]), elem);
  }
  return 1;
}
static  HashElem *findElementGivenHash(const  Hash *pH , const  char *pKey , int nKey , unsigned  int h )  {
  HashElem *elem;
  int count;
  if (pH->ht) {
    struct  _ht   *pEntry =  (&pH->ht[h]);
    (elem = pEntry->chain);
    (count = pEntry->count);
  }  
  else {
    (elem = pH->first);
    (count = pH->count);
  }
  while ((((id2i_sqlite_coverage_test ) ) ? (count-- && 1) : (count-- && elem))) {
    if (((elem->nKey == nKey) && (sqlite3_strnicmp(elem->pKey, pKey, nKey) == 0))) {
      return elem;
    }  
    (elem = elem->next);
  }
  return 0;
}
static  void removeElementGivenHash(Hash *pH , HashElem *elem , unsigned  int h )  {
  struct  _ht   *pEntry;
  if (elem->prev) {
    (elem->prev->next = elem->next);
  }  
  else {
    (pH->first = elem->next);
  }
  if (elem->next) {
    (elem->next->prev = elem->prev);
  }  
  if (pH->ht) {
    (pEntry = (&pH->ht[h]));
    if ((pEntry->chain == elem)) {
      (pEntry->chain = elem->next);
    }  
    pEntry->count--;
    ((void ) 0);
  }  
  sqlite3_free(elem);
  pH->count--;
  if ((pH->count == 0)) {
    ((void ) 0);
    ((void ) 0);
    sqlite3HashClear(pH);
  }  
}
static  void *sqlite3HashFind(const  Hash *pH , const  char *pKey , int nKey )  {
  HashElem *elem;
  unsigned int h;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (pH->ht) {
    (h = (strHash(pKey, nKey) % pH->htsize));
  }  
  else {
    (h = 0);
  }
  (elem = findElementGivenHash(pH, pKey, nKey, h));
  return (elem ? elem->data : 0);
}
static  void *sqlite3HashInsert(Hash *pH , const  char *pKey , int nKey , void *data )  {
  unsigned int h;
  HashElem *elem;
  HashElem *new_elem;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (pH->htsize) {
    (h = (strHash(pKey, nKey) % pH->htsize));
  }  
  else {
    (h = 0);
  }
  (elem = findElementGivenHash(pH, pKey, nKey, h));
  if (elem) {
    void *old_data =  elem->data;
    if ((data == 0)) {
      removeElementGivenHash(pH, elem, h);
    }  
    else {
      (elem->data = data);
      (elem->pKey = pKey);
      ((void ) 0);
    }
    return old_data;
  }  
  if ((data == 0)) {
    return 0;
  }  
  (new_elem = ((HashElem *) sqlite3Malloc(sizeof(HashElem ))));
  if ((new_elem == 0)) {
    return data;
  }  
  (new_elem->pKey = pKey);
  (new_elem->nKey = nKey);
  (new_elem->data = data);
  pH->count++;
  if (((pH->count >= 10) && (pH->count > (2 * pH->htsize)))) {
    if (rehash(pH, (pH->count * 2))) {
      ((void ) 0);
      (h = (strHash(pKey, nKey) % pH->htsize));
    }  
  }  
  if (pH->ht) {
    insertElement(pH, (&pH->ht[h]), new_elem);
  }  
  else {
    insertElement(pH, 0, new_elem);
  }
  return 0;
}
static  const  char *sqlite3OpcodeName(int i )  {
  static const char *const azName[] =  { "?",  "Function",  "Savepoint",  "AutoCommit",  "Transaction",  "SorterNext",  "Prev",  "Next",  "AggStep",  "Checkpoint",  "JournalMode",  "Vacuum",  "VFilter",  "VUpdate",  "Goto",  "Gosub",  "Return",  "Yield",  "HaltIfNull",  "Not",  "Halt",  "Integer",  "Int64",  "String",  "Null",  "Blob",  "Variable",  "Move",  "Copy",  "SCopy",  "ResultRow",  "CollSeq",  "AddImm",  "MustBeInt",  "RealAffinity",  "Permutation",  "Compare",  "Jump",  "Once",  "If",  "IfNot",  "Column",  "Affinity",  "MakeRecord",  "Count",  "ReadCookie",  "SetCookie",  "VerifyCookie",  "OpenRead",  "OpenWrite",  "OpenAutoindex",  "OpenEphemeral",  "SorterOpen",  "OpenPseudo",  "Close",  "SeekLt",  "SeekLe",  "SeekGe",  "SeekGt",  "Seek",  "NotFound",  "Found",  "IsUnique",  "NotExists",  "Sequence",  "NewRowid",  "Insert",  "InsertInt",  "Or",  "And",  "Delete",  "ResetCount",  "SorterCompare",  "IsNull",  "NotNull",  "Ne",  "Eq",  "Gt",  "Le",  "Lt",  "Ge",  "SorterData",  "BitAnd",  "BitOr",  "ShiftLeft",  "ShiftRight",  "Add",  "Subtract",  "Multiply",  "Divide",  "Remainder",  "Concat",  "RowKey",  "BitNot",  "String8",  "RowData",  "Rowid",  "NullRow",  "Last",  "SorterSort",  "Sort",  "Rewind",  "SorterInsert",  "IdxInsert",  "IdxDelete",  "IdxRowid",  "IdxLT",  "IdxGE",  "Destroy",  "Clear",  "CreateIndex",  "CreateTable",  "ParseSchema",  "LoadAnalysis",  "DropTable",  "DropIndex",  "DropTrigger",  "IntegrityCk",  "RowSetAdd",  "RowSetRead",  "RowSetTest",  "Program",  "Param",  "FkCounter",  "FkIfZero",  "MemMax",  "IfPos",  "IfNeg",  "IfZero",  "AggFinal",  "Real",  "IncrVacuum",  "Expire",  "TableLock",  "VBegin",  "VCreate",  "VDestroy",  "VOpen",  "VColumn",  "VNext",  "VRename",  "ToText",  "ToBlob",  "ToNumeric",  "ToInt",  "ToReal",  "Pagecount",  "MaxPgcnt",  "Trace",  "Noop",  "Explain"};
  return azName[i];
}
struct  stat {
  __dev_t st_dev ;
  __ino_t st_ino ;
  __nlink_t st_nlink ;
  __mode_t st_mode ;
  __uid_t st_uid ;
  __gid_t st_gid ;
  int __pad0 ;
  __dev_t st_rdev ;
  __off_t st_size ;
  __blksize_t st_blksize ;
  __blkcnt_t st_blocks ;
  struct  timespec   st_atim ;
  struct  timespec   st_mtim ;
  struct  timespec   st_ctim ;
  __syscall_slong_t __glibc_reserved[3] ;
}  ;
struct  stat64 {
  __dev_t st_dev ;
  __ino64_t st_ino ;
  __nlink_t st_nlink ;
  __mode_t st_mode ;
  __uid_t st_uid ;
  __gid_t st_gid ;
  int __pad0 ;
  __dev_t st_rdev ;
  __off_t st_size ;
  __blksize_t st_blksize ;
  __blkcnt64_t st_blocks ;
  struct  timespec   st_atim ;
  struct  timespec   st_mtim ;
  struct  timespec   st_ctim ;
  __syscall_slong_t __glibc_reserved[3] ;
}  ;
extern int stat(const  char *__restrict __file , struct  stat   *__restrict __buf ) __asm__( "" "stat64") __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int fstat(int __fd , struct  stat   *__buf ) __asm__( "" "fstat64") __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int stat64(const  char *__restrict __file , struct  stat64   *__restrict __buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int fstat64(int __fd , struct  stat64   *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int fstatat(int __fd , const  char *__restrict __file , struct  stat   *__restrict __buf , int __flag ) __asm__( "" "fstatat64") __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int fstatat64(int __fd , const  char *__restrict __file , struct  stat64   *__restrict __buf , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int lstat(const  char *__restrict __file , struct  stat   *__restrict __buf ) __asm__( "" "lstat64") __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int lstat64(const  char *__restrict __file , struct  stat64   *__restrict __buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int chmod(const  char *__file , __mode_t __mode ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int lchmod(const  char *__file , __mode_t __mode ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int fchmod(int __fd , __mode_t __mode ) __attribute__((__nothrow__));
extern int fchmodat(int __fd , const  char *__file , __mode_t __mode , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern __mode_t umask(__mode_t __mask ) __attribute__((__nothrow__));
extern __mode_t getumask(void ) __attribute__((__nothrow__));
extern int mkdir(const  char *__path , __mode_t __mode ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int mkdirat(int __fd , const  char *__path , __mode_t __mode ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int mknod(const  char *__path , __mode_t __mode , __dev_t __dev ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int mknodat(int __fd , const  char *__path , __mode_t __mode , __dev_t __dev ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int mkfifo(const  char *__path , __mode_t __mode ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int mkfifoat(int __fd , const  char *__path , __mode_t __mode ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int utimensat(int __fd , const  char *__path , const  struct  timespec   __times[2] , int __flags ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int futimens(int __fd , const  struct  timespec   __times[2] ) __attribute__((__nothrow__));
extern int __fxstat(int __ver , int __fildes , struct  stat   *__stat_buf ) __asm__( "" "__fxstat64") __attribute__((__nothrow__)) __attribute__((__nonnull__ (3)));
extern int __xstat(int __ver , const  char *__filename , struct  stat   *__stat_buf ) __asm__( "" "__xstat64") __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int __lxstat(int __ver , const  char *__filename , struct  stat   *__stat_buf ) __asm__( "" "__lxstat64") __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int __fxstatat(int __ver , int __fildes , const  char *__filename , struct  stat   *__stat_buf , int __flag ) __asm__( "" "__fxstatat64") __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4)));
extern int __fxstat64(int __ver , int __fildes , struct  stat64   *__stat_buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3)));
extern int __xstat64(int __ver , const  char *__filename , struct  stat64   *__stat_buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int __lxstat64(int __ver , const  char *__filename , struct  stat64   *__stat_buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int __fxstatat64(int __ver , int __fildes , const  char *__filename , struct  stat64   *__stat_buf , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4)));
extern int __xmknod(int __ver , const  char *__path , __mode_t __mode , __dev_t *__dev ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 4)));
extern int __xmknodat(int __ver , int __fd , const  char *__path , __mode_t __mode , __dev_t *__dev ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 5)));
struct  flock {
  short  int l_type ;
  short  int l_whence ;
  __off64_t l_start ;
  __off64_t l_len ;
  __pid_t l_pid ;
}  ;
struct  flock64 {
  short  int l_type ;
  short  int l_whence ;
  __off64_t l_start ;
  __off64_t l_len ;
  __pid_t l_pid ;
}  ;
struct  iovec {
  void *iov_base ;
  size_t iov_len ;
}  ;
enum __pid_type {
  F_OWNER_TID = 0,
  F_OWNER_PID,
  F_OWNER_PGRP,
  F_OWNER_GID = F_OWNER_PGRP
} ;
struct  f_owner_ex {
  enum __pid_type type ;
  __pid_t pid ;
}  ;
struct  file_handle {
  unsigned  int handle_bytes ;
  int handle_type ;
  unsigned  char f_handle[0] ;
}  ;
extern ssize_t readahead(int __fd , __off64_t __offset , size_t __count ) __attribute__((__nothrow__));
extern int sync_file_range(int __fd , __off64_t __offset , __off64_t __count , unsigned  int __flags );
extern ssize_t vmsplice(int __fdout , const  struct  iovec   *__iov , size_t __count , unsigned  int __flags );
extern ssize_t splice(int __fdin , __off64_t *__offin , int __fdout , __off64_t *__offout , size_t __len , unsigned  int __flags );
extern ssize_t tee(int __fdin , int __fdout , size_t __len , unsigned  int __flags );
extern int fallocate(int __fd , int __mode , __off64_t __offset , __off64_t __len ) __asm__( "" "fallocate64");
extern int fallocate64(int __fd , int __mode , __off64_t __offset , __off64_t __len );
extern int name_to_handle_at(int __dfd , const  char *__name , struct  file_handle   *__handle , int *__mnt_id , int __flags ) __attribute__((__nothrow__));
extern int open_by_handle_at(int __mountdirfd , struct  file_handle   *__handle , int __flags );
extern int fcntl(int __fd , int __cmd , ...);
extern int open(const  char *__file , int __oflag , ...) __asm__( "" "open64") __attribute__((__nonnull__ (1)));
extern int open64(const  char *__file , int __oflag , ...) __attribute__((__nonnull__ (1)));
extern int openat(int __fd , const  char *__file , int __oflag , ...) __asm__( "" "openat64") __attribute__((__nonnull__ (2)));
extern int openat64(int __fd , const  char *__file , int __oflag , ...) __attribute__((__nonnull__ (2)));
extern int creat(const  char *__file , mode_t __mode ) __asm__( "" "creat64") __attribute__((__nonnull__ (1)));
extern int creat64(const  char *__file , mode_t __mode ) __attribute__((__nonnull__ (1)));
extern int lockf(int __fd , int __cmd , __off64_t __len ) __asm__( "" "lockf64");
extern int lockf64(int __fd , int __cmd , off64_t __len );
extern int posix_fadvise(int __fd , __off64_t __offset , __off64_t __len , int __advise ) __asm__( "" "posix_fadvise64") __attribute__((__nothrow__));
extern int posix_fadvise64(int __fd , off64_t __offset , off64_t __len , int __advise ) __attribute__((__nothrow__));
extern int posix_fallocate(int __fd , __off64_t __offset , __off64_t __len ) __asm__( "" "posix_fallocate64");
extern int posix_fallocate64(int __fd , off64_t __offset , off64_t __len );
typedef __intptr_t _1268_intptr_t;
typedef __socklen_t socklen_t;
extern int access(const  char *__name , int __type ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int euidaccess(const  char *__name , int __type ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int eaccess(const  char *__name , int __type ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int faccessat(int __fd , const  char *__file , int __type , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern __off64_t lseek(int __fd , __off64_t __offset , int __whence ) __asm__( "" "lseek64") __attribute__((__nothrow__));
extern __off64_t lseek64(int __fd , __off64_t __offset , int __whence ) __attribute__((__nothrow__));
extern int close(int __fd );
extern ssize_t read(int __fd , void *__buf , size_t __nbytes );
extern ssize_t write(int __fd , const  void *__buf , size_t __n );
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) __asm__( "" "pread64");
extern ssize_t pwrite(int __fd , const  void *__buf , size_t __nbytes , __off64_t __offset ) __asm__( "" "pwrite64");
extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset );
extern ssize_t pwrite64(int __fd , const  void *__buf , size_t __n , __off64_t __offset );
extern int pipe(int __pipedes[2] ) __attribute__((__nothrow__));
extern int pipe2(int __pipedes[2] , int __flags ) __attribute__((__nothrow__));
extern unsigned int alarm(unsigned  int __seconds ) __attribute__((__nothrow__));
extern unsigned int sleep(unsigned  int __seconds );
extern __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) __attribute__((__nothrow__));
extern int usleep(__useconds_t __useconds );
extern int pause(void );
extern int chown(const  char *__file , __uid_t __owner , __gid_t __group ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int fchown(int __fd , __uid_t __owner , __gid_t __group ) __attribute__((__nothrow__));
extern int lchown(const  char *__file , __uid_t __owner , __gid_t __group ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int fchownat(int __fd , const  char *__file , __uid_t __owner , __gid_t __group , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int chdir(const  char *__path ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int fchdir(int __fd ) __attribute__((__nothrow__));
extern char *getcwd(char *__buf , size_t __size ) __attribute__((__nothrow__));
extern char *get_current_dir_name(void ) __attribute__((__nothrow__));
extern char *getwd(char *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1))) __attribute__((__deprecated__));
extern int dup(int __fd ) __attribute__((__nothrow__));
extern int dup2(int __fd , int __fd2 ) __attribute__((__nothrow__));
extern int dup3(int __fd , int __fd2 , int __flags ) __attribute__((__nothrow__));
extern char **__environ;
extern char **environ;
extern int execve(const  char *__path , char *const __argv[] , char *const __envp[] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int fexecve(int __fd , char *const __argv[] , char *const __envp[] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int execv(const  char *__path , char *const __argv[] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int execle(const  char *__path , const  char *__arg , ...) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int execl(const  char *__path , const  char *__arg , ...) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int execvp(const  char *__file , char *const __argv[] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int execlp(const  char *__file , const  char *__arg , ...) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int execvpe(const  char *__file , char *const __argv[] , char *const __envp[] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int nice(int __inc ) __attribute__((__nothrow__));
extern void _exit(int __status ) __attribute__((__noreturn__));
enum  {
  _PC_LINK_MAX,
  _PC_MAX_CANON,
  _PC_MAX_INPUT,
  _PC_NAME_MAX,
  _PC_PATH_MAX,
  _PC_PIPE_BUF,
  _PC_CHOWN_RESTRICTED,
  _PC_NO_TRUNC,
  _PC_VDISABLE,
  _PC_SYNC_IO,
  _PC_ASYNC_IO,
  _PC_PRIO_IO,
  _PC_SOCK_MAXBUF,
  _PC_FILESIZEBITS,
  _PC_REC_INCR_XFER_SIZE,
  _PC_REC_MAX_XFER_SIZE,
  _PC_REC_MIN_XFER_SIZE,
  _PC_REC_XFER_ALIGN,
  _PC_ALLOC_SIZE_MIN,
  _PC_SYMLINK_MAX,
  _PC_2_SYMLINKS
} ;
enum  {
  _SC_ARG_MAX,
  _SC_CHILD_MAX,
  _SC_CLK_TCK,
  _SC_NGROUPS_MAX,
  _SC_OPEN_MAX,
  _SC_STREAM_MAX,
  _SC_TZNAME_MAX,
  _SC_JOB_CONTROL,
  _SC_SAVED_IDS,
  _SC_REALTIME_SIGNALS,
  _SC_PRIORITY_SCHEDULING,
  _SC_TIMERS,
  _SC_ASYNCHRONOUS_IO,
  _SC_PRIORITIZED_IO,
  _SC_SYNCHRONIZED_IO,
  _SC_FSYNC,
  _SC_MAPPED_FILES,
  _SC_MEMLOCK,
  _SC_MEMLOCK_RANGE,
  _SC_MEMORY_PROTECTION,
  _SC_MESSAGE_PASSING,
  _SC_SEMAPHORES,
  _SC_SHARED_MEMORY_OBJECTS,
  _SC_AIO_LISTIO_MAX,
  _SC_AIO_MAX,
  _SC_AIO_PRIO_DELTA_MAX,
  _SC_DELAYTIMER_MAX,
  _SC_MQ_OPEN_MAX,
  _SC_MQ_PRIO_MAX,
  _SC_VERSION,
  _SC_PAGESIZE,
  _SC_RTSIG_MAX,
  _SC_SEM_NSEMS_MAX,
  _SC_SEM_VALUE_MAX,
  _SC_SIGQUEUE_MAX,
  _SC_TIMER_MAX,
  _SC_BC_BASE_MAX,
  _SC_BC_DIM_MAX,
  _SC_BC_SCALE_MAX,
  _SC_BC_STRING_MAX,
  _SC_COLL_WEIGHTS_MAX,
  _SC_EQUIV_CLASS_MAX,
  _SC_EXPR_NEST_MAX,
  _SC_LINE_MAX,
  _SC_RE_DUP_MAX,
  _SC_CHARCLASS_NAME_MAX,
  _SC_2_VERSION,
  _SC_2_C_BIND,
  _SC_2_C_DEV,
  _SC_2_FORT_DEV,
  _SC_2_FORT_RUN,
  _SC_2_SW_DEV,
  _SC_2_LOCALEDEF,
  _SC_PII,
  _SC_PII_XTI,
  _SC_PII_SOCKET,
  _SC_PII_INTERNET,
  _SC_PII_OSI,
  _SC_POLL,
  _SC_SELECT,
  _SC_UIO_MAXIOV,
  _SC_IOV_MAX = _SC_UIO_MAXIOV,
  _SC_PII_INTERNET_STREAM,
  _SC_PII_INTERNET_DGRAM,
  _SC_PII_OSI_COTS,
  _SC_PII_OSI_CLTS,
  _SC_PII_OSI_M,
  _SC_T_IOV_MAX,
  _SC_THREADS,
  _SC_THREAD_SAFE_FUNCTIONS,
  _SC_GETGR_R_SIZE_MAX,
  _SC_GETPW_R_SIZE_MAX,
  _SC_LOGIN_NAME_MAX,
  _SC_TTY_NAME_MAX,
  _SC_THREAD_DESTRUCTOR_ITERATIONS,
  _SC_THREAD_KEYS_MAX,
  _SC_THREAD_STACK_MIN,
  _SC_THREAD_THREADS_MAX,
  _SC_THREAD_ATTR_STACKADDR,
  _SC_THREAD_ATTR_STACKSIZE,
  _SC_THREAD_PRIORITY_SCHEDULING,
  _SC_THREAD_PRIO_INHERIT,
  _SC_THREAD_PRIO_PROTECT,
  _SC_THREAD_PROCESS_SHARED,
  _SC_NPROCESSORS_CONF,
  _SC_NPROCESSORS_ONLN,
  _SC_PHYS_PAGES,
  _SC_AVPHYS_PAGES,
  _SC_ATEXIT_MAX,
  _SC_PASS_MAX,
  _SC_XOPEN_VERSION,
  _SC_XOPEN_XCU_VERSION,
  _SC_XOPEN_UNIX,
  _SC_XOPEN_CRYPT,
  _SC_XOPEN_ENH_I18N,
  _SC_XOPEN_SHM,
  _SC_2_CHAR_TERM,
  _SC_2_C_VERSION,
  _SC_2_UPE,
  _SC_XOPEN_XPG2,
  _SC_XOPEN_XPG3,
  _SC_XOPEN_XPG4,
  _SC_CHAR_BIT,
  _SC_CHAR_MAX,
  _SC_CHAR_MIN,
  _SC_INT_MAX,
  _SC_INT_MIN,
  _SC_LONG_BIT,
  _SC_WORD_BIT,
  _SC_MB_LEN_MAX,
  _SC_NZERO,
  _SC_SSIZE_MAX,
  _SC_SCHAR_MAX,
  _SC_SCHAR_MIN,
  _SC_SHRT_MAX,
  _SC_SHRT_MIN,
  _SC_UCHAR_MAX,
  _SC_UINT_MAX,
  _SC_ULONG_MAX,
  _SC_USHRT_MAX,
  _SC_NL_ARGMAX,
  _SC_NL_LANGMAX,
  _SC_NL_MSGMAX,
  _SC_NL_NMAX,
  _SC_NL_SETMAX,
  _SC_NL_TEXTMAX,
  _SC_XBS5_ILP32_OFF32,
  _SC_XBS5_ILP32_OFFBIG,
  _SC_XBS5_LP64_OFF64,
  _SC_XBS5_LPBIG_OFFBIG,
  _SC_XOPEN_LEGACY,
  _SC_XOPEN_REALTIME,
  _SC_XOPEN_REALTIME_THREADS,
  _SC_ADVISORY_INFO,
  _SC_BARRIERS,
  _SC_BASE,
  _SC_C_LANG_SUPPORT,
  _SC_C_LANG_SUPPORT_R,
  _SC_CLOCK_SELECTION,
  _SC_CPUTIME,
  _SC_THREAD_CPUTIME,
  _SC_DEVICE_IO,
  _SC_DEVICE_SPECIFIC,
  _SC_DEVICE_SPECIFIC_R,
  _SC_FD_MGMT,
  _SC_FIFO,
  _SC_PIPE,
  _SC_FILE_ATTRIBUTES,
  _SC_FILE_LOCKING,
  _SC_FILE_SYSTEM,
  _SC_MONOTONIC_CLOCK,
  _SC_MULTI_PROCESS,
  _SC_SINGLE_PROCESS,
  _SC_NETWORKING,
  _SC_READER_WRITER_LOCKS,
  _SC_SPIN_LOCKS,
  _SC_REGEXP,
  _SC_REGEX_VERSION,
  _SC_SHELL,
  _SC_SIGNALS,
  _SC_SPAWN,
  _SC_SPORADIC_SERVER,
  _SC_THREAD_SPORADIC_SERVER,
  _SC_SYSTEM_DATABASE,
  _SC_SYSTEM_DATABASE_R,
  _SC_TIMEOUTS,
  _SC_TYPED_MEMORY_OBJECTS,
  _SC_USER_GROUPS,
  _SC_USER_GROUPS_R,
  _SC_2_PBS,
  _SC_2_PBS_ACCOUNTING,
  _SC_2_PBS_LOCATE,
  _SC_2_PBS_MESSAGE,
  _SC_2_PBS_TRACK,
  _SC_SYMLOOP_MAX,
  _SC_STREAMS,
  _SC_2_PBS_CHECKPOINT,
  _SC_V6_ILP32_OFF32,
  _SC_V6_ILP32_OFFBIG,
  _SC_V6_LP64_OFF64,
  _SC_V6_LPBIG_OFFBIG,
  _SC_HOST_NAME_MAX,
  _SC_TRACE,
  _SC_TRACE_EVENT_FILTER,
  _SC_TRACE_INHERIT,
  _SC_TRACE_LOG,
  _SC_LEVEL1_ICACHE_SIZE,
  _SC_LEVEL1_ICACHE_ASSOC,
  _SC_LEVEL1_ICACHE_LINESIZE,
  _SC_LEVEL1_DCACHE_SIZE,
  _SC_LEVEL1_DCACHE_ASSOC,
  _SC_LEVEL1_DCACHE_LINESIZE,
  _SC_LEVEL2_CACHE_SIZE,
  _SC_LEVEL2_CACHE_ASSOC,
  _SC_LEVEL2_CACHE_LINESIZE,
  _SC_LEVEL3_CACHE_SIZE,
  _SC_LEVEL3_CACHE_ASSOC,
  _SC_LEVEL3_CACHE_LINESIZE,
  _SC_LEVEL4_CACHE_SIZE,
  _SC_LEVEL4_CACHE_ASSOC,
  _SC_LEVEL4_CACHE_LINESIZE,
  _SC_IPV6 = (_SC_LEVEL1_ICACHE_SIZE + 50),
  _SC_RAW_SOCKETS,
  _SC_V7_ILP32_OFF32,
  _SC_V7_ILP32_OFFBIG,
  _SC_V7_LP64_OFF64,
  _SC_V7_LPBIG_OFFBIG,
  _SC_SS_REPL_MAX,
  _SC_TRACE_EVENT_NAME_MAX,
  _SC_TRACE_NAME_MAX,
  _SC_TRACE_SYS_MAX,
  _SC_TRACE_USER_EVENT_MAX,
  _SC_XOPEN_STREAMS,
  _SC_THREAD_ROBUST_PRIO_INHERIT,
  _SC_THREAD_ROBUST_PRIO_PROTECT
} ;
enum  {
  _CS_PATH,
  _CS_V6_WIDTH_RESTRICTED_ENVS,
  _CS_GNU_LIBC_VERSION,
  _CS_GNU_LIBPTHREAD_VERSION,
  _CS_V5_WIDTH_RESTRICTED_ENVS,
  _CS_V7_WIDTH_RESTRICTED_ENVS,
  _CS_LFS_CFLAGS = 1000,
  _CS_LFS_LDFLAGS,
  _CS_LFS_LIBS,
  _CS_LFS_LINTFLAGS,
  _CS_LFS64_CFLAGS,
  _CS_LFS64_LDFLAGS,
  _CS_LFS64_LIBS,
  _CS_LFS64_LINTFLAGS,
  _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
  _CS_XBS5_ILP32_OFF32_LDFLAGS,
  _CS_XBS5_ILP32_OFF32_LIBS,
  _CS_XBS5_ILP32_OFF32_LINTFLAGS,
  _CS_XBS5_ILP32_OFFBIG_CFLAGS,
  _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
  _CS_XBS5_ILP32_OFFBIG_LIBS,
  _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
  _CS_XBS5_LP64_OFF64_CFLAGS,
  _CS_XBS5_LP64_OFF64_LDFLAGS,
  _CS_XBS5_LP64_OFF64_LIBS,
  _CS_XBS5_LP64_OFF64_LINTFLAGS,
  _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
  _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
  _CS_XBS5_LPBIG_OFFBIG_LIBS,
  _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,
  _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
  _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
  _CS_POSIX_V6_ILP32_OFF32_LIBS,
  _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
  _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
  _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
  _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
  _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
  _CS_POSIX_V6_LP64_OFF64_CFLAGS,
  _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
  _CS_POSIX_V6_LP64_OFF64_LIBS,
  _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
  _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
  _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
  _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
  _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,
  _CS_POSIX_V7_ILP32_OFF32_CFLAGS,
  _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,
  _CS_POSIX_V7_ILP32_OFF32_LIBS,
  _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,
  _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,
  _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,
  _CS_POSIX_V7_ILP32_OFFBIG_LIBS,
  _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,
  _CS_POSIX_V7_LP64_OFF64_CFLAGS,
  _CS_POSIX_V7_LP64_OFF64_LDFLAGS,
  _CS_POSIX_V7_LP64_OFF64_LIBS,
  _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,
  _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,
  _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,
  _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,
  _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,
  _CS_V6_ENV,
  _CS_V7_ENV
} ;
extern long int pathconf(const  char *__path , int __name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long int fpathconf(int __fd , int __name ) __attribute__((__nothrow__));
extern long int sysconf(int __name ) __attribute__((__nothrow__));
extern size_t confstr(int __name , char *__buf , size_t __len ) __attribute__((__nothrow__));
extern __pid_t getpid(void ) __attribute__((__nothrow__));
extern __pid_t getppid(void ) __attribute__((__nothrow__));
extern __pid_t getpgrp(void ) __attribute__((__nothrow__));
extern __pid_t __getpgid(__pid_t __pid ) __attribute__((__nothrow__));
extern __pid_t getpgid(__pid_t __pid ) __attribute__((__nothrow__));
extern int setpgid(__pid_t __pid , __pid_t __pgid ) __attribute__((__nothrow__));
extern int setpgrp(void ) __attribute__((__nothrow__));
extern __pid_t setsid(void ) __attribute__((__nothrow__));
extern __pid_t getsid(__pid_t __pid ) __attribute__((__nothrow__));
extern __uid_t getuid(void ) __attribute__((__nothrow__));
extern __uid_t geteuid(void ) __attribute__((__nothrow__));
extern __gid_t getgid(void ) __attribute__((__nothrow__));
extern __gid_t getegid(void ) __attribute__((__nothrow__));
extern int getgroups(int __size , __gid_t __list[] ) __attribute__((__nothrow__));
extern int group_member(__gid_t __gid ) __attribute__((__nothrow__));
extern int setuid(__uid_t __uid ) __attribute__((__nothrow__));
extern int setreuid(__uid_t __ruid , __uid_t __euid ) __attribute__((__nothrow__));
extern int seteuid(__uid_t __uid ) __attribute__((__nothrow__));
extern int setgid(__gid_t __gid ) __attribute__((__nothrow__));
extern int setregid(__gid_t __rgid , __gid_t __egid ) __attribute__((__nothrow__));
extern int setegid(__gid_t __gid ) __attribute__((__nothrow__));
extern int getresuid(__uid_t *__ruid , __uid_t *__euid , __uid_t *__suid ) __attribute__((__nothrow__));
extern int getresgid(__gid_t *__rgid , __gid_t *__egid , __gid_t *__sgid ) __attribute__((__nothrow__));
extern int setresuid(__uid_t __ruid , __uid_t __euid , __uid_t __suid ) __attribute__((__nothrow__));
extern int setresgid(__gid_t __rgid , __gid_t __egid , __gid_t __sgid ) __attribute__((__nothrow__));
extern __pid_t fork(void ) __attribute__((__nothrow__));
extern __pid_t vfork(void ) __attribute__((__nothrow__));
extern char *ttyname(int __fd ) __attribute__((__nothrow__));
extern int ttyname_r(int __fd , char *__buf , size_t __buflen ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int isatty(int __fd ) __attribute__((__nothrow__));
extern int ttyslot(void ) __attribute__((__nothrow__));
extern int link(const  char *__from , const  char *__to ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int linkat(int __fromfd , const  char *__from , int __tofd , const  char *__to , int __flags ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 4)));
extern int symlink(const  char *__from , const  char *__to ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern ssize_t readlink(const  char *__restrict __path , char *__restrict __buf , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int symlinkat(const  char *__from , int __tofd , const  char *__to ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 3)));
extern ssize_t readlinkat(int __fd , const  char *__restrict __path , char *__restrict __buf , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int unlink(const  char *__name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int unlinkat(int __fd , const  char *__name , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int rmdir(const  char *__path ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern __pid_t tcgetpgrp(int __fd ) __attribute__((__nothrow__));
extern int tcsetpgrp(int __fd , __pid_t __pgrp_id ) __attribute__((__nothrow__));
extern char *getlogin(void );
extern int getlogin_r(char *__name , size_t __name_len ) __attribute__((__nonnull__ (1)));
extern int setlogin(const  char *__name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern char *optarg;
extern int optind;
extern int opterr;
extern int optopt;
extern int getopt(int ___argc , char *const *___argv , const  char *__shortopts ) __attribute__((__nothrow__));
extern int gethostname(char *__name , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int sethostname(const  char *__name , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int sethostid(long  int __id ) __attribute__((__nothrow__));
extern int getdomainname(char *__name , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int setdomainname(const  char *__name , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int vhangup(void ) __attribute__((__nothrow__));
extern int revoke(const  char *__file ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int profil(unsigned  short  int *__sample_buffer , size_t __size , size_t __offset , unsigned  int __scale ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int acct(const  char *__name ) __attribute__((__nothrow__));
extern char *getusershell(void ) __attribute__((__nothrow__));
extern void endusershell(void ) __attribute__((__nothrow__));
extern void setusershell(void ) __attribute__((__nothrow__));
extern int daemon(int __nochdir , int __noclose ) __attribute__((__nothrow__));
extern int chroot(const  char *__path ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern char *getpass(const  char *__prompt ) __attribute__((__nonnull__ (1)));
extern int fsync(int __fd );
extern int syncfs(int __fd ) __attribute__((__nothrow__));
extern long int gethostid(void );
extern void sync(void ) __attribute__((__nothrow__));
extern int getpagesize(void ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int getdtablesize(void ) __attribute__((__nothrow__));
extern int truncate(const  char *__file , __off64_t __length ) __asm__( "" "truncate64") __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int truncate64(const  char *__file , __off64_t __length ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int ftruncate(int __fd , __off64_t __length ) __asm__( "" "ftruncate64") __attribute__((__nothrow__));
extern int ftruncate64(int __fd , __off64_t __length ) __attribute__((__nothrow__));
extern int brk(void *__addr ) __attribute__((__nothrow__));
extern void *sbrk(_1266_intptr_t __delta ) __attribute__((__nothrow__));
/*id2i.remove: removed unused variant for the following declaration: extern void *sbrk(_1268_intptr_t __delta ) __attribute__((__nothrow__));*/
extern long int syscall(long  int __sysno , ...) __attribute__((__nothrow__));
extern int fdatasync(int __fildes );
extern char *crypt(const  char *__key , const  char *__salt ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void encrypt(char *__glibc_block , int __edflag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void swab(const  void *__restrict __from , void *__restrict __to , ssize_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
struct  timezone {
  int tz_minuteswest ;
  int tz_dsttime ;
}  ;
typedef struct  timezone   *__restrict __timezone_ptr_t;
extern int gettimeofday(struct  timeval   *__restrict __tv , __timezone_ptr_t __tz ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int settimeofday(const  struct  timeval   *__tv , const  struct  timezone   *__tz ) __attribute__((__nothrow__));
extern int adjtime(const  struct  timeval   *__delta , struct  timeval   *__olddelta ) __attribute__((__nothrow__));
enum __itimer_which {
  ITIMER_REAL = 0,
  ITIMER_VIRTUAL = 1,
  ITIMER_PROF = 2
} ;
struct  itimerval {
  struct  timeval   it_interval ;
  struct  timeval   it_value ;
}  ;
typedef enum __itimer_which __itimer_which_t;
extern int getitimer(__itimer_which_t __which , struct  itimerval   *__value ) __attribute__((__nothrow__));
extern int setitimer(__itimer_which_t __which , const  struct  itimerval   *__restrict __new , struct  itimerval   *__restrict __old ) __attribute__((__nothrow__));
extern int utimes(const  char *__file , const  struct  timeval   __tvp[2] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int lutimes(const  char *__file , const  struct  timeval   __tvp[2] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int futimes(int __fd , const  struct  timeval   __tvp[2] ) __attribute__((__nothrow__));
extern int futimesat(int __fd , const  char *__file , const  struct  timeval   __tvp[2] ) __attribute__((__nothrow__));
extern int *__errno_location(void ) __attribute__((__nothrow__)) __attribute__((__const__));
extern char *program_invocation_name, *program_invocation_short_name;
typedef int error_t;
extern void *mmap(void *__addr , size_t __len , int __prot , int __flags , int __fd , __off64_t __offset ) __asm__( "" "mmap64") __attribute__((__nothrow__));
extern void *mmap64(void *__addr , size_t __len , int __prot , int __flags , int __fd , __off64_t __offset ) __attribute__((__nothrow__));
extern int munmap(void *__addr , size_t __len ) __attribute__((__nothrow__));
extern int mprotect(void *__addr , size_t __len , int __prot ) __attribute__((__nothrow__));
extern int msync(void *__addr , size_t __len , int __flags );
extern int madvise(void *__addr , size_t __len , int __advice ) __attribute__((__nothrow__));
extern int posix_madvise(void *__addr , size_t __len , int __advice ) __attribute__((__nothrow__));
extern int mlock(const  void *__addr , size_t __len ) __attribute__((__nothrow__));
extern int munlock(const  void *__addr , size_t __len ) __attribute__((__nothrow__));
extern int mlockall(int __flags ) __attribute__((__nothrow__));
extern int munlockall(void ) __attribute__((__nothrow__));
extern int mincore(void *__start , size_t __len , unsigned  char *__vec ) __attribute__((__nothrow__));
extern void *mremap(void *__addr , size_t __old_len , size_t __new_len , int __flags , ...) __attribute__((__nothrow__));
extern int remap_file_pages(void *__start , size_t __size , int __prot , size_t __pgoff , int __flags ) __attribute__((__nothrow__));
extern int shm_open(const  char *__name , int __oflag , mode_t __mode );
extern int shm_unlink(const  char *__name );
typedef struct  unixShm   unixShm;
typedef struct  unixShmNode   unixShmNode;
typedef struct  unixInodeInfo   unixInodeInfo;
typedef struct  UnixUnusedFd   UnixUnusedFd;
struct  UnixUnusedFd {
  int fd ;
  int flags ;
  UnixUnusedFd *pNext ;
}  ;
typedef struct  unixFile   unixFile;
struct  unixFile {
  sqlite3_io_methods  const *pMethod ;
  sqlite3_vfs *pVfs ;
  unixInodeInfo *pInode ;
  int h ;
  unsigned  char eFileLock ;
  unsigned  short  int ctrlFlags ;
  int lastErrno ;
  void *lockingContext ;
  UnixUnusedFd *pUnused ;
  const  char *zPath ;
  unixShm *pShm ;
  int szChunk ;
}  ;
static  int posixOpen(const  char *zFile , int flags , int mode )  {
  return open(zFile, flags, mode);
}
static  int posixFchown(int fd , uid_t uid , gid_t gid )  {
  return (geteuid() ? 0 : fchown(fd, uid, gid));
}
static int openDirectory(const  char * , int * );
static struct  unix_syscall {
  const  char *zName ;
  sqlite3_syscall_ptr pCurrent ;
  sqlite3_syscall_ptr pDefault ;
}  ;
static struct  unix_syscall   _1305_aSyscall[] =  { { "open",  ((sqlite3_syscall_ptr ) posixOpen),  0},  { "close",  ((sqlite3_syscall_ptr ) close),  0},  { "access",  ((sqlite3_syscall_ptr ) access),  0},  { "getcwd",  ((sqlite3_syscall_ptr ) getcwd),  0},  { "stat",  ((sqlite3_syscall_ptr ) stat),  0},  { "fstat",  ((sqlite3_syscall_ptr ) fstat),  0},  { "ftruncate",  ((sqlite3_syscall_ptr ) ftruncate),  0},  { "fcntl",  ((sqlite3_syscall_ptr ) fcntl),  0},  { "read",  ((sqlite3_syscall_ptr ) read),  0},  { "pread",  ((sqlite3_syscall_ptr ) 0),  0},  { "pread64",  ((sqlite3_syscall_ptr ) 0),  0},  { "write",  ((sqlite3_syscall_ptr ) write),  0},  { "pwrite",  ((sqlite3_syscall_ptr ) 0),  0},  { "pwrite64",  ((sqlite3_syscall_ptr ) 0),  0},  { "fchmod",  ((sqlite3_syscall_ptr ) fchmod),  0},  { "fallocate",  ((sqlite3_syscall_ptr ) 0),  0},  { "unlink",  ((sqlite3_syscall_ptr ) unlink),  0},  { "openDirectory",  ((sqlite3_syscall_ptr ) openDirectory),  0},  { "mkdir",  ((sqlite3_syscall_ptr ) mkdir),  0},  { "rmdir",  ((sqlite3_syscall_ptr ) rmdir),  0},  { "fchown",  ((sqlite3_syscall_ptr ) posixFchown),  0},  { "mmap",  ((sqlite3_syscall_ptr ) mmap),  0},  { "munmap",  ((sqlite3_syscall_ptr ) munmap),  0},  { "mremap",  ((sqlite3_syscall_ptr ) mremap),  0}};
static struct  unix_syscall   _1306_aSyscall[] =  { { "open",  ((sqlite3_syscall_ptr ) posixOpen),  0},  { "close",  ((sqlite3_syscall_ptr ) close),  0},  { "access",  ((sqlite3_syscall_ptr ) access),  0},  { "getcwd",  ((sqlite3_syscall_ptr ) getcwd),  0},  { "stat",  ((sqlite3_syscall_ptr ) stat),  0},  { "fstat",  ((sqlite3_syscall_ptr ) fstat),  0},  { "ftruncate",  ((sqlite3_syscall_ptr ) ftruncate),  0},  { "fcntl",  ((sqlite3_syscall_ptr ) fcntl),  0},  { "read",  ((sqlite3_syscall_ptr ) read),  0},  { "pread",  ((sqlite3_syscall_ptr ) 0),  0},  { "pread64",  ((sqlite3_syscall_ptr ) pread64),  0},  { "write",  ((sqlite3_syscall_ptr ) write),  0},  { "pwrite",  ((sqlite3_syscall_ptr ) 0),  0},  { "pwrite64",  ((sqlite3_syscall_ptr ) pwrite64),  0},  { "fchmod",  ((sqlite3_syscall_ptr ) fchmod),  0},  { "fallocate",  ((sqlite3_syscall_ptr ) 0),  0},  { "unlink",  ((sqlite3_syscall_ptr ) unlink),  0},  { "openDirectory",  ((sqlite3_syscall_ptr ) openDirectory),  0},  { "mkdir",  ((sqlite3_syscall_ptr ) mkdir),  0},  { "rmdir",  ((sqlite3_syscall_ptr ) rmdir),  0},  { "fchown",  ((sqlite3_syscall_ptr ) posixFchown),  0},  { "mmap",  ((sqlite3_syscall_ptr ) mmap),  0},  { "munmap",  ((sqlite3_syscall_ptr ) munmap),  0},  { "mremap",  ((sqlite3_syscall_ptr ) mremap),  0}};
static struct  unix_syscall   _1307_aSyscall[] =  { { "open",  ((sqlite3_syscall_ptr ) posixOpen),  0},  { "close",  ((sqlite3_syscall_ptr ) close),  0},  { "access",  ((sqlite3_syscall_ptr ) access),  0},  { "getcwd",  ((sqlite3_syscall_ptr ) getcwd),  0},  { "stat",  ((sqlite3_syscall_ptr ) stat),  0},  { "fstat",  ((sqlite3_syscall_ptr ) fstat),  0},  { "ftruncate",  ((sqlite3_syscall_ptr ) ftruncate),  0},  { "fcntl",  ((sqlite3_syscall_ptr ) fcntl),  0},  { "read",  ((sqlite3_syscall_ptr ) read),  0},  { "pread",  ((sqlite3_syscall_ptr ) pread),  0},  { "pread64",  ((sqlite3_syscall_ptr ) 0),  0},  { "write",  ((sqlite3_syscall_ptr ) write),  0},  { "pwrite",  ((sqlite3_syscall_ptr ) pwrite),  0},  { "pwrite64",  ((sqlite3_syscall_ptr ) 0),  0},  { "fchmod",  ((sqlite3_syscall_ptr ) fchmod),  0},  { "fallocate",  ((sqlite3_syscall_ptr ) 0),  0},  { "unlink",  ((sqlite3_syscall_ptr ) unlink),  0},  { "openDirectory",  ((sqlite3_syscall_ptr ) openDirectory),  0},  { "mkdir",  ((sqlite3_syscall_ptr ) mkdir),  0},  { "rmdir",  ((sqlite3_syscall_ptr ) rmdir),  0},  { "fchown",  ((sqlite3_syscall_ptr ) posixFchown),  0},  { "mmap",  ((sqlite3_syscall_ptr ) mmap),  0},  { "munmap",  ((sqlite3_syscall_ptr ) munmap),  0},  { "mremap",  ((sqlite3_syscall_ptr ) mremap),  0}};
static struct  unix_syscall   _1308_aSyscall[] =  { { "open",  ((sqlite3_syscall_ptr ) posixOpen),  0},  { "close",  ((sqlite3_syscall_ptr ) close),  0},  { "access",  ((sqlite3_syscall_ptr ) access),  0},  { "getcwd",  ((sqlite3_syscall_ptr ) getcwd),  0},  { "stat",  ((sqlite3_syscall_ptr ) stat),  0},  { "fstat",  ((sqlite3_syscall_ptr ) fstat),  0},  { "ftruncate",  ((sqlite3_syscall_ptr ) ftruncate),  0},  { "fcntl",  ((sqlite3_syscall_ptr ) fcntl),  0},  { "read",  ((sqlite3_syscall_ptr ) read),  0},  { "pread",  ((sqlite3_syscall_ptr ) pread),  0},  { "pread64",  ((sqlite3_syscall_ptr ) pread64),  0},  { "write",  ((sqlite3_syscall_ptr ) write),  0},  { "pwrite",  ((sqlite3_syscall_ptr ) pwrite),  0},  { "pwrite64",  ((sqlite3_syscall_ptr ) pwrite64),  0},  { "fchmod",  ((sqlite3_syscall_ptr ) fchmod),  0},  { "fallocate",  ((sqlite3_syscall_ptr ) 0),  0},  { "unlink",  ((sqlite3_syscall_ptr ) unlink),  0},  { "openDirectory",  ((sqlite3_syscall_ptr ) openDirectory),  0},  { "mkdir",  ((sqlite3_syscall_ptr ) mkdir),  0},  { "rmdir",  ((sqlite3_syscall_ptr ) rmdir),  0},  { "fchown",  ((sqlite3_syscall_ptr ) posixFchown),  0},  { "mmap",  ((sqlite3_syscall_ptr ) mmap),  0},  { "munmap",  ((sqlite3_syscall_ptr ) munmap),  0},  { "mremap",  ((sqlite3_syscall_ptr ) mremap),  0}};
static  int unixSetSystemCall(sqlite3_vfs *pNotUsed , const  char *zName , sqlite3_syscall_ptr pNewFunc )  {
  unsigned int i;
  int rc =  12;
  ((void ) pNotUsed);
  if ((zName == 0)) {
    (rc = 0);
    for ((i = 0); (((id2i_use_pread && id2i_use_pread64) ) ? (i < (sizeof(_1308_aSyscall) / sizeof(_1308_aSyscall[0]))) : (((id2i_use_pread && (! id2i_use_pread64)) ) ? (i < (sizeof(_1307_aSyscall) / sizeof(_1307_aSyscall[0]))) : ((((! id2i_use_pread) && id2i_use_pread64) ) ? (i < (sizeof(_1306_aSyscall) / sizeof(_1306_aSyscall[0]))) : (i < (sizeof(_1305_aSyscall) / sizeof(_1305_aSyscall[0])))))); i++) {
      if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
        if (_1305_aSyscall[i].pDefault) {
          (_1305_aSyscall[i].pCurrent = _1305_aSyscall[i].pDefault);
        }  
      }  
      if ((((! id2i_use_pread) && id2i_use_pread64) )) {
        if (_1306_aSyscall[i].pDefault) {
          (_1306_aSyscall[i].pCurrent = _1306_aSyscall[i].pDefault);
        }  
      }  
      if (((id2i_use_pread && (! id2i_use_pread64)) )) {
        if (_1307_aSyscall[i].pDefault) {
          (_1307_aSyscall[i].pCurrent = _1307_aSyscall[i].pDefault);
        }  
      }  
      if (((id2i_use_pread && id2i_use_pread64) )) {
        if (_1308_aSyscall[i].pDefault) {
          (_1308_aSyscall[i].pCurrent = _1308_aSyscall[i].pDefault);
        }  
      }  
    }
  }  
  else {
    for ((i = 0); (((id2i_use_pread && id2i_use_pread64) ) ? (i < (sizeof(_1308_aSyscall) / sizeof(_1308_aSyscall[0]))) : (((id2i_use_pread && (! id2i_use_pread64)) ) ? (i < (sizeof(_1307_aSyscall) / sizeof(_1307_aSyscall[0]))) : ((((! id2i_use_pread) && id2i_use_pread64) ) ? (i < (sizeof(_1306_aSyscall) / sizeof(_1306_aSyscall[0]))) : (i < (sizeof(_1305_aSyscall) / sizeof(_1305_aSyscall[0])))))); i++) {
      if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
        if ((strcmp(zName, _1305_aSyscall[i].zName) == 0)) {
          if ((_1305_aSyscall[i].pDefault == 0)) {
            (_1305_aSyscall[i].pDefault = _1305_aSyscall[i].pCurrent);
          }  
          (rc = 0);
          if ((pNewFunc == 0)) {
            (pNewFunc = _1305_aSyscall[i].pDefault);
          }  
          (_1305_aSyscall[i].pCurrent = pNewFunc);
          break;
        }  
      }  
      if ((((! id2i_use_pread) && id2i_use_pread64) )) {
        if ((strcmp(zName, _1306_aSyscall[i].zName) == 0)) {
          if ((_1306_aSyscall[i].pDefault == 0)) {
            (_1306_aSyscall[i].pDefault = _1306_aSyscall[i].pCurrent);
          }  
          (rc = 0);
          if ((pNewFunc == 0)) {
            (pNewFunc = _1306_aSyscall[i].pDefault);
          }  
          (_1306_aSyscall[i].pCurrent = pNewFunc);
          break;
        }  
      }  
      if (((id2i_use_pread && (! id2i_use_pread64)) )) {
        if ((strcmp(zName, _1307_aSyscall[i].zName) == 0)) {
          if ((_1307_aSyscall[i].pDefault == 0)) {
            (_1307_aSyscall[i].pDefault = _1307_aSyscall[i].pCurrent);
          }  
          (rc = 0);
          if ((pNewFunc == 0)) {
            (pNewFunc = _1307_aSyscall[i].pDefault);
          }  
          (_1307_aSyscall[i].pCurrent = pNewFunc);
          break;
        }  
      }  
      if (((id2i_use_pread && id2i_use_pread64) )) {
        if ((strcmp(zName, _1308_aSyscall[i].zName) == 0)) {
          if ((_1308_aSyscall[i].pDefault == 0)) {
            (_1308_aSyscall[i].pDefault = _1308_aSyscall[i].pCurrent);
          }  
          (rc = 0);
          if ((pNewFunc == 0)) {
            (pNewFunc = _1308_aSyscall[i].pDefault);
          }  
          (_1308_aSyscall[i].pCurrent = pNewFunc);
          break;
        }  
      }  
    }
  }
  return rc;
}
static  sqlite3_syscall_ptr unixGetSystemCall(sqlite3_vfs *pNotUsed , const  char *zName )  {
  unsigned int i;
  ((void ) pNotUsed);
  for ((i = 0); (((id2i_use_pread && id2i_use_pread64) ) ? (i < (sizeof(_1308_aSyscall) / sizeof(_1308_aSyscall[0]))) : (((id2i_use_pread && (! id2i_use_pread64)) ) ? (i < (sizeof(_1307_aSyscall) / sizeof(_1307_aSyscall[0]))) : ((((! id2i_use_pread) && id2i_use_pread64) ) ? (i < (sizeof(_1306_aSyscall) / sizeof(_1306_aSyscall[0]))) : (i < (sizeof(_1305_aSyscall) / sizeof(_1305_aSyscall[0])))))); i++) {
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      if ((strcmp(zName, _1305_aSyscall[i].zName) == 0)) {
        return _1305_aSyscall[i].pCurrent;
      }  
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      if ((strcmp(zName, _1306_aSyscall[i].zName) == 0)) {
        return _1306_aSyscall[i].pCurrent;
      }  
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      if ((strcmp(zName, _1307_aSyscall[i].zName) == 0)) {
        return _1307_aSyscall[i].pCurrent;
      }  
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      if ((strcmp(zName, _1308_aSyscall[i].zName) == 0)) {
        return _1308_aSyscall[i].pCurrent;
      }  
    }  
  }
  return 0;
}
static  const  char *unixNextSystemCall(sqlite3_vfs *p , const  char *zName )  {
  int i =  (- 1);
  ((void ) p);
  if (zName) {
    for ((i = 0); (((id2i_use_pread && id2i_use_pread64) ) ? (i < (((int ) (sizeof(_1308_aSyscall) / sizeof(_1308_aSyscall[0]))) - 1)) : (((id2i_use_pread && (! id2i_use_pread64)) ) ? (i < (((int ) (sizeof(_1307_aSyscall) / sizeof(_1307_aSyscall[0]))) - 1)) : ((((! id2i_use_pread) && id2i_use_pread64) ) ? (i < (((int ) (sizeof(_1306_aSyscall) / sizeof(_1306_aSyscall[0]))) - 1)) : (i < (((int ) (sizeof(_1305_aSyscall) / sizeof(_1305_aSyscall[0]))) - 1))))); i++) {
      if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
        if ((strcmp(zName, _1305_aSyscall[i].zName) == 0)) {
          break;
        }  
      }  
      if ((((! id2i_use_pread) && id2i_use_pread64) )) {
        if ((strcmp(zName, _1306_aSyscall[i].zName) == 0)) {
          break;
        }  
      }  
      if (((id2i_use_pread && (! id2i_use_pread64)) )) {
        if ((strcmp(zName, _1307_aSyscall[i].zName) == 0)) {
          break;
        }  
      }  
      if (((id2i_use_pread && id2i_use_pread64) )) {
        if ((strcmp(zName, _1308_aSyscall[i].zName) == 0)) {
          break;
        }  
      }  
    }
  }  
  for (i++; (((id2i_use_pread && id2i_use_pread64) ) ? (i < ((int ) (sizeof(_1308_aSyscall) / sizeof(_1308_aSyscall[0])))) : (((id2i_use_pread && (! id2i_use_pread64)) ) ? (i < ((int ) (sizeof(_1307_aSyscall) / sizeof(_1307_aSyscall[0])))) : ((((! id2i_use_pread) && id2i_use_pread64) ) ? (i < ((int ) (sizeof(_1306_aSyscall) / sizeof(_1306_aSyscall[0])))) : (i < ((int ) (sizeof(_1305_aSyscall) / sizeof(_1305_aSyscall[0]))))))); i++) {
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      if ((_1305_aSyscall[i].pCurrent != 0)) {
        return _1305_aSyscall[i].zName;
      }  
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      if ((_1306_aSyscall[i].pCurrent != 0)) {
        return _1306_aSyscall[i].zName;
      }  
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      if ((_1307_aSyscall[i].pCurrent != 0)) {
        return _1307_aSyscall[i].zName;
      }  
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      if ((_1308_aSyscall[i].pCurrent != 0)) {
        return _1308_aSyscall[i].zName;
      }  
    }  
  }
  return 0;
}
static  int robust_open(const  char *z , int f , mode_t m )  {
  int fd;
  mode_t m2 =  (m ? m : 0644);
  while (1) {
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      (fd = ((int ( *)(const  char * , int , int )) _1305_aSyscall[0].pCurrent)(z, (f | 02000000), m2));
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      (fd = ((int ( *)(const  char * , int , int )) _1306_aSyscall[0].pCurrent)(z, (f | 02000000), m2));
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      (fd = ((int ( *)(const  char * , int , int )) _1307_aSyscall[0].pCurrent)(z, (f | 02000000), m2));
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      (fd = ((int ( *)(const  char * , int , int )) _1308_aSyscall[0].pCurrent)(z, (f | 02000000), m2));
    }  
    if ((fd < 0)) {
      if (((*__errno_location()) == 4)) {
        continue;
      }  
      break;
    }  
    if ((fd >= 3)) {
      break;
    }  
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      ((int ( *)(int )) _1305_aSyscall[1].pCurrent)(fd);
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      ((int ( *)(int )) _1306_aSyscall[1].pCurrent)(fd);
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      ((int ( *)(int )) _1307_aSyscall[1].pCurrent)(fd);
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      ((int ( *)(int )) _1308_aSyscall[1].pCurrent)(fd);
    }  
    sqlite3_log(28, "attempt to open \"%s\" as file descriptor %d", z, fd);
    (fd = (- 1));
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      if ((((int ( *)(const  char * , int , int )) _1305_aSyscall[0].pCurrent)("/dev/null", f, m) < 0)) {
        break;
      }  
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      if ((((int ( *)(const  char * , int , int )) _1306_aSyscall[0].pCurrent)("/dev/null", f, m) < 0)) {
        break;
      }  
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      if ((((int ( *)(const  char * , int , int )) _1307_aSyscall[0].pCurrent)("/dev/null", f, m) < 0)) {
        break;
      }  
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      if ((((int ( *)(const  char * , int , int )) _1308_aSyscall[0].pCurrent)("/dev/null", f, m) < 0)) {
        break;
      }  
    }  
  }
  if ((fd >= 0)) {
    if ((m != 0)) {
      struct  stat   statbuf;
      if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
        if (((((int ( *)(int , struct  stat   * )) _1305_aSyscall[5].pCurrent)(fd, (&statbuf)) == 0) && (statbuf.st_size == 0) && ((statbuf.st_mode & 0777) != m))) {
          ((int ( *)(int , mode_t )) _1305_aSyscall[14].pCurrent)(fd, m);
        }  
      }  
      if ((((! id2i_use_pread) && id2i_use_pread64) )) {
        if (((((int ( *)(int , struct  stat   * )) _1306_aSyscall[5].pCurrent)(fd, (&statbuf)) == 0) && (statbuf.st_size == 0) && ((statbuf.st_mode & 0777) != m))) {
          ((int ( *)(int , mode_t )) _1306_aSyscall[14].pCurrent)(fd, m);
        }  
      }  
      if (((id2i_use_pread && (! id2i_use_pread64)) )) {
        if (((((int ( *)(int , struct  stat   * )) _1307_aSyscall[5].pCurrent)(fd, (&statbuf)) == 0) && (statbuf.st_size == 0) && ((statbuf.st_mode & 0777) != m))) {
          ((int ( *)(int , mode_t )) _1307_aSyscall[14].pCurrent)(fd, m);
        }  
      }  
      if (((id2i_use_pread && id2i_use_pread64) )) {
        if (((((int ( *)(int , struct  stat   * )) _1308_aSyscall[5].pCurrent)(fd, (&statbuf)) == 0) && (statbuf.st_size == 0) && ((statbuf.st_mode & 0777) != m))) {
          ((int ( *)(int , mode_t )) _1308_aSyscall[14].pCurrent)(fd, m);
        }  
      }  
    }  
  }  
  return fd;
}
static  void unixEnterMutex(void )  {
  
}
static  void unixLeaveMutex(void )  {
  
}
static  int robust_ftruncate(int h , sqlite3_int64 sz )  {
  int rc;
  do {
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      (rc = ((int ( *)(int , off_t )) _1305_aSyscall[6].pCurrent)(h, sz));
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      (rc = ((int ( *)(int , off_t )) _1306_aSyscall[6].pCurrent)(h, sz));
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      (rc = ((int ( *)(int , off_t )) _1307_aSyscall[6].pCurrent)(h, sz));
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      (rc = ((int ( *)(int , off_t )) _1308_aSyscall[6].pCurrent)(h, sz));
    }  
  } while (((rc < 0) && ((*__errno_location()) == 4)));
  return rc;
}
static  int sqliteErrorFromPosixError(int posixError , int sqliteIOErr )  {
  switch (posixError) {
    case 11:
    case 110:
    case 16:
    case 4:
    case 37:
    return 5;
    case 13:
    if (((sqliteIOErr == (10 | (15 << 8))) || (sqliteIOErr == (10 | (8 << 8))) || (sqliteIOErr == (10 | (9 << 8))) || (sqliteIOErr == (10 | (14 << 8))))) {
      return 5;
    }  
    case 1:
    return 3;
    case 95:
    case 5:
    case 9:
    case 22:
    case 107:
    case 19:
    case 6:
    case 2:
    case 116:
    case 38:
    id2i_label_1:
    default:
    return sqliteIOErr;
  }
}
struct  vxworksFileId {
  struct  vxworksFileId   *pNext ;
  int nRef ;
  int nName ;
  char *zCanonicalName ;
}  ;
struct  unixFileId {
  dev_t dev ;
  ino_t ino ;
}  ;
struct  unixInodeInfo {
  struct  unixFileId   fileId ;
  int nShared ;
  unsigned  char eFileLock ;
  unsigned  char bProcessLock ;
  int nRef ;
  unixShmNode *pShmNode ;
  int nLock ;
  UnixUnusedFd *pUnused ;
  unixInodeInfo *pNext ;
  unixInodeInfo *pPrev ;
}  ;
static unixInodeInfo *inodeList =  0;
static  int unixLogErrorAtLine(int errcode , const  char *zFunc , const  char *zPath , int iLine )  {
  char *zErr;
  int iErrno =  (*__errno_location());
  (zErr = strerror(iErrno));
  if ((zPath == 0)) {
    (zPath = "");
  }  
  sqlite3_log(errcode, "os_unix.c:%d: (%d) %s(%s) - %s", iLine, iErrno, zFunc, zPath, zErr);
  return errcode;
}
static  void robust_close(unixFile *pFile , int h , int lineno )  {
  if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
    if (((int ( *)(int )) _1305_aSyscall[1].pCurrent)(h)) {
      unixLogErrorAtLine((10 | (16 << 8)), "close", (pFile ? pFile->zPath : 0), lineno);
    }  
  }  
  if ((((! id2i_use_pread) && id2i_use_pread64) )) {
    if (((int ( *)(int )) _1306_aSyscall[1].pCurrent)(h)) {
      unixLogErrorAtLine((10 | (16 << 8)), "close", (pFile ? pFile->zPath : 0), lineno);
    }  
  }  
  if (((id2i_use_pread && (! id2i_use_pread64)) )) {
    if (((int ( *)(int )) _1307_aSyscall[1].pCurrent)(h)) {
      unixLogErrorAtLine((10 | (16 << 8)), "close", (pFile ? pFile->zPath : 0), lineno);
    }  
  }  
  if (((id2i_use_pread && id2i_use_pread64) )) {
    if (((int ( *)(int )) _1308_aSyscall[1].pCurrent)(h)) {
      unixLogErrorAtLine((10 | (16 << 8)), "close", (pFile ? pFile->zPath : 0), lineno);
    }  
  }  
}
static  void closePendingFds(unixFile *pFile )  {
  unixInodeInfo *pInode =  pFile->pInode;
  UnixUnusedFd *p;
  UnixUnusedFd *pNext;
  for ((p = pInode->pUnused); p; (p = pNext)) {
    (pNext = p->pNext);
    robust_close(pFile, p->fd, 24191);
    sqlite3_free(p);
  }
  (pInode->pUnused = 0);
}
static  void releaseInodeInfo(unixFile *pFile )  {
  unixInodeInfo *pInode =  pFile->pInode;
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      pInode->nRef--;
      if ((pInode->nRef == 0)) {
        ((void ) 0);
        closePendingFds(pFile);
        if (pInode->pPrev) {
          ((void ) 0);
          (pInode->pPrev->pNext = pInode->pNext);
        }  
        else {
          ((void ) 0);
          (inodeList = pInode->pNext);
        }
        if (pInode->pNext) {
          ((void ) 0);
          (pInode->pNext->pPrev = pInode->pPrev);
        }  
        sqlite3_free(pInode);
      }  
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pInode) {
      pInode->nRef--;
      if ((pInode->nRef == 0)) {
        ((void ) 0);
        closePendingFds(pFile);
        if (pInode->pPrev) {
          ((void ) 0);
          (pInode->pPrev->pNext = pInode->pNext);
        }  
        else {
          ((void ) 0);
          (inodeList = pInode->pNext);
        }
        if (pInode->pNext) {
          ((void ) 0);
          (pInode->pNext->pPrev = pInode->pPrev);
        }  
        sqlite3_free(pInode);
      }  
    }  
  }  
}
static  int findInodeInfo(unixFile *pFile , unixInodeInfo **ppInode )  {
  int rc;
  int fd;
  struct  unixFileId   fileId;
  struct  stat   statbuf;
  unixInodeInfo *pInode =  0;
  ((void ) 0);
  (fd = pFile->h);
  if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
    (rc = ((int ( *)(int , struct  stat   * )) _1305_aSyscall[5].pCurrent)(fd, (&statbuf)));
  }  
  if ((((! id2i_use_pread) && id2i_use_pread64) )) {
    (rc = ((int ( *)(int , struct  stat   * )) _1306_aSyscall[5].pCurrent)(fd, (&statbuf)));
  }  
  if (((id2i_use_pread && (! id2i_use_pread64)) )) {
    (rc = ((int ( *)(int , struct  stat   * )) _1307_aSyscall[5].pCurrent)(fd, (&statbuf)));
  }  
  if (((id2i_use_pread && id2i_use_pread64) )) {
    (rc = ((int ( *)(int , struct  stat   * )) _1308_aSyscall[5].pCurrent)(fd, (&statbuf)));
  }  
  if ((rc != 0)) {
    (pFile->lastErrno = (*__errno_location()));
    if ((pFile->lastErrno == 75)) {
      return 22;
    }  
    return 10;
  }  
  memset((&fileId), 0, sizeof(fileId));
  (fileId.dev = statbuf.st_dev);
  (fileId.ino = statbuf.st_ino);
  (pInode = inodeList);
  while ((pInode && memcmp((&fileId), (&pInode->fileId), sizeof(fileId)))) {
    (pInode = pInode->pNext);
  }
  if ((pInode == 0)) {
    (pInode = sqlite3_malloc(sizeof((*pInode))));
    if ((pInode == 0)) {
      return 7;
    }  
    memset(pInode, 0, sizeof((*pInode)));
    memcpy((&pInode->fileId), (&fileId), sizeof(fileId));
    (pInode->nRef = 1);
    (pInode->pNext = inodeList);
    (pInode->pPrev = 0);
    if (inodeList) {
      (inodeList->pPrev = pInode);
    }  
    (inodeList = pInode);
  }  
  else {
    pInode->nRef++;
  }
  ((*ppInode) = pInode);
  return 0;
}
static  void verifyDbFile(unixFile *pFile )  {
  struct  stat   buf;
  int rc;
  if ((pFile->ctrlFlags & 0x0100)) {
    return;
  }  
  if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
    (rc = ((int ( *)(int , struct  stat   * )) _1305_aSyscall[5].pCurrent)(pFile->h, (&buf)));
  }  
  if ((((! id2i_use_pread) && id2i_use_pread64) )) {
    (rc = ((int ( *)(int , struct  stat   * )) _1306_aSyscall[5].pCurrent)(pFile->h, (&buf)));
  }  
  if (((id2i_use_pread && (! id2i_use_pread64)) )) {
    (rc = ((int ( *)(int , struct  stat   * )) _1307_aSyscall[5].pCurrent)(pFile->h, (&buf)));
  }  
  if (((id2i_use_pread && id2i_use_pread64) )) {
    (rc = ((int ( *)(int , struct  stat   * )) _1308_aSyscall[5].pCurrent)(pFile->h, (&buf)));
  }  
  if ((rc != 0)) {
    sqlite3_log(28, "cannot fstat db file %s", pFile->zPath);
    (pFile->ctrlFlags |= 0x0100);
    return;
  }  
  if (((buf.st_nlink == 0) && ((pFile->ctrlFlags & 0x20) == 0))) {
    sqlite3_log(28, "file unlinked while open: %s", pFile->zPath);
    (pFile->ctrlFlags |= 0x0100);
    return;
  }  
  if ((buf.st_nlink > 1)) {
    sqlite3_log(28, "multiple links to file: %s", pFile->zPath);
    (pFile->ctrlFlags |= 0x0100);
    return;
  }  
  if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
    if (((pFile->pInode != 0) && (((rc = ((int ( *)(const  char * , struct  stat   * )) _1305_aSyscall[4].pCurrent)(pFile->zPath, (&buf))) != 0) || (buf.st_ino != pFile->pInode->fileId.ino)))) {
      sqlite3_log(28, "file renamed while open: %s", pFile->zPath);
      (pFile->ctrlFlags |= 0x0100);
      return;
    }  
  }  
  if ((((! id2i_use_pread) && id2i_use_pread64) )) {
    if (((pFile->pInode != 0) && (((rc = ((int ( *)(const  char * , struct  stat   * )) _1306_aSyscall[4].pCurrent)(pFile->zPath, (&buf))) != 0) || (buf.st_ino != pFile->pInode->fileId.ino)))) {
      sqlite3_log(28, "file renamed while open: %s", pFile->zPath);
      (pFile->ctrlFlags |= 0x0100);
      return;
    }  
  }  
  if (((id2i_use_pread && (! id2i_use_pread64)) )) {
    if (((pFile->pInode != 0) && (((rc = ((int ( *)(const  char * , struct  stat   * )) _1307_aSyscall[4].pCurrent)(pFile->zPath, (&buf))) != 0) || (buf.st_ino != pFile->pInode->fileId.ino)))) {
      sqlite3_log(28, "file renamed while open: %s", pFile->zPath);
      (pFile->ctrlFlags |= 0x0100);
      return;
    }  
  }  
  if (((id2i_use_pread && id2i_use_pread64) )) {
    if (((pFile->pInode != 0) && (((rc = ((int ( *)(const  char * , struct  stat   * )) _1308_aSyscall[4].pCurrent)(pFile->zPath, (&buf))) != 0) || (buf.st_ino != pFile->pInode->fileId.ino)))) {
      sqlite3_log(28, "file renamed while open: %s", pFile->zPath);
      (pFile->ctrlFlags |= 0x0100);
      return;
    }  
  }  
}
static  int unixCheckReservedLock(sqlite3_file *id , int *pResOut )  {
  int rc =  0;
  int reserved =  0;
  unixFile *pFile =  ((unixFile *) id);
  ((void ) 0);
  unixEnterMutex();
  if ((pFile->pInode->eFileLock > 1)) {
    (reserved = 1);
  }  
  if (((! reserved) && (! pFile->pInode->bProcessLock))) {
    struct  flock   lock;
    (lock.l_whence = 0);
    (lock.l_start = (sqlite3PendingByte + 1));
    (lock.l_len = 1);
    (lock.l_type = 1);
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      if (((int ( *)(int , int , ...)) _1305_aSyscall[7].pCurrent)(pFile->h, 5, (&lock))) {
        (rc = (10 | (14 << 8)));
        (pFile->lastErrno = (*__errno_location()));
      } 
      else if ((lock.l_type != 2)) {
        (reserved = 1);
      } 
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      if (((int ( *)(int , int , ...)) _1306_aSyscall[7].pCurrent)(pFile->h, 5, (&lock))) {
        (rc = (10 | (14 << 8)));
        (pFile->lastErrno = (*__errno_location()));
      } 
      else if ((lock.l_type != 2)) {
        (reserved = 1);
      } 
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      if (((int ( *)(int , int , ...)) _1307_aSyscall[7].pCurrent)(pFile->h, 5, (&lock))) {
        (rc = (10 | (14 << 8)));
        (pFile->lastErrno = (*__errno_location()));
      } 
      else if ((lock.l_type != 2)) {
        (reserved = 1);
      } 
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      if (((int ( *)(int , int , ...)) _1308_aSyscall[7].pCurrent)(pFile->h, 5, (&lock))) {
        (rc = (10 | (14 << 8)));
        (pFile->lastErrno = (*__errno_location()));
      } 
      else if ((lock.l_type != 2)) {
        (reserved = 1);
      } 
    }  
  }  
  unixLeaveMutex();
  ((*pResOut) = reserved);
  return rc;
}
static  int unixFileLock(unixFile *pFile , struct  flock   *pLock )  {
  int rc;
  unixInodeInfo *pInode =  pFile->pInode;
  ((void ) 0);
  ((void ) 0);
  if (((((pFile->ctrlFlags & 0x01) != 0) || pInode->bProcessLock) && ((pFile->ctrlFlags & 0x02) == 0))) {
    if ((pInode->bProcessLock == 0)) {
      struct  flock   lock;
      ((void ) 0);
      (lock.l_whence = 0);
      (lock.l_start = (sqlite3PendingByte + 2));
      (lock.l_len = 510);
      (lock.l_type = 1);
      if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
        (rc = ((int ( *)(int , int , ...)) _1305_aSyscall[7].pCurrent)(pFile->h, 6, (&lock)));
      }  
      if ((((! id2i_use_pread) && id2i_use_pread64) )) {
        (rc = ((int ( *)(int , int , ...)) _1306_aSyscall[7].pCurrent)(pFile->h, 6, (&lock)));
      }  
      if (((id2i_use_pread && (! id2i_use_pread64)) )) {
        (rc = ((int ( *)(int , int , ...)) _1307_aSyscall[7].pCurrent)(pFile->h, 6, (&lock)));
      }  
      if (((id2i_use_pread && id2i_use_pread64) )) {
        (rc = ((int ( *)(int , int , ...)) _1308_aSyscall[7].pCurrent)(pFile->h, 6, (&lock)));
      }  
      if ((rc < 0)) {
        return rc;
      }  
      (pInode->bProcessLock = 1);
      pInode->nLock++;
    }  
    else {
      (rc = 0);
    }
  }  
  else {
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      (rc = ((int ( *)(int , int , ...)) _1305_aSyscall[7].pCurrent)(pFile->h, 6, pLock));
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      (rc = ((int ( *)(int , int , ...)) _1306_aSyscall[7].pCurrent)(pFile->h, 6, pLock));
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      (rc = ((int ( *)(int , int , ...)) _1307_aSyscall[7].pCurrent)(pFile->h, 6, pLock));
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      (rc = ((int ( *)(int , int , ...)) _1308_aSyscall[7].pCurrent)(pFile->h, 6, pLock));
    }  
  }
  return rc;
}
static  int unixLock(sqlite3_file *id , int eFileLock )  {
  int rc =  0;
  unixFile *pFile =  ((unixFile *) id);
  unixInodeInfo *pInode;
  struct  flock   lock;
  int tErrno =  0;
  ((void ) 0);
  if ((pFile->eFileLock >= eFileLock)) {
    return 0;
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  unixEnterMutex();
  (pInode = pFile->pInode);
  if (((pFile->eFileLock != pInode->eFileLock) && ((pInode->eFileLock >= 3) || (eFileLock > 1)))) {
    (rc = 5);
    goto end_lock;
  }  
  if (((eFileLock == 1) && ((pInode->eFileLock == 1) || (pInode->eFileLock == 2)))) {
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    (pFile->eFileLock = 1);
    pInode->nShared++;
    pInode->nLock++;
    goto end_lock;
  }  
  (lock.l_len = 1L);
  (lock.l_whence = 0);
  if (((eFileLock == 1) || ((eFileLock == 4) && (pFile->eFileLock < 3)))) {
    (lock.l_type = ((eFileLock == 1) ? 0 : 1));
    (lock.l_start = sqlite3PendingByte);
    if (unixFileLock(pFile, (&lock))) {
      (tErrno = (*__errno_location()));
      (rc = sqliteErrorFromPosixError(tErrno, (10 | (15 << 8))));
      if ((rc != 5)) {
        (pFile->lastErrno = tErrno);
      }  
      goto end_lock;
    }  
  }  
  if ((eFileLock == 1)) {
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    (lock.l_start = (sqlite3PendingByte + 2));
    (lock.l_len = 510);
    if (unixFileLock(pFile, (&lock))) {
      (tErrno = (*__errno_location()));
      (rc = sqliteErrorFromPosixError(tErrno, (10 | (15 << 8))));
    }  
    (lock.l_start = sqlite3PendingByte);
    (lock.l_len = 1L);
    (lock.l_type = 2);
    if ((unixFileLock(pFile, (&lock)) && (rc == 0))) {
      (tErrno = (*__errno_location()));
      (rc = (10 | (8 << 8)));
    }  
    if (rc) {
      if ((rc != 5)) {
        (pFile->lastErrno = tErrno);
      }  
      goto end_lock;
    }  
    else {
      (pFile->eFileLock = 1);
      pInode->nLock++;
      (pInode->nShared = 1);
    }
  } 
  else if (((eFileLock == 4) && (pInode->nShared > 1))) {
    (rc = 5);
  } 
  else {
    ((void ) 0);
    (lock.l_type = 1);
    ((void ) 0);
    if ((eFileLock == 2)) {
      (lock.l_start = (sqlite3PendingByte + 1));
      (lock.l_len = 1L);
    }  
    else {
      (lock.l_start = (sqlite3PendingByte + 2));
      (lock.l_len = 510);
    }
    if (unixFileLock(pFile, (&lock))) {
      (tErrno = (*__errno_location()));
      (rc = sqliteErrorFromPosixError(tErrno, (10 | (15 << 8))));
      if ((rc != 5)) {
        (pFile->lastErrno = tErrno);
      }  
    }  
  }
  if ((rc == 0)) {
    (pFile->eFileLock = eFileLock);
    (pInode->eFileLock = eFileLock);
  } 
  else if ((eFileLock == 4)) {
    (pFile->eFileLock = 3);
    (pInode->eFileLock = 3);
  } 
  end_lock:
  unixLeaveMutex();
  return rc;
}
static  void setPendingFd(unixFile *pFile )  {
  unixInodeInfo *pInode =  pFile->pInode;
  UnixUnusedFd *p =  pFile->pUnused;
  (p->pNext = pInode->pUnused);
  (pInode->pUnused = p);
  (pFile->h = (- 1));
  (pFile->pUnused = 0);
}
static  int posixUnlock(sqlite3_file *id , int eFileLock , int handleNFSUnlock )  {
  unixFile *pFile =  ((unixFile *) id);
  unixInodeInfo *pInode;
  struct  flock   lock;
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  if ((pFile->eFileLock <= eFileLock)) {
    return 0;
  }  
  unixEnterMutex();
  (pInode = pFile->pInode);
  ((void ) 0);
  if ((pFile->eFileLock > 1)) {
    ((void ) 0);
    if ((eFileLock == 1)) {
      ((void ) handleNFSUnlock);
      ((void ) 0);
      {
        (lock.l_type = 0);
        (lock.l_whence = 0);
        (lock.l_start = (sqlite3PendingByte + 2));
        (lock.l_len = 510);
        if (unixFileLock(pFile, (&lock))) {
          (rc = (10 | (9 << 8)));
          (pFile->lastErrno = (*__errno_location()));
          goto end_unlock;
        }  
      }
    }  
    (lock.l_type = 2);
    (lock.l_whence = 0);
    (lock.l_start = sqlite3PendingByte);
    (lock.l_len = 2L);
    ((void ) 0);
    if ((unixFileLock(pFile, (&lock)) == 0)) {
      (pInode->eFileLock = 1);
    }  
    else {
      (rc = (10 | (8 << 8)));
      (pFile->lastErrno = (*__errno_location()));
      goto end_unlock;
    }
  }  
  if ((eFileLock == 0)) {
    pInode->nShared--;
    if ((pInode->nShared == 0)) {
      (lock.l_type = 2);
      (lock.l_whence = 0);
      (lock.l_start = (lock.l_len = 0L));
      if ((unixFileLock(pFile, (&lock)) == 0)) {
        (pInode->eFileLock = 0);
      }  
      else {
        (rc = (10 | (8 << 8)));
        (pFile->lastErrno = (*__errno_location()));
        (pInode->eFileLock = 0);
        (pFile->eFileLock = 0);
      }
    }  
    pInode->nLock--;
    ((void ) 0);
    if ((pInode->nLock == 0)) {
      closePendingFds(pFile);
    }  
  }  
  end_unlock:
  unixLeaveMutex();
  if ((rc == 0)) {
    (pFile->eFileLock = eFileLock);
  }  
  return rc;
}
static  int unixUnlock(sqlite3_file *id , int eFileLock )  {
  ((void ) 0);
  return posixUnlock(id, eFileLock, 0);
}
static  int closeUnixFile(sqlite3_file *id )  {
  unixFile *pFile =  ((unixFile *) id);
  if ((pFile->h >= 0)) {
    robust_close(pFile, pFile->h, 24917);
    (pFile->h = (- 1));
  }  
  sqlite3_free(pFile->pUnused);
  memset(pFile, 0, sizeof(unixFile ));
  return 0;
}
static  int unixClose(sqlite3_file *id )  {
  int rc =  0;
  unixFile *pFile =  ((unixFile *) id);
  verifyDbFile(pFile);
  unixUnlock(id, 0);
  unixEnterMutex();
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((1 && pFile->pInode->nLock)) {
      setPendingFd(pFile);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pFile->pInode && pFile->pInode->nLock)) {
      setPendingFd(pFile);
    }  
  }  
  releaseInodeInfo(pFile);
  (rc = closeUnixFile(id));
  unixLeaveMutex();
  return rc;
}
static  int nolockCheckReservedLock(sqlite3_file *NotUsed , int *pResOut )  {
  ((void ) NotUsed);
  ((*pResOut) = 0);
  return 0;
}
static  int nolockLock(sqlite3_file *NotUsed , int NotUsed2 )  {
  ((void ) NotUsed), ((void ) NotUsed2);
  return 0;
}
static  int nolockUnlock(sqlite3_file *NotUsed , int NotUsed2 )  {
  ((void ) NotUsed), ((void ) NotUsed2);
  return 0;
}
static  int nolockClose(sqlite3_file *id )  {
  return closeUnixFile(id);
}
static  int dotlockCheckReservedLock(sqlite3_file *id , int *pResOut )  {
  int rc =  0;
  int reserved =  0;
  unixFile *pFile =  ((unixFile *) id);
  ((void ) 0);
  if ((pFile->eFileLock > 1)) {
    (reserved = 1);
  }  
  else {
    const char *zLockFile =  ((const  char *) pFile->lockingContext);
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      (reserved = (((int ( *)(const  char * , int )) _1305_aSyscall[2].pCurrent)(zLockFile, 0) == 0));
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      (reserved = (((int ( *)(const  char * , int )) _1306_aSyscall[2].pCurrent)(zLockFile, 0) == 0));
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      (reserved = (((int ( *)(const  char * , int )) _1307_aSyscall[2].pCurrent)(zLockFile, 0) == 0));
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      (reserved = (((int ( *)(const  char * , int )) _1308_aSyscall[2].pCurrent)(zLockFile, 0) == 0));
    }  
  }
  ((*pResOut) = reserved);
  return rc;
}
static  int dotlockLock(sqlite3_file *id , int eFileLock )  {
  unixFile *pFile =  ((unixFile *) id);
  char *zLockFile =  ((char *) pFile->lockingContext);
  int rc =  0;
  if ((pFile->eFileLock > 0)) {
    (pFile->eFileLock = eFileLock);
    utimes(zLockFile, ((void *) 0));
    return 0;
  }  
  if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
    (rc = ((int ( *)(const  char * , mode_t )) _1305_aSyscall[18].pCurrent)(zLockFile, 0777));
  }  
  if ((((! id2i_use_pread) && id2i_use_pread64) )) {
    (rc = ((int ( *)(const  char * , mode_t )) _1306_aSyscall[18].pCurrent)(zLockFile, 0777));
  }  
  if (((id2i_use_pread && (! id2i_use_pread64)) )) {
    (rc = ((int ( *)(const  char * , mode_t )) _1307_aSyscall[18].pCurrent)(zLockFile, 0777));
  }  
  if (((id2i_use_pread && id2i_use_pread64) )) {
    (rc = ((int ( *)(const  char * , mode_t )) _1308_aSyscall[18].pCurrent)(zLockFile, 0777));
  }  
  if ((rc < 0)) {
    int tErrno =  (*__errno_location());
    if ((17 == tErrno)) {
      (rc = 5);
    }  
    else {
      (rc = sqliteErrorFromPosixError(tErrno, (10 | (15 << 8))));
      if (((rc != 0) && (rc != 5))) {
        (pFile->lastErrno = tErrno);
      }  
    }
    return rc;
  }  
  (pFile->eFileLock = eFileLock);
  return rc;
}
static  int dotlockUnlock(sqlite3_file *id , int eFileLock )  {
  unixFile *pFile =  ((unixFile *) id);
  char *zLockFile =  ((char *) pFile->lockingContext);
  int rc;
  ((void ) 0);
  ((void ) 0);
  if ((pFile->eFileLock == eFileLock)) {
    return 0;
  }  
  if ((eFileLock == 1)) {
    (pFile->eFileLock = 1);
    return 0;
  }  
  ((void ) 0);
  if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
    (rc = ((int ( *)(const  char * )) _1305_aSyscall[19].pCurrent)(zLockFile));
  }  
  if ((((! id2i_use_pread) && id2i_use_pread64) )) {
    (rc = ((int ( *)(const  char * )) _1306_aSyscall[19].pCurrent)(zLockFile));
  }  
  if (((id2i_use_pread && (! id2i_use_pread64)) )) {
    (rc = ((int ( *)(const  char * )) _1307_aSyscall[19].pCurrent)(zLockFile));
  }  
  if (((id2i_use_pread && id2i_use_pread64) )) {
    (rc = ((int ( *)(const  char * )) _1308_aSyscall[19].pCurrent)(zLockFile));
  }  
  if (((rc < 0) && ((*__errno_location()) == 20))) {
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      (rc = ((int ( *)(const  char * )) _1305_aSyscall[16].pCurrent)(zLockFile));
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      (rc = ((int ( *)(const  char * )) _1306_aSyscall[16].pCurrent)(zLockFile));
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      (rc = ((int ( *)(const  char * )) _1307_aSyscall[16].pCurrent)(zLockFile));
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      (rc = ((int ( *)(const  char * )) _1308_aSyscall[16].pCurrent)(zLockFile));
    }  
  }  
  if ((rc < 0)) {
    int tErrno =  (*__errno_location());
    (rc = 0);
    if ((2 != tErrno)) {
      (rc = (10 | (8 << 8)));
    }  
    if (((rc != 0) && (rc != 5))) {
      (pFile->lastErrno = tErrno);
    }  
    return rc;
  }  
  (pFile->eFileLock = 0);
  return 0;
}
static  int dotlockClose(sqlite3_file *id )  {
  int rc =  0;
  if (id) {
    unixFile *pFile =  ((unixFile *) id);
    dotlockUnlock(id, 0);
    sqlite3_free(pFile->lockingContext);
    (rc = closeUnixFile(id));
  }  
  return rc;
}
static  int seekAndRead(unixFile *id , sqlite3_int64 offset , void *pBuf , int cnt )  {
  int got;
  int prior =  0;
  i64 newOffset;
  ((void ) 0);
  ((void ) 0);
  (cnt &= 0x1ffff);
  do {
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      (got = ((ssize_t ( *)(int , void * , size_t , off_t )) _1307_aSyscall[9].pCurrent)(id->h, pBuf, cnt, offset));
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      (got = ((ssize_t ( *)(int , void * , size_t , off_t )) _1308_aSyscall[9].pCurrent)(id->h, pBuf, cnt, offset));
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      (got = ((ssize_t ( *)(int , void * , size_t , off_t )) _1306_aSyscall[10].pCurrent)(id->h, pBuf, cnt, offset));
    }  
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      (newOffset = lseek(id->h, offset, 0));
    }  
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      if ((newOffset != offset)) {
        if ((newOffset == (- 1))) {
          (((unixFile *) id)->lastErrno = (*__errno_location()));
        }  
        else {
          (((unixFile *) id)->lastErrno = 0);
        }
        return (- 1);
      }  
    }  
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      (got = ((ssize_t ( *)(int , void * , size_t )) _1305_aSyscall[8].pCurrent)(id->h, pBuf, cnt));
    }  
    if ((got == cnt)) {
      break;
    }  
    if ((got < 0)) {
      if (((*__errno_location()) == 4)) {
        (got = 1);
        continue;
      }  
      (prior = 0);
      (((unixFile *) id)->lastErrno = (*__errno_location()));
      break;
    } 
    else if ((got > 0)) {
      (cnt -= got);
      (offset += got);
      (prior += got);
      (pBuf = ((void *) (got + ((char *) pBuf))));
    } 
  } while ((got > 0));
  return (got + prior);
}
static  int unixRead(sqlite3_file *id , void *pBuf , int amt , sqlite3_int64 offset )  {
  unixFile *pFile =  ((unixFile *) id);
  int got;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (got = seekAndRead(pFile, offset, pBuf, amt));
  if ((got == amt)) {
    return 0;
  } 
  else if ((got < 0)) {
    return (10 | (1 << 8));
  } 
  else {
    (pFile->lastErrno = 0);
    memset((&((char *) pBuf)[got]), 0, (amt - got));
    return (10 | (2 << 8));
  }
}
static  int seekAndWriteFd(int fd , i64 iOff , const  void *pBuf , int nBuf , int *piErrno )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  (nBuf &= 0x1ffff);
  if (((id2i_use_pread ) )) {
    do {
      if ((((! id2i_use_pread64) ) )) {
        (rc = ((ssize_t ( *)(int , const  void * , size_t , off_t )) _1307_aSyscall[12].pCurrent)(fd, pBuf, nBuf, iOff));
      }  
      if (((id2i_use_pread64 ) )) {
        (rc = ((ssize_t ( *)(int , const  void * , size_t , off_t )) _1308_aSyscall[12].pCurrent)(fd, pBuf, nBuf, iOff));
      }  
    } while (((rc < 0) && ((*__errno_location()) == 4)));
  }  
  if ((((! id2i_use_pread) && id2i_use_pread64) )) {
    do {
      (rc = ((ssize_t ( *)(int , const  void * , size_t , off_t )) _1306_aSyscall[13].pCurrent)(fd, pBuf, nBuf, iOff));
    } while (((rc < 0) && ((*__errno_location()) == 4)));
  }  
  if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
    do {
      i64 iSeek =  lseek(fd, iOff, 0);
      if ((iSeek != iOff)) {
        if (piErrno) {
          ((*piErrno) = ((iSeek == (- 1)) ? (*__errno_location()) : 0));
        }  
        return (- 1);
      }  
      (rc = ((ssize_t ( *)(int , const  void * , size_t )) _1305_aSyscall[11].pCurrent)(fd, pBuf, nBuf));
    } while (((rc < 0) && ((*__errno_location()) == 4)));
  }  
  if (((rc < 0) && piErrno)) {
    ((*piErrno) = (*__errno_location()));
  }  
  return rc;
}
static  int seekAndWrite(unixFile *id , i64 offset , const  void *pBuf , int cnt )  {
  return seekAndWriteFd(id->h, offset, pBuf, cnt, (&id->lastErrno));
}
static  int unixWrite(sqlite3_file *id , const  void *pBuf , int amt , sqlite3_int64 offset )  {
  unixFile *pFile =  ((unixFile *) id);
  int wrote =  0;
  ((void ) 0);
  ((void ) 0);
  while (((amt > 0) && ((wrote = seekAndWrite(pFile, offset, pBuf, amt)) > 0))) {
    (amt -= wrote);
    (offset += wrote);
    (pBuf = (&((char *) pBuf)[wrote]));
  }
  if ((amt > 0)) {
    if (((wrote < 0) && (pFile->lastErrno != 28))) {
      return (10 | (3 << 8));
    }  
    else {
      (pFile->lastErrno = 0);
      return 13;
    }
  }  
  return 0;
}
static  int full_fsync(int fd , int fullSync , int dataOnly )  {
  int rc;
  if (((id2i_sqlite_no_sync ) )) {
    ((void ) fd);
  }  
  if (((id2i_sqlite_no_sync ) )) {
    ((void ) fullSync);
  }  
  if (((id2i_sqlite_no_sync ) )) {
    ((void ) dataOnly);
  }  
  if ((((! id2i_sqlite_no_sync) ) )) {
    ((void ) fullSync);
  }  
  if (((id2i_sqlite_no_sync ) )) {
    (rc = 0);
  }  
  if ((((! id2i_sqlite_no_sync) ) )) {
    ((void ) dataOnly);
  }  
  if ((((! id2i_sqlite_no_sync) ) )) {
    (rc = fsync(fd));
  }  
  if ((0 && (rc != (- 1)))) {
    (rc = 0);
  }  
  return rc;
}
static  int openDirectory(const  char *zFilename , int *pFd )  {
  int ii;
  int fd =  (- 1);
  char zDirname[(512 + 1)];
  sqlite3_snprintf(512, zDirname, "%s", zFilename);
  for ((ii = ((int ) strlen(zDirname))); ((ii > 1) && (zDirname[ii] != '/')); ii--) {
    
  }
  if ((ii > 0)) {
    (zDirname[ii] = '\0');
    (fd = robust_open(zDirname, (00 | 0), 0));
    if ((fd >= 0)) {
      
    }  
  }  
  ((*pFd) = fd);
  return ((fd >= 0) ? 0 : unixLogErrorAtLine(sqlite3CantopenError(26522), "open", zDirname, 26522));
}
static  int unixSync(sqlite3_file *id , int flags )  {
  int rc;
  unixFile *pFile =  ((unixFile *) id);
  int isDataOnly =  (flags & 0x00010);
  int isFullsync =  ((flags & 0x0F) == 0x00003);
  ((void ) 0);
  ((void ) 0);
  (rc = full_fsync(pFile->h, isFullsync, isDataOnly));
  if (rc) {
    (pFile->lastErrno = (*__errno_location()));
    return unixLogErrorAtLine((10 | (4 << 8)), "full_fsync", pFile->zPath, 26563);
  }  
  if ((pFile->ctrlFlags & 0x08)) {
    int dirfd;
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      (rc = ((int ( *)(const  char * , int * )) _1305_aSyscall[17].pCurrent)(pFile->zPath, (&dirfd)));
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      (rc = ((int ( *)(const  char * , int * )) _1306_aSyscall[17].pCurrent)(pFile->zPath, (&dirfd)));
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      (rc = ((int ( *)(const  char * , int * )) _1307_aSyscall[17].pCurrent)(pFile->zPath, (&dirfd)));
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      (rc = ((int ( *)(const  char * , int * )) _1308_aSyscall[17].pCurrent)(pFile->zPath, (&dirfd)));
    }  
    if (((rc == 0) && (dirfd >= 0))) {
      full_fsync(dirfd, 0, 0);
      robust_close(pFile, dirfd, 26577);
    } 
    else if ((rc == 14)) {
      (rc = 0);
    } 
    (pFile->ctrlFlags &= (~ 0x08));
  }  
  return rc;
}
static  int unixTruncate(sqlite3_file *id , i64 nByte )  {
  unixFile *pFile =  ((unixFile *) id);
  int rc;
  ((void ) 0);
  if ((pFile->szChunk > 0)) {
    (nByte = (((nByte + pFile->szChunk - 1) / pFile->szChunk) * pFile->szChunk));
  }  
  (rc = robust_ftruncate(pFile->h, ((off_t ) nByte)));
  if (rc) {
    (pFile->lastErrno = (*__errno_location()));
    return unixLogErrorAtLine((10 | (6 << 8)), "ftruncate", pFile->zPath, 26607);
  }  
  else {
    return 0;
  }
}
static  int unixFileSize(sqlite3_file *id , i64 *pSize )  {
  int rc;
  struct  stat   buf;
  ((void ) 0);
  if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
    (rc = ((int ( *)(int , struct  stat   * )) _1305_aSyscall[5].pCurrent)(((unixFile *) id)->h, (&buf)));
  }  
  if ((((! id2i_use_pread) && id2i_use_pread64) )) {
    (rc = ((int ( *)(int , struct  stat   * )) _1306_aSyscall[5].pCurrent)(((unixFile *) id)->h, (&buf)));
  }  
  if (((id2i_use_pread && (! id2i_use_pread64)) )) {
    (rc = ((int ( *)(int , struct  stat   * )) _1307_aSyscall[5].pCurrent)(((unixFile *) id)->h, (&buf)));
  }  
  if (((id2i_use_pread && id2i_use_pread64) )) {
    (rc = ((int ( *)(int , struct  stat   * )) _1308_aSyscall[5].pCurrent)(((unixFile *) id)->h, (&buf)));
  }  
  if ((rc != 0)) {
    (((unixFile *) id)->lastErrno = (*__errno_location()));
    return (10 | (7 << 8));
  }  
  ((*pSize) = buf.st_size);
  if (((*pSize) == 1)) {
    ((*pSize) = 0);
  }  
  return 0;
}
static  int fcntlSizeHint(unixFile *pFile , i64 nByte )  {
  if ((pFile->szChunk > 0)) {
    i64 nSize;
    struct  stat   buf;
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      if (((int ( *)(int , struct  stat   * )) _1305_aSyscall[5].pCurrent)(pFile->h, (&buf))) {
        return (10 | (7 << 8));
      }  
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      if (((int ( *)(int , struct  stat   * )) _1306_aSyscall[5].pCurrent)(pFile->h, (&buf))) {
        return (10 | (7 << 8));
      }  
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      if (((int ( *)(int , struct  stat   * )) _1307_aSyscall[5].pCurrent)(pFile->h, (&buf))) {
        return (10 | (7 << 8));
      }  
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      if (((int ( *)(int , struct  stat   * )) _1308_aSyscall[5].pCurrent)(pFile->h, (&buf))) {
        return (10 | (7 << 8));
      }  
    }  
    (nSize = (((nByte + pFile->szChunk - 1) / pFile->szChunk) * pFile->szChunk));
    if ((nSize > ((i64 ) buf.st_size))) {
      int nBlk =  buf.st_blksize;
      i64 iWrite;
      if (robust_ftruncate(pFile->h, nSize)) {
        (pFile->lastErrno = (*__errno_location()));
        return unixLogErrorAtLine((10 | (6 << 8)), "ftruncate", pFile->zPath, 26708);
      }  
      (iWrite = ((((buf.st_size + (2 * nBlk) - 1) / nBlk) * nBlk) - 1));
      while ((iWrite < nSize)) {
        int nWrite =  seekAndWrite(pFile, iWrite, "", 1);
        if ((nWrite != 1)) {
          return (10 | (3 << 8));
        }  
        (iWrite += nBlk);
      }
    }  
  }  
  return 0;
}
static  void unixModeBit(unixFile *pFile , unsigned  char mask , int *pArg )  {
  if (((*pArg) < 0)) {
    ((*pArg) = ((pFile->ctrlFlags & mask) != 0));
  } 
  else if (((*pArg) == 0)) {
    (pFile->ctrlFlags &= (~ mask));
  } 
  else {
    (pFile->ctrlFlags |= mask);
  }
}
static int unixGetTempname(int nBuf , char *zBuf );
static  int unixFileControl(sqlite3_file *id , int op , void *pArg )  {
  unixFile *pFile =  ((unixFile *) id);
  switch (op) {
    case 1:
    {
      ((*((int *) pArg)) = pFile->eFileLock);
      return 0;
    }
    case 4:
    {
      ((*((int *) pArg)) = pFile->lastErrno);
      return 0;
    }
    case 6:
    {
      (pFile->szChunk = (*((int *) pArg)));
      return 0;
    }
    case 5:
    {
      int rc;
      (rc = fcntlSizeHint(pFile, (*((i64 *) pArg))));
      return rc;
    }
    case 10:
    {
      unixModeBit(pFile, 0x04, ((int *) pArg));
      return 0;
    }
    case 13:
    {
      unixModeBit(pFile, 0x10, ((int *) pArg));
      return 0;
    }
    case 12:
    {
      ((*((char **) pArg)) = sqlite3_mprintf("%s", pFile->pVfs->zName));
      return 0;
    }
    case 16:
    {
      char *zTFile =  sqlite3_malloc(pFile->pVfs->mxPathname);
      if (zTFile) {
        unixGetTempname(pFile->pVfs->mxPathname, zTFile);
        ((*((char **) pArg)) = zTFile);
      }  
      return 0;
    }
  }
  return 12;
}
static  int unixSectorSize(sqlite3_file *NotUsed )  {
  ((void ) NotUsed);
  return 4096;
}
static  int unixDeviceCharacteristics(sqlite3_file *id )  {
  unixFile *p =  ((unixFile *) id);
  int rc =  0;
  if ((p->ctrlFlags & 0x10)) {
    (rc |= 0x00001000);
  }  
  return rc;
}
struct  unixShmNode {
  unixInodeInfo *pInode ;
  sqlite3_mutex *mutex ;
  char *zFilename ;
  int h ;
  int szRegion ;
  u16 nRegion ;
  u8 isReadonly ;
  char **apRegion ;
  int nRef ;
  unixShm *pFirst ;
}  ;
struct  unixShm {
  unixShmNode *pShmNode ;
  unixShm *pNext ;
  u8 hasMutex ;
  u8 id ;
  u16 sharedMask ;
  u16 exclMask ;
}  ;
static  int unixShmSystemLock(unixShmNode *pShmNode , int lockType , int ofst , int n )  {
  struct  flock   f;
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pShmNode->h >= 0)) {
    memset((&f), 0, sizeof(f));
    (f.l_type = lockType);
    (f.l_whence = 0);
    (f.l_start = ofst);
    (f.l_len = n);
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      (rc = ((int ( *)(int , int , ...)) _1305_aSyscall[7].pCurrent)(pShmNode->h, 6, (&f)));
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      (rc = ((int ( *)(int , int , ...)) _1306_aSyscall[7].pCurrent)(pShmNode->h, 6, (&f)));
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      (rc = ((int ( *)(int , int , ...)) _1307_aSyscall[7].pCurrent)(pShmNode->h, 6, (&f)));
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      (rc = ((int ( *)(int , int , ...)) _1308_aSyscall[7].pCurrent)(pShmNode->h, 6, (&f)));
    }  
    (rc = ((rc != (- 1)) ? 0 : 5));
  }  
  return rc;
}
static  void unixShmPurge(unixFile *pFd )  {
  unixShmNode *p =  pFd->pInode->pShmNode;
  ((void ) 0);
  if ((p && (p->nRef == 0))) {
    int i;
    ((void ) 0);
    for ((i = 0); (i < p->nRegion); i++) {
      if ((p->h >= 0)) {
        if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
          ((void *( *)(void * , size_t )) _1305_aSyscall[22].pCurrent)(p->apRegion[i], p->szRegion);
        }  
        if ((((! id2i_use_pread) && id2i_use_pread64) )) {
          ((void *( *)(void * , size_t )) _1306_aSyscall[22].pCurrent)(p->apRegion[i], p->szRegion);
        }  
        if (((id2i_use_pread && (! id2i_use_pread64)) )) {
          ((void *( *)(void * , size_t )) _1307_aSyscall[22].pCurrent)(p->apRegion[i], p->szRegion);
        }  
        if (((id2i_use_pread && id2i_use_pread64) )) {
          ((void *( *)(void * , size_t )) _1308_aSyscall[22].pCurrent)(p->apRegion[i], p->szRegion);
        }  
      }  
      else {
        sqlite3_free(p->apRegion[i]);
      }
    }
    sqlite3_free(p->apRegion);
    if ((p->h >= 0)) {
      robust_close(pFd, p->h, 27139);
      (p->h = (- 1));
    }  
    (p->pInode->pShmNode = 0);
    sqlite3_free(p);
  }  
}
static  int unixOpenSharedMemory(unixFile *pDbFd )  {
  struct  unixShm   *p =  0;
  struct  unixShmNode   *pShmNode;
  int rc;
  unixInodeInfo *pInode;
  char *zShmFilename;
  int nShmFilename;
  (p = sqlite3_malloc(sizeof((*p))));
  if ((p == 0)) {
    return 7;
  }  
  memset(p, 0, sizeof((*p)));
  ((void ) 0);
  unixEnterMutex();
  (pInode = pDbFd->pInode);
  (pShmNode = pInode->pShmNode);
  if ((pShmNode == 0)) {
    struct  stat   sStat;
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      if ((((int ( *)(int , struct  stat   * )) _1305_aSyscall[5].pCurrent)(pDbFd->h, (&sStat)) && (pInode->bProcessLock == 0))) {
        (rc = (10 | (7 << 8)));
        goto shm_open_err;
      }  
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      if ((((int ( *)(int , struct  stat   * )) _1306_aSyscall[5].pCurrent)(pDbFd->h, (&sStat)) && (pInode->bProcessLock == 0))) {
        (rc = (10 | (7 << 8)));
        goto shm_open_err;
      }  
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      if ((((int ( *)(int , struct  stat   * )) _1307_aSyscall[5].pCurrent)(pDbFd->h, (&sStat)) && (pInode->bProcessLock == 0))) {
        (rc = (10 | (7 << 8)));
        goto shm_open_err;
      }  
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      if ((((int ( *)(int , struct  stat   * )) _1308_aSyscall[5].pCurrent)(pDbFd->h, (&sStat)) && (pInode->bProcessLock == 0))) {
        (rc = (10 | (7 << 8)));
        goto shm_open_err;
      }  
    }  
    (nShmFilename = (6 + ((int ) strlen(pDbFd->zPath))));
    (pShmNode = sqlite3_malloc((sizeof((*pShmNode)) + nShmFilename)));
    if ((pShmNode == 0)) {
      (rc = 7);
      goto shm_open_err;
    }  
    memset(pShmNode, 0, (sizeof((*pShmNode)) + nShmFilename));
    (zShmFilename = (pShmNode->zFilename = ((char *) (&pShmNode[1]))));
    sqlite3_snprintf(nShmFilename, zShmFilename, "%s-shm", pDbFd->zPath);
    (pShmNode->h = (- 1));
    (pDbFd->pInode->pShmNode = pShmNode);
    (pShmNode->pInode = pDbFd->pInode);
    (pShmNode->mutex = ((sqlite3_mutex *) 8));
    if ((pShmNode->mutex == 0)) {
      (rc = 7);
      goto shm_open_err;
    }  
    if ((pInode->bProcessLock == 0)) {
      int openFlags =  (02 | 0100);
      if (sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0)) {
        (openFlags = 00);
        (pShmNode->isReadonly = 1);
      }  
      (pShmNode->h = robust_open(zShmFilename, openFlags, (sStat.st_mode & 0777)));
      if ((pShmNode->h < 0)) {
        (rc = unixLogErrorAtLine(sqlite3CantopenError(27251), "open", zShmFilename, 27251));
        goto shm_open_err;
      }  
      if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
        ((int ( *)(int , uid_t , gid_t )) _1305_aSyscall[20].pCurrent)(pShmNode->h, sStat.st_uid, sStat.st_gid);
      }  
      if ((((! id2i_use_pread) && id2i_use_pread64) )) {
        ((int ( *)(int , uid_t , gid_t )) _1306_aSyscall[20].pCurrent)(pShmNode->h, sStat.st_uid, sStat.st_gid);
      }  
      if (((id2i_use_pread && (! id2i_use_pread64)) )) {
        ((int ( *)(int , uid_t , gid_t )) _1307_aSyscall[20].pCurrent)(pShmNode->h, sStat.st_uid, sStat.st_gid);
      }  
      if (((id2i_use_pread && id2i_use_pread64) )) {
        ((int ( *)(int , uid_t , gid_t )) _1308_aSyscall[20].pCurrent)(pShmNode->h, sStat.st_uid, sStat.st_gid);
      }  
      (rc = 0);
      if ((unixShmSystemLock(pShmNode, 1, (((22 + 8) * 4) + 8), 1) == 0)) {
        if (robust_ftruncate(pShmNode->h, 0)) {
          (rc = unixLogErrorAtLine((10 | (18 << 8)), "ftruncate", zShmFilename, 27267));
        }  
      }  
      if ((rc == 0)) {
        (rc = unixShmSystemLock(pShmNode, 0, (((22 + 8) * 4) + 8), 1));
      }  
      if (rc) {
        goto shm_open_err;
      }  
    }  
  }  
  (p->pShmNode = pShmNode);
  pShmNode->nRef++;
  (pDbFd->pShm = p);
  unixLeaveMutex();
  (p->pNext = pShmNode->pFirst);
  (pShmNode->pFirst = p);
  return 0;
  shm_open_err:
  unixShmPurge(pDbFd);
  sqlite3_free(p);
  unixLeaveMutex();
  return rc;
}
static  int unixShmMap(sqlite3_file *fd , int iRegion , int szRegion , int bExtend , void  volatile **pp )  {
  unixFile *pDbFd =  ((unixFile *) fd);
  unixShm *p;
  unixShmNode *pShmNode;
  int rc =  0;
  if ((pDbFd->pShm == 0)) {
    (rc = unixOpenSharedMemory(pDbFd));
    if ((rc != 0)) {
      return rc;
    }  
  }  
  (p = pDbFd->pShm);
  (pShmNode = p->pShmNode);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pShmNode->nRegion <= iRegion)) {
    char **apNew;
    int nByte =  ((iRegion + 1) * szRegion);
    struct  stat   sStat;
    (pShmNode->szRegion = szRegion);
    if ((pShmNode->h >= 0)) {
      if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
        if (((int ( *)(int , struct  stat   * )) _1305_aSyscall[5].pCurrent)(pShmNode->h, (&sStat))) {
          (rc = (10 | (19 << 8)));
          goto shmpage_out;
        }  
      }  
      if ((((! id2i_use_pread) && id2i_use_pread64) )) {
        if (((int ( *)(int , struct  stat   * )) _1306_aSyscall[5].pCurrent)(pShmNode->h, (&sStat))) {
          (rc = (10 | (19 << 8)));
          goto shmpage_out;
        }  
      }  
      if (((id2i_use_pread && (! id2i_use_pread64)) )) {
        if (((int ( *)(int , struct  stat   * )) _1307_aSyscall[5].pCurrent)(pShmNode->h, (&sStat))) {
          (rc = (10 | (19 << 8)));
          goto shmpage_out;
        }  
      }  
      if (((id2i_use_pread && id2i_use_pread64) )) {
        if (((int ( *)(int , struct  stat   * )) _1308_aSyscall[5].pCurrent)(pShmNode->h, (&sStat))) {
          (rc = (10 | (19 << 8)));
          goto shmpage_out;
        }  
      }  
      if ((sStat.st_size < nByte)) {
        if ((! bExtend)) {
          goto shmpage_out;
        }  
        else {
          static const int pgsz =  4096;
          int iPg;
          ((void ) 0);
          for ((iPg = (sStat.st_size / pgsz)); (iPg < (nByte / pgsz)); iPg++) {
            if ((seekAndWriteFd(pShmNode->h, ((iPg * pgsz) + pgsz - 1), "", 1, 0) != 1)) {
              const char *zFile =  pShmNode->zFilename;
              (rc = unixLogErrorAtLine((10 | (19 << 8)), "write", zFile, 27393));
              goto shmpage_out;
            }  
          }
        }
      }  
    }  
    (apNew = ((char **) sqlite3_realloc(pShmNode->apRegion, ((iRegion + 1) * sizeof(char *)))));
    if ((! apNew)) {
      (rc = (10 | (12 << 8)));
      goto shmpage_out;
    }  
    (pShmNode->apRegion = apNew);
    while ((pShmNode->nRegion <= iRegion)) {
      void *pMem;
      if ((pShmNode->h >= 0)) {
        if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
          (pMem = ((void *( *)(void * , size_t , int , int , int , off_t )) _1305_aSyscall[21].pCurrent)(0, szRegion, (pShmNode->isReadonly ? 0x1 : (0x1 | 0x2)), 0x01, pShmNode->h, (szRegion * ((i64 ) pShmNode->nRegion))));
        }  
        if ((((! id2i_use_pread) && id2i_use_pread64) )) {
          (pMem = ((void *( *)(void * , size_t , int , int , int , off_t )) _1306_aSyscall[21].pCurrent)(0, szRegion, (pShmNode->isReadonly ? 0x1 : (0x1 | 0x2)), 0x01, pShmNode->h, (szRegion * ((i64 ) pShmNode->nRegion))));
        }  
        if (((id2i_use_pread && (! id2i_use_pread64)) )) {
          (pMem = ((void *( *)(void * , size_t , int , int , int , off_t )) _1307_aSyscall[21].pCurrent)(0, szRegion, (pShmNode->isReadonly ? 0x1 : (0x1 | 0x2)), 0x01, pShmNode->h, (szRegion * ((i64 ) pShmNode->nRegion))));
        }  
        if (((id2i_use_pread && id2i_use_pread64) )) {
          (pMem = ((void *( *)(void * , size_t , int , int , int , off_t )) _1308_aSyscall[21].pCurrent)(0, szRegion, (pShmNode->isReadonly ? 0x1 : (0x1 | 0x2)), 0x01, pShmNode->h, (szRegion * ((i64 ) pShmNode->nRegion))));
        }  
        if ((pMem == ((void *) (- 1)))) {
          (rc = unixLogErrorAtLine((10 | (21 << 8)), "mmap", pShmNode->zFilename, 27418));
          goto shmpage_out;
        }  
      }  
      else {
        (pMem = sqlite3_malloc(szRegion));
        if ((pMem == 0)) {
          (rc = 7);
          goto shmpage_out;
        }  
        memset(pMem, 0, szRegion);
      }
      (pShmNode->apRegion[pShmNode->nRegion] = pMem);
      pShmNode->nRegion++;
    }
  }  
  shmpage_out:
  if ((pShmNode->nRegion > iRegion)) {
    ((*pp) = pShmNode->apRegion[iRegion]);
  }  
  else {
    ((*pp) = 0);
  }
  if ((pShmNode->isReadonly && (rc == 0))) {
    (rc = 8);
  }  
  return rc;
}
static  int unixShmLock(sqlite3_file *fd , int ofst , int n , int flags )  {
  unixFile *pDbFd =  ((unixFile *) fd);
  unixShm *p =  pDbFd->pShm;
  unixShm *pX;
  unixShmNode *pShmNode =  p->pShmNode;
  int rc =  0;
  u16 mask;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (mask = ((1 << (ofst + n)) - (1 << ofst)));
  ((void ) 0);
  if ((flags & 1)) {
    u16 allMask =  0;
    for ((pX = pShmNode->pFirst); pX; (pX = pX->pNext)) {
      if ((pX == p)) {
        continue;
      }  
      ((void ) 0);
      (allMask |= pX->sharedMask);
    }
    if (((mask & allMask) == 0)) {
      (rc = unixShmSystemLock(pShmNode, 2, (ofst + ((22 + 8) * 4)), n));
    }  
    else {
      (rc = 0);
    }
    if ((rc == 0)) {
      (p->exclMask &= (~ mask));
      (p->sharedMask &= (~ mask));
    }  
  } 
  else if ((flags & 4)) {
    u16 allShared =  0;
    for ((pX = pShmNode->pFirst); pX; (pX = pX->pNext)) {
      if (((pX->exclMask & mask) != 0)) {
        (rc = 5);
        break;
      }  
      (allShared |= pX->sharedMask);
    }
    if ((rc == 0)) {
      if (((allShared & mask) == 0)) {
        (rc = unixShmSystemLock(pShmNode, 0, (ofst + ((22 + 8) * 4)), n));
      }  
      else {
        (rc = 0);
      }
    }  
    if ((rc == 0)) {
      (p->sharedMask |= mask);
    }  
  } 
  else {
    for ((pX = pShmNode->pFirst); pX; (pX = pX->pNext)) {
      if ((((pX->exclMask & mask) != 0) || ((pX->sharedMask & mask) != 0))) {
        (rc = 5);
        break;
      }  
    }
    if ((rc == 0)) {
      (rc = unixShmSystemLock(pShmNode, 1, (ofst + ((22 + 8) * 4)), n));
      if ((rc == 0)) {
        ((void ) 0);
        (p->exclMask |= mask);
      }  
    }  
  }
  return rc;
}
static  void unixShmBarrier(sqlite3_file *fd )  {
  ((void ) fd);
  unixEnterMutex();
  unixLeaveMutex();
}
static  int unixShmUnmap(sqlite3_file *fd , int deleteFlag )  {
  unixShm *p;
  unixShmNode *pShmNode;
  unixShm **pp;
  unixFile *pDbFd;
  (pDbFd = ((unixFile *) fd));
  (p = pDbFd->pShm);
  if ((p == 0)) {
    return 0;
  }  
  (pShmNode = p->pShmNode);
  ((void ) 0);
  ((void ) 0);
  for ((pp = (&pShmNode->pFirst)); ((*pp) != p); (pp = (&(*pp)->pNext))) {
    
  }
  ((*pp) = p->pNext);
  sqlite3_free(p);
  (pDbFd->pShm = 0);
  unixEnterMutex();
  ((void ) 0);
  pShmNode->nRef--;
  if ((pShmNode->nRef == 0)) {
    if ((deleteFlag && (pShmNode->h >= 0))) {
      if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
        ((int ( *)(const  char * )) _1305_aSyscall[16].pCurrent)(pShmNode->zFilename);
      }  
      if ((((! id2i_use_pread) && id2i_use_pread64) )) {
        ((int ( *)(const  char * )) _1306_aSyscall[16].pCurrent)(pShmNode->zFilename);
      }  
      if (((id2i_use_pread && (! id2i_use_pread64)) )) {
        ((int ( *)(const  char * )) _1307_aSyscall[16].pCurrent)(pShmNode->zFilename);
      }  
      if (((id2i_use_pread && id2i_use_pread64) )) {
        ((int ( *)(const  char * )) _1308_aSyscall[16].pCurrent)(pShmNode->zFilename);
      }  
    }  
    unixShmPurge(pDbFd);
  }  
  unixLeaveMutex();
  return 0;
}
static  int unixFetch(sqlite3_file *fd , i64 iOff , int nAmt , void **pp )  {
  ((*pp) = 0);
  return 0;
}
static  int unixUnfetch(sqlite3_file *fd , i64 iOff , void *p )  {
  unixFile *pFd =  ((unixFile *) fd);
  ((void ) iOff);
  return 0;
}
static const sqlite3_io_methods posixIoMethods =  { 3,  unixClose,  unixRead,  unixWrite,  unixTruncate,  unixSync,  unixFileSize,  unixLock,  unixUnlock,  unixCheckReservedLock,  unixFileControl,  unixSectorSize,  unixDeviceCharacteristics,  unixShmMap,  unixShmLock,  unixShmBarrier,  unixShmUnmap,  unixFetch,  unixUnfetch};
static  const  sqlite3_io_methods *posixIoFinderImpl(const  char *z , unixFile *p )  {
  ((void ) z);
  ((void ) p);
  return (&posixIoMethods);
}
static const sqlite3_io_methods *( *const posixIoFinder)(const  char * , unixFile *p ) =  posixIoFinderImpl;
static const sqlite3_io_methods nolockIoMethods =  { 1,  nolockClose,  unixRead,  unixWrite,  unixTruncate,  unixSync,  unixFileSize,  nolockLock,  nolockUnlock,  nolockCheckReservedLock,  unixFileControl,  unixSectorSize,  unixDeviceCharacteristics,  unixShmMap,  unixShmLock,  unixShmBarrier,  unixShmUnmap,  unixFetch,  unixUnfetch};
static  const  sqlite3_io_methods *nolockIoFinderImpl(const  char *z , unixFile *p )  {
  ((void ) z);
  ((void ) p);
  return (&nolockIoMethods);
}
static const sqlite3_io_methods *( *const nolockIoFinder)(const  char * , unixFile *p ) =  nolockIoFinderImpl;
static const sqlite3_io_methods dotlockIoMethods =  { 1,  dotlockClose,  unixRead,  unixWrite,  unixTruncate,  unixSync,  unixFileSize,  dotlockLock,  dotlockUnlock,  dotlockCheckReservedLock,  unixFileControl,  unixSectorSize,  unixDeviceCharacteristics,  unixShmMap,  unixShmLock,  unixShmBarrier,  unixShmUnmap,  unixFetch,  unixUnfetch};
static  const  sqlite3_io_methods *dotlockIoFinderImpl(const  char *z , unixFile *p )  {
  ((void ) z);
  ((void ) p);
  return (&dotlockIoMethods);
}
static const sqlite3_io_methods *( *const dotlockIoFinder)(const  char * , unixFile *p ) =  dotlockIoFinderImpl;
typedef const sqlite3_io_methods *( *finder_type)(const  char * , unixFile * );
static  int fillInUnixFile(sqlite3_vfs *pVfs , int h , sqlite3_file *pId , const  char *zFilename , int ctrlFlags )  {
  const sqlite3_io_methods *pLockingStyle;
  unixFile *pNew =  ((unixFile *) pId);
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (pNew->h = h);
  (pNew->pVfs = pVfs);
  (pNew->zPath = zFilename);
  (pNew->ctrlFlags = ((u8 ) ctrlFlags));
  if (sqlite3_uri_boolean(((ctrlFlags & 0x40) ? zFilename : 0), "psow", 1)) {
    (pNew->ctrlFlags |= 0x10);
  }  
  if ((strcmp(pVfs->zName, "unix-excl") == 0)) {
    (pNew->ctrlFlags |= 0x01);
  }  
  if ((ctrlFlags & 0x80)) {
    (pLockingStyle = (&nolockIoMethods));
  }  
  else {
    (pLockingStyle = (*(*((finder_type *) pVfs->pAppData)))(zFilename, pNew));
  }
  if ((pLockingStyle == (&posixIoMethods))) {
    unixEnterMutex();
    (rc = findInodeInfo(pNew, (&pNew->pInode)));
    if ((rc != 0)) {
      robust_close(pNew, h, 28241);
      (h = (- 1));
    }  
    unixLeaveMutex();
  } 
  else if ((pLockingStyle == (&dotlockIoMethods))) {
    char *zLockFile;
    int nFilename;
    ((void ) 0);
    (nFilename = (((int ) strlen(zFilename)) + 6));
    (zLockFile = ((char *) sqlite3_malloc(nFilename)));
    if ((zLockFile == 0)) {
      (rc = 7);
    }  
    else {
      sqlite3_snprintf(nFilename, zLockFile, "%s" ".lock", zFilename);
    }
    (pNew->lockingContext = zLockFile);
  } 
  (pNew->lastErrno = 0);
  if ((rc != 0)) {
    if ((h >= 0)) {
      robust_close(pNew, h, 28326);
    }  
  }  
  else {
    (pNew->pMethod = pLockingStyle);
    verifyDbFile(pNew);
  }
  return rc;
}
static  const  char *unixTempFileDir(void )  {
  static const char *azDirs[] =  { 0,  0,  0,  "/var/tmp",  "/usr/tmp",  "/tmp",  0};
  unsigned int i;
  struct  stat   buf;
  const char *zDir =  0;
  (azDirs[0] = sqlite3_temp_directory);
  if ((! azDirs[1])) {
    (azDirs[1] = getenv("SQLITE_TMPDIR"));
  }  
  if ((! azDirs[2])) {
    (azDirs[2] = getenv("TMPDIR"));
  }  
  for ((i = 0); (i < (sizeof(azDirs) / sizeof(azDirs[0]))); (zDir = azDirs[i++])) {
    if ((zDir == 0)) {
      continue;
    }  
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      if (((int ( *)(const  char * , struct  stat   * )) _1305_aSyscall[4].pCurrent)(zDir, (&buf))) {
        continue;
      }  
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      if (((int ( *)(const  char * , struct  stat   * )) _1306_aSyscall[4].pCurrent)(zDir, (&buf))) {
        continue;
      }  
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      if (((int ( *)(const  char * , struct  stat   * )) _1307_aSyscall[4].pCurrent)(zDir, (&buf))) {
        continue;
      }  
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      if (((int ( *)(const  char * , struct  stat   * )) _1308_aSyscall[4].pCurrent)(zDir, (&buf))) {
        continue;
      }  
    }  
    if ((! ((buf.st_mode & 0170000) == 0040000))) {
      continue;
    }  
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      if (((int ( *)(const  char * , int )) _1305_aSyscall[2].pCurrent)(zDir, 07)) {
        continue;
      }  
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      if (((int ( *)(const  char * , int )) _1306_aSyscall[2].pCurrent)(zDir, 07)) {
        continue;
      }  
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      if (((int ( *)(const  char * , int )) _1307_aSyscall[2].pCurrent)(zDir, 07)) {
        continue;
      }  
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      if (((int ( *)(const  char * , int )) _1308_aSyscall[2].pCurrent)(zDir, 07)) {
        continue;
      }  
    }  
    break;
  }
  return zDir;
}
static  int unixGetTempname(int nBuf , char *zBuf )  {
  static const unsigned char zChars[] =  "abcdefghijklmnopqrstuvwxyz" "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "0123456789";
  unsigned int i, j;
  const char *zDir;
  (zDir = unixTempFileDir());
  if ((zDir == 0)) {
    (zDir = ".");
  }  
  if (((strlen(zDir) + strlen("etilqs_") + 18) >= ((size_t ) nBuf))) {
    return 1;
  }  
  do {
    sqlite3_snprintf((nBuf - 18), zBuf, "%s/" "etilqs_", zDir);
    (j = ((int ) strlen(zBuf)));
    sqlite3_randomness(15, (&zBuf[j]));
    for ((i = 0); (i < 15); i++, j++) {
      (zBuf[j] = ((char ) zChars[(((unsigned  char ) zBuf[j]) % (sizeof(zChars) - 1))]));
    }
    (zBuf[j] = 0);
    (zBuf[(j + 1)] = 0);
  } while ((((id2i_use_pread && id2i_use_pread64) ) ? (((int ( *)(const  char * , int )) _1308_aSyscall[2].pCurrent)(zBuf, 0) == 0) : (((id2i_use_pread && (! id2i_use_pread64)) ) ? (((int ( *)(const  char * , int )) _1307_aSyscall[2].pCurrent)(zBuf, 0) == 0) : ((((! id2i_use_pread) && id2i_use_pread64) ) ? (((int ( *)(const  char * , int )) _1306_aSyscall[2].pCurrent)(zBuf, 0) == 0) : (((int ( *)(const  char * , int )) _1305_aSyscall[2].pCurrent)(zBuf, 0) == 0)))));
  return 0;
}
static  UnixUnusedFd *findReusableFd(const  char *zPath , int flags )  {
  UnixUnusedFd *pUnused =  0;
  struct  stat   sStat;
  if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
    if ((0 == ((int ( *)(const  char * , struct  stat   * )) _1305_aSyscall[4].pCurrent)(zPath, (&sStat)))) {
      unixInodeInfo *pInode;
      unixEnterMutex();
      (pInode = inodeList);
      while ((pInode && ((pInode->fileId.dev != sStat.st_dev) || (pInode->fileId.ino != sStat.st_ino)))) {
        (pInode = pInode->pNext);
      }
      if (pInode) {
        UnixUnusedFd **pp;
        for ((pp = (&pInode->pUnused)); ((*pp) && ((*pp)->flags != flags)); (pp = (&(*pp)->pNext))) {
          
        }
        (pUnused = (*pp));
        if (pUnused) {
          ((*pp) = pUnused->pNext);
        }  
      }  
      unixLeaveMutex();
    }  
  }  
  if ((((! id2i_use_pread) && id2i_use_pread64) )) {
    if ((0 == ((int ( *)(const  char * , struct  stat   * )) _1306_aSyscall[4].pCurrent)(zPath, (&sStat)))) {
      unixInodeInfo *pInode;
      unixEnterMutex();
      (pInode = inodeList);
      while ((pInode && ((pInode->fileId.dev != sStat.st_dev) || (pInode->fileId.ino != sStat.st_ino)))) {
        (pInode = pInode->pNext);
      }
      if (pInode) {
        UnixUnusedFd **pp;
        for ((pp = (&pInode->pUnused)); ((*pp) && ((*pp)->flags != flags)); (pp = (&(*pp)->pNext))) {
          
        }
        (pUnused = (*pp));
        if (pUnused) {
          ((*pp) = pUnused->pNext);
        }  
      }  
      unixLeaveMutex();
    }  
  }  
  if (((id2i_use_pread && (! id2i_use_pread64)) )) {
    if ((0 == ((int ( *)(const  char * , struct  stat   * )) _1307_aSyscall[4].pCurrent)(zPath, (&sStat)))) {
      unixInodeInfo *pInode;
      unixEnterMutex();
      (pInode = inodeList);
      while ((pInode && ((pInode->fileId.dev != sStat.st_dev) || (pInode->fileId.ino != sStat.st_ino)))) {
        (pInode = pInode->pNext);
      }
      if (pInode) {
        UnixUnusedFd **pp;
        for ((pp = (&pInode->pUnused)); ((*pp) && ((*pp)->flags != flags)); (pp = (&(*pp)->pNext))) {
          
        }
        (pUnused = (*pp));
        if (pUnused) {
          ((*pp) = pUnused->pNext);
        }  
      }  
      unixLeaveMutex();
    }  
  }  
  if (((id2i_use_pread && id2i_use_pread64) )) {
    if ((0 == ((int ( *)(const  char * , struct  stat   * )) _1308_aSyscall[4].pCurrent)(zPath, (&sStat)))) {
      unixInodeInfo *pInode;
      unixEnterMutex();
      (pInode = inodeList);
      while ((pInode && ((pInode->fileId.dev != sStat.st_dev) || (pInode->fileId.ino != sStat.st_ino)))) {
        (pInode = pInode->pNext);
      }
      if (pInode) {
        UnixUnusedFd **pp;
        for ((pp = (&pInode->pUnused)); ((*pp) && ((*pp)->flags != flags)); (pp = (&(*pp)->pNext))) {
          
        }
        (pUnused = (*pp));
        if (pUnused) {
          ((*pp) = pUnused->pNext);
        }  
      }  
      unixLeaveMutex();
    }  
  }  
  return pUnused;
}
static  int findCreateFileMode(const  char *zPath , int flags , mode_t *pMode , uid_t *pUid , gid_t *pGid )  {
  int rc =  0;
  ((*pMode) = 0);
  ((*pUid) = 0);
  ((*pGid) = 0);
  if ((flags & (0x00080000 | 0x00000800))) {
    char zDb[(512 + 1)];
    int nDb;
    struct  stat   sStat;
    (nDb = (sqlite3Strlen30(zPath) - 1));
    while ((zPath[nDb] != '-')) {
      ((void ) 0);
      ((void ) 0);
      nDb--;
    }
    memcpy(zDb, zPath, nDb);
    (zDb[nDb] = '\0');
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      if ((0 == ((int ( *)(const  char * , struct  stat   * )) _1305_aSyscall[4].pCurrent)(zDb, (&sStat)))) {
        ((*pMode) = (sStat.st_mode & 0777));
        ((*pUid) = sStat.st_uid);
        ((*pGid) = sStat.st_gid);
      }  
      else {
        (rc = (10 | (7 << 8)));
      }
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      if ((0 == ((int ( *)(const  char * , struct  stat   * )) _1306_aSyscall[4].pCurrent)(zDb, (&sStat)))) {
        ((*pMode) = (sStat.st_mode & 0777));
        ((*pUid) = sStat.st_uid);
        ((*pGid) = sStat.st_gid);
      }  
      else {
        (rc = (10 | (7 << 8)));
      }
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      if ((0 == ((int ( *)(const  char * , struct  stat   * )) _1307_aSyscall[4].pCurrent)(zDb, (&sStat)))) {
        ((*pMode) = (sStat.st_mode & 0777));
        ((*pUid) = sStat.st_uid);
        ((*pGid) = sStat.st_gid);
      }  
      else {
        (rc = (10 | (7 << 8)));
      }
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      if ((0 == ((int ( *)(const  char * , struct  stat   * )) _1308_aSyscall[4].pCurrent)(zDb, (&sStat)))) {
        ((*pMode) = (sStat.st_mode & 0777));
        ((*pUid) = sStat.st_uid);
        ((*pGid) = sStat.st_gid);
      }  
      else {
        (rc = (10 | (7 << 8)));
      }
    }  
  } 
  else if ((flags & 0x00000008)) {
    ((*pMode) = 0600);
  } 
  return rc;
}
static  int unixOpen(sqlite3_vfs *pVfs , const  char *zPath , sqlite3_file *pFile , int flags , int *pOutFlags )  {
  unixFile *p =  ((unixFile *) pFile);
  int fd =  (- 1);
  int openFlags =  0;
  int eType =  (flags & 0xFFFFFF00);
  int noLock;
  int rc =  0;
  int ctrlFlags =  0;
  int isExclusive =  (flags & 0x00000010);
  int isDelete =  (flags & 0x00000008);
  int isCreate =  (flags & 0x00000004);
  int isReadonly =  (flags & 0x00000001);
  int isReadWrite =  (flags & 0x00000002);
  int syncDir =  (isCreate && ((eType == 0x00004000) || (eType == 0x00000800) || (eType == 0x00080000)));
  char zTmpname[(512 + 2)];
  const char *zName =  zPath;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  memset(p, 0, sizeof(unixFile ));
  if ((eType == 0x00000100)) {
    UnixUnusedFd *pUnused;
    (pUnused = findReusableFd(zName, flags));
    if (pUnused) {
      (fd = pUnused->fd);
    }  
    else {
      (pUnused = sqlite3_malloc(sizeof((*pUnused))));
      if ((! pUnused)) {
        return 7;
      }  
    }
    (p->pUnused = pUnused);
    ((void ) 0);
  } 
  else if ((! zName)) {
    ((void ) 0);
    (rc = unixGetTempname((512 + 2), zTmpname));
    if ((rc != 0)) {
      return rc;
    }  
    (zName = zTmpname);
    ((void ) 0);
  } 
  if (isReadonly) {
    (openFlags |= 00);
  }  
  if (isReadWrite) {
    (openFlags |= 02);
  }  
  if (isCreate) {
    (openFlags |= 0100);
  }  
  if (isExclusive) {
    (openFlags |= (0200 | 0400000));
  }  
  (openFlags |= (0 | 0));
  if ((fd < 0)) {
    mode_t openMode;
    uid_t uid;
    gid_t gid;
    (rc = findCreateFileMode(zName, flags, (&openMode), (&uid), (&gid)));
    if ((rc != 0)) {
      ((void ) 0);
      ((void ) 0);
      return rc;
    }  
    (fd = robust_open(zName, openFlags, openMode));
    if (((fd < 0) && ((*__errno_location()) != 21) && isReadWrite && (! isExclusive))) {
      (flags &= (~ (0x00000002 | 0x00000004)));
      (openFlags &= (~ (02 | 0100)));
      (flags |= 0x00000001);
      (openFlags |= 00);
      (isReadonly = 1);
      (fd = robust_open(zName, openFlags, openMode));
    }  
    if ((fd < 0)) {
      (rc = unixLogErrorAtLine(sqlite3CantopenError(28708), "open", zName, 28708));
      goto open_finished;
    }  
    if ((flags & (0x00080000 | 0x00000800))) {
      if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
        ((int ( *)(int , uid_t , gid_t )) _1305_aSyscall[20].pCurrent)(fd, uid, gid);
      }  
      if ((((! id2i_use_pread) && id2i_use_pread64) )) {
        ((int ( *)(int , uid_t , gid_t )) _1306_aSyscall[20].pCurrent)(fd, uid, gid);
      }  
      if (((id2i_use_pread && (! id2i_use_pread64)) )) {
        ((int ( *)(int , uid_t , gid_t )) _1307_aSyscall[20].pCurrent)(fd, uid, gid);
      }  
      if (((id2i_use_pread && id2i_use_pread64) )) {
        ((int ( *)(int , uid_t , gid_t )) _1308_aSyscall[20].pCurrent)(fd, uid, gid);
      }  
    }  
  }  
  ((void ) 0);
  if (pOutFlags) {
    ((*pOutFlags) = flags);
  }  
  if (p->pUnused) {
    (p->pUnused->fd = fd);
    (p->pUnused->flags = flags);
  }  
  if (isDelete) {
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      ((int ( *)(const  char * )) _1305_aSyscall[16].pCurrent)(zName);
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      ((int ( *)(const  char * )) _1306_aSyscall[16].pCurrent)(zName);
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      ((int ( *)(const  char * )) _1307_aSyscall[16].pCurrent)(zName);
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      ((int ( *)(const  char * )) _1308_aSyscall[16].pCurrent)(zName);
    }  
  }  
  (noLock = (eType != 0x00000100));
  if (isDelete) {
    (ctrlFlags |= 0x20);
  }  
  if (isReadonly) {
    (ctrlFlags |= 0x02);
  }  
  if (noLock) {
    (ctrlFlags |= 0x80);
  }  
  if (syncDir) {
    (ctrlFlags |= 0x08);
  }  
  if ((flags & 0x00000040)) {
    (ctrlFlags |= 0x40);
  }  
  (rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags));
  open_finished:
  if ((rc != 0)) {
    sqlite3_free(p->pUnused);
  }  
  return rc;
}
static  int unixDelete(sqlite3_vfs *NotUsed , const  char *zPath , int dirSync )  {
  int rc =  0;
  ((void ) NotUsed);
  if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
    if ((((int ( *)(const  char * )) _1305_aSyscall[16].pCurrent)(zPath) == (- 1))) {
      if (((*__errno_location()) == 2)) {
        (rc = (10 | (23 << 8)));
      }  
      else {
        (rc = unixLogErrorAtLine((10 | (10 << 8)), "unlink", zPath, 28836));
      }
      return rc;
    }  
  }  
  if ((((! id2i_use_pread) && id2i_use_pread64) )) {
    if ((((int ( *)(const  char * )) _1306_aSyscall[16].pCurrent)(zPath) == (- 1))) {
      if (((*__errno_location()) == 2)) {
        (rc = (10 | (23 << 8)));
      }  
      else {
        (rc = unixLogErrorAtLine((10 | (10 << 8)), "unlink", zPath, 28836));
      }
      return rc;
    }  
  }  
  if (((id2i_use_pread && (! id2i_use_pread64)) )) {
    if ((((int ( *)(const  char * )) _1307_aSyscall[16].pCurrent)(zPath) == (- 1))) {
      if (((*__errno_location()) == 2)) {
        (rc = (10 | (23 << 8)));
      }  
      else {
        (rc = unixLogErrorAtLine((10 | (10 << 8)), "unlink", zPath, 28836));
      }
      return rc;
    }  
  }  
  if (((id2i_use_pread && id2i_use_pread64) )) {
    if ((((int ( *)(const  char * )) _1308_aSyscall[16].pCurrent)(zPath) == (- 1))) {
      if (((*__errno_location()) == 2)) {
        (rc = (10 | (23 << 8)));
      }  
      else {
        (rc = unixLogErrorAtLine((10 | (10 << 8)), "unlink", zPath, 28836));
      }
      return rc;
    }  
  }  
  if (((dirSync & 1) != 0)) {
    int fd;
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      (rc = ((int ( *)(const  char * , int * )) _1305_aSyscall[17].pCurrent)(zPath, (&fd)));
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      (rc = ((int ( *)(const  char * , int * )) _1306_aSyscall[17].pCurrent)(zPath, (&fd)));
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      (rc = ((int ( *)(const  char * , int * )) _1307_aSyscall[17].pCurrent)(zPath, (&fd)));
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      (rc = ((int ( *)(const  char * , int * )) _1308_aSyscall[17].pCurrent)(zPath, (&fd)));
    }  
    if ((rc == 0)) {
      if (fsync(fd)) {
        (rc = unixLogErrorAtLine((10 | (5 << 8)), "fsync", zPath, 28851));
      }  
      robust_close(0, fd, 28853);
    } 
    else if ((rc == 14)) {
      (rc = 0);
    } 
  }  
  return rc;
}
static  int unixAccess(sqlite3_vfs *NotUsed , const  char *zPath , int flags , int *pResOut )  {
  int amode =  0;
  ((void ) NotUsed);
  switch (flags) {
    case 0:
    (amode = 0);
    break;
    case 1:
    (amode = (2 | 4));
    break;
    case 2:
    (amode = 4);
    break;
    id2i_label_1:
    default:
    ((void ) 0);
  }
  if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
    ((*pResOut) = (((int ( *)(const  char * , int )) _1305_aSyscall[2].pCurrent)(zPath, amode) == 0));
  }  
  if ((((! id2i_use_pread) && id2i_use_pread64) )) {
    ((*pResOut) = (((int ( *)(const  char * , int )) _1306_aSyscall[2].pCurrent)(zPath, amode) == 0));
  }  
  if (((id2i_use_pread && (! id2i_use_pread64)) )) {
    ((*pResOut) = (((int ( *)(const  char * , int )) _1307_aSyscall[2].pCurrent)(zPath, amode) == 0));
  }  
  if (((id2i_use_pread && id2i_use_pread64) )) {
    ((*pResOut) = (((int ( *)(const  char * , int )) _1308_aSyscall[2].pCurrent)(zPath, amode) == 0));
  }  
  if (((flags == 0) && (*pResOut))) {
    struct  stat   buf;
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      if (((0 == ((int ( *)(const  char * , struct  stat   * )) _1305_aSyscall[4].pCurrent)(zPath, (&buf))) && (buf.st_size == 0))) {
        ((*pResOut) = 0);
      }  
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      if (((0 == ((int ( *)(const  char * , struct  stat   * )) _1306_aSyscall[4].pCurrent)(zPath, (&buf))) && (buf.st_size == 0))) {
        ((*pResOut) = 0);
      }  
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      if (((0 == ((int ( *)(const  char * , struct  stat   * )) _1307_aSyscall[4].pCurrent)(zPath, (&buf))) && (buf.st_size == 0))) {
        ((*pResOut) = 0);
      }  
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      if (((0 == ((int ( *)(const  char * , struct  stat   * )) _1308_aSyscall[4].pCurrent)(zPath, (&buf))) && (buf.st_size == 0))) {
        ((*pResOut) = 0);
      }  
    }  
  }  
  return 0;
}
static  int unixFullPathname(sqlite3_vfs *pVfs , const  char *zPath , int nOut , char *zOut )  {
  ((void ) 0);
  ((void ) pVfs);
  (zOut[(nOut - 1)] = '\0');
  if ((zPath[0] == '/')) {
    sqlite3_snprintf(nOut, zOut, "%s", zPath);
  }  
  else {
    int nCwd;
    if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
      if ((((char *( *)(char * , size_t )) _1305_aSyscall[3].pCurrent)(zOut, (nOut - 1)) == 0)) {
        return unixLogErrorAtLine(sqlite3CantopenError(28938), "getcwd", zPath, 28938);
      }  
    }  
    if ((((! id2i_use_pread) && id2i_use_pread64) )) {
      if ((((char *( *)(char * , size_t )) _1306_aSyscall[3].pCurrent)(zOut, (nOut - 1)) == 0)) {
        return unixLogErrorAtLine(sqlite3CantopenError(28938), "getcwd", zPath, 28938);
      }  
    }  
    if (((id2i_use_pread && (! id2i_use_pread64)) )) {
      if ((((char *( *)(char * , size_t )) _1307_aSyscall[3].pCurrent)(zOut, (nOut - 1)) == 0)) {
        return unixLogErrorAtLine(sqlite3CantopenError(28938), "getcwd", zPath, 28938);
      }  
    }  
    if (((id2i_use_pread && id2i_use_pread64) )) {
      if ((((char *( *)(char * , size_t )) _1308_aSyscall[3].pCurrent)(zOut, (nOut - 1)) == 0)) {
        return unixLogErrorAtLine(sqlite3CantopenError(28938), "getcwd", zPath, 28938);
      }  
    }  
    (nCwd = ((int ) strlen(zOut)));
    sqlite3_snprintf((nOut - nCwd), (&zOut[nCwd]), "/%s", zPath);
  }
  return 0;
}
static  int unixRandomness(sqlite3_vfs *NotUsed , int nBuf , char *zBuf )  {
  ((void ) NotUsed);
  ((void ) 0);
  memset(zBuf, 0, nBuf);
  {
    int pid, fd, got;
    (fd = robust_open("/dev/urandom", 00, 0));
    if ((fd < 0)) {
      time_t t;
      time((&t));
      memcpy(zBuf, (&t), sizeof(t));
      (pid = getpid());
      memcpy((&zBuf[sizeof(t)]), (&pid), sizeof(pid));
      ((void ) 0);
      (nBuf = (sizeof(t) + sizeof(pid)));
    }  
    else {
      do {
        if ((((! id2i_use_pread) && (! id2i_use_pread64)) )) {
          (got = ((ssize_t ( *)(int , void * , size_t )) _1305_aSyscall[8].pCurrent)(fd, zBuf, nBuf));
        }  
        if ((((! id2i_use_pread) && id2i_use_pread64) )) {
          (got = ((ssize_t ( *)(int , void * , size_t )) _1306_aSyscall[8].pCurrent)(fd, zBuf, nBuf));
        }  
        if (((id2i_use_pread && (! id2i_use_pread64)) )) {
          (got = ((ssize_t ( *)(int , void * , size_t )) _1307_aSyscall[8].pCurrent)(fd, zBuf, nBuf));
        }  
        if (((id2i_use_pread && id2i_use_pread64) )) {
          (got = ((ssize_t ( *)(int , void * , size_t )) _1308_aSyscall[8].pCurrent)(fd, zBuf, nBuf));
        }  
      } while (((got < 0) && ((*__errno_location()) == 4)));
      robust_close(0, fd, 29043);
    }
  }
  return nBuf;
}
static  int unixSleep(sqlite3_vfs *NotUsed , int microseconds )  {
  int seconds =  ((microseconds + 999999) / 1000000);
  sleep(seconds);
  ((void ) NotUsed);
  return (seconds * 1000000);
}
static  int unixCurrentTimeInt64(sqlite3_vfs *NotUsed , sqlite3_int64 *piNow )  {
  static const sqlite3_int64 unixEpoch =  (24405875 * ((sqlite3_int64 ) 8640000));
  int rc =  0;
  time_t _1310_t;
  if (((id2i_no_gettod ) )) {
    time((&_1310_t));
  }  
  if (((id2i_no_gettod ) )) {
    ((*piNow) = ((((sqlite3_int64 ) _1310_t) * 1000) + unixEpoch));
  }  
  struct  timeval   sNow;
  if ((((! id2i_no_gettod) ) )) {
    if ((gettimeofday((&sNow), 0) == 0)) {
      ((*piNow) = (unixEpoch + (1000 * ((sqlite3_int64 ) sNow.tv_sec)) + (sNow.tv_usec / 1000)));
    }  
    else {
      (rc = 1);
    }
  }  
  ((void ) NotUsed);
  return rc;
}
static  int unixCurrentTime(sqlite3_vfs *NotUsed , double *prNow )  {
  sqlite3_int64 i =  0;
  int rc;
  ((void ) NotUsed);
  (rc = unixCurrentTimeInt64(0, (&i)));
  ((*prNow) = (i / 86400000.0));
  return rc;
}
static  int unixGetLastError(sqlite3_vfs *NotUsed , int NotUsed2 , char *NotUsed3 )  {
  ((void ) NotUsed);
  ((void ) NotUsed2);
  ((void ) NotUsed3);
  return 0;
}
int sqlite3_os_init(void )  {
  static sqlite3_vfs aVfs[] =  { { 3,  sizeof(unixFile ),  512,  0,  "unix",  ((void *) (&posixIoFinder)),  unixOpen,  unixDelete,  unixAccess,  unixFullPathname,  0,  0,  0,  0,  unixRandomness,  unixSleep,  unixCurrentTime,  unixGetLastError,  unixCurrentTimeInt64,  unixSetSystemCall,  unixGetSystemCall,  unixNextSystemCall},  { 3,  sizeof(unixFile ),  512,  0,  "unix-none",  ((void *) (&nolockIoFinder)),  unixOpen,  unixDelete,  unixAccess,  unixFullPathname,  0,  0,  0,  0,  unixRandomness,  unixSleep,  unixCurrentTime,  unixGetLastError,  unixCurrentTimeInt64,  unixSetSystemCall,  unixGetSystemCall,  unixNextSystemCall},  { 3,  sizeof(unixFile ),  512,  0,  "unix-dotfile",  ((void *) (&dotlockIoFinder)),  unixOpen,  unixDelete,  unixAccess,  unixFullPathname,  0,  0,  0,  0,  unixRandomness,  unixSleep,  unixCurrentTime,  unixGetLastError,  unixCurrentTimeInt64,  unixSetSystemCall,  unixGetSystemCall,  unixNextSystemCall},  { 3,  sizeof(unixFile ),  512,  0,  "unix-excl",  ((void *) (&posixIoFinder)),  unixOpen,  unixDelete,  unixAccess,  unixFullPathname,  0,  0,  0,  0,  unixRandomness,  unixSleep,  unixCurrentTime,  unixGetLastError,  unixCurrentTimeInt64,  unixSetSystemCall,  unixGetSystemCall,  unixNextSystemCall}};
  unsigned int i;
  ((void ) 0);
  for ((i = 0); (i < (sizeof(aVfs) / sizeof(sqlite3_vfs ))); i++) {
    sqlite3_vfs_register((&aVfs[i]), (i == 0));
  }
  return 0;
}
int sqlite3_os_end(void )  {
  return 0;
}
struct  Bitvec {
  u32 iSize ;
  u32 nSet ;
  u32 iDivisor ;
  union   {
    u8 aBitmap[((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8 ))] ;
    u32 aHash[((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 ))] ;
    Bitvec *apSub[((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))] ;
  }  u ;
}  ;
static  Bitvec *sqlite3BitvecCreate(u32 iSize )  {
  Bitvec *p;
  ((void ) 0);
  (p = sqlite3MallocZero(sizeof((*p))));
  if (p) {
    (p->iSize = iSize);
  }  
  return p;
}
static  int sqlite3BitvecTest(Bitvec *p , u32 i )  {
  if ((p == 0)) {
    return 0;
  }  
  if (((i > p->iSize) || (i == 0))) {
    return 0;
  }  
  i--;
  while (p->iDivisor) {
    u32 bin =  (i / p->iDivisor);
    (i = (i % p->iDivisor));
    (p = p->u.apSub[bin]);
    if ((! p)) {
      return 0;
    }  
  }
  if ((p->iSize <= (((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8 )) * 8))) {
    return ((p->u.aBitmap[(i / 8)] & (1 << (i & (8 - 1)))) != 0);
  }  
  else {
    u32 h =  ((i++ * 1) % ((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )));
    while (p->u.aHash[h]) {
      if ((p->u.aHash[h] == i)) {
        return 1;
      }  
      (h = ((h + 1) % ((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 ))));
    }
    return 0;
  }
}
static  int sqlite3BitvecSet(Bitvec *p , u32 i )  {
  u32 h;
  if ((p == 0)) {
    return 0;
  }  
  ((void ) 0);
  ((void ) 0);
  i--;
  while (((p->iSize > (((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8 )) * 8)) && p->iDivisor)) {
    u32 bin =  (i / p->iDivisor);
    (i = (i % p->iDivisor));
    if ((p->u.apSub[bin] == 0)) {
      (p->u.apSub[bin] = sqlite3BitvecCreate(p->iDivisor));
      if ((p->u.apSub[bin] == 0)) {
        return 7;
      }  
    }  
    (p = p->u.apSub[bin]);
  }
  if ((p->iSize <= (((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8 )) * 8))) {
    (p->u.aBitmap[(i / 8)] |= (1 << (i & (8 - 1))));
    return 0;
  }  
  (h = ((i++ * 1) % ((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 ))));
  if ((! p->u.aHash[h])) {
    if ((p->nSet < (((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )) - 1))) {
      goto bitvec_set_end;
    }  
    else {
      goto bitvec_set_rehash;
    }
  }  
  do {
    if ((p->u.aHash[h] == i)) {
      return 0;
    }  
    h++;
    if ((h >= ((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )))) {
      (h = 0);
    }  
  } while (p->u.aHash[h]);
  bitvec_set_rehash:
  if ((p->nSet >= (((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )) / 2))) {
    unsigned int j;
    int rc;
    u32 *aiValues =  sqlite3DbMallocRaw(0, sizeof(p->u.aHash));
    if ((aiValues == 0)) {
      return 7;
    }  
    else {
      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
      memset(p->u.apSub, 0, sizeof(p->u.apSub));
      (p->iDivisor = ((p->iSize + ((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *)) - 1) / ((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))));
      (rc = sqlite3BitvecSet(p, i));
      for ((j = 0); (j < ((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 ))); j++) {
        if (aiValues[j]) {
          (rc |= sqlite3BitvecSet(p, aiValues[j]));
        }  
      }
      sqlite3DbFree(0, aiValues);
      return rc;
    }
  }  
  bitvec_set_end:
  p->nSet++;
  (p->u.aHash[h] = i);
  return 0;
}
static  void sqlite3BitvecClear(Bitvec *p , u32 i , void *pBuf )  {
  if ((p == 0)) {
    return;
  }  
  ((void ) 0);
  i--;
  while (p->iDivisor) {
    u32 bin =  (i / p->iDivisor);
    (i = (i % p->iDivisor));
    (p = p->u.apSub[bin]);
    if ((! p)) {
      return;
    }  
  }
  if ((p->iSize <= (((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8 )) * 8))) {
    (p->u.aBitmap[(i / 8)] &= (~ (1 << (i & (8 - 1)))));
  }  
  else {
    unsigned int j;
    u32 *aiValues =  pBuf;
    memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
    memset(p->u.aHash, 0, sizeof(p->u.aHash));
    (p->nSet = 0);
    for ((j = 0); (j < ((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 ))); j++) {
      if ((aiValues[j] && (aiValues[j] != (i + 1)))) {
        u32 h =  (((aiValues[j] - 1) * 1) % ((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )));
        p->nSet++;
        while (p->u.aHash[h]) {
          h++;
          if ((h >= ((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )))) {
            (h = 0);
          }  
        }
        (p->u.aHash[h] = aiValues[j]);
      }  
    }
  }
}
static  void sqlite3BitvecDestroy(Bitvec *p )  {
  if ((p == 0)) {
    return;
  }  
  if (p->iDivisor) {
    unsigned int i;
    for ((i = 0); (i < ((((512 - (3 * sizeof(u32 ))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))); i++) {
      sqlite3BitvecDestroy(p->u.apSub[i]);
    }
  }  
  sqlite3_free(p);
}
static  u32 sqlite3BitvecSize(Bitvec *p )  {
  return p->iSize;
}
static  int sqlite3BitvecBuiltinTest(int sz , int *aOp )  {
  Bitvec *pBitvec =  0;
  unsigned char *pV =  0;
  int rc =  (- 1);
  int i, nx, pc, op;
  void *pTmpSpace;
  (pBitvec = sqlite3BitvecCreate(sz));
  (pV = sqlite3MallocZero((((sz + 7) / 8) + 1)));
  (pTmpSpace = sqlite3_malloc(512));
  if (((pBitvec == 0) || (pV == 0) || (pTmpSpace == 0))) {
    goto _1279_bitvec_end;
  }  
  sqlite3BitvecSet(0, 1);
  sqlite3BitvecClear(0, 1, pTmpSpace);
  (pc = 0);
  while (((op = aOp[pc]) != 0)) {
    switch (op) {
      case 1:
      case 2:
      case 5:
      {
        (nx = 4);
        (i = (aOp[(pc + 2)] - 1));
        (aOp[(pc + 2)] += aOp[(pc + 3)]);
        break;
      }
      case 3:
      case 4:
      id2i_label_1:
      default:
      {
        (nx = 2);
        sqlite3_randomness(sizeof(i), (&i));
        break;
      }
    }
    if ((--aOp[(pc + 1)] > 0)) {
      (nx = 0);
    }  
    (pc += nx);
    (i = ((i & 0x7fffffff) % sz));
    if (((op & 1) != 0)) {
      (pV[((i + 1) >> 3)] |= (1 << ((i + 1) & 7)));
      if ((op != 5)) {
        if (sqlite3BitvecSet(pBitvec, (i + 1))) {
          goto _1279_bitvec_end;
        }  
      }  
    }  
    else {
      (pV[((i + 1) >> 3)] &= (~ (1 << ((i + 1) & 7))));
      sqlite3BitvecClear(pBitvec, (i + 1), pTmpSpace);
    }
  }
  (rc = (sqlite3BitvecTest(0, 0) + sqlite3BitvecTest(pBitvec, (sz + 1)) + sqlite3BitvecTest(pBitvec, 0) + (sqlite3BitvecSize(pBitvec) - sz)));
  for ((i = 1); (i <= sz); i++) {
    if ((((pV[(i >> 3)] & (1 << (i & 7))) != 0) != sqlite3BitvecTest(pBitvec, i))) {
      (rc = i);
      break;
    }  
  }
  _1279_bitvec_end:
  sqlite3_free(pTmpSpace);
  sqlite3_free(pV);
  sqlite3BitvecDestroy(pBitvec);
  return rc;
}
struct  PCache {
  PgHdr *pDirty , *pDirtyTail ;
  PgHdr *pSynced ;
  int nRef ;
  int szCache ;
  int szPage ;
  int szExtra ;
  int bPurgeable ;
  int ( *xStress)(void * , PgHdr * ) ;
  void *pStress ;
  sqlite3_pcache *pCache ;
  PgHdr *pPage1 ;
}  ;
static  void pcacheRemoveFromDirtyList(PgHdr *pPage )  {
  PCache *p =  pPage->pCache;
  ((void ) 0);
  ((void ) 0);
  if ((p->pSynced == pPage)) {
    PgHdr *pSynced =  pPage->pDirtyPrev;
    while ((pSynced && (pSynced->flags & 0x004))) {
      (pSynced = pSynced->pDirtyPrev);
    }
    (p->pSynced = pSynced);
  }  
  if (pPage->pDirtyNext) {
    (pPage->pDirtyNext->pDirtyPrev = pPage->pDirtyPrev);
  }  
  else {
    ((void ) 0);
    (p->pDirtyTail = pPage->pDirtyPrev);
  }
  if (pPage->pDirtyPrev) {
    (pPage->pDirtyPrev->pDirtyNext = pPage->pDirtyNext);
  }  
  else {
    ((void ) 0);
    (p->pDirty = pPage->pDirtyNext);
  }
  (pPage->pDirtyNext = 0);
  (pPage->pDirtyPrev = 0);
  if (((id2i_sqlite_enable_expensive_assert ) )) {
    ((void ) 0);
  }  
}
static  void pcacheAddToDirtyList(PgHdr *pPage )  {
  PCache *p =  pPage->pCache;
  ((void ) 0);
  (pPage->pDirtyNext = p->pDirty);
  if (pPage->pDirtyNext) {
    ((void ) 0);
    (pPage->pDirtyNext->pDirtyPrev = pPage);
  }  
  (p->pDirty = pPage);
  if ((! p->pDirtyTail)) {
    (p->pDirtyTail = pPage);
  }  
  if (((! p->pSynced) && (0 == (pPage->flags & 0x004)))) {
    (p->pSynced = pPage);
  }  
  if (((id2i_sqlite_enable_expensive_assert ) )) {
    ((void ) 0);
  }  
}
static  void pcacheUnpin(PgHdr *p )  {
  PCache *pCache =  p->pCache;
  if (pCache->bPurgeable) {
    if ((p->pgno == 1)) {
      (pCache->pPage1 = 0);
    }  
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      _1283_sqlite3Config.pcache2.xUnpin(pCache->pCache, p->pPage, 0);
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      _1284_sqlite3Config.pcache2.xUnpin(pCache->pCache, p->pPage, 0);
    }  
  }  
}
static  int sqlite3PcacheInitialize(void )  {
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if ((_1283_sqlite3Config.pcache2.xInit == 0)) {
      sqlite3PCacheSetDefault();
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if ((_1284_sqlite3Config.pcache2.xInit == 0)) {
      sqlite3PCacheSetDefault();
    }  
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    return _1283_sqlite3Config.pcache2.xInit(_1283_sqlite3Config.pcache2.pArg);
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    return _1284_sqlite3Config.pcache2.xInit(_1284_sqlite3Config.pcache2.pArg);
  }  
}
static  void sqlite3PcacheShutdown(void )  {
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (_1283_sqlite3Config.pcache2.xShutdown) {
      _1283_sqlite3Config.pcache2.xShutdown(_1283_sqlite3Config.pcache2.pArg);
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (_1284_sqlite3Config.pcache2.xShutdown) {
      _1284_sqlite3Config.pcache2.xShutdown(_1284_sqlite3Config.pcache2.pArg);
    }  
  }  
}
static  int sqlite3PcacheSize(void )  {
  return sizeof(PCache );
}
static  void sqlite3PcacheOpen(int szPage , int szExtra , int bPurgeable , int ( *xStress)(void * , PgHdr * ) , void *pStress , PCache *p )  {
  memset(p, 0, sizeof(PCache ));
  (p->szPage = szPage);
  (p->szExtra = szExtra);
  (p->bPurgeable = bPurgeable);
  (p->xStress = xStress);
  (p->pStress = pStress);
  (p->szCache = 100);
}
static  void sqlite3PcacheSetPageSize(PCache *pCache , int szPage )  {
  ((void ) 0);
  if (pCache->pCache) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      _1283_sqlite3Config.pcache2.xDestroy(pCache->pCache);
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      _1284_sqlite3Config.pcache2.xDestroy(pCache->pCache);
    }  
    (pCache->pCache = 0);
    (pCache->pPage1 = 0);
  }  
  (pCache->szPage = szPage);
}
static  int numberOfCachePages(PCache *p )  {
  if ((p->szCache >= 0)) {
    return p->szCache;
  }  
  else {
    return ((int ) (((- 1024) * ((i64 ) p->szCache)) / (p->szPage + p->szExtra)));
  }
}
static  int sqlite3PcacheFetch(PCache *pCache , Pgno pgno , int createFlag , PgHdr **ppPage )  {
  sqlite3_pcache_page *pPage =  0;
  PgHdr *pPgHdr =  0;
  int eCreate;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((! pCache->pCache) && createFlag)) {
    sqlite3_pcache *p;
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      (p = _1283_sqlite3Config.pcache2.xCreate(pCache->szPage, (pCache->szExtra + sizeof(PgHdr )), pCache->bPurgeable));
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      (p = _1284_sqlite3Config.pcache2.xCreate(pCache->szPage, (pCache->szExtra + sizeof(PgHdr )), pCache->bPurgeable));
    }  
    if ((! p)) {
      return 7;
    }  
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      _1283_sqlite3Config.pcache2.xCachesize(p, numberOfCachePages(pCache));
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      _1284_sqlite3Config.pcache2.xCachesize(p, numberOfCachePages(pCache));
    }  
    (pCache->pCache = p);
  }  
  (eCreate = (createFlag * (1 + ((! pCache->bPurgeable) || (! pCache->pDirty)))));
  if (pCache->pCache) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      (pPage = _1283_sqlite3Config.pcache2.xFetch(pCache->pCache, pgno, eCreate));
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      (pPage = _1284_sqlite3Config.pcache2.xFetch(pCache->pCache, pgno, eCreate));
    }  
  }  
  if (((! pPage) && (eCreate == 1))) {
    PgHdr *pPg;
    if (((id2i_sqlite_enable_expensive_assert ) )) {
      ((void ) 0);
    }  
    for ((pPg = pCache->pSynced); (pPg && (pPg->nRef || (pPg->flags & 0x004))); (pPg = pPg->pDirtyPrev)) {
      
    }
    (pCache->pSynced = pPg);
    if ((! pPg)) {
      for ((pPg = pCache->pDirtyTail); (pPg && pPg->nRef); (pPg = pPg->pDirtyPrev)) {
        
      }
    }  
    if (pPg) {
      int rc;
      (rc = pCache->xStress(pCache->pStress, pPg));
      if (((rc != 0) && (rc != 5))) {
        return rc;
      }  
    }  
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      (pPage = _1283_sqlite3Config.pcache2.xFetch(pCache->pCache, pgno, 2));
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      (pPage = _1284_sqlite3Config.pcache2.xFetch(pCache->pCache, pgno, 2));
    }  
  }  
  if (pPage) {
    (pPgHdr = ((PgHdr *) pPage->pExtra));
    if ((! pPgHdr->pPage)) {
      memset(pPgHdr, 0, sizeof(PgHdr ));
      (pPgHdr->pPage = pPage);
      (pPgHdr->pData = pPage->pBuf);
      (pPgHdr->pExtra = ((void *) (&pPgHdr[1])));
      memset(pPgHdr->pExtra, 0, pCache->szExtra);
      (pPgHdr->pCache = pCache);
      (pPgHdr->pgno = pgno);
    }  
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    if ((0 == pPgHdr->nRef)) {
      pCache->nRef++;
    }  
    pPgHdr->nRef++;
    if ((pgno == 1)) {
      (pCache->pPage1 = pPgHdr);
    }  
  }  
  ((*ppPage) = pPgHdr);
  return (((pPgHdr == 0) && eCreate) ? 7 : 0);
}
static  void sqlite3PcacheRelease(PgHdr *p )  {
  ((void ) 0);
  p->nRef--;
  if ((p->nRef == 0)) {
    PCache *pCache =  p->pCache;
    pCache->nRef--;
    if (((p->flags & 0x002) == 0)) {
      pcacheUnpin(p);
    }  
    else {
      pcacheRemoveFromDirtyList(p);
      pcacheAddToDirtyList(p);
    }
  }  
}
static  void sqlite3PcacheRef(PgHdr *p )  {
  ((void ) 0);
  p->nRef++;
}
static  void sqlite3PcacheDrop(PgHdr *p )  {
  PCache *pCache;
  ((void ) 0);
  if ((p->flags & 0x002)) {
    pcacheRemoveFromDirtyList(p);
  }  
  (pCache = p->pCache);
  pCache->nRef--;
  if ((p->pgno == 1)) {
    (pCache->pPage1 = 0);
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    _1283_sqlite3Config.pcache2.xUnpin(pCache->pCache, p->pPage, 1);
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    _1284_sqlite3Config.pcache2.xUnpin(pCache->pCache, p->pPage, 1);
  }  
}
static  void sqlite3PcacheMakeDirty(PgHdr *p )  {
  (p->flags &= (~ 0x020));
  ((void ) 0);
  if ((0 == (p->flags & 0x002))) {
    (p->flags |= 0x002);
    pcacheAddToDirtyList(p);
  }  
}
static  void sqlite3PcacheMakeClean(PgHdr *p )  {
  if ((p->flags & 0x002)) {
    pcacheRemoveFromDirtyList(p);
    (p->flags &= (~ (0x002 | 0x004)));
    if ((p->nRef == 0)) {
      pcacheUnpin(p);
    }  
  }  
}
static  void sqlite3PcacheCleanAll(PCache *pCache )  {
  PgHdr *p;
  while (((p = pCache->pDirty) != 0)) {
    sqlite3PcacheMakeClean(p);
  }
}
static  void sqlite3PcacheClearSyncFlags(PCache *pCache )  {
  PgHdr *p;
  for ((p = pCache->pDirty); p; (p = p->pDirtyNext)) {
    (p->flags &= (~ 0x004));
  }
  (pCache->pSynced = pCache->pDirtyTail);
}
static  void sqlite3PcacheMove(PgHdr *p , Pgno newPgno )  {
  PCache *pCache =  p->pCache;
  ((void ) 0);
  ((void ) 0);
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    _1283_sqlite3Config.pcache2.xRekey(pCache->pCache, p->pPage, p->pgno, newPgno);
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    _1284_sqlite3Config.pcache2.xRekey(pCache->pCache, p->pPage, p->pgno, newPgno);
  }  
  (p->pgno = newPgno);
  if (((p->flags & 0x002) && (p->flags & 0x004))) {
    pcacheRemoveFromDirtyList(p);
    pcacheAddToDirtyList(p);
  }  
}
static  void sqlite3PcacheTruncate(PCache *pCache , Pgno pgno )  {
  if (pCache->pCache) {
    PgHdr *p;
    PgHdr *pNext;
    for ((p = pCache->pDirty); p; (p = pNext)) {
      (pNext = p->pDirtyNext);
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if (1) {
          ((void ) 0);
          sqlite3PcacheMakeClean(p);
        }  
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if ((p->pgno > pgno)) {
          ((void ) 0);
          sqlite3PcacheMakeClean(p);
        }  
      }  
    }
    if (((pgno == 0) && pCache->pPage1)) {
      memset(pCache->pPage1->pData, 0, pCache->szPage);
      (pgno = 1);
    }  
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      _1283_sqlite3Config.pcache2.xTruncate(pCache->pCache, (pgno + 1));
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      _1284_sqlite3Config.pcache2.xTruncate(pCache->pCache, (pgno + 1));
    }  
  }  
}
static  void sqlite3PcacheClose(PCache *pCache )  {
  if (pCache->pCache) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      _1283_sqlite3Config.pcache2.xDestroy(pCache->pCache);
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      _1284_sqlite3Config.pcache2.xDestroy(pCache->pCache);
    }  
  }  
}
static  void sqlite3PcacheClear(PCache *pCache )  {
  sqlite3PcacheTruncate(pCache, 0);
}
static  PgHdr *pcacheMergeDirtyList(PgHdr *pA , PgHdr *pB )  {
  PgHdr result, *pTail;
  (pTail = (&result));
  while ((pA && pB)) {
    if ((pA->pgno < pB->pgno)) {
      (pTail->pDirty = pA);
      (pTail = pA);
      (pA = pA->pDirty);
    }  
    else {
      (pTail->pDirty = pB);
      (pTail = pB);
      (pB = pB->pDirty);
    }
  }
  if (pA) {
    (pTail->pDirty = pA);
  } 
  else if (pB) {
    (pTail->pDirty = pB);
  } 
  else {
    (pTail->pDirty = 0);
  }
  return result.pDirty;
}
static  PgHdr *pcacheSortDirtyList(PgHdr *pIn )  {
  PgHdr *a[32], *p;
  int i;
  memset(a, 0, sizeof(a));
  while (pIn) {
    (p = pIn);
    (pIn = p->pDirty);
    (p->pDirty = 0);
    if (((id2i_sqlite_coverage_test ) )) {
      for ((i = 0); 1; i++) {
        if ((a[i] == 0)) {
          (a[i] = p);
          break;
        }  
        else {
          (p = pcacheMergeDirtyList(a[i], p));
          (a[i] = 0);
        }
      }
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      for ((i = 0); (i < (32 - 1)); i++) {
        if ((a[i] == 0)) {
          (a[i] = p);
          break;
        }  
        else {
          (p = pcacheMergeDirtyList(a[i], p));
          (a[i] = 0);
        }
      }
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if (0) {
        (a[i] = pcacheMergeDirtyList(a[i], p));
      }  
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      if ((i == (32 - 1))) {
        (a[i] = pcacheMergeDirtyList(a[i], p));
      }  
    }  
  }
  (p = a[0]);
  for ((i = 1); (i < 32); i++) {
    (p = pcacheMergeDirtyList(p, a[i]));
  }
  return p;
}
static  PgHdr *sqlite3PcacheDirtyList(PCache *pCache )  {
  PgHdr *p;
  for ((p = pCache->pDirty); p; (p = p->pDirtyNext)) {
    (p->pDirty = p->pDirtyNext);
  }
  return pcacheSortDirtyList(pCache->pDirty);
}
static  int sqlite3PcacheRefCount(PCache *pCache )  {
  return pCache->nRef;
}
static  int sqlite3PcachePageRefcount(PgHdr *p )  {
  return p->nRef;
}
static  int sqlite3PcachePagecount(PCache *pCache )  {
  int nPage =  0;
  if (pCache->pCache) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      (nPage = _1283_sqlite3Config.pcache2.xPagecount(pCache->pCache));
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      (nPage = _1284_sqlite3Config.pcache2.xPagecount(pCache->pCache));
    }  
  }  
  return nPage;
}
static  void sqlite3PcacheSetCachesize(PCache *pCache , int mxPage )  {
  (pCache->szCache = mxPage);
  if (pCache->pCache) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      _1283_sqlite3Config.pcache2.xCachesize(pCache->pCache, numberOfCachePages(pCache));
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      _1284_sqlite3Config.pcache2.xCachesize(pCache->pCache, numberOfCachePages(pCache));
    }  
  }  
}
static  void sqlite3PcacheShrink(PCache *pCache )  {
  if (pCache->pCache) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      _1283_sqlite3Config.pcache2.xShrink(pCache->pCache);
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      _1284_sqlite3Config.pcache2.xShrink(pCache->pCache);
    }  
  }  
}
static  void sqlite3PcacheIterateDirty(PCache *pCache , void ( *xIter)(PgHdr * ) )  {
  PgHdr *pDirty;
  for ((pDirty = pCache->pDirty); pDirty; (pDirty = pDirty->pDirtyNext)) {
    xIter(pDirty);
  }
}
typedef struct  PCache1   PCache1;
typedef struct  PgHdr1   PgHdr1;
typedef struct  PgFreeslot   PgFreeslot;
typedef struct  PGroup   PGroup;
struct  PGroup {
  sqlite3_mutex *mutex ;
  unsigned  int nMaxPage ;
  unsigned  int nMinPage ;
  unsigned  int mxPinned ;
  unsigned  int nCurrentPage ;
  PgHdr1 *pLruHead , *pLruTail ;
}  ;
struct  PCache1 {
  PGroup *pGroup ;
  int szPage ;
  int szExtra ;
  int bPurgeable ;
  unsigned  int nMin ;
  unsigned  int nMax ;
  unsigned  int n90pct ;
  unsigned  int iMaxKey ;
  unsigned  int nRecyclable ;
  unsigned  int nPage ;
  unsigned  int nHash ;
  PgHdr1 **apHash ;
}  ;
struct  PgHdr1 {
  sqlite3_pcache_page page ;
  unsigned  int iKey ;
  PgHdr1 *pNext ;
  PCache1 *pCache ;
  PgHdr1 *pLruNext ;
  PgHdr1 *pLruPrev ;
}  ;
struct  PgFreeslot {
  PgFreeslot *pNext ;
}  ;
static struct  PCacheGlobal {
  PGroup grp ;
  int isInit ;
  int szSlot ;
  int nSlot ;
  int nReserve ;
  void *pStart , *pEnd ;
  sqlite3_mutex *mutex ;
  PgFreeslot *pFree ;
  int nFreeSlot ;
  int bUnderPressure ;
}  pcache1_g;
static  void sqlite3PCacheBufferSetup(void *pBuf , int sz , int n )  {
  if (pcache1_g.isInit) {
    PgFreeslot *p;
    (sz = (sz & (~ 7)));
    (pcache1_g.szSlot = sz);
    (pcache1_g.nSlot = (pcache1_g.nFreeSlot = n));
    (pcache1_g.nReserve = ((n > 90) ? 10 : ((n / 10) + 1)));
    (pcache1_g.pStart = pBuf);
    (pcache1_g.pFree = 0);
    (pcache1_g.bUnderPressure = 0);
    while (n--) {
      (p = ((PgFreeslot *) pBuf));
      (p->pNext = pcache1_g.pFree);
      (pcache1_g.pFree = p);
      (pBuf = ((void *) (&((char *) pBuf)[sz])));
    }
    (pcache1_g.pEnd = pBuf);
  }  
}
static  void *pcache1Alloc(int nByte )  {
  void *p =  0;
  ((void ) 0);
  sqlite3StatusSet(7, nByte);
  if ((nByte <= pcache1_g.szSlot)) {
    (p = ((PgHdr1 *) pcache1_g.pFree));
    if (p) {
      (pcache1_g.pFree = pcache1_g.pFree->pNext);
      pcache1_g.nFreeSlot--;
      (pcache1_g.bUnderPressure = (pcache1_g.nFreeSlot < pcache1_g.nReserve));
      ((void ) 0);
      sqlite3StatusAdd(1, 1);
    }  
  }  
  if ((p == 0)) {
    (p = sqlite3Malloc(nByte));
    if (p) {
      int sz =  sqlite3MallocSize(p);
      sqlite3StatusAdd(2, sz);
    }  
  }  
  return p;
}
static  int pcache1Free(void *p )  {
  int nFreed =  0;
  if ((p == 0)) {
    return 0;
  }  
  if (((p >= pcache1_g.pStart) && (p < pcache1_g.pEnd))) {
    PgFreeslot *pSlot;
    sqlite3StatusAdd(1, (- 1));
    (pSlot = ((PgFreeslot *) p));
    (pSlot->pNext = pcache1_g.pFree);
    (pcache1_g.pFree = pSlot);
    pcache1_g.nFreeSlot++;
    (pcache1_g.bUnderPressure = (pcache1_g.nFreeSlot < pcache1_g.nReserve));
    ((void ) 0);
  }  
  else {
    ((void ) 0);
    (nFreed = sqlite3MallocSize(p));
    sqlite3StatusAdd(2, (- nFreed));
    sqlite3_free(p);
  }
  return nFreed;
}
static  int pcache1MemSize(void *p )  {
  if (((p >= pcache1_g.pStart) && (p < pcache1_g.pEnd))) {
    return pcache1_g.szSlot;
  }  
  else {
    int iSize;
    ((void ) 0);
    (iSize = sqlite3MallocSize(p));
    return iSize;
  }
}
static  PgHdr1 *pcache1AllocPage(PCache1 *pCache )  {
  PgHdr1 *p =  0;
  void *pPg;
  ((void ) 0);
  (pPg = pcache1Alloc((sizeof(PgHdr1 ) + pCache->szPage + pCache->szExtra)));
  (p = ((PgHdr1 *) (&((u8 *) pPg)[pCache->szPage])));
  if (pPg) {
    (p->page.pBuf = pPg);
    (p->page.pExtra = (&p[1]));
    if (pCache->bPurgeable) {
      pCache->pGroup->nCurrentPage++;
    }  
    return p;
  }  
  return 0;
}
static  void pcache1FreePage(PgHdr1 *p )  {
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      PCache1 *pCache =  p->pCache;
      ((void ) 0);
      pcache1Free(p->page.pBuf);
      if (pCache->bPurgeable) {
        pCache->pGroup->nCurrentPage--;
      }  
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (p) {
      PCache1 *pCache =  p->pCache;
      ((void ) 0);
      pcache1Free(p->page.pBuf);
      if (pCache->bPurgeable) {
        pCache->pGroup->nCurrentPage--;
      }  
    }  
  }  
}
static  void *sqlite3PageMalloc(int sz )  {
  return pcache1Alloc(sz);
}
static  void sqlite3PageFree(void *p )  {
  pcache1Free(p);
}
static  int pcache1UnderMemoryPressure(PCache1 *pCache )  {
  if ((pcache1_g.nSlot && ((pCache->szPage + pCache->szExtra) <= pcache1_g.szSlot))) {
    return pcache1_g.bUnderPressure;
  }  
  else {
    return sqlite3HeapNearlyFull();
  }
}
static  int pcache1ResizeHash(PCache1 *p )  {
  PgHdr1 **apNew;
  unsigned int nNew;
  unsigned int i;
  ((void ) 0);
  (nNew = (p->nHash * 2));
  if ((nNew < 256)) {
    (nNew = 256);
  }  
  if (p->nHash) {
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      sqlite3BeginBenignMalloc();
    }  
  }  
  (apNew = ((PgHdr1 **) sqlite3MallocZero((sizeof(PgHdr1 *) * nNew))));
  if (p->nHash) {
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      sqlite3EndBenignMalloc();
    }  
  }  
  if (apNew) {
    for ((i = 0); (i < p->nHash); i++) {
      PgHdr1 *pPage;
      PgHdr1 *pNext =  p->apHash[i];
      while (((pPage = pNext) != 0)) {
        unsigned int h =  (pPage->iKey % nNew);
        (pNext = pPage->pNext);
        (pPage->pNext = apNew[h]);
        (apNew[h] = pPage);
      }
    }
    sqlite3_free(p->apHash);
    (p->apHash = apNew);
    (p->nHash = nNew);
  }  
  return (p->apHash ? 0 : 7);
}
static  void pcache1PinPage(PgHdr1 *pPage )  {
  PCache1 *pCache;
  PGroup *pGroup;
  if ((pPage == 0)) {
    return;
  }  
  (pCache = pPage->pCache);
  (pGroup = pCache->pGroup);
  ((void ) 0);
  if ((pPage->pLruNext || (pPage == pGroup->pLruTail))) {
    if (pPage->pLruPrev) {
      (pPage->pLruPrev->pLruNext = pPage->pLruNext);
    }  
    if (pPage->pLruNext) {
      (pPage->pLruNext->pLruPrev = pPage->pLruPrev);
    }  
    if ((pGroup->pLruHead == pPage)) {
      (pGroup->pLruHead = pPage->pLruNext);
    }  
    if ((pGroup->pLruTail == pPage)) {
      (pGroup->pLruTail = pPage->pLruPrev);
    }  
    (pPage->pLruNext = 0);
    (pPage->pLruPrev = 0);
    pPage->pCache->nRecyclable--;
  }  
}
static  void pcache1RemoveFromHash(PgHdr1 *pPage )  {
  unsigned int h;
  PCache1 *pCache =  pPage->pCache;
  PgHdr1 **pp;
  ((void ) 0);
  (h = (pPage->iKey % pCache->nHash));
  for ((pp = (&pCache->apHash[h])); ((*pp) != pPage); (pp = (&(*pp)->pNext))) {
    
  }
  ((*pp) = (*pp)->pNext);
  pCache->nPage--;
}
static  void pcache1EnforceMaxPage(PGroup *pGroup )  {
  ((void ) 0);
  while (((pGroup->nCurrentPage > pGroup->nMaxPage) && pGroup->pLruTail)) {
    PgHdr1 *p =  pGroup->pLruTail;
    ((void ) 0);
    pcache1PinPage(p);
    pcache1RemoveFromHash(p);
    pcache1FreePage(p);
  }
}
static  void pcache1TruncateUnsafe(PCache1 *pCache , unsigned  int iLimit )  {
  unsigned int _1267_nPage =  0;
  unsigned int h;
  ((void ) 0);
  for ((h = 0); (h < pCache->nHash); h++) {
    PgHdr1 **pp =  (&pCache->apHash[h]);
    PgHdr1 *pPage;
    while (((pPage = (*pp)) != 0)) {
      if ((pPage->iKey >= iLimit)) {
        pCache->nPage--;
        ((*pp) = pPage->pNext);
        pcache1PinPage(pPage);
        pcache1FreePage(pPage);
      }  
      else {
        (pp = (&pPage->pNext));
        if (((id2i_sqlite_coverage_test ) )) {
          _1267_nPage++;
        }  
      }
    }
  }
  ((void ) 0);
}
static  int pcache1Init(void *NotUsed )  {
  ((void ) NotUsed);
  ((void ) 0);
  memset((&pcache1_g), 0, sizeof(pcache1_g));
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (_1283_sqlite3Config.bCoreMutex) {
      (pcache1_g.grp.mutex = ((sqlite3_mutex *) 8));
      (pcache1_g.mutex = ((sqlite3_mutex *) 8));
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (_1284_sqlite3Config.bCoreMutex) {
      (pcache1_g.grp.mutex = ((sqlite3_mutex *) 8));
      (pcache1_g.mutex = ((sqlite3_mutex *) 8));
    }  
  }  
  (pcache1_g.grp.mxPinned = 10);
  (pcache1_g.isInit = 1);
  return 0;
}
static  void pcache1Shutdown(void *NotUsed )  {
  ((void ) NotUsed);
  ((void ) 0);
  memset((&pcache1_g), 0, sizeof(pcache1_g));
}
static  sqlite3_pcache *pcache1Create(int szPage , int szExtra , int bPurgeable )  {
  PCache1 *pCache;
  PGroup *pGroup;
  int sz;
  const int separateCache =  0;
  ((void ) 0);
  ((void ) 0);
  (sz = (sizeof(PCache1 ) + (sizeof(PGroup ) * separateCache)));
  (pCache = ((PCache1 *) sqlite3MallocZero(sz)));
  if (pCache) {
    if (separateCache) {
      (pGroup = ((PGroup *) (&pCache[1])));
      (pGroup->mxPinned = 10);
    }  
    else {
      (pGroup = (&pcache1_g.grp));
    }
    (pCache->pGroup = pGroup);
    (pCache->szPage = szPage);
    (pCache->szExtra = szExtra);
    (pCache->bPurgeable = (bPurgeable ? 1 : 0));
    if (bPurgeable) {
      (pCache->nMin = 10);
      (pGroup->nMinPage += pCache->nMin);
      (pGroup->mxPinned = (pGroup->nMaxPage + 10 - pGroup->nMinPage));
    }  
  }  
  return ((sqlite3_pcache *) pCache);
}
static  void pcache1Cachesize(sqlite3_pcache *p , int nMax )  {
  PCache1 *pCache =  ((PCache1 *) p);
  if (pCache->bPurgeable) {
    PGroup *pGroup =  pCache->pGroup;
    (pGroup->nMaxPage += (nMax - pCache->nMax));
    (pGroup->mxPinned = (pGroup->nMaxPage + 10 - pGroup->nMinPage));
    (pCache->nMax = nMax);
    (pCache->n90pct = (pCache->nMax * 9 / 10));
    pcache1EnforceMaxPage(pGroup);
  }  
}
static  void pcache1Shrink(sqlite3_pcache *p )  {
  PCache1 *pCache =  ((PCache1 *) p);
  if (pCache->bPurgeable) {
    PGroup *pGroup =  pCache->pGroup;
    int savedMaxPage;
    (savedMaxPage = pGroup->nMaxPage);
    (pGroup->nMaxPage = 0);
    pcache1EnforceMaxPage(pGroup);
    (pGroup->nMaxPage = savedMaxPage);
  }  
}
static  int pcache1Pagecount(sqlite3_pcache *p )  {
  int n;
  PCache1 *pCache =  ((PCache1 *) p);
  (n = pCache->nPage);
  return n;
}
static  sqlite3_pcache_page *pcache1Fetch(sqlite3_pcache *p , unsigned  int iKey , int createFlag )  {
  unsigned int nPinned;
  PCache1 *pCache =  ((PCache1 *) p);
  PGroup *pGroup;
  PgHdr1 *pPage =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pCache->nHash > 0)) {
    unsigned int h =  (iKey % pCache->nHash);
    for ((pPage = pCache->apHash[h]); (pPage && (pPage->iKey != iKey)); (pPage = pPage->pNext)) {
      
    }
  }  
  if ((pPage || (createFlag == 0))) {
    pcache1PinPage(pPage);
    goto fetch_out;
  }  
  (pGroup = pCache->pGroup);
  ((void ) 0);
  (nPinned = (pCache->nPage - pCache->nRecyclable));
  ((void ) 0);
  ((void ) 0);
  if (((createFlag == 1) && ((nPinned >= pGroup->mxPinned) || (nPinned >= pCache->n90pct) || pcache1UnderMemoryPressure(pCache)))) {
    goto fetch_out;
  }  
  if (((pCache->nPage >= pCache->nHash) && pcache1ResizeHash(pCache))) {
    goto fetch_out;
  }  
  ((void ) 0);
  if ((pCache->bPurgeable && pGroup->pLruTail && (((pCache->nPage + 1) >= pCache->nMax) || (pGroup->nCurrentPage >= pGroup->nMaxPage) || pcache1UnderMemoryPressure(pCache)))) {
    PCache1 *pOther;
    (pPage = pGroup->pLruTail);
    pcache1RemoveFromHash(pPage);
    pcache1PinPage(pPage);
    (pOther = pPage->pCache);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    if (((pOther->szPage + pOther->szExtra) != (pCache->szPage + pCache->szExtra))) {
      pcache1FreePage(pPage);
      (pPage = 0);
    }  
    else {
      (pGroup->nCurrentPage -= (pOther->bPurgeable - pCache->bPurgeable));
    }
  }  
  if ((! pPage)) {
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      if ((createFlag == 1)) {
        sqlite3BeginBenignMalloc();
      }  
    }  
    if (((id2i_sqlite_omit_builtin_test ) )) {
      if ((createFlag == 1)) {
        
      }  
    }  
    (pPage = pcache1AllocPage(pCache));
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      if ((createFlag == 1)) {
        sqlite3EndBenignMalloc();
      }  
    }  
    if (((id2i_sqlite_omit_builtin_test ) )) {
      if ((createFlag == 1)) {
        
      }  
    }  
  }  
  if (pPage) {
    unsigned int h =  (iKey % pCache->nHash);
    pCache->nPage++;
    (pPage->iKey = iKey);
    (pPage->pNext = pCache->apHash[h]);
    (pPage->pCache = pCache);
    (pPage->pLruPrev = 0);
    (pPage->pLruNext = 0);
    ((*((void **) pPage->page.pExtra)) = 0);
    (pCache->apHash[h] = pPage);
  }  
  fetch_out:
  if ((pPage && (iKey > pCache->iMaxKey))) {
    (pCache->iMaxKey = iKey);
  }  
  return (&pPage->page);
}
static  void pcache1Unpin(sqlite3_pcache *p , sqlite3_pcache_page *pPg , int reuseUnlikely )  {
  PCache1 *pCache =  ((PCache1 *) p);
  PgHdr1 *pPage =  ((PgHdr1 *) pPg);
  PGroup *pGroup =  pCache->pGroup;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((reuseUnlikely || (pGroup->nCurrentPage > pGroup->nMaxPage))) {
    pcache1RemoveFromHash(pPage);
    pcache1FreePage(pPage);
  }  
  else {
    if (pGroup->pLruHead) {
      (pGroup->pLruHead->pLruPrev = pPage);
      (pPage->pLruNext = pGroup->pLruHead);
      (pGroup->pLruHead = pPage);
    }  
    else {
      (pGroup->pLruTail = pPage);
      (pGroup->pLruHead = pPage);
    }
    pCache->nRecyclable++;
  }
}
static  void pcache1Rekey(sqlite3_pcache *p , sqlite3_pcache_page *pPg , unsigned  int iOld , unsigned  int iNew )  {
  PCache1 *pCache =  ((PCache1 *) p);
  PgHdr1 *pPage =  ((PgHdr1 *) pPg);
  PgHdr1 **pp;
  unsigned int h;
  ((void ) 0);
  ((void ) 0);
  (h = (iOld % pCache->nHash));
  (pp = (&pCache->apHash[h]));
  while (((*pp) != pPage)) {
    (pp = (&(*pp)->pNext));
  }
  ((*pp) = pPage->pNext);
  (h = (iNew % pCache->nHash));
  (pPage->iKey = iNew);
  (pPage->pNext = pCache->apHash[h]);
  (pCache->apHash[h] = pPage);
  if ((iNew > pCache->iMaxKey)) {
    (pCache->iMaxKey = iNew);
  }  
}
static  void pcache1Truncate(sqlite3_pcache *p , unsigned  int iLimit )  {
  PCache1 *pCache =  ((PCache1 *) p);
  if ((iLimit <= pCache->iMaxKey)) {
    pcache1TruncateUnsafe(pCache, iLimit);
    (pCache->iMaxKey = (iLimit - 1));
  }  
}
static  void pcache1Destroy(sqlite3_pcache *p )  {
  PCache1 *pCache =  ((PCache1 *) p);
  PGroup *pGroup =  pCache->pGroup;
  ((void ) 0);
  pcache1TruncateUnsafe(pCache, 0);
  ((void ) 0);
  (pGroup->nMaxPage -= pCache->nMax);
  ((void ) 0);
  (pGroup->nMinPage -= pCache->nMin);
  (pGroup->mxPinned = (pGroup->nMaxPage + 10 - pGroup->nMinPage));
  pcache1EnforceMaxPage(pGroup);
  sqlite3_free(pCache->apHash);
  sqlite3_free(pCache);
}
static  void sqlite3PCacheSetDefault(void )  {
  static const sqlite3_pcache_methods2 defaultMethods =  { 1,  0,  pcache1Init,  pcache1Shutdown,  pcache1Create,  pcache1Cachesize,  pcache1Pagecount,  pcache1Fetch,  pcache1Unpin,  pcache1Rekey,  pcache1Truncate,  pcache1Destroy,  pcache1Shrink};
  sqlite3_config(18, (&defaultMethods));
}
static  int sqlite3PcacheReleaseMemory(int nReq )  {
  int nFree =  0;
  ((void ) 0);
  ((void ) 0);
  if ((pcache1_g.pStart == 0)) {
    PgHdr1 *p;
    while ((((nReq < 0) || (nFree < nReq)) && ((p = pcache1_g.grp.pLruTail) != 0))) {
      (nFree += pcache1MemSize(p->page.pBuf));
      pcache1PinPage(p);
      pcache1RemoveFromHash(p);
      pcache1FreePage(p);
    }
  }  
  return nFree;
}
struct  RowSetEntry {
  i64 v ;
  struct  RowSetEntry   *pRight ;
  struct  RowSetEntry   *pLeft ;
}  ;
struct  RowSetChunk {
  struct  RowSetChunk   *pNextChunk ;
  struct  RowSetEntry   aEntry[((1024 - 8) / sizeof(struct  RowSetEntry   ))] ;
}  ;
struct  RowSet {
  struct  RowSetChunk   *pChunk ;
  sqlite3 *db ;
  struct  RowSetEntry   *pEntry ;
  struct  RowSetEntry   *pLast ;
  struct  RowSetEntry   *pFresh ;
  struct  RowSetEntry   *pForest ;
  u16 nFresh ;
  u8 rsFlags ;
  u8 iBatch ;
}  ;
static  RowSet *sqlite3RowSetInit(sqlite3 *db , void *pSpace , unsigned  int N )  {
  RowSet *p;
  ((void ) 0);
  (p = pSpace);
  (p->pChunk = 0);
  (p->db = db);
  (p->pEntry = 0);
  (p->pLast = 0);
  (p->pForest = 0);
  (p->pFresh = ((struct  RowSetEntry   *) (((sizeof((*p)) + 7) & (~ 7)) + ((char *) p))));
  (p->nFresh = ((u16 ) ((N - ((sizeof((*p)) + 7) & (~ 7))) / sizeof(struct  RowSetEntry   ))));
  (p->rsFlags = 0x01);
  (p->iBatch = 0);
  return p;
}
static  void sqlite3RowSetClear(RowSet *p )  {
  struct  RowSetChunk   *pChunk, *pNextChunk;
  for ((pChunk = p->pChunk); pChunk; (pChunk = pNextChunk)) {
    (pNextChunk = pChunk->pNextChunk);
    sqlite3DbFree(p->db, pChunk);
  }
  (p->pChunk = 0);
  (p->nFresh = 0);
  (p->pEntry = 0);
  (p->pLast = 0);
  (p->pForest = 0);
  (p->rsFlags = 0x01);
}
static  struct  RowSetEntry   *rowSetEntryAlloc(RowSet *p )  {
  ((void ) 0);
  if ((p->nFresh == 0)) {
    struct  RowSetChunk   *pNew;
    (pNew = sqlite3DbMallocRaw(p->db, sizeof((*pNew))));
    if ((pNew == 0)) {
      return 0;
    }  
    (pNew->pNextChunk = p->pChunk);
    (p->pChunk = pNew);
    (p->pFresh = pNew->aEntry);
    (p->nFresh = ((1024 - 8) / sizeof(struct  RowSetEntry   )));
  }  
  p->nFresh--;
  return p->pFresh++;
}
static  void sqlite3RowSetInsert(RowSet *p , i64 rowid )  {
  struct  RowSetEntry   *pEntry;
  struct  RowSetEntry   *pLast;
  ((void ) 0);
  (pEntry = rowSetEntryAlloc(p));
  if ((pEntry == 0)) {
    return;
  }  
  (pEntry->v = rowid);
  (pEntry->pRight = 0);
  (pLast = p->pLast);
  if (pLast) {
    if ((((p->rsFlags & 0x01) != 0) && (rowid <= pLast->v))) {
      (p->rsFlags &= (~ 0x01));
    }  
    (pLast->pRight = pEntry);
  }  
  else {
    (p->pEntry = pEntry);
  }
  (p->pLast = pEntry);
}
static  struct  RowSetEntry   *rowSetEntryMerge(struct  RowSetEntry   *pA , struct  RowSetEntry   *pB )  {
  struct  RowSetEntry   head;
  struct  RowSetEntry   *pTail;
  (pTail = (&head));
  while ((pA && pB)) {
    ((void ) 0);
    ((void ) 0);
    if ((pA->v < pB->v)) {
      (pTail->pRight = pA);
      (pA = pA->pRight);
      (pTail = pTail->pRight);
    } 
    else if ((pB->v < pA->v)) {
      (pTail->pRight = pB);
      (pB = pB->pRight);
      (pTail = pTail->pRight);
    } 
    else {
      (pA = pA->pRight);
    }
  }
  if (pA) {
    ((void ) 0);
    (pTail->pRight = pA);
  }  
  else {
    ((void ) 0);
    (pTail->pRight = pB);
  }
  return head.pRight;
}
static  struct  RowSetEntry   *rowSetEntrySort(struct  RowSetEntry   *pIn )  {
  unsigned int i;
  struct  RowSetEntry   *pNext, *aBucket[40];
  memset(aBucket, 0, sizeof(aBucket));
  while (pIn) {
    (pNext = pIn->pRight);
    (pIn->pRight = 0);
    for ((i = 0); aBucket[i]; i++) {
      (pIn = rowSetEntryMerge(aBucket[i], pIn));
      (aBucket[i] = 0);
    }
    (aBucket[i] = pIn);
    (pIn = pNext);
  }
  (pIn = 0);
  for ((i = 0); (i < (sizeof(aBucket) / sizeof(aBucket[0]))); i++) {
    (pIn = rowSetEntryMerge(pIn, aBucket[i]));
  }
  return pIn;
}
static  void rowSetTreeToList(struct  RowSetEntry   *pIn , struct  RowSetEntry   **ppFirst , struct  RowSetEntry   **ppLast )  {
  ((void ) 0);
  if (pIn->pLeft) {
    struct  RowSetEntry   *p;
    rowSetTreeToList(pIn->pLeft, ppFirst, (&p));
    (p->pRight = pIn);
  }  
  else {
    ((*ppFirst) = pIn);
  }
  if (pIn->pRight) {
    rowSetTreeToList(pIn->pRight, (&pIn->pRight), ppLast);
  }  
  else {
    ((*ppLast) = pIn);
  }
  ((void ) 0);
}
static  struct  RowSetEntry   *rowSetNDeepTree(struct  RowSetEntry   **ppList , int iDepth )  {
  struct  RowSetEntry   *p;
  struct  RowSetEntry   *pLeft;
  if (((*ppList) == 0)) {
    return 0;
  }  
  if ((iDepth == 1)) {
    (p = (*ppList));
    ((*ppList) = p->pRight);
    (p->pLeft = (p->pRight = 0));
    return p;
  }  
  (pLeft = rowSetNDeepTree(ppList, (iDepth - 1)));
  (p = (*ppList));
  if ((p == 0)) {
    return pLeft;
  }  
  (p->pLeft = pLeft);
  ((*ppList) = p->pRight);
  (p->pRight = rowSetNDeepTree(ppList, (iDepth - 1)));
  return p;
}
static  struct  RowSetEntry   *rowSetListToTree(struct  RowSetEntry   *pList )  {
  int iDepth;
  struct  RowSetEntry   *p;
  struct  RowSetEntry   *pLeft;
  ((void ) 0);
  (p = pList);
  (pList = p->pRight);
  (p->pLeft = (p->pRight = 0));
  for ((iDepth = 1); pList; iDepth++) {
    (pLeft = p);
    (p = pList);
    (pList = p->pRight);
    (p->pLeft = pLeft);
    (p->pRight = rowSetNDeepTree((&pList), iDepth));
  }
  return p;
}
static  void rowSetToList(RowSet *p )  {
  ((void ) 0);
  if (((p->rsFlags & 0x01) == 0)) {
    (p->pEntry = rowSetEntrySort(p->pEntry));
  }  
  ((void ) 0);
  (p->rsFlags |= 0x02);
}
static  int sqlite3RowSetNext(RowSet *p , i64 *pRowid )  {
  ((void ) 0);
  if (((p->rsFlags & 0x02) == 0)) {
    rowSetToList(p);
  }  
  if (p->pEntry) {
    ((*pRowid) = p->pEntry->v);
    (p->pEntry = p->pEntry->pRight);
    if ((p->pEntry == 0)) {
      sqlite3RowSetClear(p);
    }  
    return 1;
  }  
  else {
    return 0;
  }
}
static  int sqlite3RowSetTest(RowSet *pRowSet , u8 iBatch , sqlite3_int64 iRowid )  {
  struct  RowSetEntry   *p, *pTree;
  ((void ) 0);
  if ((iBatch != pRowSet->iBatch)) {
    (p = pRowSet->pEntry);
    if (p) {
      struct  RowSetEntry   **ppPrevTree =  (&pRowSet->pForest);
      if (((pRowSet->rsFlags & 0x01) == 0)) {
        (p = rowSetEntrySort(p));
      }  
      for ((pTree = pRowSet->pForest); pTree; (pTree = pTree->pRight)) {
        (ppPrevTree = (&pTree->pRight));
        if ((pTree->pLeft == 0)) {
          (pTree->pLeft = rowSetListToTree(p));
          break;
        }  
        else {
          struct  RowSetEntry   *pAux, *pTail;
          rowSetTreeToList(pTree->pLeft, (&pAux), (&pTail));
          (pTree->pLeft = 0);
          (p = rowSetEntryMerge(pAux, p));
        }
      }
      if ((pTree == 0)) {
        ((*ppPrevTree) = (pTree = rowSetEntryAlloc(pRowSet)));
        if (pTree) {
          (pTree->v = 0);
          (pTree->pRight = 0);
          (pTree->pLeft = rowSetListToTree(p));
        }  
      }  
      (pRowSet->pEntry = 0);
      (pRowSet->pLast = 0);
      (pRowSet->rsFlags |= 0x01);
    }  
    (pRowSet->iBatch = iBatch);
  }  
  for ((pTree = pRowSet->pForest); pTree; (pTree = pTree->pRight)) {
    (p = pTree->pLeft);
    while (p) {
      if ((p->v < iRowid)) {
        (p = p->pRight);
      } 
      else if ((p->v > iRowid)) {
        (p = p->pLeft);
      } 
      else {
        return 1;
      }
    }
  }
  return 0;
}
typedef struct  Wal   Wal;
static int sqlite3WalOpen(sqlite3_vfs * , sqlite3_file * , const  char * , int , i64 , Wal ** );
static int sqlite3WalClose(Wal *pWal , int sync_flags , int , u8 * );
static void sqlite3WalLimit(Wal * , i64 );
static int sqlite3WalBeginReadTransaction(Wal *pWal , int * );
static void sqlite3WalEndReadTransaction(Wal *pWal );
static int sqlite3WalFindFrame(Wal * , Pgno , u32 * );
static int sqlite3WalReadFrame(Wal * , u32 , int , u8 * );
static Pgno sqlite3WalDbsize(Wal *pWal );
static int sqlite3WalBeginWriteTransaction(Wal *pWal );
static int sqlite3WalEndWriteTransaction(Wal *pWal );
static int sqlite3WalUndo(Wal *pWal , int ( *xUndo)(void * , Pgno ) , void *pUndoCtx );
static void sqlite3WalSavepoint(Wal *pWal , u32 *aWalData );
static int sqlite3WalSavepointUndo(Wal *pWal , u32 *aWalData );
static int sqlite3WalFrames(Wal *pWal , int , PgHdr * , Pgno , int , int );
static int sqlite3WalCheckpoint(Wal *pWal , int eMode , int ( *xBusy)(void * ) , void *pBusyArg , int sync_flags , int nBuf , u8 *zBuf , int *pnLog , int *pnCkpt );
static int sqlite3WalCallback(Wal *pWal );
static int sqlite3WalExclusiveMode(Wal *pWal , int op );
static int sqlite3WalHeapMemory(Wal *pWal );
typedef struct  PagerSavepoint   PagerSavepoint;
struct  PagerSavepoint {
  i64 iOffset ;
  i64 iHdrOffset ;
  Bitvec *pInSavepoint ;
  Pgno nOrig ;
  Pgno iSubRec ;
  u32 aWalData[4] ;
}  ;
struct  Pager {
  sqlite3_vfs *pVfs ;
  u8 exclusiveMode ;
  u8 journalMode ;
  u8 useJournal ;
  u8 noSync ;
  u8 fullSync ;
  u8 ckptSyncFlags ;
  u8 walSyncFlags ;
  u8 syncFlags ;
  u8 tempFile ;
  u8 readOnly ;
  u8 memDb ;
  u8 eState ;
  u8 eLock ;
  u8 changeCountDone ;
  u8 setMaster ;
  u8 doNotSpill ;
  u8 subjInMemory ;
  Pgno dbSize ;
  Pgno dbOrigSize ;
  Pgno dbFileSize ;
  Pgno dbHintSize ;
  int errCode ;
  int nRec ;
  u32 cksumInit ;
  u32 nSubRec ;
  Bitvec *pInJournal ;
  sqlite3_file *fd ;
  sqlite3_file *jfd ;
  sqlite3_file *sjfd ;
  i64 journalOff ;
  i64 journalHdr ;
  sqlite3_backup *pBackup ;
  PagerSavepoint *aSavepoint ;
  int nSavepoint ;
  char dbFileVers[16] ;
  u8 bUseFetch ;
  int nMmapOut ;
  sqlite3_int64 szMmap ;
  PgHdr *pMmapFreelist ;
  u16 nExtra ;
  i16 nReserve ;
  u32 vfsFlags ;
  u32 sectorSize ;
  int pageSize ;
  Pgno mxPgno ;
  i64 journalSizeLimit ;
  char *zFilename ;
  char *zJournal ;
  int ( *xBusyHandler)(void * ) ;
  void *pBusyHandlerArg ;
  int aStat[3] ;
  void ( *xReiniter)(DbPage * ) ;
  char *pTmpSpace ;
  PCache *pPCache ;
  Wal *pWal ;
  char *zWal ;
}  ;
static const unsigned char aJournalMagic[] =  { 0xd9,  0xd5,  0x05,  0xf9,  0x20,  0xa1,  0x63,  0xd7};
static  int pagerUseWal(Pager *pPager )  {
  return (pPager->pWal != 0);
}
static  int subjRequiresPage(PgHdr *pPg )  {
  Pager *pPager =  pPg->pPager;
  PagerSavepoint *p;
  Pgno pgno;
  int i;
  if (pPager->nSavepoint) {
    (pgno = pPg->pgno);
    for ((i = 0); (i < pPager->nSavepoint); i++) {
      (p = (&pPager->aSavepoint[i]));
      if (((p->nOrig >= pgno) && (0 == sqlite3BitvecTest(p->pInSavepoint, pgno)))) {
        return 1;
      }  
    }
  }  
  return 0;
}
static  int pageInJournal(PgHdr *pPg )  {
  return sqlite3BitvecTest(pPg->pPager->pInJournal, pPg->pgno);
}
static  int read32bits(sqlite3_file *fd , i64 offset , u32 *pRes )  {
  unsigned char ac[4];
  int rc =  sqlite3OsRead(fd, ac, sizeof(ac), offset);
  if ((rc == 0)) {
    ((*pRes) = sqlite3Get4byte(ac));
  }  
  return rc;
}
static  int write32bits(sqlite3_file *fd , i64 offset , u32 val )  {
  char ac[4];
  sqlite3Put4byte(((u8 *) ac), val);
  return sqlite3OsWrite(fd, ac, 4, offset);
}
static  int pagerUnlockDb(Pager *pPager , int eLock )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (pPager->fd->pMethods) {
    ((void ) 0);
    (rc = sqlite3OsUnlock(pPager->fd, eLock));
    if ((pPager->eLock != (4 + 1))) {
      (pPager->eLock = ((u8 ) eLock));
    }  
    if (((id2i_sqlite_enable_iotrace ) )) {
      if (_1280_sqlite3IoTrace) {
        _1280_sqlite3IoTrace("UNLOCK %p %d\n", pPager, eLock);
      }  
    }  
  }  
  return rc;
}
static  int pagerLockDb(Pager *pPager , int eLock )  {
  int rc =  0;
  ((void ) 0);
  if (((pPager->eLock < eLock) || (pPager->eLock == (4 + 1)))) {
    (rc = sqlite3OsLock(pPager->fd, eLock));
    if (((rc == 0) && ((pPager->eLock != (4 + 1)) || (eLock == 4)))) {
      (pPager->eLock = ((u8 ) eLock));
      if (((id2i_sqlite_enable_iotrace ) )) {
        if (_1280_sqlite3IoTrace) {
          _1280_sqlite3IoTrace("LOCK %p %d\n", pPager, eLock);
        }  
      }  
    }  
  }  
  return rc;
}
static  u32 pager_datahash(int nByte , unsigned  char *pData )  {
  u32 hash =  0;
  int i;
  for ((i = 0); (i < nByte); i++) {
    (hash = ((hash * 1039) + pData[i]));
  }
  return hash;
}
static  u32 pager_pagehash(PgHdr *pPage )  {
  return pager_datahash(pPage->pPager->pageSize, ((unsigned  char *) pPage->pData));
}
static  void pager_set_pagehash(PgHdr *pPage )  {
  (pPage->_1270_pageHash = pager_pagehash(pPage));
}
static  void checkPage(PgHdr *pPg )  {
  Pager *pPager =  pPg->pPager;
  ((void ) 0);
  ((void ) 0);
}
static  int readMasterJournal(sqlite3_file *pJrnl , char *zMaster , u32 nMaster )  {
  int rc;
  u32 len;
  i64 szJ;
  u32 cksum;
  u32 u;
  unsigned char aMagic[8];
  (zMaster[0] = '\0');
  if (((0 != (rc = sqlite3OsFileSize(pJrnl, (&szJ)))) || (szJ < 16) || (0 != (rc = read32bits(pJrnl, (szJ - 16), (&len)))) || (len >= nMaster) || (0 != (rc = read32bits(pJrnl, (szJ - 12), (&cksum)))) || (0 != (rc = sqlite3OsRead(pJrnl, aMagic, 8, (szJ - 8)))) || memcmp(aMagic, aJournalMagic, 8) || (0 != (rc = sqlite3OsRead(pJrnl, zMaster, len, (szJ - 16 - len)))))) {
    return rc;
  }  
  for ((u = 0); (u < len); u++) {
    (cksum -= zMaster[u]);
  }
  if (cksum) {
    (len = 0);
  }  
  (zMaster[len] = '\0');
  return 0;
}
static  i64 journalHdrOffset(Pager *pPager )  {
  i64 offset =  0;
  i64 c =  pPager->journalOff;
  if (c) {
    (offset = ((((c - 1) / pPager->sectorSize) + 1) * pPager->sectorSize));
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  return offset;
}
static  int zeroJournalHdr(Pager *pPager , int doTruncate )  {
  int rc =  0;
  ((void ) 0);
  if (pPager->journalOff) {
    const i64 iLimit =  pPager->journalSizeLimit;
    if (((id2i_sqlite_enable_iotrace ) )) {
      if (_1280_sqlite3IoTrace) {
        _1280_sqlite3IoTrace("JZEROHDR %p\n", pPager);
      }  
    }  
    if ((doTruncate || (iLimit == 0))) {
      (rc = sqlite3OsTruncate(pPager->jfd, 0));
    }  
    else {
      static const char zeroHdr[28] =  { 0};
      (rc = sqlite3OsWrite(pPager->jfd, zeroHdr, sizeof(zeroHdr), 0));
    }
    if (((rc == 0) && (! pPager->noSync))) {
      (rc = sqlite3OsSync(pPager->jfd, (0x00010 | pPager->syncFlags)));
    }  
    if (((rc == 0) && (iLimit > 0))) {
      i64 sz;
      (rc = sqlite3OsFileSize(pPager->jfd, (&sz)));
      if (((rc == 0) && (sz > iLimit))) {
        (rc = sqlite3OsTruncate(pPager->jfd, iLimit));
      }  
    }  
  }  
  return rc;
}
static  int writeJournalHdr(Pager *pPager )  {
  int rc =  0;
  char *zHeader =  pPager->pTmpSpace;
  u32 nHeader =  ((u32 ) pPager->pageSize);
  u32 nWrite;
  int ii;
  ((void ) 0);
  if ((nHeader > pPager->sectorSize)) {
    (nHeader = pPager->sectorSize);
  }  
  for ((ii = 0); (ii < pPager->nSavepoint); ii++) {
    if ((pPager->aSavepoint[ii].iHdrOffset == 0)) {
      (pPager->aSavepoint[ii].iHdrOffset = pPager->journalOff);
    }  
  }
  (pPager->journalHdr = (pPager->journalOff = journalHdrOffset(pPager)));
  ((void ) 0);
  if ((pPager->noSync || (pPager->journalMode == 4) || (sqlite3OsDeviceCharacteristics(pPager->fd) & 0x00000200))) {
    memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
    sqlite3Put4byte(((u8 *) (&zHeader[sizeof(aJournalMagic)])), 0xffffffff);
  }  
  else {
    memset(zHeader, 0, (sizeof(aJournalMagic) + 4));
  }
  sqlite3_randomness(sizeof(pPager->cksumInit), (&pPager->cksumInit));
  sqlite3Put4byte(((u8 *) (&zHeader[(sizeof(aJournalMagic) + 4)])), pPager->cksumInit);
  sqlite3Put4byte(((u8 *) (&zHeader[(sizeof(aJournalMagic) + 8)])), pPager->dbOrigSize);
  sqlite3Put4byte(((u8 *) (&zHeader[(sizeof(aJournalMagic) + 12)])), pPager->sectorSize);
  sqlite3Put4byte(((u8 *) (&zHeader[(sizeof(aJournalMagic) + 16)])), pPager->pageSize);
  memset((&zHeader[(sizeof(aJournalMagic) + 20)]), 0, (nHeader - (sizeof(aJournalMagic) + 20)));
  for ((nWrite = 0); ((rc == 0) && (nWrite < pPager->sectorSize)); (nWrite += nHeader)) {
    if (((id2i_sqlite_enable_iotrace ) )) {
      if (_1280_sqlite3IoTrace) {
        _1280_sqlite3IoTrace("JHDR %p %lld %d\n", pPager, pPager->journalHdr, nHeader);
      }  
    }  
    (rc = sqlite3OsWrite(pPager->jfd, zHeader, nHeader, pPager->journalOff));
    ((void ) 0);
    (pPager->journalOff += nHeader);
  }
  return rc;
}
static  int readJournalHdr(Pager *pPager , int isHot , i64 journalSize , u32 *pNRec , u32 *pDbSize )  {
  int rc;
  unsigned char aMagic[8];
  i64 iHdrOff;
  ((void ) 0);
  (pPager->journalOff = journalHdrOffset(pPager));
  if (((pPager->journalOff + pPager->sectorSize) > journalSize)) {
    return 101;
  }  
  (iHdrOff = pPager->journalOff);
  if ((isHot || (iHdrOff != pPager->journalHdr))) {
    (rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic), iHdrOff));
    if (rc) {
      return rc;
    }  
    if ((memcmp(aMagic, aJournalMagic, sizeof(aMagic)) != 0)) {
      return 101;
    }  
  }  
  if (((0 != (rc = read32bits(pPager->jfd, (iHdrOff + 8), pNRec))) || (0 != (rc = read32bits(pPager->jfd, (iHdrOff + 12), (&pPager->cksumInit)))) || (0 != (rc = read32bits(pPager->jfd, (iHdrOff + 16), pDbSize))))) {
    return rc;
  }  
  if ((pPager->journalOff == 0)) {
    u32 iPageSize;
    u32 iSectorSize;
    if (((0 != (rc = read32bits(pPager->jfd, (iHdrOff + 20), (&iSectorSize)))) || (0 != (rc = read32bits(pPager->jfd, (iHdrOff + 24), (&iPageSize)))))) {
      return rc;
    }  
    if ((iPageSize == 0)) {
      (iPageSize = pPager->pageSize);
    }  
    if (((iPageSize < 512) || (iSectorSize < 32) || (iPageSize > 65536) || (iSectorSize > 0x10000) || (((iPageSize - 1) & iPageSize) != 0) || (((iSectorSize - 1) & iSectorSize) != 0))) {
      return 101;
    }  
    (rc = sqlite3PagerSetPagesize(pPager, (&iPageSize), (- 1)));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((rc != 0)) {
        sqlite3Coverage(40164);
      }  
    }  
    (pPager->sectorSize = iSectorSize);
  }  
  (pPager->journalOff += pPager->sectorSize);
  return rc;
}
static  int writeMasterJournal(Pager *pPager , const  char *zMaster )  {
  int rc;
  int nMaster;
  i64 iHdrOff;
  i64 jrnlSize;
  u32 cksum =  0;
  ((void ) 0);
  ((void ) 0);
  if (((! zMaster) || (pPager->journalMode == 4) || (pPager->journalMode == 2))) {
    return 0;
  }  
  (pPager->setMaster = 1);
  ((void ) 0);
  ((void ) 0);
  for ((nMaster = 0); zMaster[nMaster]; nMaster++) {
    (cksum += zMaster[nMaster]);
  }
  if (pPager->fullSync) {
    (pPager->journalOff = journalHdrOffset(pPager));
  }  
  (iHdrOff = pPager->journalOff);
  if (((0 != (rc = write32bits(pPager->jfd, iHdrOff, ((Pgno ) ((sqlite3PendingByte / pPager->pageSize) + 1))))) || (0 != (rc = sqlite3OsWrite(pPager->jfd, zMaster, nMaster, (iHdrOff + 4)))) || (0 != (rc = write32bits(pPager->jfd, (iHdrOff + 4 + nMaster), nMaster))) || (0 != (rc = write32bits(pPager->jfd, (iHdrOff + 4 + nMaster + 4), cksum))) || (0 != (rc = sqlite3OsWrite(pPager->jfd, aJournalMagic, 8, (iHdrOff + 4 + nMaster + 8)))))) {
    return rc;
  }  
  (pPager->journalOff += (nMaster + 20));
  if (((0 == (rc = sqlite3OsFileSize(pPager->jfd, (&jrnlSize)))) && (jrnlSize > pPager->journalOff))) {
    (rc = sqlite3OsTruncate(pPager->jfd, pPager->journalOff));
  }  
  return rc;
}
static  PgHdr *pager_lookup(Pager *pPager , Pgno pgno )  {
  PgHdr *p;
  ((void ) sqlite3PcacheFetch(pPager->pPCache, pgno, 0, (&p)));
  return p;
}
static  void pager_reset(Pager *pPager )  {
  sqlite3BackupRestart(pPager->pBackup);
  sqlite3PcacheClear(pPager->pPCache);
}
static  void releaseAllSavepoints(Pager *pPager )  {
  int ii;
  for ((ii = 0); (ii < pPager->nSavepoint); ii++) {
    sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
  }
  if (((! pPager->exclusiveMode) || sqlite3IsMemJournal(pPager->sjfd))) {
    sqlite3OsClose(pPager->sjfd);
  }  
  sqlite3_free(pPager->aSavepoint);
  (pPager->aSavepoint = 0);
  (pPager->nSavepoint = 0);
  (pPager->nSubRec = 0);
}
static  int addToSavepointBitvecs(Pager *pPager , Pgno pgno )  {
  int ii;
  int rc =  0;
  for ((ii = 0); (ii < pPager->nSavepoint); ii++) {
    PagerSavepoint *p =  (&pPager->aSavepoint[ii]);
    if ((pgno <= p->nOrig)) {
      (rc |= sqlite3BitvecSet(p->pInSavepoint, pgno));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((rc == 7)) {
          sqlite3Coverage(40319);
        }  
      }  
      ((void ) 0);
    }  
  }
  return rc;
}
static  void pager_unlock(Pager *pPager )  {
  ((void ) 0);
  sqlite3BitvecDestroy(pPager->pInJournal);
  (pPager->pInJournal = 0);
  releaseAllSavepoints(pPager);
  if (pagerUseWal(pPager)) {
    ((void ) 0);
    sqlite3WalEndReadTransaction(pPager->pWal);
    (pPager->eState = 0);
  } 
  else if ((! pPager->exclusiveMode)) {
    int rc;
    int iDc =  (pPager->fd->pMethods ? sqlite3OsDeviceCharacteristics(pPager->fd) : 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    if (((0 == (iDc & 0x00000800)) || (1 != (pPager->journalMode & 5)))) {
      sqlite3OsClose(pPager->jfd);
    }  
    (rc = pagerUnlockDb(pPager, 0));
    if (((rc != 0) && (pPager->eState == 6))) {
      (pPager->eLock = (4 + 1));
    }  
    ((void ) 0);
    (pPager->changeCountDone = 0);
    (pPager->eState = 0);
  } 
  if (pPager->errCode) {
    ((void ) 0);
    pager_reset(pPager);
    (pPager->changeCountDone = pPager->tempFile);
    (pPager->eState = 0);
    (pPager->errCode = 0);
    if (0) {
      sqlite3OsUnfetch(pPager->fd, 0, 0);
    }  
  }  
  (pPager->journalOff = 0);
  (pPager->journalHdr = 0);
  (pPager->setMaster = 0);
}
static  int pager_error(Pager *pPager , int rc )  {
  int rc2 =  (rc & 0xff);
  ((void ) 0);
  ((void ) 0);
  if (((rc2 == 13) || (rc2 == 10))) {
    (pPager->errCode = rc);
    (pPager->eState = 6);
  }  
  return rc;
}
static int pager_truncate(Pager *pPager , Pgno nPage );
static  int pager_end_transaction(Pager *pPager , int hasMaster , int bCommit )  {
  int rc =  0;
  int rc2 =  0;
  ((void ) 0);
  ((void ) 0);
  if (((pPager->eState < 2) && (pPager->eLock < 2))) {
    return 0;
  }  
  releaseAllSavepoints(pPager);
  ((void ) 0);
  if (pPager->jfd->pMethods) {
    ((void ) 0);
    if (sqlite3IsMemJournal(pPager->jfd)) {
      ((void ) 0);
      sqlite3OsClose(pPager->jfd);
    } 
    else if ((pPager->journalMode == 3)) {
      if ((pPager->journalOff == 0)) {
        (rc = 0);
      }  
      else {
        (rc = sqlite3OsTruncate(pPager->jfd, 0));
      }
      (pPager->journalOff = 0);
    }
    
    else if (((pPager->journalMode == 1) || (pPager->exclusiveMode && (pPager->journalMode != 5)))) {
      (rc = zeroJournalHdr(pPager, hasMaster));
      (pPager->journalOff = 0);
    } 
    else {
      int bDelete =  ((! pPager->tempFile) && 1);
      ((void ) 0);
      sqlite3OsClose(pPager->jfd);
      if (bDelete) {
        (rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0));
      }  
    }
  }  
  if (((id2i_sqlite_check_pages ) )) {
    sqlite3PcacheIterateDirty(pPager->pPCache, pager_set_pagehash);
  }  
  if (((id2i_sqlite_check_pages ) )) {
    if (((pPager->dbSize == 0) && (sqlite3PcacheRefCount(pPager->pPCache) > 0))) {
      PgHdr *p =  pager_lookup(pPager, 1);
      if (p) {
        (p->_1270_pageHash = 0);
        sqlite3PagerUnref(p);
      }  
    }  
  }  
  sqlite3BitvecDestroy(pPager->pInJournal);
  (pPager->pInJournal = 0);
  (pPager->nRec = 0);
  sqlite3PcacheCleanAll(pPager->pPCache);
  sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);
  if (pagerUseWal(pPager)) {
    (rc2 = sqlite3WalEndWriteTransaction(pPager->pWal));
    ((void ) 0);
  } 
  else if (((rc == 0) && bCommit && (pPager->dbFileSize > pPager->dbSize))) {
    ((void ) 0);
    (rc = pager_truncate(pPager, pPager->dbSize));
  } 
  if (((! pPager->exclusiveMode) && ((! pagerUseWal(pPager)) || sqlite3WalExclusiveMode(pPager->pWal, 0)))) {
    (rc2 = pagerUnlockDb(pPager, 1));
    (pPager->changeCountDone = 0);
  }  
  (pPager->eState = 1);
  (pPager->setMaster = 0);
  return ((rc == 0) ? rc2 : rc);
}
static  void pagerUnlockAndRollback(Pager *pPager )  {
  if (((pPager->eState != 6) && (pPager->eState != 0))) {
    ((void ) 0);
    if ((pPager->eState >= 2)) {
      if ((((! id2i_sqlite_omit_builtin_test) ) )) {
        sqlite3BeginBenignMalloc();
      }  
      sqlite3PagerRollback(pPager);
      if ((((! id2i_sqlite_omit_builtin_test) ) )) {
        sqlite3EndBenignMalloc();
      }  
    } 
    else if ((! pPager->exclusiveMode)) {
      ((void ) 0);
      pager_end_transaction(pPager, 0, 0);
    } 
  }  
  pager_unlock(pPager);
}
static  u32 pager_cksum(Pager *pPager , const  u8 *aData )  {
  u32 cksum =  pPager->cksumInit;
  int i =  (pPager->pageSize - 200);
  while ((i > 0)) {
    (cksum += aData[i]);
    (i -= 200);
  }
  return cksum;
}
static  int pager_playback_one_page(Pager *pPager , i64 *pOffset , Bitvec *pDone , int isMainJrnl , int isSavepnt )  {
  int rc;
  PgHdr *pPg;
  Pgno pgno;
  u32 cksum;
  char *aData;
  sqlite3_file *jfd;
  int isSynced;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (aData = pPager->pTmpSpace);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (jfd = (isMainJrnl ? pPager->jfd : pPager->sjfd));
  (rc = read32bits(jfd, (*pOffset), (&pgno)));
  if ((rc != 0)) {
    return rc;
  }  
  (rc = sqlite3OsRead(jfd, ((u8 *) aData), pPager->pageSize, ((*pOffset) + 4)));
  if ((rc != 0)) {
    return rc;
  }  
  ((*pOffset) += (pPager->pageSize + 4 + (isMainJrnl * 4)));
  if (((pgno == 0) || (pgno == ((Pgno ) ((sqlite3PendingByte / pPager->pageSize) + 1))))) {
    ((void ) 0);
    return 101;
  }  
  if (((pgno > ((Pgno ) pPager->dbSize)) || sqlite3BitvecTest(pDone, pgno))) {
    return 0;
  }  
  if (isMainJrnl) {
    (rc = read32bits(jfd, ((*pOffset) - 4), (&cksum)));
    if (rc) {
      return rc;
    }  
    if (((! isSavepnt) && (pager_cksum(pPager, ((u8 *) aData)) != cksum))) {
      return 101;
    }  
  }  
  if ((pDone && ((rc = sqlite3BitvecSet(pDone, pgno)) != 0))) {
    return rc;
  }  
  if (((pgno == 1) && (pPager->nReserve != ((u8 *) aData)[20]))) {
    (pPager->nReserve = ((u8 *) aData)[20]);
  }  
  if (pagerUseWal(pPager)) {
    (pPg = 0);
  }  
  else {
    (pPg = pager_lookup(pPager, pgno));
  }
  ((void ) 0);
  ((void ) 0);
  if (isMainJrnl) {
    (isSynced = (pPager->noSync || ((*pOffset) <= pPager->journalHdr)));
  }  
  else {
    (isSynced = ((pPg == 0) || (0 == (pPg->flags & 0x004))));
  }
  if ((pPager->fd->pMethods && ((pPager->eState >= 4) || (pPager->eState == 0)) && isSynced)) {
    i64 ofst =  ((pgno - 1) * ((i64 ) pPager->pageSize));
    if (((id2i_sqlite_coverage_test ) )) {
      if (((! isSavepnt) && (pPg != 0) && ((pPg->flags & 0x004) != 0))) {
        sqlite3Coverage(40863);
      }  
    }  
    ((void ) 0);
    (rc = sqlite3OsWrite(pPager->fd, ((u8 *) aData), pPager->pageSize, ofst));
    if ((pgno > pPager->dbFileSize)) {
      (pPager->dbFileSize = pgno);
    }  
    if (pPager->pBackup) {
      sqlite3BackupUpdate(pPager->pBackup, pgno, ((u8 *) aData));
      (aData = ((char *) aData));
    }  
  } 
  else if (((! isMainJrnl) && (pPg == 0))) {
    ((void ) 0);
    ((void ) 0);
    (pPager->doNotSpill |= 0x02);
    (rc = sqlite3PagerAcquire(pPager, pgno, (&pPg), 1));
    ((void ) 0);
    (pPager->doNotSpill &= (~ 0x02));
    if ((rc != 0)) {
      return rc;
    }  
    (pPg->flags &= (~ 0x008));
    sqlite3PcacheMakeDirty(pPg);
  } 
  if (pPg) {
    void *pData;
    (pData = pPg->pData);
    memcpy(pData, ((u8 *) aData), pPager->pageSize);
    pPager->xReiniter(pPg);
    if ((isMainJrnl && ((! isSavepnt) || ((*pOffset) <= pPager->journalHdr)))) {
      ((void ) 0);
      sqlite3PcacheMakeClean(pPg);
    }  
    if (((id2i_sqlite_check_pages ) )) {
      pager_set_pagehash(pPg);
    }  
    if ((pgno == 1)) {
      memcpy((&pPager->dbFileVers), (&((u8 *) pData)[24]), sizeof(pPager->dbFileVers));
    }  
    sqlite3PcacheRelease(pPg);
  }  
  return rc;
}
static  int pager_delmaster(Pager *pPager , const  char *zMaster )  {
  sqlite3_vfs *pVfs =  pPager->pVfs;
  int rc;
  sqlite3_file *pMaster;
  sqlite3_file *pJournal;
  char *zMasterJournal =  0;
  i64 nMasterJournal;
  char *zJournal;
  char *zMasterPtr;
  int nMasterPtr;
  (pMaster = ((sqlite3_file *) sqlite3MallocZero((pVfs->szOsFile * 2))));
  (pJournal = ((sqlite3_file *) (((u8 *) pMaster) + pVfs->szOsFile)));
  if ((! pMaster)) {
    (rc = 7);
  }  
  else {
    const int flags =  (0x00000001 | 0x00004000);
    (rc = sqlite3OsOpen(pVfs, zMaster, pMaster, flags, 0));
  }
  if ((rc != 0)) {
    goto delmaster_out;
  }  
  (rc = sqlite3OsFileSize(pMaster, (&nMasterJournal)));
  if ((rc != 0)) {
    goto delmaster_out;
  }  
  (nMasterPtr = (pVfs->mxPathname + 1));
  (zMasterJournal = sqlite3Malloc((((int ) nMasterJournal) + nMasterPtr + 1)));
  if ((! zMasterJournal)) {
    (rc = 7);
    goto delmaster_out;
  }  
  (zMasterPtr = (&zMasterJournal[(nMasterJournal + 1)]));
  (rc = sqlite3OsRead(pMaster, zMasterJournal, ((int ) nMasterJournal), 0));
  if ((rc != 0)) {
    goto delmaster_out;
  }  
  (zMasterJournal[nMasterJournal] = 0);
  (zJournal = zMasterJournal);
  while (((zJournal - zMasterJournal) < nMasterJournal)) {
    int exists;
    (rc = sqlite3OsAccess(pVfs, zJournal, 0, (&exists)));
    if ((rc != 0)) {
      goto delmaster_out;
    }  
    if (exists) {
      int c;
      int flags =  (0x00000001 | 0x00000800);
      (rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0));
      if ((rc != 0)) {
        goto delmaster_out;
      }  
      (rc = readMasterJournal(pJournal, zMasterPtr, nMasterPtr));
      sqlite3OsClose(pJournal);
      if ((rc != 0)) {
        goto delmaster_out;
      }  
      (c = ((zMasterPtr[0] != 0) && (strcmp(zMasterPtr, zMaster) == 0)));
      if (c) {
        goto delmaster_out;
      }  
    }  
    (zJournal += (sqlite3Strlen30(zJournal) + 1));
  }
  sqlite3OsClose(pMaster);
  (rc = sqlite3OsDelete(pVfs, zMaster, 0));
  delmaster_out:
  sqlite3_free(zMasterJournal);
  if (pMaster) {
    sqlite3OsClose(pMaster);
    ((void ) 0);
    sqlite3_free(pMaster);
  }  
  return rc;
}
static  int pager_truncate(Pager *pPager , Pgno nPage )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  if ((pPager->fd->pMethods && ((pPager->eState >= 4) || (pPager->eState == 0)))) {
    i64 currentSize, newSize;
    int szPage =  pPager->pageSize;
    ((void ) 0);
    (rc = sqlite3OsFileSize(pPager->fd, (&currentSize)));
    (newSize = (szPage * ((i64 ) nPage)));
    if (((rc == 0) && (currentSize != newSize))) {
      if ((currentSize > newSize)) {
        (rc = sqlite3OsTruncate(pPager->fd, newSize));
      } 
      else if (((currentSize + szPage) <= newSize)) {
        char *pTmp =  pPager->pTmpSpace;
        memset(pTmp, 0, szPage);
        if (((id2i_sqlite_coverage_test ) )) {
          if (((newSize - szPage) == currentSize)) {
            sqlite3Coverage(41123);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if (((newSize - szPage) > currentSize)) {
            sqlite3Coverage(41124);
          }  
        }  
        (rc = sqlite3OsWrite(pPager->fd, pTmp, szPage, (newSize - szPage)));
      } 
      if ((rc == 0)) {
        (pPager->dbFileSize = nPage);
      }  
    }  
  }  
  return rc;
}
static  int sqlite3SectorSize(sqlite3_file *pFile )  {
  int iRet =  sqlite3OsSectorSize(pFile);
  if ((iRet < 32)) {
    (iRet = 512);
  } 
  else if ((iRet > 0x10000)) {
    ((void ) 0);
    (iRet = 0x10000);
  } 
  return iRet;
}
static  void setSectorSize(Pager *pPager )  {
  ((void ) 0);
  if ((pPager->tempFile || ((sqlite3OsDeviceCharacteristics(pPager->fd) & 0x00001000) != 0))) {
    (pPager->sectorSize = 512);
  }  
  else {
    (pPager->sectorSize = sqlite3SectorSize(pPager->fd));
  }
}
static  int pager_playback(Pager *pPager , int isHot )  {
  sqlite3_vfs *pVfs =  pPager->pVfs;
  i64 szJ;
  u32 nRec;
  u32 u;
  Pgno mxPg =  0;
  int rc;
  int res =  1;
  char *zMaster =  0;
  int needPagerReset;
  int nPlayback =  0;
  ((void ) 0);
  (rc = sqlite3OsFileSize(pPager->jfd, (&szJ)));
  if ((rc != 0)) {
    goto end_playback;
  }  
  (zMaster = pPager->pTmpSpace);
  (rc = readMasterJournal(pPager->jfd, zMaster, (pPager->pVfs->mxPathname + 1)));
  if (((rc == 0) && zMaster[0])) {
    (rc = sqlite3OsAccess(pVfs, zMaster, 0, (&res)));
  }  
  (zMaster = 0);
  if (((rc != 0) || (! res))) {
    goto end_playback;
  }  
  (pPager->journalOff = 0);
  (needPagerReset = isHot);
  while (1) {
    (rc = readJournalHdr(pPager, isHot, szJ, (&nRec), (&mxPg)));
    if ((rc != 0)) {
      if ((rc == 101)) {
        (rc = 0);
      }  
      goto end_playback;
    }  
    if ((nRec == 0xffffffff)) {
      ((void ) 0);
      (nRec = ((int ) ((szJ - pPager->sectorSize) / (pPager->pageSize + 8))));
    }  
    if (((nRec == 0) && (! isHot) && ((pPager->journalHdr + pPager->sectorSize) == pPager->journalOff))) {
      (nRec = ((int ) ((szJ - pPager->journalOff) / (pPager->pageSize + 8))));
    }  
    if ((pPager->journalOff == pPager->sectorSize)) {
      (rc = pager_truncate(pPager, mxPg));
      if ((rc != 0)) {
        goto end_playback;
      }  
      (pPager->dbSize = mxPg);
    }  
    for ((u = 0); (u < nRec); u++) {
      if (needPagerReset) {
        pager_reset(pPager);
        (needPagerReset = 0);
      }  
      (rc = pager_playback_one_page(pPager, (&pPager->journalOff), 0, 1, 0));
      if ((rc == 0)) {
        nPlayback++;
      }  
      else {
        if ((rc == 101)) {
          (pPager->journalOff = szJ);
          break;
        } 
        else if ((rc == (10 | (2 << 8)))) {
          (rc = 0);
          goto end_playback;
        } 
        else {
          goto end_playback;
        }
      }
    }
  }
  ((void ) 0);
  end_playback:
  (pPager->changeCountDone = pPager->tempFile);
  if ((rc == 0)) {
    (zMaster = pPager->pTmpSpace);
    (rc = readMasterJournal(pPager->jfd, zMaster, (pPager->pVfs->mxPathname + 1)));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((rc != 0)) {
        sqlite3Coverage(41411);
      }  
    }  
  }  
  if (((rc == 0) && ((pPager->eState >= 4) || (pPager->eState == 0)))) {
    (rc = sqlite3PagerSync(pPager));
  }  
  if ((rc == 0)) {
    (rc = pager_end_transaction(pPager, (zMaster[0] != '\0'), 0));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((rc != 0)) {
        sqlite3Coverage(41420);
      }  
    }  
  }  
  if (((rc == 0) && zMaster[0] && res)) {
    (rc = pager_delmaster(pPager, zMaster));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((rc != 0)) {
        sqlite3Coverage(41427);
      }  
    }  
  }  
  if ((isHot && nPlayback)) {
    sqlite3_log((27 | (2 << 8)), "recovered %d pages from %s", nPlayback, pPager->zJournal);
  }  
  setSectorSize(pPager);
  return rc;
}
static  int readDbPage(PgHdr *pPg , u32 iFrame )  {
  Pager *pPager =  pPg->pPager;
  Pgno pgno =  pPg->pgno;
  int rc =  0;
  int pgsz =  pPager->pageSize;
  ((void ) 0);
  ((void ) 0);
  if (iFrame) {
    (rc = sqlite3WalReadFrame(pPager->pWal, iFrame, pgsz, pPg->pData));
  }  
  else {
    i64 iOffset =  ((pgno - 1) * ((i64 ) pPager->pageSize));
    (rc = sqlite3OsRead(pPager->fd, pPg->pData, pgsz, iOffset));
    if ((rc == (10 | (2 << 8)))) {
      (rc = 0);
    }  
  }
  if ((pgno == 1)) {
    if (rc) {
      memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));
    }  
    else {
      u8 *dbFileVers =  (&((u8 *) pPg->pData)[24]);
      memcpy((&pPager->dbFileVers), dbFileVers, sizeof(pPager->dbFileVers));
    }
  }  
  if (((id2i_sqlite_enable_iotrace ) )) {
    if (_1280_sqlite3IoTrace) {
      _1280_sqlite3IoTrace("PGIN %p %d\n", pPager, pgno);
    }  
  }  
  return rc;
}
static  void pager_write_changecounter(PgHdr *pPg )  {
  u32 change_counter;
  (change_counter = (sqlite3Get4byte(((u8 *) pPg->pPager->dbFileVers)) + 1));
  sqlite3Put4byte((((u8 *) ((char *) pPg->pData)) + 24), change_counter);
  sqlite3Put4byte((((u8 *) ((char *) pPg->pData)) + 92), change_counter);
  sqlite3Put4byte((((u8 *) ((char *) pPg->pData)) + 96), 3008001);
}
static  int pagerUndoCallback(void *pCtx , Pgno iPg )  {
  int rc =  0;
  Pager *pPager =  ((Pager *) pCtx);
  PgHdr *pPg;
  ((void ) 0);
  (pPg = sqlite3PagerLookup(pPager, iPg));
  if (pPg) {
    if ((sqlite3PcachePageRefcount(pPg) == 1)) {
      sqlite3PcacheDrop(pPg);
    }  
    else {
      u32 iFrame =  0;
      (rc = sqlite3WalFindFrame(pPager->pWal, pPg->pgno, (&iFrame)));
      if ((rc == 0)) {
        (rc = readDbPage(pPg, iFrame));
      }  
      if ((rc == 0)) {
        pPager->xReiniter(pPg);
      }  
      sqlite3PagerUnref(pPg);
    }
  }  
  sqlite3BackupRestart(pPager->pBackup);
  return rc;
}
static  int pagerRollbackWal(Pager *pPager )  {
  int rc;
  PgHdr *pList;
  (pPager->dbSize = pPager->dbOrigSize);
  (rc = sqlite3WalUndo(pPager->pWal, pagerUndoCallback, ((void *) pPager)));
  (pList = sqlite3PcacheDirtyList(pPager->pPCache));
  while ((pList && (rc == 0))) {
    PgHdr *pNext =  pList->pDirty;
    (rc = pagerUndoCallback(((void *) pPager), pList->pgno));
    (pList = pNext);
  }
  return rc;
}
static  int pagerWalFrames(Pager *pPager , PgHdr *pList , Pgno nTruncate , int isCommit )  {
  int rc;
  int nList;
  PgHdr *_1270_p;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (isCommit) {
    PgHdr *p;
    PgHdr **ppNext =  (&pList);
    (nList = 0);
    for ((p = pList); (((*ppNext) = p) != 0); (p = p->pDirty)) {
      if ((p->pgno <= nTruncate)) {
        (ppNext = (&p->pDirty));
        nList++;
      }  
    }
    ((void ) 0);
  }  
  else {
    (nList = 1);
  }
  (pPager->aStat[2] += nList);
  if ((pList->pgno == 1)) {
    pager_write_changecounter(pList);
  }  
  (rc = sqlite3WalFrames(pPager->pWal, pPager->pageSize, pList, nTruncate, isCommit, pPager->walSyncFlags));
  if (((rc == 0) && pPager->pBackup)) {
    PgHdr *p;
    for ((p = pList); p; (p = p->pDirty)) {
      sqlite3BackupUpdate(pPager->pBackup, p->pgno, ((u8 *) p->pData));
    }
  }  
  if (((id2i_sqlite_check_pages ) )) {
    (pList = sqlite3PcacheDirtyList(pPager->pPCache));
  }  
  if (((id2i_sqlite_check_pages ) )) {
    for ((_1270_p = pList); _1270_p; (_1270_p = _1270_p->pDirty)) {
      pager_set_pagehash(_1270_p);
    }
  }  
  return rc;
}
static  int pagerBeginReadTransaction(Pager *pPager )  {
  int rc;
  int changed =  0;
  ((void ) 0);
  ((void ) 0);
  sqlite3WalEndReadTransaction(pPager->pWal);
  (rc = sqlite3WalBeginReadTransaction(pPager->pWal, (&changed)));
  if (((rc != 0) || changed)) {
    pager_reset(pPager);
    if (0) {
      sqlite3OsUnfetch(pPager->fd, 0, 0);
    }  
  }  
  return rc;
}
static  int pagerPagecount(Pager *pPager , Pgno *pnPage )  {
  Pgno nPage;
  ((void ) 0);
  ((void ) 0);
  (nPage = sqlite3WalDbsize(pPager->pWal));
  if ((nPage == 0)) {
    i64 n =  0;
    ((void ) 0);
    if (pPager->fd->pMethods) {
      int rc =  sqlite3OsFileSize(pPager->fd, (&n));
      if ((rc != 0)) {
        return rc;
      }  
    }  
    (nPage = ((Pgno ) ((n + pPager->pageSize - 1) / pPager->pageSize)));
  }  
  if ((nPage > pPager->mxPgno)) {
    (pPager->mxPgno = ((Pgno ) nPage));
  }  
  ((*pnPage) = nPage);
  return 0;
}
static  int pagerOpenWalIfPresent(Pager *pPager )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  if ((! pPager->tempFile)) {
    int isWal;
    Pgno nPage;
    (rc = pagerPagecount(pPager, (&nPage)));
    if (rc) {
      return rc;
    }  
    if ((nPage == 0)) {
      (rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0));
      if ((rc == (10 | (23 << 8)))) {
        (rc = 0);
      }  
      (isWal = 0);
    }  
    else {
      (rc = sqlite3OsAccess(pPager->pVfs, pPager->zWal, 0, (&isWal)));
    }
    if ((rc == 0)) {
      if (isWal) {
        if (((id2i_sqlite_coverage_test ) )) {
          if ((sqlite3PcachePagecount(pPager->pPCache) == 0)) {
            sqlite3Coverage(41802);
          }  
        }  
        (rc = sqlite3PagerOpenWal(pPager, 0));
      } 
      else if ((pPager->journalMode == 5)) {
        (pPager->journalMode = 0);
      } 
    }  
  }  
  return rc;
}
static  int pagerPlaybackSavepoint(Pager *pPager , PagerSavepoint *pSavepoint )  {
  i64 szJ;
  i64 iHdrOff;
  int rc =  0;
  Bitvec *pDone =  0;
  ((void ) 0);
  ((void ) 0);
  if (pSavepoint) {
    (pDone = sqlite3BitvecCreate(pSavepoint->nOrig));
    if ((! pDone)) {
      return 7;
    }  
  }  
  (pPager->dbSize = (pSavepoint ? pSavepoint->nOrig : pPager->dbOrigSize));
  (pPager->changeCountDone = pPager->tempFile);
  if (((! pSavepoint) && pagerUseWal(pPager))) {
    return pagerRollbackWal(pPager);
  }  
  (szJ = pPager->journalOff);
  ((void ) 0);
  if ((pSavepoint && (! pagerUseWal(pPager)))) {
    (iHdrOff = (pSavepoint->iHdrOffset ? pSavepoint->iHdrOffset : szJ));
    (pPager->journalOff = pSavepoint->iOffset);
    while (((rc == 0) && (pPager->journalOff < iHdrOff))) {
      (rc = pager_playback_one_page(pPager, (&pPager->journalOff), pDone, 1, 1));
    }
    ((void ) 0);
  }  
  else {
    (pPager->journalOff = 0);
  }
  while (((rc == 0) && (pPager->journalOff < szJ))) {
    u32 ii;
    u32 nJRec =  0;
    u32 dummy;
    (rc = readJournalHdr(pPager, 0, szJ, (&nJRec), (&dummy)));
    ((void ) 0);
    if (((nJRec == 0) && ((pPager->journalHdr + pPager->sectorSize) == pPager->journalOff))) {
      (nJRec = ((u32 ) ((szJ - pPager->journalOff) / (pPager->pageSize + 8))));
    }  
    for ((ii = 0); ((rc == 0) && (ii < nJRec) && (pPager->journalOff < szJ)); ii++) {
      (rc = pager_playback_one_page(pPager, (&pPager->journalOff), pDone, 1, 1));
    }
    ((void ) 0);
  }
  ((void ) 0);
  if (pSavepoint) {
    u32 ii;
    i64 offset =  (((i64 ) pSavepoint->iSubRec) * (4 + pPager->pageSize));
    if (pagerUseWal(pPager)) {
      (rc = sqlite3WalSavepointUndo(pPager->pWal, pSavepoint->aWalData));
    }  
    for ((ii = pSavepoint->iSubRec); ((rc == 0) && (ii < pPager->nSubRec)); ii++) {
      ((void ) 0);
      (rc = pager_playback_one_page(pPager, (&offset), pDone, 0, 1));
    }
    ((void ) 0);
  }  
  sqlite3BitvecDestroy(pDone);
  if ((rc == 0)) {
    (pPager->journalOff = szJ);
  }  
  return rc;
}
static  void sqlite3PagerSetCachesize(Pager *pPager , int mxPage )  {
  sqlite3PcacheSetCachesize(pPager->pPCache, mxPage);
}
static  void pagerFixMaplimit(Pager *pPager )  {
  
}
static  void sqlite3PagerSetMmapLimit(Pager *pPager , sqlite3_int64 szMmap )  {
  (pPager->szMmap = szMmap);
  pagerFixMaplimit(pPager);
}
static  void sqlite3PagerShrink(Pager *pPager )  {
  sqlite3PcacheShrink(pPager->pPCache);
}
static  void sqlite3PagerSetFlags(Pager *pPager , unsigned pgFlags )  {
  unsigned level =  (pgFlags & 0x03);
  ((void ) 0);
  (pPager->noSync = (((level == 1) || pPager->tempFile) ? 1 : 0));
  (pPager->fullSync = (((level == 3) && (! pPager->tempFile)) ? 1 : 0));
  if (pPager->noSync) {
    (pPager->syncFlags = 0);
    (pPager->ckptSyncFlags = 0);
  } 
  else if ((pgFlags & 0x04)) {
    (pPager->syncFlags = 0x00003);
    (pPager->ckptSyncFlags = 0x00003);
  }
  
  else if ((pgFlags & 0x08)) {
    (pPager->syncFlags = 0x00002);
    (pPager->ckptSyncFlags = 0x00003);
  } 
  else {
    (pPager->syncFlags = 0x00002);
    (pPager->ckptSyncFlags = 0x00002);
  }
  (pPager->walSyncFlags = pPager->syncFlags);
  if (pPager->fullSync) {
    (pPager->walSyncFlags |= 0x20);
  }  
  if ((pgFlags & 0x10)) {
    (pPager->doNotSpill &= (~ 0x01));
  }  
  else {
    (pPager->doNotSpill |= 0x01);
  }
}
static  int pagerOpentemp(Pager *pPager , sqlite3_file *pFile , int vfsFlags )  {
  int rc;
  (vfsFlags |= (0x00000002 | 0x00000004 | 0x00000010 | 0x00000008));
  (rc = sqlite3OsOpen(pPager->pVfs, 0, pFile, vfsFlags, 0));
  ((void ) 0);
  return rc;
}
static  void sqlite3PagerSetBusyhandler(Pager *pPager , int ( *xBusyHandler)(void * ) , void *pBusyHandlerArg )  {
  (pPager->xBusyHandler = xBusyHandler);
  (pPager->pBusyHandlerArg = pBusyHandlerArg);
  if (pPager->fd->pMethods) {
    void **ap =  ((void **) (&pPager->xBusyHandler));
    ((void ) 0);
    ((void ) 0);
    sqlite3OsFileControlHint(pPager->fd, 15, ((void *) ap));
  }  
}
static  int sqlite3PagerSetPagesize(Pager *pPager , u32 *pPageSize , int nReserve )  {
  int rc =  0;
  u32 pageSize =  (*pPageSize);
  ((void ) 0);
  if ((((pPager->memDb == 0) || (pPager->dbSize == 0)) && (sqlite3PcacheRefCount(pPager->pPCache) == 0) && pageSize && (pageSize != ((u32 ) pPager->pageSize)))) {
    char *pNew =  ((void *) 0);
    i64 nByte =  0;
    if (((pPager->eState > 0) && pPager->fd->pMethods)) {
      (rc = sqlite3OsFileSize(pPager->fd, (&nByte)));
    }  
    if ((rc == 0)) {
      (pNew = ((char *) sqlite3PageMalloc(pageSize)));
      if ((! pNew)) {
        (rc = 7);
      }  
    }  
    if ((rc == 0)) {
      pager_reset(pPager);
      (pPager->dbSize = ((Pgno ) ((nByte + pageSize - 1) / pageSize)));
      (pPager->pageSize = pageSize);
      sqlite3PageFree(pPager->pTmpSpace);
      (pPager->pTmpSpace = pNew);
      sqlite3PcacheSetPageSize(pPager->pPCache, pageSize);
    }  
  }  
  ((*pPageSize) = pPager->pageSize);
  if ((rc == 0)) {
    if ((nReserve < 0)) {
      (nReserve = pPager->nReserve);
    }  
    ((void ) 0);
    (pPager->nReserve = ((i16 ) nReserve));
    pagerFixMaplimit(pPager);
  }  
  return rc;
}
static  void *sqlite3PagerTempSpace(Pager *pPager )  {
  return pPager->pTmpSpace;
}
static  int sqlite3PagerMaxPageCount(Pager *pPager , int mxPage )  {
  if ((mxPage > 0)) {
    (pPager->mxPgno = mxPage);
  }  
  ((void ) 0);
  ((void ) 0);
  return pPager->mxPgno;
}
static  int sqlite3PagerReadFileheader(Pager *pPager , int N , unsigned  char *pDest )  {
  int rc =  0;
  memset(pDest, 0, N);
  ((void ) 0);
  ((void ) 0);
  if (pPager->fd->pMethods) {
    if (((id2i_sqlite_enable_iotrace ) )) {
      if (_1280_sqlite3IoTrace) {
        _1280_sqlite3IoTrace("DBHDR %p 0 %d\n", pPager, N);
      }  
    }  
    (rc = sqlite3OsRead(pPager->fd, pDest, N, 0));
    if ((rc == (10 | (2 << 8)))) {
      (rc = 0);
    }  
  }  
  return rc;
}
static  void sqlite3PagerPagecount(Pager *pPager , int *pnPage )  {
  ((void ) 0);
  ((void ) 0);
  ((*pnPage) = ((int ) pPager->dbSize));
}
static  int pager_wait_on_lock(Pager *pPager , int locktype )  {
  int rc;
  ((void ) 0);
  do {
    (rc = pagerLockDb(pPager, locktype));
  } while (((rc == 5) && pPager->xBusyHandler(pPager->pBusyHandlerArg)));
  return rc;
}
static  void sqlite3PagerTruncateImage(Pager *pPager , Pgno nPage )  {
  ((void ) 0);
  ((void ) 0);
  (pPager->dbSize = nPage);
}
static  int pagerSyncHotJournal(Pager *pPager )  {
  int rc =  0;
  if ((! pPager->noSync)) {
    (rc = sqlite3OsSync(pPager->jfd, 0x00002));
  }  
  if ((rc == 0)) {
    (rc = sqlite3OsFileSize(pPager->jfd, (&pPager->journalHdr)));
  }  
  return rc;
}
static  int pagerAcquireMapPage(Pager *pPager , Pgno pgno , void *pData , PgHdr **ppPage )  {
  PgHdr *p;
  if (pPager->pMmapFreelist) {
    ((*ppPage) = (p = pPager->pMmapFreelist));
    (pPager->pMmapFreelist = p->pDirty);
    (p->pDirty = 0);
    memset(p->pExtra, 0, pPager->nExtra);
  }  
  else {
    ((*ppPage) = (p = ((PgHdr *) sqlite3MallocZero((sizeof(PgHdr ) + pPager->nExtra)))));
    if ((p == 0)) {
      sqlite3OsUnfetch(pPager->fd, (((i64 ) (pgno - 1)) * pPager->pageSize), pData);
      return 7;
    }  
    (p->pExtra = ((void *) (&p[1])));
    (p->flags = 0x040);
    (p->nRef = 1);
    (p->pPager = pPager);
  }
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (p->pgno = pgno);
  (p->pData = pData);
  pPager->nMmapOut++;
  return 0;
}
static  void pagerReleaseMapPage(PgHdr *pPg )  {
  Pager *pPager =  pPg->pPager;
  pPager->nMmapOut--;
  (pPg->pDirty = pPager->pMmapFreelist);
  (pPager->pMmapFreelist = pPg);
  ((void ) 0);
  sqlite3OsUnfetch(pPager->fd, (((i64 ) (pPg->pgno - 1)) * pPager->pageSize), pPg->pData);
}
static  void pagerFreeMapHdrs(Pager *pPager )  {
  PgHdr *p;
  PgHdr *pNext;
  for ((p = pPager->pMmapFreelist); p; (p = pNext)) {
    (pNext = p->pDirty);
    sqlite3_free(p);
  }
}
static  int sqlite3PagerClose(Pager *pPager )  {
  u8 *pTmp =  ((u8 *) pPager->pTmpSpace);
  ((void ) 0);
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    sqlite3BeginBenignMalloc();
  }  
  pagerFreeMapHdrs(pPager);
  (pPager->exclusiveMode = 0);
  sqlite3WalClose(pPager->pWal, pPager->ckptSyncFlags, pPager->pageSize, pTmp);
  (pPager->pWal = 0);
  pager_reset(pPager);
  if (pPager->memDb) {
    pager_unlock(pPager);
  }  
  else {
    if (pPager->jfd->pMethods) {
      pager_error(pPager, pagerSyncHotJournal(pPager));
    }  
    pagerUnlockAndRollback(pPager);
  }
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    sqlite3EndBenignMalloc();
  }  
  if (((id2i_sqlite_enable_iotrace ) )) {
    if (_1280_sqlite3IoTrace) {
      _1280_sqlite3IoTrace("CLOSE %p\n", pPager);
    }  
  }  
  sqlite3OsClose(pPager->jfd);
  sqlite3OsClose(pPager->fd);
  sqlite3PageFree(pTmp);
  sqlite3PcacheClose(pPager->pPCache);
  ((void ) 0);
  ((void ) 0);
  sqlite3_free(pPager);
  return 0;
}
static  void sqlite3PagerRef(DbPage *pPg )  {
  sqlite3PcacheRef(pPg);
}
static  int syncJournal(Pager *pPager , int newHdr )  {
  int rc;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (rc = sqlite3PagerExclusiveLock(pPager));
  if ((rc != 0)) {
    return rc;
  }  
  if ((! pPager->noSync)) {
    ((void ) 0);
    if ((pPager->jfd->pMethods && (pPager->journalMode != 4))) {
      const int iDc =  sqlite3OsDeviceCharacteristics(pPager->fd);
      ((void ) 0);
      if ((0 == (iDc & 0x00000200))) {
        i64 iNextHdrOffset;
        u8 aMagic[8];
        u8 zHeader[(sizeof(aJournalMagic) + 4)];
        memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
        sqlite3Put4byte(((u8 *) (&zHeader[sizeof(aJournalMagic)])), pPager->nRec);
        (iNextHdrOffset = journalHdrOffset(pPager));
        (rc = sqlite3OsRead(pPager->jfd, aMagic, 8, iNextHdrOffset));
        if (((rc == 0) && (0 == memcmp(aMagic, aJournalMagic, 8)))) {
          static const u8 zerobyte =  0;
          (rc = sqlite3OsWrite(pPager->jfd, (&zerobyte), 1, iNextHdrOffset));
        }  
        if (((rc != 0) && (rc != (10 | (2 << 8))))) {
          return rc;
        }  
        if ((pPager->fullSync && (0 == (iDc & 0x00000400)))) {
          if (((id2i_sqlite_enable_iotrace ) )) {
            if (_1280_sqlite3IoTrace) {
              _1280_sqlite3IoTrace("JSYNC %p\n", pPager);
            }  
          }  
          (rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags));
          if ((rc != 0)) {
            return rc;
          }  
        }  
        if (((id2i_sqlite_enable_iotrace ) )) {
          if (_1280_sqlite3IoTrace) {
            _1280_sqlite3IoTrace("JHDR %p %lld\n", pPager, pPager->journalHdr);
          }  
        }  
        (rc = sqlite3OsWrite(pPager->jfd, zHeader, sizeof(zHeader), pPager->journalHdr));
        if ((rc != 0)) {
          return rc;
        }  
      }  
      if ((0 == (iDc & 0x00000400))) {
        if (((id2i_sqlite_enable_iotrace ) )) {
          if (_1280_sqlite3IoTrace) {
            _1280_sqlite3IoTrace("JSYNC %p\n", pPager);
          }  
        }  
        (rc = sqlite3OsSync(pPager->jfd, (pPager->syncFlags | ((pPager->syncFlags == 0x00003) ? 0x00010 : 0))));
        if ((rc != 0)) {
          return rc;
        }  
      }  
      (pPager->journalHdr = pPager->journalOff);
      if ((newHdr && (0 == (iDc & 0x00000200)))) {
        (pPager->nRec = 0);
        (rc = writeJournalHdr(pPager));
        if ((rc != 0)) {
          return rc;
        }  
      }  
    }  
    else {
      (pPager->journalHdr = pPager->journalOff);
    }
  }  
  sqlite3PcacheClearSyncFlags(pPager->pPCache);
  (pPager->eState = 4);
  ((void ) 0);
  return 0;
}
static  int pager_write_pagelist(Pager *pPager , PgHdr *pList )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((! pPager->fd->pMethods)) {
    ((void ) 0);
    (rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags));
  }  
  ((void ) 0);
  if (((rc == 0) && (pPager->dbHintSize < pPager->dbSize) && (pList->pDirty || (pList->pgno > pPager->dbHintSize)))) {
    sqlite3_int64 szFile =  (pPager->pageSize * ((sqlite3_int64 ) pPager->dbSize));
    sqlite3OsFileControlHint(pPager->fd, 5, (&szFile));
    (pPager->dbHintSize = pPager->dbSize);
  }  
  while (((rc == 0) && pList)) {
    Pgno pgno =  pList->pgno;
    if (((pgno <= pPager->dbSize) && (0 == (pList->flags & 0x020)))) {
      i64 offset =  ((pgno - 1) * ((i64 ) pPager->pageSize));
      char *pData;
      ((void ) 0);
      if ((pList->pgno == 1)) {
        pager_write_changecounter(pList);
      }  
      (pData = ((char *) pList->pData));
      (rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset));
      if ((pgno == 1)) {
        memcpy((&pPager->dbFileVers), (&pData[24]), sizeof(pPager->dbFileVers));
      }  
      if ((pgno > pPager->dbFileSize)) {
        (pPager->dbFileSize = pgno);
      }  
      pPager->aStat[2]++;
      sqlite3BackupUpdate(pPager->pBackup, pgno, ((u8 *) pList->pData));
      if (((id2i_sqlite_enable_iotrace ) )) {
        if (_1280_sqlite3IoTrace) {
          _1280_sqlite3IoTrace("PGOUT %p %d\n", pPager, pgno);
        }  
      }  
    }  
    else {
      
    }
    if (((id2i_sqlite_check_pages ) )) {
      pager_set_pagehash(pList);
    }  
    (pList = pList->pDirty);
  }
  return rc;
}
static  int openSubJournal(Pager *pPager )  {
  int rc =  0;
  if ((! pPager->sjfd->pMethods)) {
    if (((pPager->journalMode == 4) || pPager->subjInMemory)) {
      sqlite3MemJournalOpen(pPager->sjfd);
    }  
    else {
      (rc = pagerOpentemp(pPager, pPager->sjfd, 0x00002000));
    }
  }  
  return rc;
}
static  int subjournalPage(PgHdr *pPg )  {
  int rc =  0;
  Pager *pPager =  pPg->pPager;
  if ((pPager->journalMode != 2)) {
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    (rc = openSubJournal(pPager));
    if ((rc == 0)) {
      void *pData =  pPg->pData;
      i64 offset =  (((i64 ) pPager->nSubRec) * (4 + pPager->pageSize));
      char *pData2;
      (pData2 = ((char *) pData));
      (rc = write32bits(pPager->sjfd, offset, pPg->pgno));
      if ((rc == 0)) {
        (rc = sqlite3OsWrite(pPager->sjfd, pData2, pPager->pageSize, (offset + 4)));
      }  
    }  
  }  
  if ((rc == 0)) {
    pPager->nSubRec++;
    ((void ) 0);
    (rc = addToSavepointBitvecs(pPager, pPg->pgno));
  }  
  return rc;
}
static  int pagerStress(void *p , PgHdr *pPg )  {
  Pager *pPager =  ((Pager *) p);
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return 0;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pPager->errCode) {
      return 0;
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pPager->doNotSpill & 0x02)) {
      sqlite3Coverage(42988);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pPager->doNotSpill & 0x01)) {
      sqlite3Coverage(42989);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pPager->doNotSpill & 0x04)) {
      sqlite3Coverage(42990);
    }  
  }  
  if ((pPager->doNotSpill && (((pPager->doNotSpill & (0x02 | 0x01)) != 0) || ((pPg->flags & 0x004) != 0)))) {
    return 0;
  }  
  (pPg->pDirty = 0);
  if (pagerUseWal(pPager)) {
    if (subjRequiresPage(pPg)) {
      (rc = subjournalPage(pPg));
    }  
    if ((rc == 0)) {
      (rc = pagerWalFrames(pPager, pPg, 0, 0));
    }  
  }  
  else {
    if (((pPg->flags & 0x004) || (pPager->eState == 3))) {
      (rc = syncJournal(pPager, 1));
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if (0) {
        (rc = subjournalPage(pPg));
      }  
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      if (((rc == 0) && (pPg->pgno > pPager->dbSize) && subjRequiresPage(pPg))) {
        (rc = subjournalPage(pPg));
      }  
    }  
    if ((rc == 0)) {
      ((void ) 0);
      (rc = pager_write_pagelist(pPager, pPg));
    }  
  }
  if ((rc == 0)) {
    sqlite3PcacheMakeClean(pPg);
  }  
  return pager_error(pPager, rc);
}
static  int sqlite3PagerOpen(sqlite3_vfs *pVfs , Pager **ppPager , const  char *zFilename , int nExtra , int flags , int vfsFlags , void ( *xReinit)(DbPage * ) )  {
  u8 *pPtr;
  Pager *pPager =  0;
  int rc =  0;
  int tempFile =  0;
  int memDb =  0;
  int readOnly =  0;
  int journalFileSize;
  char *zPathname =  0;
  int nPathname =  0;
  int useJournal =  ((flags & 0x0001) == 0);
  int pcacheSize =  sqlite3PcacheSize();
  u32 szPageDflt =  1024;
  const char *zUri =  0;
  int nUri =  0;
  if ((pVfs->szOsFile > sqlite3MemJournalSize())) {
    (journalFileSize = ((pVfs->szOsFile + 7) & (~ 7)));
  }  
  else {
    (journalFileSize = ((sqlite3MemJournalSize() + 7) & (~ 7)));
  }
  ((*ppPager) = 0);
  if ((flags & 0x0002)) {
    (memDb = 1);
    if ((zFilename && zFilename[0])) {
      (zPathname = sqlite3DbStrDup(0, zFilename));
      if ((zPathname == 0)) {
        return 7;
      }  
      (nPathname = sqlite3Strlen30(zPathname));
      (zFilename = 0);
    }  
  }  
  if ((zFilename && zFilename[0])) {
    const char *z;
    (nPathname = (pVfs->mxPathname + 1));
    (zPathname = sqlite3DbMallocRaw(0, (nPathname * 2)));
    if ((zPathname == 0)) {
      return 7;
    }  
    (zPathname[0] = 0);
    (rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname));
    (nPathname = sqlite3Strlen30(zPathname));
    (z = (zUri = (&zFilename[(sqlite3Strlen30(zFilename) + 1)])));
    while ((*z)) {
      (z += (sqlite3Strlen30(z) + 1));
      (z += (sqlite3Strlen30(z) + 1));
    }
    (nUri = ((int ) ((&z[1]) - zUri)));
    ((void ) 0);
    if (((rc == 0) && ((nPathname + 8) > pVfs->mxPathname))) {
      (rc = sqlite3CantopenError(43177));
    }  
    if ((rc != 0)) {
      sqlite3DbFree(0, zPathname);
      return rc;
    }  
  }  
  (pPtr = ((u8 *) sqlite3MallocZero((((sizeof((*pPager)) + 7) & (~ 7)) + ((pcacheSize + 7) & (~ 7)) + ((pVfs->szOsFile + 7) & (~ 7)) + (journalFileSize * 2) + nPathname + 1 + nUri + nPathname + 8 + 2 + nPathname + 4 + 2))));
  ((void ) 0);
  if ((! pPtr)) {
    sqlite3DbFree(0, zPathname);
    return 7;
  }  
  (pPager = ((Pager *) pPtr));
  (pPager->pPCache = ((PCache *) (pPtr += ((sizeof((*pPager)) + 7) & (~ 7)))));
  (pPager->fd = ((sqlite3_file *) (pPtr += ((pcacheSize + 7) & (~ 7)))));
  (pPager->sjfd = ((sqlite3_file *) (pPtr += ((pVfs->szOsFile + 7) & (~ 7)))));
  (pPager->jfd = ((sqlite3_file *) (pPtr += journalFileSize)));
  (pPager->zFilename = ((char *) (pPtr += journalFileSize)));
  ((void ) 0);
  if (zPathname) {
    ((void ) 0);
    (pPager->zJournal = ((char *) (pPtr += (nPathname + 1 + nUri))));
    memcpy(pPager->zFilename, zPathname, nPathname);
    if (nUri) {
      memcpy((&pPager->zFilename[(nPathname + 1)]), zUri, nUri);
    }  
    memcpy(pPager->zJournal, zPathname, nPathname);
    memcpy((&pPager->zJournal[nPathname]), "-journal\000", (8 + 2));
    (pPager->zWal = (&pPager->zJournal[(nPathname + 8 + 1)]));
    memcpy(pPager->zWal, zPathname, nPathname);
    memcpy((&pPager->zWal[nPathname]), "-wal\000", (4 + 1));
    sqlite3DbFree(0, zPathname);
  }  
  (pPager->pVfs = pVfs);
  (pPager->vfsFlags = vfsFlags);
  if ((zFilename && zFilename[0])) {
    int fout =  0;
    (rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, (&fout)));
    ((void ) 0);
    (readOnly = (fout & 0x00000001));
    if (((rc == 0) && (! readOnly))) {
      setSectorSize(pPager);
      ((void ) 0);
      if ((szPageDflt < pPager->sectorSize)) {
        if ((pPager->sectorSize > 8192)) {
          (szPageDflt = 8192);
        }  
        else {
          (szPageDflt = ((u32 ) pPager->sectorSize));
        }
      }  
    }  
  }  
  else {
    (tempFile = 1);
    (pPager->eState = 1);
    (pPager->eLock = 4);
    (readOnly = (vfsFlags & 0x00000001));
  }
  if ((rc == 0)) {
    ((void ) 0);
    (rc = sqlite3PagerSetPagesize(pPager, (&szPageDflt), (- 1)));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((rc != 0)) {
        sqlite3Coverage(43303);
      }  
    }  
  }  
  if ((rc != 0)) {
    ((void ) 0);
    sqlite3OsClose(pPager->fd);
    sqlite3_free(pPager);
    return rc;
  }  
  ((void ) 0);
  (nExtra = ((nExtra + 7) & (~ 7)));
  sqlite3PcacheOpen(szPageDflt, nExtra, (! memDb), ((! memDb) ? pagerStress : 0), ((void *) pPager), pPager->pPCache);
  if (((id2i_sqlite_enable_iotrace ) )) {
    if (_1280_sqlite3IoTrace) {
      _1280_sqlite3IoTrace("OPEN %p %s\n", pPager, pPager->zFilename);
    }  
  }  
  (pPager->useJournal = ((u8 ) useJournal));
  (pPager->mxPgno = 1073741823);
  (pPager->tempFile = ((u8 ) tempFile));
  ((void ) 0);
  ((void ) 0);
  (pPager->exclusiveMode = ((u8 ) tempFile));
  (pPager->changeCountDone = pPager->tempFile);
  (pPager->memDb = ((u8 ) memDb));
  (pPager->readOnly = ((u8 ) readOnly));
  ((void ) 0);
  (pPager->noSync = pPager->tempFile);
  if (pPager->noSync) {
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
  }  
  else {
    (pPager->fullSync = 1);
    (pPager->syncFlags = 0x00002);
    (pPager->walSyncFlags = (0x00002 | 0x20));
    (pPager->ckptSyncFlags = 0x00002);
  }
  (pPager->nExtra = ((u16 ) nExtra));
  (pPager->journalSizeLimit = (- 1));
  ((void ) 0);
  setSectorSize(pPager);
  if ((! useJournal)) {
    (pPager->journalMode = 2);
  } 
  else if (memDb) {
    (pPager->journalMode = 4);
  } 
  (pPager->xReiniter = xReinit);
  ((*ppPager) = pPager);
  return 0;
}
static  int hasHotJournal(Pager *pPager , int *pExists )  {
  sqlite3_vfs *const pVfs =  pPager->pVfs;
  int rc =  0;
  int exists =  1;
  int jrnlOpen =  (! (! pPager->jfd->pMethods));
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((*pExists) = 0);
  if ((! jrnlOpen)) {
    (rc = sqlite3OsAccess(pVfs, pPager->zJournal, 0, (&exists)));
  }  
  if (((rc == 0) && exists)) {
    int locked =  0;
    (rc = sqlite3OsCheckReservedLock(pPager->fd, (&locked)));
    if (((rc == 0) && (! locked))) {
      Pgno nPage;
      (rc = pagerPagecount(pPager, (&nPage)));
      if ((rc == 0)) {
        if ((nPage == 0)) {
          if ((((! id2i_sqlite_omit_builtin_test) ) )) {
            sqlite3BeginBenignMalloc();
          }  
          if ((pagerLockDb(pPager, 2) == 0)) {
            sqlite3OsDelete(pVfs, pPager->zJournal, 0);
            if ((! pPager->exclusiveMode)) {
              pagerUnlockDb(pPager, 1);
            }  
          }  
          if ((((! id2i_sqlite_omit_builtin_test) ) )) {
            sqlite3EndBenignMalloc();
          }  
        }  
        else {
          if ((! jrnlOpen)) {
            int f =  (0x00000001 | 0x00000800);
            (rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, (&f)));
          }  
          if ((rc == 0)) {
            u8 first =  0;
            (rc = sqlite3OsRead(pPager->jfd, ((void *) (&first)), 1, 0));
            if ((rc == (10 | (2 << 8)))) {
              (rc = 0);
            }  
            if ((! jrnlOpen)) {
              sqlite3OsClose(pPager->jfd);
            }  
            ((*pExists) = (first != 0));
          } 
          else if ((rc == 14)) {
            ((*pExists) = 1);
            (rc = 0);
          } 
        }
      }  
    }  
  }  
  return rc;
}
static  int sqlite3PagerSharedLock(Pager *pPager )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return pPager->errCode;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pPager->memDb && pPager->errCode)) {
      return pPager->errCode;
    }  
  }  
  if (((! pagerUseWal(pPager)) && (pPager->eState == 0))) {
    int bHotJournal =  1;
    ((void ) 0);
    (rc = pager_wait_on_lock(pPager, 1));
    if ((rc != 0)) {
      ((void ) 0);
      goto failed;
    }  
    if ((pPager->eLock <= 1)) {
      (rc = hasHotJournal(pPager, (&bHotJournal)));
    }  
    if ((rc != 0)) {
      goto failed;
    }  
    if (bHotJournal) {
      if (pPager->readOnly) {
        (rc = (8 | (3 << 8)));
        goto failed;
      }  
      (rc = pagerLockDb(pPager, 4));
      if ((rc != 0)) {
        goto failed;
      }  
      if ((! pPager->jfd->pMethods)) {
        sqlite3_vfs *const pVfs =  pPager->pVfs;
        int bExists;
        (rc = sqlite3OsAccess(pVfs, pPager->zJournal, 0, (&bExists)));
        if (((rc == 0) && bExists)) {
          int fout =  0;
          int f =  (0x00000002 | 0x00000800);
          ((void ) 0);
          (rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, (&fout)));
          ((void ) 0);
          if (((rc == 0) && (fout & 0x00000001))) {
            (rc = sqlite3CantopenError(43615));
            sqlite3OsClose(pPager->jfd);
          }  
        }  
      }  
      if (pPager->jfd->pMethods) {
        ((void ) 0);
        (rc = pagerSyncHotJournal(pPager));
        if ((rc == 0)) {
          (rc = pager_playback(pPager, 1));
          (pPager->eState = 0);
        }  
      } 
      else if ((! pPager->exclusiveMode)) {
        pagerUnlockDb(pPager, 1);
      } 
      if ((rc != 0)) {
        pager_error(pPager, rc);
        goto failed;
      }  
      ((void ) 0);
      ((void ) 0);
    }  
    if (((! pPager->tempFile) && (pPager->pBackup || (sqlite3PcachePagecount(pPager->pPCache) > 0) || 0))) {
      Pgno nPage =  0;
      char dbFileVers[sizeof(pPager->dbFileVers)];
      (rc = pagerPagecount(pPager, (&nPage)));
      if (rc) {
        goto failed;
      }  
      if ((nPage > 0)) {
        if (((id2i_sqlite_enable_iotrace ) )) {
          if (_1280_sqlite3IoTrace) {
            _1280_sqlite3IoTrace("CKVERS %p %d\n", pPager, sizeof(dbFileVers));
          }  
        }  
        (rc = sqlite3OsRead(pPager->fd, (&dbFileVers), sizeof(dbFileVers), 24));
        if (((rc != 0) && (rc != (10 | (2 << 8))))) {
          goto failed;
        }  
      }  
      else {
        memset(dbFileVers, 0, sizeof(dbFileVers));
      }
      if ((memcmp(pPager->dbFileVers, dbFileVers, sizeof(dbFileVers)) != 0)) {
        pager_reset(pPager);
        if (0) {
          sqlite3OsUnfetch(pPager->fd, 0, 0);
        }  
      }  
    }  
    (rc = pagerOpenWalIfPresent(pPager));
    ((void ) 0);
  }  
  if (pagerUseWal(pPager)) {
    ((void ) 0);
    (rc = pagerBeginReadTransaction(pPager));
  }  
  if (((pPager->eState == 0) && (rc == 0))) {
    (rc = pagerPagecount(pPager, (&pPager->dbSize)));
  }  
  failed:
  if ((rc != 0)) {
    ((void ) 0);
    pager_unlock(pPager);
    ((void ) 0);
  }  
  else {
    (pPager->eState = 1);
  }
  return rc;
}
static  void pagerUnlockIfUnused(Pager *pPager )  {
  if (((pPager->nMmapOut == 0) && (sqlite3PcacheRefCount(pPager->pPCache) == 0))) {
    pagerUnlockAndRollback(pPager);
  }  
}
static  int sqlite3PagerAcquire(Pager *pPager , Pgno pgno , DbPage **ppPage , int flags )  {
  int rc =  0;
  PgHdr *pPg =  0;
  u32 iFrame =  0;
  const int noContent =  (flags & 0x01);
  const int bMmapOk =  ((pgno != 1) && 0 && ((pPager->eState == 1) || (flags & 0x02)));
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pgno == 0)) {
    return sqlite3CorruptError(43839);
  }  
  if ((pPager->errCode != 0)) {
    (rc = pPager->errCode);
  }  
  else {
    if ((bMmapOk && pagerUseWal(pPager))) {
      (rc = sqlite3WalFindFrame(pPager->pWal, pgno, (&iFrame)));
      if ((rc != 0)) {
        goto pager_acquire_err;
      }  
    }  
    if (((iFrame == 0) && bMmapOk)) {
      void *pData =  0;
      (rc = sqlite3OsFetch(pPager->fd, (((i64 ) (pgno - 1)) * pPager->pageSize), pPager->pageSize, (&pData)));
      if (((rc == 0) && pData)) {
        if ((pPager->eState > 1)) {
          ((void ) sqlite3PcacheFetch(pPager->pPCache, pgno, 0, (&pPg)));
        }  
        if ((pPg == 0)) {
          (rc = pagerAcquireMapPage(pPager, pgno, pData, (&pPg)));
        }  
        else {
          sqlite3OsUnfetch(pPager->fd, (((i64 ) (pgno - 1)) * pPager->pageSize), pData);
        }
        if (pPg) {
          ((void ) 0);
          ((*ppPage) = pPg);
          return 0;
        }  
      }  
      if ((rc != 0)) {
        goto pager_acquire_err;
      }  
    }  
    (rc = sqlite3PcacheFetch(pPager->pPCache, pgno, 1, ppPage));
  }
  if ((rc != 0)) {
    (pPg = 0);
    goto pager_acquire_err;
  }  
  ((void ) 0);
  ((void ) 0);
  if (((*ppPage)->pPager && (! noContent))) {
    ((void ) 0);
    pPager->aStat[0]++;
    return 0;
  }  
  else {
    (pPg = (*ppPage));
    (pPg->pPager = pPager);
    if (((pgno > 2147483647) || (pgno == ((Pgno ) ((sqlite3PendingByte / pPager->pageSize) + 1))))) {
      (rc = sqlite3CorruptError(43910));
      goto pager_acquire_err;
    }  
    if ((pPager->memDb || (pPager->dbSize < pgno) || noContent || (! pPager->fd->pMethods))) {
      if ((pgno > pPager->mxPgno)) {
        (rc = 13);
        goto pager_acquire_err;
      }  
      if (noContent) {
        if ((((! id2i_sqlite_omit_builtin_test) ) )) {
          sqlite3BeginBenignMalloc();
        }  
        if ((pgno <= pPager->dbOrigSize)) {
          if (((id2i_sqlite_coverage_test ) )) {
            (rc = sqlite3BitvecSet(pPager->pInJournal, pgno));
          }  
          if ((((! id2i_sqlite_coverage_test) ) )) {
            sqlite3BitvecSet(pPager->pInJournal, pgno);
          }  
          if (((id2i_sqlite_coverage_test ) )) {
            if ((rc == 7)) {
              sqlite3Coverage(43929);
            }  
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          (rc = addToSavepointBitvecs(pPager, pgno));
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          addToSavepointBitvecs(pPager, pgno);
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((rc == 7)) {
            sqlite3Coverage(43932);
          }  
        }  
        if ((((! id2i_sqlite_omit_builtin_test) ) )) {
          sqlite3EndBenignMalloc();
        }  
      }  
      memset(pPg->pData, 0, pPager->pageSize);
      if (((id2i_sqlite_enable_iotrace ) )) {
        if (_1280_sqlite3IoTrace) {
          _1280_sqlite3IoTrace("ZERO %p %d\n", pPager, pgno);
        }  
      }  
    }  
    else {
      if ((pagerUseWal(pPager) && (bMmapOk == 0))) {
        (rc = sqlite3WalFindFrame(pPager->pWal, pgno, (&iFrame)));
        if ((rc != 0)) {
          goto pager_acquire_err;
        }  
      }  
      ((void ) 0);
      pPager->aStat[1]++;
      (rc = readDbPage(pPg, iFrame));
      if ((rc != 0)) {
        goto pager_acquire_err;
      }  
    }
    if (((id2i_sqlite_check_pages ) )) {
      pager_set_pagehash(pPg);
    }  
  }
  return 0;
  pager_acquire_err:
  ((void ) 0);
  if (pPg) {
    sqlite3PcacheDrop(pPg);
  }  
  pagerUnlockIfUnused(pPager);
  ((*ppPage) = 0);
  return rc;
}
static  DbPage *sqlite3PagerLookup(Pager *pPager , Pgno pgno )  {
  PgHdr *pPg =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  sqlite3PcacheFetch(pPager->pPCache, pgno, 0, (&pPg));
  return pPg;
}
static  void sqlite3PagerUnref(DbPage *pPg )  {
  if (pPg) {
    Pager *pPager =  pPg->pPager;
    if ((pPg->flags & 0x040)) {
      pagerReleaseMapPage(pPg);
    }  
    else {
      sqlite3PcacheRelease(pPg);
    }
    pagerUnlockIfUnused(pPager);
  }  
}
static  int pager_open_journal(Pager *pPager )  {
  int rc =  0;
  sqlite3_vfs *const pVfs =  pPager->pVfs;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return pPager->errCode;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pPager->errCode) {
      return pPager->errCode;
    }  
  }  
  if (((! pagerUseWal(pPager)) && (pPager->journalMode != 2))) {
    (pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize));
    if ((pPager->pInJournal == 0)) {
      return 7;
    }  
    if ((! pPager->jfd->pMethods)) {
      if ((pPager->journalMode == 4)) {
        sqlite3MemJournalOpen(pPager->jfd);
      }  
      else {
        const int flags =  (0x00000002 | 0x00000004 | (pPager->tempFile ? (0x00000008 | 0x00001000) : 0x00000800));
        (rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, flags, 0));
      }
      ((void ) 0);
    }  
    if ((rc == 0)) {
      (pPager->nRec = 0);
      (pPager->journalOff = 0);
      (pPager->setMaster = 0);
      (pPager->journalHdr = 0);
      (rc = writeJournalHdr(pPager));
    }  
  }  
  if ((rc != 0)) {
    sqlite3BitvecDestroy(pPager->pInJournal);
    (pPager->pInJournal = 0);
  }  
  else {
    ((void ) 0);
    (pPager->eState = 3);
  }
  return rc;
}
static  int sqlite3PagerBegin(Pager *pPager , int exFlag , int subjInMemory )  {
  int rc =  0;
  if (pPager->errCode) {
    return pPager->errCode;
  }  
  ((void ) 0);
  (pPager->subjInMemory = ((u8 ) subjInMemory));
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      ((void ) 0);
      if (pagerUseWal(pPager)) {
        if ((pPager->exclusiveMode && sqlite3WalExclusiveMode(pPager->pWal, (- 1)))) {
          (rc = pagerLockDb(pPager, 4));
          if ((rc != 0)) {
            return rc;
          }  
          sqlite3WalExclusiveMode(pPager->pWal, 1);
        }  
        (rc = sqlite3WalBeginWriteTransaction(pPager->pWal));
      }  
      else {
        (rc = pagerLockDb(pPager, 2));
        if (((rc == 0) && exFlag)) {
          (rc = pager_wait_on_lock(pPager, 4));
        }  
      }
      if ((rc == 0)) {
        (pPager->eState = 2);
        (pPager->dbHintSize = pPager->dbSize);
        (pPager->dbFileSize = pPager->dbSize);
        (pPager->dbOrigSize = pPager->dbSize);
        (pPager->journalOff = 0);
      }  
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pPager->eState == 1)) {
      ((void ) 0);
      if (pagerUseWal(pPager)) {
        if ((pPager->exclusiveMode && sqlite3WalExclusiveMode(pPager->pWal, (- 1)))) {
          (rc = pagerLockDb(pPager, 4));
          if ((rc != 0)) {
            return rc;
          }  
          sqlite3WalExclusiveMode(pPager->pWal, 1);
        }  
        (rc = sqlite3WalBeginWriteTransaction(pPager->pWal));
      }  
      else {
        (rc = pagerLockDb(pPager, 2));
        if (((rc == 0) && exFlag)) {
          (rc = pager_wait_on_lock(pPager, 4));
        }  
      }
      if ((rc == 0)) {
        (pPager->eState = 2);
        (pPager->dbHintSize = pPager->dbSize);
        (pPager->dbFileSize = pPager->dbSize);
        (pPager->dbOrigSize = pPager->dbSize);
        (pPager->journalOff = 0);
      }  
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
    }  
  }  
  return rc;
}
static  int pager_write(PgHdr *pPg )  {
  void *pData =  pPg->pData;
  Pager *pPager =  pPg->pPager;
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return pPager->errCode;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pPager->errCode) {
      return pPager->errCode;
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return 3;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pPager->readOnly) {
      return 3;
    }  
  }  
  if (((id2i_sqlite_check_pages ) )) {
    checkPage(pPg);
  }  
  if ((pPager->eState == 2)) {
    (rc = pager_open_journal(pPager));
    if ((rc != 0)) {
      return rc;
    }  
  }  
  ((void ) 0);
  ((void ) 0);
  sqlite3PcacheMakeDirty(pPg);
  if ((pageInJournal(pPg) && (! subjRequiresPage(pPg)))) {
    ((void ) 0);
  }  
  else {
    if (((! pageInJournal(pPg)) && (! pagerUseWal(pPager)))) {
      ((void ) 0);
      if (((pPg->pgno <= pPager->dbOrigSize) && pPager->jfd->pMethods)) {
        u32 cksum;
        char *pData2;
        i64 iOff =  pPager->journalOff;
        ((void ) 0);
        ((void ) 0);
        (pData2 = ((char *) pData));
        (cksum = pager_cksum(pPager, ((u8 *) pData2)));
        (pPg->flags |= 0x004);
        (rc = write32bits(pPager->jfd, iOff, pPg->pgno));
        if ((rc != 0)) {
          return rc;
        }  
        (rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, (iOff + 4)));
        if ((rc != 0)) {
          return rc;
        }  
        (rc = write32bits(pPager->jfd, (iOff + pPager->pageSize + 4), cksum));
        if ((rc != 0)) {
          return rc;
        }  
        if (((id2i_sqlite_enable_iotrace ) )) {
          if (_1280_sqlite3IoTrace) {
            _1280_sqlite3IoTrace("JOUT %p %d %lld %d\n", pPager, pPg->pgno, pPager->journalOff, pPager->pageSize);
          }  
        }  
        (pPager->journalOff += (8 + pPager->pageSize));
        pPager->nRec++;
        ((void ) 0);
        (rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno));
        if (((id2i_sqlite_coverage_test ) )) {
          if ((rc == 7)) {
            sqlite3Coverage(44280);
          }  
        }  
        ((void ) 0);
        (rc |= addToSavepointBitvecs(pPager, pPg->pgno));
        if ((rc != 0)) {
          ((void ) 0);
          return rc;
        }  
      }  
      else {
        if ((pPager->eState != 4)) {
          (pPg->flags |= 0x004);
        }  
      }
    }  
    if (subjRequiresPage(pPg)) {
      (rc = subjournalPage(pPg));
    }  
  }
  if ((pPager->dbSize < pPg->pgno)) {
    (pPager->dbSize = pPg->pgno);
  }  
  return rc;
}
static  int sqlite3PagerWrite(DbPage *pDbPage )  {
  int rc =  0;
  PgHdr *pPg =  pDbPage;
  Pager *pPager =  pPg->pPager;
  Pgno nPagePerSector =  (pPager->sectorSize / pPager->pageSize);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((nPagePerSector > 1)) {
    Pgno nPageCount;
    Pgno pg1;
    int nPage =  0;
    int ii;
    int needSync =  0;
    ((void ) 0);
    ((void ) 0);
    (pPager->doNotSpill |= 0x04);
    (pg1 = (((pPg->pgno - 1) & (~ (nPagePerSector - 1))) + 1));
    (nPageCount = pPager->dbSize);
    if ((pPg->pgno > nPageCount)) {
      (nPage = ((pPg->pgno - pg1) + 1));
    } 
    else if (((pg1 + nPagePerSector - 1) > nPageCount)) {
      (nPage = (nPageCount + 1 - pg1));
    } 
    else {
      (nPage = nPagePerSector);
    }
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    for ((ii = 0); ((ii < nPage) && (rc == 0)); ii++) {
      Pgno pg =  (pg1 + ii);
      PgHdr *pPage;
      if (((pg == pPg->pgno) || (! sqlite3BitvecTest(pPager->pInJournal, pg)))) {
        if ((pg != ((Pgno ) ((sqlite3PendingByte / pPager->pageSize) + 1)))) {
          (rc = sqlite3PagerAcquire(pPager, pg, (&pPage), 0));
          if ((rc == 0)) {
            (rc = pager_write(pPage));
            if ((pPage->flags & 0x004)) {
              (needSync = 1);
            }  
            sqlite3PagerUnref(pPage);
          }  
        }  
      } 
      else if (((pPage = pager_lookup(pPager, pg)) != 0)) {
        if ((pPage->flags & 0x004)) {
          (needSync = 1);
        }  
        sqlite3PagerUnref(pPage);
      } 
    }
    if (((rc == 0) && needSync)) {
      ((void ) 0);
      for ((ii = 0); (ii < nPage); ii++) {
        PgHdr *pPage =  pager_lookup(pPager, (pg1 + ii));
        if (pPage) {
          (pPage->flags |= 0x004);
          sqlite3PagerUnref(pPage);
        }  
      }
    }  
    ((void ) 0);
    (pPager->doNotSpill &= (~ 0x04));
  }  
  else {
    (rc = pager_write(pDbPage));
  }
  return rc;
}
static  void sqlite3PagerDontWrite(PgHdr *pPg )  {
  Pager *pPager =  pPg->pPager;
  if (((pPg->flags & 0x002) && (pPager->nSavepoint == 0))) {
    if (((id2i_sqlite_enable_iotrace ) )) {
      if (_1280_sqlite3IoTrace) {
        _1280_sqlite3IoTrace("CLEAN %p %d\n", pPager, pPg->pgno);
      }  
    }  
    (pPg->flags |= 0x020);
    if (((id2i_sqlite_check_pages ) )) {
      pager_set_pagehash(pPg);
    }  
  }  
}
static  int pager_incr_changecounter(Pager *pPager , int isDirectMode )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) isDirectMode);
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((! pPager->changeCountDone) && (pPager->dbSize > 0))) {
      PgHdr *pPgHdr;
      ((void ) 0);
      (rc = sqlite3PagerAcquire(pPager, 1, (&pPgHdr), 0));
      ((void ) 0);
      if (((! 0) && (rc == 0))) {
        (rc = sqlite3PagerWrite(pPgHdr));
      }  
      if ((rc == 0)) {
        pager_write_changecounter(pPgHdr);
        if (0) {
          const void *zBuf;
          ((void ) 0);
          (zBuf = ((char *) pPgHdr->pData));
          if ((rc == 0)) {
            (rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0));
            pPager->aStat[2]++;
          }  
          if ((rc == 0)) {
            const void *pCopy =  ((const  void *) (&((const  char *) zBuf)[24]));
            memcpy((&pPager->dbFileVers), pCopy, sizeof(pPager->dbFileVers));
            (pPager->changeCountDone = 1);
          }  
        }  
        else {
          (pPager->changeCountDone = 1);
        }
      }  
      sqlite3PagerUnref(pPgHdr);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((! pPager->changeCountDone) && 1)) {
      PgHdr *pPgHdr;
      ((void ) 0);
      (rc = sqlite3PagerAcquire(pPager, 1, (&pPgHdr), 0));
      ((void ) 0);
      if (((! 0) && 1)) {
        (rc = sqlite3PagerWrite(pPgHdr));
      }  
      if ((rc == 0)) {
        pager_write_changecounter(pPgHdr);
        if (0) {
          const void *zBuf;
          ((void ) 0);
          (zBuf = ((char *) pPgHdr->pData));
          if ((rc == 0)) {
            (rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0));
            pPager->aStat[2]++;
          }  
          if ((rc == 0)) {
            const void *pCopy =  ((const  void *) (&((const  char *) zBuf)[24]));
            memcpy((&pPager->dbFileVers), pCopy, sizeof(pPager->dbFileVers));
            (pPager->changeCountDone = 1);
          }  
        }  
        else {
          (pPager->changeCountDone = 1);
        }
      }  
      sqlite3PagerUnref(pPgHdr);
    }  
  }  
  return rc;
}
static  int sqlite3PagerSync(Pager *pPager )  {
  int rc =  0;
  if ((! pPager->noSync)) {
    ((void ) 0);
    (rc = sqlite3OsSync(pPager->fd, pPager->syncFlags));
  } 
  else if (pPager->fd->pMethods) {
    ((void ) 0);
    (rc = sqlite3OsFileControl(pPager->fd, 8, 0));
    if ((rc == 12)) {
      (rc = 0);
    }  
  } 
  return rc;
}
static  int sqlite3PagerExclusiveLock(Pager *pPager )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  if ((0 == pagerUseWal(pPager))) {
    (rc = pager_wait_on_lock(pPager, 4));
  }  
  return rc;
}
static  int sqlite3PagerCommitPhaseOne(Pager *pPager , const  char *zMaster , int noSync )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return pPager->errCode;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pPager->errCode) {
      return pPager->errCode;
    }  
  }  
  if ((pPager->eState < 3)) {
    return 0;
  }  
  if (pPager->memDb) {
    sqlite3BackupRestart(pPager->pBackup);
  }  
  else {
    if (pagerUseWal(pPager)) {
      PgHdr *pList =  sqlite3PcacheDirtyList(pPager->pPCache);
      PgHdr *pPageOne =  0;
      if ((pList == 0)) {
        (rc = sqlite3PagerAcquire(pPager, 1, (&pPageOne), 0));
        (pList = pPageOne);
        (pList->pDirty = 0);
      }  
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if (1) {
          (rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1));
        }  
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if (pList) {
          (rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1));
        }  
      }  
      sqlite3PagerUnref(pPageOne);
      if ((rc == 0)) {
        sqlite3PcacheCleanAll(pPager->pPCache);
      }  
    }  
    else {
      (rc = pager_incr_changecounter(pPager, 0));
      if ((rc != 0)) {
        goto commit_phase_one_exit;
      }  
      (rc = writeMasterJournal(pPager, zMaster));
      if ((rc != 0)) {
        goto commit_phase_one_exit;
      }  
      (rc = syncJournal(pPager, 0));
      if ((rc != 0)) {
        goto commit_phase_one_exit;
      }  
      (rc = pager_write_pagelist(pPager, sqlite3PcacheDirtyList(pPager->pPCache)));
      if ((rc != 0)) {
        ((void ) 0);
        goto commit_phase_one_exit;
      }  
      sqlite3PcacheCleanAll(pPager->pPCache);
      if ((pPager->dbSize > pPager->dbFileSize)) {
        Pgno nNew =  (pPager->dbSize - (pPager->dbSize == ((Pgno ) ((sqlite3PendingByte / pPager->pageSize) + 1))));
        ((void ) 0);
        (rc = pager_truncate(pPager, nNew));
        if ((rc != 0)) {
          goto commit_phase_one_exit;
        }  
      }  
      if ((! noSync)) {
        (rc = sqlite3PagerSync(pPager));
      }  
      if (((id2i_sqlite_enable_iotrace ) )) {
        if (_1280_sqlite3IoTrace) {
          _1280_sqlite3IoTrace("DBSYNC %p\n", pPager);
        }  
      }  
    }
  }
  commit_phase_one_exit:
  if (((rc == 0) && (! pagerUseWal(pPager)))) {
    (pPager->eState = 5);
  }  
  return rc;
}
static  int sqlite3PagerCommitPhaseTwo(Pager *pPager )  {
  int rc =  0;
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return pPager->errCode;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pPager->errCode) {
      return pPager->errCode;
    }  
  }  
  ((void ) 0);
  ((void ) 0);
  if (((pPager->eState == 2) && pPager->exclusiveMode && (pPager->journalMode == 1))) {
    ((void ) 0);
    (pPager->eState = 1);
    return 0;
  }  
  (rc = pager_end_transaction(pPager, pPager->setMaster, 1));
  return pager_error(pPager, rc);
}
static  int sqlite3PagerRollback(Pager *pPager )  {
  int rc =  0;
  ((void ) 0);
  if ((pPager->eState == 6)) {
    return pPager->errCode;
  }  
  if ((pPager->eState <= 1)) {
    return 0;
  }  
  if (pagerUseWal(pPager)) {
    int rc2;
    (rc = sqlite3PagerSavepoint(pPager, 2, (- 1)));
    (rc2 = pager_end_transaction(pPager, pPager->setMaster, 0));
    if ((rc == 0)) {
      (rc = rc2);
    }  
  } 
  else if (((! pPager->jfd->pMethods) || (pPager->eState == 2))) {
    int eState =  pPager->eState;
    (rc = pager_end_transaction(pPager, 0, 0));
    if (((! pPager->memDb) && (eState > 2))) {
      (pPager->errCode = 4);
      (pPager->eState = 6);
      return rc;
    }  
  } 
  else {
    (rc = pager_playback(pPager, 0));
  }
  ((void ) 0);
  ((void ) 0);
  return pager_error(pPager, rc);
}
static  u8 sqlite3PagerIsreadonly(Pager *pPager )  {
  return pPager->readOnly;
}
static  int sqlite3PagerRefcount(Pager *pPager )  {
  return sqlite3PcacheRefCount(pPager->pPCache);
}
static  int sqlite3PagerMemUsed(Pager *pPager )  {
  int perPageSize =  (pPager->pageSize + pPager->nExtra + sizeof(PgHdr ) + (5 * sizeof(void *)));
  return ((perPageSize * sqlite3PcachePagecount(pPager->pPCache)) + sqlite3MallocSize(pPager) + pPager->pageSize);
}
static  int sqlite3PagerPageRefcount(DbPage *pPage )  {
  return sqlite3PcachePageRefcount(pPage);
}
static  void sqlite3PagerCacheStat(Pager *pPager , int eStat , int reset , int *pnVal )  {
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((*pnVal) += pPager->aStat[(eStat - 7)]);
  if (reset) {
    (pPager->aStat[(eStat - 7)] = 0);
  }  
}
static  int sqlite3PagerIsMemdb(Pager *pPager )  {
  return pPager->memDb;
}
static  int sqlite3PagerOpenSavepoint(Pager *pPager , int nSavepoint )  {
  int rc =  0;
  int nCurrent =  pPager->nSavepoint;
  ((void ) 0);
  ((void ) 0);
  if (((nSavepoint > nCurrent) && pPager->useJournal)) {
    int ii;
    PagerSavepoint *aNew;
    (aNew = ((PagerSavepoint *) sqlite3Realloc(pPager->aSavepoint, (sizeof(PagerSavepoint ) * nSavepoint))));
    if ((! aNew)) {
      return 7;
    }  
    memset((&aNew[nCurrent]), 0, ((nSavepoint - nCurrent) * sizeof(PagerSavepoint )));
    (pPager->aSavepoint = aNew);
    for ((ii = nCurrent); (ii < nSavepoint); ii++) {
      (aNew[ii].nOrig = pPager->dbSize);
      if ((pPager->jfd->pMethods && (pPager->journalOff > 0))) {
        (aNew[ii].iOffset = pPager->journalOff);
      }  
      else {
        (aNew[ii].iOffset = pPager->sectorSize);
      }
      (aNew[ii].iSubRec = pPager->nSubRec);
      (aNew[ii].pInSavepoint = sqlite3BitvecCreate(pPager->dbSize));
      if ((! aNew[ii].pInSavepoint)) {
        return 7;
      }  
      if (pagerUseWal(pPager)) {
        sqlite3WalSavepoint(pPager->pWal, aNew[ii].aWalData);
      }  
      (pPager->nSavepoint = (ii + 1));
    }
    ((void ) 0);
  }  
  return rc;
}
static  int sqlite3PagerSavepoint(Pager *pPager , int op , int iSavepoint )  {
  int rc =  pPager->errCode;
  ((void ) 0);
  ((void ) 0);
  if (((rc == 0) && (iSavepoint < pPager->nSavepoint))) {
    int ii;
    int nNew;
    (nNew = (iSavepoint + ((op == 1) ? 0 : 1)));
    for ((ii = nNew); (ii < pPager->nSavepoint); ii++) {
      sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
    }
    (pPager->nSavepoint = nNew);
    if ((op == 1)) {
      if (((nNew == 0) && pPager->sjfd->pMethods)) {
        if (sqlite3IsMemJournal(pPager->sjfd)) {
          (rc = sqlite3OsTruncate(pPager->sjfd, 0));
          ((void ) 0);
        }  
        (pPager->nSubRec = 0);
      }  
    } 
    else if ((pagerUseWal(pPager) || pPager->jfd->pMethods)) {
      PagerSavepoint *pSavepoint =  ((nNew == 0) ? 0 : (&pPager->aSavepoint[(nNew - 1)]));
      (rc = pagerPlaybackSavepoint(pPager, pSavepoint));
      ((void ) 0);
    } 
  }  
  return rc;
}
static  const  char *sqlite3PagerFilename(Pager *pPager , int nullIfMemDb )  {
  return ((nullIfMemDb && pPager->memDb) ? "" : pPager->zFilename);
}
static  const  sqlite3_vfs *sqlite3PagerVfs(Pager *pPager )  {
  return pPager->pVfs;
}
static  sqlite3_file *sqlite3PagerFile(Pager *pPager )  {
  return pPager->fd;
}
static  const  char *sqlite3PagerJournalname(Pager *pPager )  {
  return pPager->zJournal;
}
static  int sqlite3PagerNosync(Pager *pPager )  {
  return pPager->noSync;
}
static  int sqlite3PagerMovepage(Pager *pPager , DbPage *pPg , Pgno pgno , int isCommit )  {
  PgHdr *pPgOld;
  Pgno needSyncPgno =  0;
  int rc;
  Pgno origPgno;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (pPager->memDb) {
    (rc = sqlite3PagerWrite(pPg));
    if (rc) {
      return rc;
    }  
  }  
  if (((pPg->flags & 0x002) && subjRequiresPage(pPg) && (0 != (rc = subjournalPage(pPg))))) {
    return rc;
  }  
  if (((id2i_sqlite_enable_iotrace ) )) {
    if (_1280_sqlite3IoTrace) {
      _1280_sqlite3IoTrace("MOVE %p %d %d\n", pPager, pPg->pgno, pgno);
    }  
  }  
  if (((pPg->flags & 0x004) && (! isCommit))) {
    (needSyncPgno = pPg->pgno);
    ((void ) 0);
    ((void ) 0);
  }  
  (pPg->flags &= (~ 0x004));
  (pPgOld = pager_lookup(pPager, pgno));
  ((void ) 0);
  if (pPgOld) {
    (pPg->flags |= (pPgOld->flags & 0x004));
    if (pPager->memDb) {
      sqlite3PcacheMove(pPgOld, (pPager->dbSize + 1));
    }  
    else {
      sqlite3PcacheDrop(pPgOld);
    }
  }  
  (origPgno = pPg->pgno);
  sqlite3PcacheMove(pPg, pgno);
  sqlite3PcacheMakeDirty(pPg);
  if (pPager->memDb) {
    ((void ) 0);
    sqlite3PcacheMove(pPgOld, origPgno);
    sqlite3PagerUnref(pPgOld);
  }  
  if (needSyncPgno) {
    PgHdr *pPgHdr;
    (rc = sqlite3PagerAcquire(pPager, needSyncPgno, (&pPgHdr), 0));
    if ((rc != 0)) {
      if ((needSyncPgno <= pPager->dbOrigSize)) {
        ((void ) 0);
        sqlite3BitvecClear(pPager->pInJournal, needSyncPgno, pPager->pTmpSpace);
      }  
      return rc;
    }  
    (pPgHdr->flags |= 0x004);
    sqlite3PcacheMakeDirty(pPgHdr);
    sqlite3PagerUnref(pPgHdr);
  }  
  return 0;
}
static  void *sqlite3PagerGetData(DbPage *pPg )  {
  ((void ) 0);
  return pPg->pData;
}
static  void *sqlite3PagerGetExtra(DbPage *pPg )  {
  return pPg->pExtra;
}
static  int sqlite3PagerLockingMode(Pager *pPager , int eMode )  {
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((eMode >= 0) && (! pPager->tempFile) && (! sqlite3WalHeapMemory(pPager->pWal)))) {
    (pPager->exclusiveMode = ((u8 ) eMode));
  }  
  return ((int ) pPager->exclusiveMode);
}
static  int sqlite3PagerSetJournalMode(Pager *pPager , int eMode )  {
  u8 eOld =  pPager->journalMode;
  ((void ) 0);
  ((void ) 0);
  if (pPager->memDb) {
    ((void ) 0);
    if (((eMode != 4) && (eMode != 2))) {
      (eMode = eOld);
    }  
  }  
  if ((eMode != eOld)) {
    ((void ) 0);
    (pPager->journalMode = ((u8 ) eMode));
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    if (((! pPager->exclusiveMode) && ((eOld & 5) == 1) && ((eMode & 1) == 0))) {
      sqlite3OsClose(pPager->jfd);
      if ((pPager->eLock >= 2)) {
        sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
      }  
      else {
        int rc =  0;
        int state =  pPager->eState;
        ((void ) 0);
        if ((state == 0)) {
          (rc = sqlite3PagerSharedLock(pPager));
        }  
        if ((pPager->eState == 1)) {
          ((void ) 0);
          (rc = pagerLockDb(pPager, 2));
        }  
        if ((rc == 0)) {
          sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
        }  
        if (((rc == 0) && (state == 1))) {
          pagerUnlockDb(pPager, 1);
        } 
        else if ((state == 0)) {
          pager_unlock(pPager);
        } 
        ((void ) 0);
      }
    }  
  }  
  return ((int ) pPager->journalMode);
}
static  int sqlite3PagerGetJournalMode(Pager *pPager )  {
  return ((int ) pPager->journalMode);
}
static  int sqlite3PagerOkToChangeJournalMode(Pager *pPager )  {
  ((void ) 0);
  if ((pPager->eState >= 3)) {
    return 0;
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return 0;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pPager->jfd->pMethods && (pPager->journalOff > 0))) {
      return 0;
    }  
  }  
  return 1;
}
static  i64 sqlite3PagerJournalSizeLimit(Pager *pPager , i64 iLimit )  {
  if ((iLimit >= (- 1))) {
    (pPager->journalSizeLimit = iLimit);
    sqlite3WalLimit(pPager->pWal, iLimit);
  }  
  return pPager->journalSizeLimit;
}
static  sqlite3_backup **sqlite3PagerBackupPtr(Pager *pPager )  {
  return (&pPager->pBackup);
}
static  void sqlite3PagerClearCache(Pager *pPager )  {
  if (((! pPager->memDb) && (pPager->tempFile == 0))) {
    pager_reset(pPager);
  }  
}
static  int sqlite3PagerCheckpoint(Pager *pPager , int eMode , int *pnLog , int *pnCkpt )  {
  int rc =  0;
  if (pPager->pWal) {
    (rc = sqlite3WalCheckpoint(pPager->pWal, eMode, pPager->xBusyHandler, pPager->pBusyHandlerArg, pPager->ckptSyncFlags, pPager->pageSize, ((u8 *) pPager->pTmpSpace), pnLog, pnCkpt));
  }  
  return rc;
}
static  int sqlite3PagerWalCallback(Pager *pPager )  {
  return sqlite3WalCallback(pPager->pWal);
}
static  int sqlite3PagerWalSupported(Pager *pPager )  {
  const sqlite3_io_methods *pMethods =  pPager->fd->pMethods;
  return (pPager->exclusiveMode || ((pMethods->iVersion >= 2) && pMethods->xShmMap));
}
static  int pagerExclusiveLock(Pager *pPager )  {
  int rc;
  ((void ) 0);
  (rc = pagerLockDb(pPager, 4));
  if ((rc != 0)) {
    pagerUnlockDb(pPager, 1);
  }  
  return rc;
}
static  int pagerOpenWal(Pager *pPager )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  if (pPager->exclusiveMode) {
    (rc = pagerExclusiveLock(pPager));
  }  
  if ((rc == 0)) {
    (rc = sqlite3WalOpen(pPager->pVfs, pPager->fd, pPager->zWal, pPager->exclusiveMode, pPager->journalSizeLimit, (&pPager->pWal)));
  }  
  pagerFixMaplimit(pPager);
  return rc;
}
static  int sqlite3PagerOpenWal(Pager *pPager , int *pbOpen )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((! pPager->tempFile) && (! pPager->pWal))) {
    if ((! sqlite3PagerWalSupported(pPager))) {
      return 14;
    }  
    sqlite3OsClose(pPager->jfd);
    (rc = pagerOpenWal(pPager));
    if ((rc == 0)) {
      (pPager->journalMode = 5);
      (pPager->eState = 0);
    }  
  }  
  else {
    ((*pbOpen) = 1);
  }
  return rc;
}
static  int sqlite3PagerCloseWal(Pager *pPager )  {
  int rc =  0;
  ((void ) 0);
  if ((! pPager->pWal)) {
    int logexists =  0;
    (rc = pagerLockDb(pPager, 1));
    if ((rc == 0)) {
      (rc = sqlite3OsAccess(pPager->pVfs, pPager->zWal, 0, (&logexists)));
    }  
    if (((rc == 0) && logexists)) {
      (rc = pagerOpenWal(pPager));
    }  
  }  
  if (((rc == 0) && pPager->pWal)) {
    (rc = pagerExclusiveLock(pPager));
    if ((rc == 0)) {
      (rc = sqlite3WalClose(pPager->pWal, pPager->ckptSyncFlags, pPager->pageSize, ((u8 *) pPager->pTmpSpace)));
      (pPager->pWal = 0);
      pagerFixMaplimit(pPager);
    }  
  }  
  return rc;
}
typedef struct  WalIndexHdr   WalIndexHdr;
typedef struct  WalIterator   WalIterator;
typedef struct  WalCkptInfo   WalCkptInfo;
struct  WalIndexHdr {
  u32 iVersion ;
  u32 unused ;
  u32 iChange ;
  u8 isInit ;
  u8 bigEndCksum ;
  u16 szPage ;
  u32 mxFrame ;
  u32 nPage ;
  u32 aFrameCksum[2] ;
  u32 aSalt[2] ;
  u32 aCksum[2] ;
}  ;
struct  WalCkptInfo {
  u32 nBackfill ;
  u32 aReadMark[(8 - 3)] ;
}  ;
struct  Wal {
  sqlite3_vfs *pVfs ;
  sqlite3_file *pDbFd ;
  sqlite3_file *pWalFd ;
  u32 iCallback ;
  i64 mxWalSize ;
  int nWiData ;
  int szFirstBlock ;
  volatile  u32 **apWiData ;
  u32 szPage ;
  i16 readLock ;
  u8 syncFlags ;
  u8 exclusiveMode ;
  u8 writeLock ;
  u8 ckptLock ;
  u8 readOnly ;
  u8 truncateOnCommit ;
  u8 syncHeader ;
  u8 padToSectorBoundary ;
  WalIndexHdr hdr ;
  const  char *zWalName ;
  u32 nCkpt ;
}  ;
typedef u16 ht_slot;
struct  WalIterator {
  int iPrior ;
  int nSegment ;
  struct  WalSegment {
    int iNext ;
    ht_slot *aIndex ;
    u32 *aPgno ;
    int nEntry ;
    int iZero ;
  }  aSegment[1] ;
}  ;
static  int walIndexPage(Wal *pWal , int iPage , volatile  u32 **ppPage )  {
  int rc =  0;
  if ((pWal->nWiData <= iPage)) {
    int nByte =  (sizeof(u32 *) * (iPage + 1));
    volatile u32 **apNew;
    (apNew = ((volatile  u32 **) sqlite3_realloc(((void *) pWal->apWiData), nByte)));
    if ((! apNew)) {
      ((*ppPage) = 0);
      return 7;
    }  
    memset(((void *) (&apNew[pWal->nWiData])), 0, (sizeof(u32 *) * (iPage + 1 - pWal->nWiData)));
    (pWal->apWiData = apNew);
    (pWal->nWiData = (iPage + 1));
  }  
  if ((pWal->apWiData[iPage] == 0)) {
    if ((pWal->exclusiveMode == 2)) {
      (pWal->apWiData[iPage] = ((u32  volatile *) sqlite3MallocZero(((sizeof(ht_slot ) * (4096 * 2)) + (4096 * sizeof(u32 ))))));
      if ((! pWal->apWiData[iPage])) {
        (rc = 7);
      }  
    }  
    else {
      (rc = sqlite3OsShmMap(pWal->pDbFd, iPage, ((sizeof(ht_slot ) * (4096 * 2)) + (4096 * sizeof(u32 ))), pWal->writeLock, ((void  volatile **) (&pWal->apWiData[iPage]))));
      if ((rc == 8)) {
        (pWal->readOnly |= 2);
        (rc = 0);
      }  
    }
  }  
  ((*ppPage) = pWal->apWiData[iPage]);
  ((void ) 0);
  return rc;
}
static  volatile  WalCkptInfo *walCkptInfo(Wal *pWal )  {
  ((void ) 0);
  return ((volatile  WalCkptInfo *) (&pWal->apWiData[0][(sizeof(WalIndexHdr ) / 2)]));
}
static  volatile  WalIndexHdr *walIndexHdr(Wal *pWal )  {
  ((void ) 0);
  return ((volatile  WalIndexHdr *) pWal->apWiData[0]);
}
static  void walChecksumBytes(int nativeCksum , u8 *a , int nByte , const  u32 *aIn , u32 *aOut )  {
  u32 s1, s2;
  u32 *aData =  ((u32 *) a);
  u32 *aEnd =  ((u32 *) (&a[nByte]));
  if (aIn) {
    (s1 = aIn[0]);
    (s2 = aIn[1]);
  }  
  else {
    (s1 = (s2 = 0));
  }
  ((void ) 0);
  ((void ) 0);
  if (nativeCksum) {
    do {
      (s1 += ((*aData++) + s2));
      (s2 += ((*aData++) + s1));
    } while ((aData < aEnd));
  }  
  else {
    do {
      (s1 += ((((aData[0] & 0x000000FF) << 24) + ((aData[0] & 0x0000FF00) << 8) + ((aData[0] & 0x00FF0000) >> 8) + ((aData[0] & 0xFF000000) >> 24)) + s2));
      (s2 += ((((aData[1] & 0x000000FF) << 24) + ((aData[1] & 0x0000FF00) << 8) + ((aData[1] & 0x00FF0000) >> 8) + ((aData[1] & 0xFF000000) >> 24)) + s1));
      (aData += 2);
    } while ((aData < aEnd));
  }
  (aOut[0] = s1);
  (aOut[1] = s2);
}
static  void walShmBarrier(Wal *pWal )  {
  if ((pWal->exclusiveMode != 2)) {
    sqlite3OsShmBarrier(pWal->pDbFd);
  }  
}
static  void walIndexWriteHdr(Wal *pWal )  {
  volatile WalIndexHdr *aHdr =  walIndexHdr(pWal);
  const int nCksum =  __builtin_offsetof(WalIndexHdr , aCksum);
  ((void ) 0);
  (pWal->hdr.isInit = 1);
  (pWal->hdr.iVersion = 3007000);
  walChecksumBytes(1, ((u8 *) (&pWal->hdr)), nCksum, 0, pWal->hdr.aCksum);
  memcpy(((void *) (&aHdr[1])), ((void *) (&pWal->hdr)), sizeof(WalIndexHdr ));
  walShmBarrier(pWal);
  memcpy(((void *) (&aHdr[0])), ((void *) (&pWal->hdr)), sizeof(WalIndexHdr ));
}
static  void walEncodeFrame(Wal *pWal , u32 iPage , u32 nTruncate , u8 *aData , u8 *aFrame )  {
  int nativeCksum;
  u32 *aCksum =  pWal->hdr.aFrameCksum;
  ((void ) 0);
  sqlite3Put4byte((&aFrame[0]), iPage);
  sqlite3Put4byte((&aFrame[4]), nTruncate);
  memcpy((&aFrame[8]), pWal->hdr.aSalt, 8);
  (nativeCksum = (pWal->hdr.bigEndCksum == 0));
  walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);
  walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);
  sqlite3Put4byte((&aFrame[16]), aCksum[0]);
  sqlite3Put4byte((&aFrame[20]), aCksum[1]);
}
static  int walDecodeFrame(Wal *pWal , u32 *piPage , u32 *pnTruncate , u8 *aData , u8 *aFrame )  {
  int nativeCksum;
  u32 *aCksum =  pWal->hdr.aFrameCksum;
  u32 pgno;
  ((void ) 0);
  if ((memcmp((&pWal->hdr.aSalt), (&aFrame[8]), 8) != 0)) {
    return 0;
  }  
  (pgno = sqlite3Get4byte((&aFrame[0])));
  if ((pgno == 0)) {
    return 0;
  }  
  (nativeCksum = (pWal->hdr.bigEndCksum == 0));
  walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);
  walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);
  if (((aCksum[0] != sqlite3Get4byte((&aFrame[16]))) || (aCksum[1] != sqlite3Get4byte((&aFrame[20]))))) {
    return 0;
  }  
  ((*piPage) = pgno);
  ((*pnTruncate) = sqlite3Get4byte((&aFrame[4])));
  return 1;
}
static  int walLockShared(Wal *pWal , int lockIdx )  {
  int rc;
  if (pWal->exclusiveMode) {
    return 0;
  }  
  (rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1, (2 | 4)));
  return rc;
}
static  void walUnlockShared(Wal *pWal , int lockIdx )  {
  if (pWal->exclusiveMode) {
    return;
  }  
  ((void ) sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1, (1 | 4)));
}
static  int walLockExclusive(Wal *pWal , int lockIdx , int n )  {
  int rc;
  if (pWal->exclusiveMode) {
    return 0;
  }  
  (rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n, (2 | 8)));
  return rc;
}
static  void walUnlockExclusive(Wal *pWal , int lockIdx , int n )  {
  if (pWal->exclusiveMode) {
    return;
  }  
  ((void ) sqlite3OsShmLock(pWal->pDbFd, lockIdx, n, (1 | 8)));
}
static  int walHash(u32 iPage )  {
  ((void ) 0);
  ((void ) 0);
  return ((iPage * 383) & ((4096 * 2) - 1));
}
static  int walNextHash(int iPriorHash )  {
  return ((iPriorHash + 1) & ((4096 * 2) - 1));
}
static  int walHashGet(Wal *pWal , int iHash , volatile  ht_slot **paHash , volatile  u32 **paPgno , u32 *piZero )  {
  int rc;
  volatile u32 *aPgno;
  (rc = walIndexPage(pWal, iHash, (&aPgno)));
  ((void ) 0);
  if ((rc == 0)) {
    u32 iZero;
    volatile ht_slot *aHash;
    (aHash = ((volatile  ht_slot *) (&aPgno[4096])));
    if ((iHash == 0)) {
      (aPgno = (&aPgno[((((sizeof(WalIndexHdr ) * 2) + sizeof(WalCkptInfo )) + 16) / sizeof(u32 ))]));
      (iZero = 0);
    }  
    else {
      (iZero = ((4096 - ((((sizeof(WalIndexHdr ) * 2) + sizeof(WalCkptInfo )) + 16) / sizeof(u32 ))) + ((iHash - 1) * 4096)));
    }
    ((*paPgno) = (&aPgno[(- 1)]));
    ((*paHash) = aHash);
    ((*piZero) = iZero);
  }  
  return rc;
}
static  int walFramePage(u32 iFrame )  {
  int iHash =  ((iFrame + 4096 - (4096 - ((((sizeof(WalIndexHdr ) * 2) + sizeof(WalCkptInfo )) + 16) / sizeof(u32 ))) - 1) / 4096);
  ((void ) 0);
  return iHash;
}
static  u32 walFramePgno(Wal *pWal , u32 iFrame )  {
  int iHash =  walFramePage(iFrame);
  if ((iHash == 0)) {
    return pWal->apWiData[0][(((((sizeof(WalIndexHdr ) * 2) + sizeof(WalCkptInfo )) + 16) / sizeof(u32 )) + iFrame - 1)];
  }  
  return pWal->apWiData[iHash][((iFrame - 1 - (4096 - ((((sizeof(WalIndexHdr ) * 2) + sizeof(WalCkptInfo )) + 16) / sizeof(u32 )))) % 4096)];
}
static  void walCleanupHash(Wal *pWal )  {
  volatile ht_slot *aHash =  0;
  volatile u32 *aPgno =  0;
  u32 iZero =  0;
  int iLimit =  0;
  int nByte;
  int i;
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pWal->hdr.mxFrame == ((4096 - ((((sizeof(WalIndexHdr ) * 2) + sizeof(WalCkptInfo )) + 16) / sizeof(u32 ))) - 1))) {
      sqlite3Coverage(46690);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pWal->hdr.mxFrame == (4096 - ((((sizeof(WalIndexHdr ) * 2) + sizeof(WalCkptInfo )) + 16) / sizeof(u32 ))))) {
      sqlite3Coverage(46691);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pWal->hdr.mxFrame == ((4096 - ((((sizeof(WalIndexHdr ) * 2) + sizeof(WalCkptInfo )) + 16) / sizeof(u32 ))) + 1))) {
      sqlite3Coverage(46692);
    }  
  }  
  if ((pWal->hdr.mxFrame == 0)) {
    return;
  }  
  ((void ) 0);
  ((void ) 0);
  walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), (&aHash), (&aPgno), (&iZero));
  (iLimit = (pWal->hdr.mxFrame - iZero));
  ((void ) 0);
  for ((i = 0); (i < (4096 * 2)); i++) {
    if ((aHash[i] > iLimit)) {
      (aHash[i] = 0);
    }  
  }
  (nByte = ((int ) (((char *) aHash) - ((char *) (&aPgno[(iLimit + 1)])))));
  memset(((void *) (&aPgno[(iLimit + 1)])), 0, nByte);
  if (((id2i_sqlite_enable_expensive_assert ) )) {
    if (iLimit) {
      int i;
      int iKey;
      for ((i = 1); (i <= iLimit); i++) {
        for ((iKey = walHash(aPgno[i])); aHash[iKey]; (iKey = walNextHash(iKey))) {
          if ((aHash[iKey] == i)) {
            break;
          }  
        }
        ((void ) 0);
      }
    }  
  }  
}
static  int walIndexAppend(Wal *pWal , u32 iFrame , u32 iPage )  {
  int rc;
  u32 iZero =  0;
  volatile u32 *aPgno =  0;
  volatile ht_slot *aHash =  0;
  (rc = walHashGet(pWal, walFramePage(iFrame), (&aHash), (&aPgno), (&iZero)));
  if ((rc == 0)) {
    int iKey;
    int idx;
    int nCollide;
    (idx = (iFrame - iZero));
    ((void ) 0);
    if ((idx == 1)) {
      int nByte =  ((int ) (((u8 *) (&aHash[(4096 * 2)])) - ((u8 *) (&aPgno[1]))));
      memset(((void *) (&aPgno[1])), 0, nByte);
    }  
    if (aPgno[idx]) {
      walCleanupHash(pWal);
      ((void ) 0);
    }  
    (nCollide = idx);
    for ((iKey = walHash(iPage)); aHash[iKey]; (iKey = walNextHash(iKey))) {
      if ((nCollide-- == 0)) {
        return sqlite3CorruptError(46784);
      }  
    }
    (aPgno[idx] = iPage);
    (aHash[iKey] = ((ht_slot ) idx));
    if (((id2i_sqlite_enable_expensive_assert ) )) {
      int i;
      int nEntry =  0;
      for ((i = 0); (i < (4096 * 2)); i++) {
        if (aHash[i]) {
          nEntry++;
        }  
      }
      ((void ) 0);
    }  
    if (((id2i_sqlite_enable_expensive_assert ) )) {
      if (((idx & 0x3ff) == 0)) {
        int i;
        for ((i = 1); (i <= idx); i++) {
          for ((iKey = walHash(aPgno[i])); aHash[iKey]; (iKey = walNextHash(iKey))) {
            if ((aHash[iKey] == i)) {
              break;
            }  
          }
          ((void ) 0);
        }
      }  
    }  
  }  
  return rc;
}
static  int walIndexRecover(Wal *pWal )  {
  int rc;
  i64 nSize;
  u32 aFrameCksum[2] =  { 0,  0};
  int iLock;
  int nLock;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (iLock = (1 + pWal->ckptLock));
  (nLock = (8 - iLock));
  (rc = walLockExclusive(pWal, iLock, nLock));
  if (rc) {
    return rc;
  }  
  memset((&pWal->hdr), 0, sizeof(WalIndexHdr ));
  (rc = sqlite3OsFileSize(pWal->pWalFd, (&nSize)));
  if ((rc != 0)) {
    goto recovery_error;
  }  
  if ((nSize > 32)) {
    u8 aBuf[32];
    u8 *aFrame =  0;
    int szFrame;
    u8 *aData;
    int iFrame;
    i64 iOffset;
    int szPage;
    u32 magic;
    u32 version;
    int isValid;
    (rc = sqlite3OsRead(pWal->pWalFd, aBuf, 32, 0));
    if ((rc != 0)) {
      goto recovery_error;
    }  
    (magic = sqlite3Get4byte((&aBuf[0])));
    (szPage = sqlite3Get4byte((&aBuf[8])));
    if ((((magic & 0xFFFFFFFE) != 0x377f0682) || (szPage & (szPage - 1)) || (szPage > 65536) || (szPage < 512))) {
      goto finished;
    }  
    (pWal->hdr.bigEndCksum = ((u8 ) (magic & 0x00000001)));
    (pWal->szPage = szPage);
    (pWal->nCkpt = sqlite3Get4byte((&aBuf[12])));
    memcpy((&pWal->hdr.aSalt), (&aBuf[16]), 8);
    walChecksumBytes((pWal->hdr.bigEndCksum == 0), aBuf, (32 - (2 * 4)), 0, pWal->hdr.aFrameCksum);
    if (((pWal->hdr.aFrameCksum[0] != sqlite3Get4byte((&aBuf[24]))) || (pWal->hdr.aFrameCksum[1] != sqlite3Get4byte((&aBuf[28]))))) {
      goto finished;
    }  
    (version = sqlite3Get4byte((&aBuf[4])));
    if ((version != 3007000)) {
      (rc = sqlite3CantopenError(46915));
      goto finished;
    }  
    (szFrame = (szPage + 24));
    (aFrame = ((u8 *) sqlite3_malloc(szFrame)));
    if ((! aFrame)) {
      (rc = 7);
      goto recovery_error;
    }  
    (aData = (&aFrame[24]));
    (iFrame = 0);
    for ((iOffset = 32); ((iOffset + szFrame) <= nSize); (iOffset += szFrame)) {
      u32 pgno;
      u32 nTruncate;
      iFrame++;
      (rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset));
      if ((rc != 0)) {
        break;
      }  
      (isValid = walDecodeFrame(pWal, (&pgno), (&nTruncate), aData, aFrame));
      if ((! isValid)) {
        break;
      }  
      (rc = walIndexAppend(pWal, iFrame, pgno));
      if ((rc != 0)) {
        break;
      }  
      if (nTruncate) {
        (pWal->hdr.mxFrame = iFrame);
        (pWal->hdr.nPage = nTruncate);
        (pWal->hdr.szPage = ((u16 ) ((szPage & 0xff00) | (szPage >> 16))));
        if (((id2i_sqlite_coverage_test ) )) {
          if ((szPage <= 32768)) {
            sqlite3Coverage(46948);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((szPage >= 65536)) {
            sqlite3Coverage(46949);
          }  
        }  
        (aFrameCksum[0] = pWal->hdr.aFrameCksum[0]);
        (aFrameCksum[1] = pWal->hdr.aFrameCksum[1]);
      }  
    }
    sqlite3_free(aFrame);
  }  
  finished:
  if ((rc == 0)) {
    volatile WalCkptInfo *pInfo;
    int i;
    (pWal->hdr.aFrameCksum[0] = aFrameCksum[0]);
    (pWal->hdr.aFrameCksum[1] = aFrameCksum[1]);
    walIndexWriteHdr(pWal);
    (pInfo = walCkptInfo(pWal));
    (pInfo->nBackfill = 0);
    (pInfo->aReadMark[0] = 0);
    for ((i = 1); (i < (8 - 3)); i++) {
      (pInfo->aReadMark[i] = 0xffffffff);
    }
    if (pWal->hdr.mxFrame) {
      (pInfo->aReadMark[1] = pWal->hdr.mxFrame);
    }  
    if (pWal->hdr.nPage) {
      sqlite3_log((27 | (1 << 8)), "recovered %d frames from WAL file %s", pWal->hdr.mxFrame, pWal->zWalName);
    }  
  }  
  recovery_error:
  walUnlockExclusive(pWal, iLock, nLock);
  return rc;
}
static  void walIndexClose(Wal *pWal , int isDelete )  {
  if ((pWal->exclusiveMode == 2)) {
    int i;
    for ((i = 0); (i < pWal->nWiData); i++) {
      sqlite3_free(((void *) pWal->apWiData[i]));
      (pWal->apWiData[i] = 0);
    }
  }  
  else {
    sqlite3OsShmUnmap(pWal->pDbFd, isDelete);
  }
}
static  int sqlite3WalOpen(sqlite3_vfs *pVfs , sqlite3_file *pDbFd , const  char *zWalName , int bNoShm , i64 mxWalSize , Wal **ppWal )  {
  int rc;
  Wal *pRet;
  int flags;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((*ppWal) = 0);
  (pRet = ((Wal *) sqlite3MallocZero((sizeof(Wal ) + pVfs->szOsFile))));
  if ((! pRet)) {
    return 7;
  }  
  (pRet->pVfs = pVfs);
  (pRet->pWalFd = ((sqlite3_file *) (&pRet[1])));
  (pRet->pDbFd = pDbFd);
  (pRet->readLock = (- 1));
  (pRet->mxWalSize = mxWalSize);
  (pRet->zWalName = zWalName);
  (pRet->syncHeader = 1);
  (pRet->padToSectorBoundary = 1);
  (pRet->exclusiveMode = (bNoShm ? 2 : 0));
  (flags = (0x00000002 | 0x00000004 | 0x00080000));
  (rc = sqlite3OsOpen(pVfs, zWalName, pRet->pWalFd, flags, (&flags)));
  if (((rc == 0) && (flags & 0x00000001))) {
    (pRet->readOnly = 1);
  }  
  if ((rc != 0)) {
    walIndexClose(pRet, 0);
    sqlite3OsClose(pRet->pWalFd);
    sqlite3_free(pRet);
  }  
  else {
    int iDC =  sqlite3OsDeviceCharacteristics(pRet->pWalFd);
    if ((iDC & 0x00000400)) {
      (pRet->syncHeader = 0);
    }  
    if ((iDC & 0x00001000)) {
      (pRet->padToSectorBoundary = 0);
    }  
    ((*ppWal) = pRet);
  }
  return rc;
}
static  void sqlite3WalLimit(Wal *pWal , i64 iLimit )  {
  if (pWal) {
    (pWal->mxWalSize = iLimit);
  }  
}
static  int walIteratorNext(WalIterator *p , u32 *piPage , u32 *piFrame )  {
  u32 iMin;
  u32 iRet =  0xFFFFFFFF;
  int i;
  (iMin = p->iPrior);
  ((void ) 0);
  for ((i = (p->nSegment - 1)); (i >= 0); i--) {
    struct  WalSegment   *pSegment =  (&p->aSegment[i]);
    while ((pSegment->iNext < pSegment->nEntry)) {
      u32 iPg =  pSegment->aPgno[pSegment->aIndex[pSegment->iNext]];
      if ((iPg > iMin)) {
        if ((iPg < iRet)) {
          (iRet = iPg);
          ((*piFrame) = (pSegment->iZero + pSegment->aIndex[pSegment->iNext]));
        }  
        break;
      }  
      pSegment->iNext++;
    }
  }
  ((*piPage) = (p->iPrior = iRet));
  return (iRet == 0xFFFFFFFF);
}
static  void walMerge(const  u32 *aContent , ht_slot *aLeft , int nLeft , ht_slot **paRight , int *pnRight , ht_slot *aTmp )  {
  int iLeft =  0;
  int iRight =  0;
  int iOut =  0;
  int nRight =  (*pnRight);
  ht_slot *aRight =  (*paRight);
  ((void ) 0);
  while (((iRight < nRight) || (iLeft < nLeft))) {
    ht_slot logpage;
    Pgno dbpage;
    if (((iLeft < nLeft) && ((iRight >= nRight) || (aContent[aLeft[iLeft]] < aContent[aRight[iRight]])))) {
      (logpage = aLeft[iLeft++]);
    }  
    else {
      (logpage = aRight[iRight++]);
    }
    (dbpage = aContent[logpage]);
    (aTmp[iOut++] = logpage);
    if (((iLeft < nLeft) && (aContent[aLeft[iLeft]] == dbpage))) {
      iLeft++;
    }  
    ((void ) 0);
    ((void ) 0);
  }
  ((*paRight) = aLeft);
  ((*pnRight) = iOut);
  memcpy(aLeft, aTmp, (sizeof(aTmp[0]) * iOut));
}
static  void walMergesort(const  u32 *aContent , ht_slot *aBuffer , ht_slot *aList , int *pnList )  {
  struct  Sublist {
    int nList ;
    ht_slot *aList ;
  }  ;
  const int nList =  (*pnList);
  int nMerge =  0;
  ht_slot *aMerge =  0;
  int iList;
  int iSub =  0;
  struct  Sublist   aSub[13];
  memset(aSub, 0, sizeof(aSub));
  ((void ) 0);
  ((void ) 0);
  for ((iList = 0); (iList < nList); iList++) {
    (nMerge = 1);
    (aMerge = (&aList[iList]));
    for ((iSub = 0); (iList & (1 << iSub)); iSub++) {
      struct  Sublist   *p =  (&aSub[iSub]);
      ((void ) 0);
      ((void ) 0);
      walMerge(aContent, p->aList, p->nList, (&aMerge), (&nMerge), aBuffer);
    }
    (aSub[iSub].aList = aMerge);
    (aSub[iSub].nList = nMerge);
  }
  for (iSub++; (iSub < ((int ) (sizeof(aSub) / sizeof(aSub[0])))); iSub++) {
    if ((nList & (1 << iSub))) {
      struct  Sublist   *p =  (&aSub[iSub]);
      ((void ) 0);
      ((void ) 0);
      walMerge(aContent, p->aList, p->nList, (&aMerge), (&nMerge), aBuffer);
    }  
  }
  ((void ) 0);
  ((*pnList) = nMerge);
}
static  void walIteratorFree(WalIterator *p )  {
  sqlite3ScratchFree(p);
}
static  int walIteratorInit(Wal *pWal , WalIterator **pp )  {
  WalIterator *p;
  int nSegment;
  u32 iLast;
  int nByte;
  int i;
  ht_slot *aTmp;
  int rc =  0;
  ((void ) 0);
  (iLast = pWal->hdr.mxFrame);
  (nSegment = (walFramePage(iLast) + 1));
  (nByte = (sizeof(WalIterator ) + ((nSegment - 1) * sizeof(struct  WalSegment   )) + (iLast * sizeof(ht_slot ))));
  (p = ((WalIterator *) sqlite3ScratchMalloc(nByte)));
  if ((! p)) {
    return 7;
  }  
  memset(p, 0, nByte);
  (p->nSegment = nSegment);
  (aTmp = ((ht_slot *) sqlite3ScratchMalloc((sizeof(ht_slot ) * ((iLast > 4096) ? 4096 : iLast)))));
  if ((! aTmp)) {
    (rc = 7);
  }  
  for ((i = 0); ((rc == 0) && (i < nSegment)); i++) {
    volatile ht_slot *aHash;
    u32 iZero;
    volatile u32 *aPgno;
    (rc = walHashGet(pWal, i, (&aHash), (&aPgno), (&iZero)));
    if ((rc == 0)) {
      int j;
      int nEntry;
      ht_slot *aIndex;
      aPgno++;
      if (((i + 1) == nSegment)) {
        (nEntry = ((int ) (iLast - iZero)));
      }  
      else {
        (nEntry = ((int ) (((u32 *) aHash) - ((u32 *) aPgno))));
      }
      (aIndex = (&((ht_slot *) (&p->aSegment[p->nSegment]))[iZero]));
      iZero++;
      for ((j = 0); (j < nEntry); j++) {
        (aIndex[j] = ((ht_slot ) j));
      }
      walMergesort(((u32 *) aPgno), aTmp, aIndex, (&nEntry));
      (p->aSegment[i].iZero = iZero);
      (p->aSegment[i].nEntry = nEntry);
      (p->aSegment[i].aIndex = aIndex);
      (p->aSegment[i].aPgno = ((u32 *) aPgno));
    }  
  }
  sqlite3ScratchFree(aTmp);
  if ((rc != 0)) {
    walIteratorFree(p);
  }  
  ((*pp) = p);
  return rc;
}
static  int walBusyLock(Wal *pWal , int ( *xBusy)(void * ) , void *pBusyArg , int lockIdx , int n )  {
  int rc;
  do {
    (rc = walLockExclusive(pWal, lockIdx, n));
  } while ((xBusy && (rc == 5) && xBusy(pBusyArg)));
  return rc;
}
static  int walPagesize(Wal *pWal )  {
  return ((pWal->hdr.szPage & 0xfe00) + ((pWal->hdr.szPage & 0x0001) << 16));
}
static  int walCheckpoint(Wal *pWal , int eMode , int ( *xBusyCall)(void * ) , void *pBusyArg , int sync_flags , u8 *zBuf )  {
  int rc;
  int szPage;
  WalIterator *pIter =  0;
  u32 iDbpage =  0;
  u32 iFrame =  0;
  u32 mxSafeFrame;
  u32 mxPage;
  int i;
  volatile WalCkptInfo *pInfo;
  int ( *xBusy)(void * ) =  0;
  (szPage = walPagesize(pWal));
  if (((id2i_sqlite_coverage_test ) )) {
    if ((szPage <= 32768)) {
      sqlite3Coverage(47449);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((szPage >= 65536)) {
      sqlite3Coverage(47450);
    }  
  }  
  (pInfo = walCkptInfo(pWal));
  if ((pInfo->nBackfill >= pWal->hdr.mxFrame)) {
    return 0;
  }  
  (rc = walIteratorInit(pWal, (&pIter)));
  if ((rc != 0)) {
    return rc;
  }  
  ((void ) 0);
  if ((eMode != 0)) {
    (xBusy = xBusyCall);
  }  
  (mxSafeFrame = pWal->hdr.mxFrame);
  (mxPage = pWal->hdr.nPage);
  for ((i = 1); (i < (8 - 3)); i++) {
    u32 y =  pInfo->aReadMark[i];
    if ((mxSafeFrame > y)) {
      ((void ) 0);
      (rc = walBusyLock(pWal, xBusy, pBusyArg, (3 + i), 1));
      if ((rc == 0)) {
        (pInfo->aReadMark[i] = ((i == 1) ? mxSafeFrame : 0xffffffff));
        walUnlockExclusive(pWal, (3 + i), 1);
      } 
      else if ((rc == 5)) {
        (mxSafeFrame = y);
        (xBusy = 0);
      } 
      else {
        goto walcheckpoint_out;
      }
    }  
  }
  if (((pInfo->nBackfill < mxSafeFrame) && ((rc = walBusyLock(pWal, xBusy, pBusyArg, (3 + 0), 1)) == 0))) {
    i64 nSize;
    u32 nBackfill =  pInfo->nBackfill;
    if (sync_flags) {
      (rc = sqlite3OsSync(pWal->pWalFd, sync_flags));
    }  
    if ((rc == 0)) {
      i64 nReq =  (((i64 ) mxPage) * szPage);
      (rc = sqlite3OsFileSize(pWal->pDbFd, (&nSize)));
      if (((rc == 0) && (nSize < nReq))) {
        sqlite3OsFileControlHint(pWal->pDbFd, 5, (&nReq));
      }  
    }  
    while (((rc == 0) && (0 == walIteratorNext(pIter, (&iDbpage), (&iFrame))))) {
      i64 iOffset;
      ((void ) 0);
      if (((iFrame <= nBackfill) || (iFrame > mxSafeFrame) || (iDbpage > mxPage))) {
        continue;
      }  
      (iOffset = ((32 + ((iFrame - 1) * ((i64 ) (szPage + 24)))) + 24));
      (rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset));
      if ((rc != 0)) {
        break;
      }  
      (iOffset = ((iDbpage - 1) * ((i64 ) szPage)));
      if (((id2i_sqlite_coverage_test ) )) {
        if (((iOffset & (~ ((i64 ) 0xffffffff))) != 0)) {
          sqlite3Coverage(47520);
        }  
      }  
      (rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset));
      if ((rc != 0)) {
        break;
      }  
    }
    if ((rc == 0)) {
      if ((mxSafeFrame == walIndexHdr(pWal)->mxFrame)) {
        i64 szDb =  (pWal->hdr.nPage * ((i64 ) szPage));
        if (((id2i_sqlite_coverage_test ) )) {
          if (((szDb & (~ ((i64 ) 0xffffffff))) != 0)) {
            sqlite3Coverage(47529);
          }  
        }  
        (rc = sqlite3OsTruncate(pWal->pDbFd, szDb));
        if (((rc == 0) && sync_flags)) {
          (rc = sqlite3OsSync(pWal->pDbFd, sync_flags));
        }  
      }  
      if ((rc == 0)) {
        (pInfo->nBackfill = mxSafeFrame);
      }  
    }  
    walUnlockExclusive(pWal, (3 + 0), 1);
  }  
  if ((rc == 5)) {
    (rc = 0);
  }  
  if (((rc == 0) && (eMode != 0))) {
    ((void ) 0);
    if ((pInfo->nBackfill < pWal->hdr.mxFrame)) {
      (rc = 5);
    } 
    else if ((eMode == 2)) {
      ((void ) 0);
      (rc = walBusyLock(pWal, xBusy, pBusyArg, (3 + 1), ((8 - 3) - 1)));
      if ((rc == 0)) {
        walUnlockExclusive(pWal, (3 + 1), ((8 - 3) - 1));
      }  
    } 
  }  
  walcheckpoint_out:
  walIteratorFree(pIter);
  return rc;
}
static  void walLimitSize(Wal *pWal , i64 nMax )  {
  i64 sz;
  int rx;
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    sqlite3BeginBenignMalloc();
  }  
  (rx = sqlite3OsFileSize(pWal->pWalFd, (&sz)));
  if (((rx == 0) && (sz > nMax))) {
    (rx = sqlite3OsTruncate(pWal->pWalFd, nMax));
  }  
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    sqlite3EndBenignMalloc();
  }  
  if (rx) {
    sqlite3_log(rx, "cannot limit WAL size: %s", pWal->zWalName);
  }  
}
static  int sqlite3WalClose(Wal *pWal , int sync_flags , int nBuf , u8 *zBuf )  {
  int rc =  0;
  if (pWal) {
    int isDelete =  0;
    (rc = sqlite3OsLock(pWal->pDbFd, 4));
    if ((rc == 0)) {
      if ((pWal->exclusiveMode == 0)) {
        (pWal->exclusiveMode = 1);
      }  
      (rc = sqlite3WalCheckpoint(pWal, 0, 0, 0, sync_flags, nBuf, zBuf, 0, 0));
      if ((rc == 0)) {
        int bPersist =  (- 1);
        sqlite3OsFileControlHint(pWal->pDbFd, 10, (&bPersist));
        if ((bPersist != 1)) {
          (isDelete = 1);
        } 
        else if ((pWal->mxWalSize >= 0)) {
          walLimitSize(pWal, 0);
        } 
      }  
    }  
    walIndexClose(pWal, isDelete);
    sqlite3OsClose(pWal->pWalFd);
    if (isDelete) {
      if ((((! id2i_sqlite_omit_builtin_test) ) )) {
        sqlite3BeginBenignMalloc();
      }  
      sqlite3OsDelete(pWal->pVfs, pWal->zWalName, 0);
      if ((((! id2i_sqlite_omit_builtin_test) ) )) {
        sqlite3EndBenignMalloc();
      }  
    }  
    sqlite3_free(((void *) pWal->apWiData));
    sqlite3_free(pWal);
  }  
  return rc;
}
static  int walIndexTryHdr(Wal *pWal , int *pChanged )  {
  u32 aCksum[2];
  WalIndexHdr h1, h2;
  WalIndexHdr volatile *aHdr;
  ((void ) 0);
  (aHdr = walIndexHdr(pWal));
  memcpy((&h1), ((void *) (&aHdr[0])), sizeof(h1));
  walShmBarrier(pWal);
  memcpy((&h2), ((void *) (&aHdr[1])), sizeof(h2));
  if ((memcmp((&h1), (&h2), sizeof(h1)) != 0)) {
    return 1;
  }  
  if ((h1.isInit == 0)) {
    return 1;
  }  
  walChecksumBytes(1, ((u8 *) (&h1)), (sizeof(h1) - sizeof(h1.aCksum)), 0, aCksum);
  if (((aCksum[0] != h1.aCksum[0]) || (aCksum[1] != h1.aCksum[1]))) {
    return 1;
  }  
  if (memcmp((&pWal->hdr), (&h1), sizeof(WalIndexHdr ))) {
    ((*pChanged) = 1);
    memcpy((&pWal->hdr), (&h1), sizeof(WalIndexHdr ));
    (pWal->szPage = ((pWal->hdr.szPage & 0xfe00) + ((pWal->hdr.szPage & 0x0001) << 16)));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pWal->szPage <= 32768)) {
        sqlite3Coverage(47711);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pWal->szPage >= 65536)) {
        sqlite3Coverage(47712);
      }  
    }  
  }  
  return 0;
}
static  int walIndexReadHdr(Wal *pWal , int *pChanged )  {
  int rc;
  int badHdr;
  volatile u32 *page0;
  ((void ) 0);
  (rc = walIndexPage(pWal, 0, (&page0)));
  if ((rc != 0)) {
    return rc;
  }  
  ((void ) 0);
  (badHdr = (page0 ? walIndexTryHdr(pWal, pChanged) : 1));
  ((void ) 0);
  if (badHdr) {
    if ((pWal->readOnly & 2)) {
      if ((0 == (rc = walLockShared(pWal, 0)))) {
        walUnlockShared(pWal, 0);
        (rc = (8 | (1 << 8)));
      }  
    } 
    else if ((0 == (rc = walLockExclusive(pWal, 0, 1)))) {
      (pWal->writeLock = 1);
      if ((0 == (rc = walIndexPage(pWal, 0, (&page0))))) {
        (badHdr = walIndexTryHdr(pWal, pChanged));
        if (badHdr) {
          (rc = walIndexRecover(pWal));
          ((*pChanged) = 1);
        }  
      }  
      (pWal->writeLock = 0);
      walUnlockExclusive(pWal, 0, 1);
    } 
  }  
  if (((badHdr == 0) && (pWal->hdr.iVersion != 3007000))) {
    (rc = sqlite3CantopenError(47786));
  }  
  return rc;
}
static  int walTryBeginRead(Wal *pWal , int *pChanged , int useWal , int cnt )  {
  volatile WalCkptInfo *pInfo;
  u32 mxReadMark;
  int mxI;
  int i;
  int rc =  0;
  ((void ) 0);
  if ((cnt > 5)) {
    int nDelay =  1;
    if ((cnt > 100)) {
      return 15;
    }  
    if ((cnt >= 10)) {
      (nDelay = ((cnt - 9) * 238));
    }  
    sqlite3OsSleep(pWal->pVfs, nDelay);
  }  
  if ((! useWal)) {
    (rc = walIndexReadHdr(pWal, pChanged));
    if ((rc == 5)) {
      if ((pWal->apWiData[0] == 0)) {
        (rc = (- 1));
      } 
      else if ((0 == (rc = walLockShared(pWal, 2)))) {
        walUnlockShared(pWal, 2);
        (rc = (- 1));
      }
      
      else if ((rc == 5)) {
        (rc = (5 | (1 << 8)));
      } 
    }  
    if ((rc != 0)) {
      return rc;
    }  
  }  
  (pInfo = walCkptInfo(pWal));
  if (((! useWal) && (pInfo->nBackfill == pWal->hdr.mxFrame))) {
    (rc = walLockShared(pWal, (3 + 0)));
    walShmBarrier(pWal);
    if ((rc == 0)) {
      if (memcmp(((void *) walIndexHdr(pWal)), (&pWal->hdr), sizeof(WalIndexHdr ))) {
        walUnlockShared(pWal, (3 + 0));
        return (- 1);
      }  
      (pWal->readLock = 0);
      return 0;
    } 
    else if ((rc != 5)) {
      return rc;
    } 
  }  
  (mxReadMark = 0);
  (mxI = 0);
  for ((i = 1); (i < (8 - 3)); i++) {
    u32 thisMark =  pInfo->aReadMark[i];
    if (((mxReadMark <= thisMark) && (thisMark <= pWal->hdr.mxFrame))) {
      ((void ) 0);
      (mxReadMark = thisMark);
      (mxI = i);
    }  
  }
  {
    if ((((pWal->readOnly & 2) == 0) && ((mxReadMark < pWal->hdr.mxFrame) || (mxI == 0)))) {
      for ((i = 1); (i < (8 - 3)); i++) {
        (rc = walLockExclusive(pWal, (3 + i), 1));
        if ((rc == 0)) {
          (mxReadMark = (pInfo->aReadMark[i] = pWal->hdr.mxFrame));
          (mxI = i);
          walUnlockExclusive(pWal, (3 + i), 1);
          break;
        } 
        else if ((rc != 5)) {
          return rc;
        } 
      }
    }  
    if ((mxI == 0)) {
      ((void ) 0);
      return ((rc == 5) ? (- 1) : (8 | (2 << 8)));
    }  
    (rc = walLockShared(pWal, (3 + mxI)));
    if (rc) {
      return ((rc == 5) ? (- 1) : rc);
    }  
    walShmBarrier(pWal);
    if (((pInfo->aReadMark[mxI] != mxReadMark) || memcmp(((void *) walIndexHdr(pWal)), (&pWal->hdr), sizeof(WalIndexHdr )))) {
      walUnlockShared(pWal, (3 + mxI));
      return (- 1);
    }  
    else {
      ((void ) 0);
      (pWal->readLock = ((i16 ) mxI));
    }
  }
  return rc;
}
static  int sqlite3WalBeginReadTransaction(Wal *pWal , int *pChanged )  {
  int rc;
  int cnt =  0;
  do {
    (rc = walTryBeginRead(pWal, pChanged, 0, ++cnt));
  } while ((rc == (- 1)));
  if (((id2i_sqlite_coverage_test ) )) {
    if (((rc & 0xff) == 5)) {
      sqlite3Coverage(48044);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((rc & 0xff) == 10)) {
      sqlite3Coverage(48045);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((rc == 15)) {
      sqlite3Coverage(48046);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((rc == 0)) {
      sqlite3Coverage(48047);
    }  
  }  
  return rc;
}
static  void sqlite3WalEndReadTransaction(Wal *pWal )  {
  sqlite3WalEndWriteTransaction(pWal);
  if ((pWal->readLock >= 0)) {
    walUnlockShared(pWal, (3 + pWal->readLock));
    (pWal->readLock = (- 1));
  }  
}
static  int sqlite3WalFindFrame(Wal *pWal , Pgno pgno , u32 *piRead )  {
  u32 iRead =  0;
  u32 iLast =  pWal->hdr.mxFrame;
  int iHash;
  ((void ) 0);
  if (((iLast == 0) || (pWal->readLock == 0))) {
    ((*piRead) = 0);
    return 0;
  }  
  for ((iHash = walFramePage(iLast)); ((iHash >= 0) && (iRead == 0)); iHash--) {
    volatile ht_slot *aHash;
    volatile u32 *aPgno;
    u32 iZero;
    int iKey;
    int nCollide;
    int rc;
    (rc = walHashGet(pWal, iHash, (&aHash), (&aPgno), (&iZero)));
    if ((rc != 0)) {
      return rc;
    }  
    (nCollide = (4096 * 2));
    for ((iKey = walHash(pgno)); aHash[iKey]; (iKey = walNextHash(iKey))) {
      u32 iFrame =  (aHash[iKey] + iZero);
      if (((iFrame <= iLast) && (aPgno[aHash[iKey]] == pgno))) {
        (iRead = iFrame);
      }  
      if ((nCollide-- == 0)) {
        return sqlite3CorruptError(48139);
      }  
    }
  }
  if (((id2i_sqlite_enable_expensive_assert ) )) {
    u32 iRead2 =  0;
    u32 iTest;
    for ((iTest = iLast); (iTest > 0); iTest--) {
      if ((walFramePgno(pWal, iTest) == pgno)) {
        (iRead2 = iTest);
        break;
      }  
    }
    ((void ) 0);
  }  
  ((*piRead) = iRead);
  return 0;
}
static  int sqlite3WalReadFrame(Wal *pWal , u32 iRead , int nOut , u8 *pOut )  {
  int sz;
  i64 iOffset;
  (sz = pWal->hdr.szPage);
  (sz = ((sz & 0xfe00) + ((sz & 0x0001) << 16)));
  if (((id2i_sqlite_coverage_test ) )) {
    if ((sz <= 32768)) {
      sqlite3Coverage(48180);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((sz >= 65536)) {
      sqlite3Coverage(48181);
    }  
  }  
  (iOffset = ((32 + ((iRead - 1) * ((i64 ) (sz + 24)))) + 24));
  return sqlite3OsRead(pWal->pWalFd, pOut, ((nOut > sz) ? sz : nOut), iOffset);
}
static  Pgno sqlite3WalDbsize(Wal *pWal )  {
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pWal && (pWal->readLock >= 0))) {
      return pWal->hdr.nPage;
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pWal && 1)) {
      return pWal->hdr.nPage;
    }  
  }  
  return 0;
}
static  int sqlite3WalBeginWriteTransaction(Wal *pWal )  {
  int rc;
  ((void ) 0);
  if (pWal->readOnly) {
    return 8;
  }  
  (rc = walLockExclusive(pWal, 0, 1));
  if (rc) {
    return rc;
  }  
  (pWal->writeLock = 1);
  if ((memcmp((&pWal->hdr), ((void *) walIndexHdr(pWal)), sizeof(WalIndexHdr )) != 0)) {
    walUnlockExclusive(pWal, 0, 1);
    (pWal->writeLock = 0);
    (rc = (5 | (2 << 8)));
  }  
  return rc;
}
static  int sqlite3WalEndWriteTransaction(Wal *pWal )  {
  if (pWal->writeLock) {
    walUnlockExclusive(pWal, 0, 1);
    (pWal->writeLock = 0);
    (pWal->truncateOnCommit = 0);
  }  
  return 0;
}
static  int sqlite3WalUndo(Wal *pWal , int ( *xUndo)(void * , Pgno ) , void *pUndoCtx )  {
  int rc =  0;
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      Pgno iMax =  pWal->hdr.mxFrame;
      Pgno iFrame;
      memcpy((&pWal->hdr), ((void *) walIndexHdr(pWal)), sizeof(WalIndexHdr ));
      for ((iFrame = (pWal->hdr.mxFrame + 1)); (1 && (iFrame <= iMax)); iFrame++) {
        ((void ) 0);
        (rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame)));
      }
      if ((iMax != pWal->hdr.mxFrame)) {
        walCleanupHash(pWal);
      }  
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pWal->writeLock) {
      Pgno iMax =  pWal->hdr.mxFrame;
      Pgno iFrame;
      memcpy((&pWal->hdr), ((void *) walIndexHdr(pWal)), sizeof(WalIndexHdr ));
      for ((iFrame = (pWal->hdr.mxFrame + 1)); ((rc == 0) && (iFrame <= iMax)); iFrame++) {
        ((void ) 0);
        (rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame)));
      }
      if ((iMax != pWal->hdr.mxFrame)) {
        walCleanupHash(pWal);
      }  
    }  
  }  
  ((void ) 0);
  return rc;
}
static  void sqlite3WalSavepoint(Wal *pWal , u32 *aWalData )  {
  ((void ) 0);
  (aWalData[0] = pWal->hdr.mxFrame);
  (aWalData[1] = pWal->hdr.aFrameCksum[0]);
  (aWalData[2] = pWal->hdr.aFrameCksum[1]);
  (aWalData[3] = pWal->nCkpt);
}
static  int sqlite3WalSavepointUndo(Wal *pWal , u32 *aWalData )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  if ((aWalData[3] != pWal->nCkpt)) {
    (aWalData[0] = 0);
    (aWalData[3] = pWal->nCkpt);
  }  
  if ((aWalData[0] < pWal->hdr.mxFrame)) {
    (pWal->hdr.mxFrame = aWalData[0]);
    (pWal->hdr.aFrameCksum[0] = aWalData[1]);
    (pWal->hdr.aFrameCksum[1] = aWalData[2]);
    walCleanupHash(pWal);
  }  
  return rc;
}
static  int walRestartLog(Wal *pWal )  {
  int rc =  0;
  int cnt;
  if ((pWal->readLock == 0)) {
    volatile WalCkptInfo *pInfo =  walCkptInfo(pWal);
    ((void ) 0);
    if ((pInfo->nBackfill > 0)) {
      u32 salt1;
      sqlite3_randomness(4, (&salt1));
      (rc = walLockExclusive(pWal, (3 + 1), ((8 - 3) - 1)));
      if ((rc == 0)) {
        int i;
        u32 *aSalt =  pWal->hdr.aSalt;
        pWal->nCkpt++;
        (pWal->hdr.mxFrame = 0);
        sqlite3Put4byte(((u8 *) (&aSalt[0])), (1 + sqlite3Get4byte(((u8 *) (&aSalt[0])))));
        (aSalt[1] = salt1);
        walIndexWriteHdr(pWal);
        (pInfo->nBackfill = 0);
        (pInfo->aReadMark[1] = 0);
        for ((i = 2); (i < (8 - 3)); i++) {
          (pInfo->aReadMark[i] = 0xffffffff);
        }
        ((void ) 0);
        walUnlockExclusive(pWal, (3 + 1), ((8 - 3) - 1));
      } 
      else if ((rc != 5)) {
        return rc;
      } 
    }  
    walUnlockShared(pWal, (3 + 0));
    (pWal->readLock = (- 1));
    (cnt = 0);
    do {
      int notUsed;
      (rc = walTryBeginRead(pWal, (&notUsed), 1, ++cnt));
    } while ((rc == (- 1)));
    ((void ) 0);
    if (((id2i_sqlite_coverage_test ) )) {
      if (((rc & 0xff) == 10)) {
        sqlite3Coverage(48409);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((rc == 15)) {
        sqlite3Coverage(48410);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((rc == 0)) {
        sqlite3Coverage(48411);
      }  
    }  
  }  
  return rc;
}
typedef struct  WalWriter {
  Wal *pWal ;
  sqlite3_file *pFd ;
  sqlite3_int64 iSyncPoint ;
  int syncFlags ;
  int szPage ;
}  WalWriter;
static  int walWriteToLog(WalWriter *p , void *pContent , int iAmt , sqlite3_int64 iOffset )  {
  int rc;
  if (((iOffset < p->iSyncPoint) && ((iOffset + iAmt) >= p->iSyncPoint))) {
    int iFirstAmt =  ((int ) (p->iSyncPoint - iOffset));
    (rc = sqlite3OsWrite(p->pFd, pContent, iFirstAmt, iOffset));
    if (rc) {
      return rc;
    }  
    (iOffset += iFirstAmt);
    (iAmt -= iFirstAmt);
    (pContent = ((void *) (iFirstAmt + ((char *) pContent))));
    ((void ) 0);
    (rc = sqlite3OsSync(p->pFd, p->syncFlags));
    if (((iAmt == 0) || rc)) {
      return rc;
    }  
  }  
  (rc = sqlite3OsWrite(p->pFd, pContent, iAmt, iOffset));
  return rc;
}
static  int walWriteOneFrame(WalWriter *p , PgHdr *pPage , int nTruncate , sqlite3_int64 iOffset )  {
  int rc;
  void *pData;
  u8 aFrame[24];
  (pData = pPage->pData);
  walEncodeFrame(p->pWal, pPage->pgno, nTruncate, pData, aFrame);
  (rc = walWriteToLog(p, aFrame, sizeof(aFrame), iOffset));
  if (rc) {
    return rc;
  }  
  (rc = walWriteToLog(p, pData, p->szPage, (iOffset + sizeof(aFrame))));
  return rc;
}
static  int sqlite3WalFrames(Wal *pWal , int szPage , PgHdr *pList , Pgno nTruncate , int isCommit , int sync_flags )  {
  int rc;
  u32 iFrame;
  PgHdr *p;
  PgHdr *pLast =  0;
  int nExtra =  0;
  int szFrame;
  i64 iOffset;
  WalWriter w;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((0 != (rc = walRestartLog(pWal)))) {
    return rc;
  }  
  (iFrame = pWal->hdr.mxFrame);
  if ((iFrame == 0)) {
    u8 aWalHdr[32];
    u32 aCksum[2];
    sqlite3Put4byte((&aWalHdr[0]), (0x377f0682 | 0));
    sqlite3Put4byte((&aWalHdr[4]), 3007000);
    sqlite3Put4byte((&aWalHdr[8]), szPage);
    sqlite3Put4byte((&aWalHdr[12]), pWal->nCkpt);
    if ((pWal->nCkpt == 0)) {
      sqlite3_randomness(8, pWal->hdr.aSalt);
    }  
    memcpy((&aWalHdr[16]), pWal->hdr.aSalt, 8);
    walChecksumBytes(1, aWalHdr, (32 - (2 * 4)), 0, aCksum);
    sqlite3Put4byte((&aWalHdr[24]), aCksum[0]);
    sqlite3Put4byte((&aWalHdr[28]), aCksum[1]);
    (pWal->szPage = szPage);
    (pWal->hdr.bigEndCksum = 0);
    (pWal->hdr.aFrameCksum[0] = aCksum[0]);
    (pWal->hdr.aFrameCksum[1] = aCksum[1]);
    (pWal->truncateOnCommit = 1);
    (rc = sqlite3OsWrite(pWal->pWalFd, aWalHdr, sizeof(aWalHdr), 0));
    if ((rc != 0)) {
      return rc;
    }  
    if ((pWal->syncHeader && sync_flags)) {
      (rc = sqlite3OsSync(pWal->pWalFd, (sync_flags & 0x13)));
      if (rc) {
        return rc;
      }  
    }  
  }  
  ((void ) 0);
  (w.pWal = pWal);
  (w.pFd = pWal->pWalFd);
  (w.iSyncPoint = 0);
  (w.syncFlags = sync_flags);
  (w.szPage = szPage);
  (iOffset = (32 + (((iFrame + 1) - 1) * ((i64 ) (szPage + 24)))));
  (szFrame = (szPage + 24));
  for ((p = pList); p; (p = p->pDirty)) {
    int nDbSize;
    iFrame++;
    ((void ) 0);
    (nDbSize = ((isCommit && (p->pDirty == 0)) ? nTruncate : 0));
    (rc = walWriteOneFrame((&w), p, nDbSize, iOffset));
    if (rc) {
      return rc;
    }  
    (pLast = p);
    (iOffset += szFrame);
  }
  if ((isCommit && ((sync_flags & 0x20) != 0))) {
    if (pWal->padToSectorBoundary) {
      int sectorSize =  sqlite3SectorSize(pWal->pWalFd);
      (w.iSyncPoint = (((iOffset + sectorSize - 1) / sectorSize) * sectorSize));
      while ((iOffset < w.iSyncPoint)) {
        (rc = walWriteOneFrame((&w), pLast, nTruncate, iOffset));
        if (rc) {
          return rc;
        }  
        (iOffset += szFrame);
        nExtra++;
      }
    }  
    else {
      (rc = sqlite3OsSync(w.pFd, (sync_flags & 0x13)));
    }
  }  
  if ((isCommit && pWal->truncateOnCommit && (pWal->mxWalSize >= 0))) {
    i64 sz =  pWal->mxWalSize;
    if (((32 + (((iFrame + nExtra + 1) - 1) * ((i64 ) (szPage + 24)))) > pWal->mxWalSize)) {
      (sz = (32 + (((iFrame + nExtra + 1) - 1) * ((i64 ) (szPage + 24)))));
    }  
    walLimitSize(pWal, sz);
    (pWal->truncateOnCommit = 0);
  }  
  (iFrame = pWal->hdr.mxFrame);
  for ((p = pList); (p && (rc == 0)); (p = p->pDirty)) {
    iFrame++;
    (rc = walIndexAppend(pWal, iFrame, p->pgno));
  }
  while (((rc == 0) && (nExtra > 0))) {
    iFrame++;
    nExtra--;
    (rc = walIndexAppend(pWal, iFrame, pLast->pgno));
  }
  if ((rc == 0)) {
    (pWal->hdr.szPage = ((u16 ) ((szPage & 0xff00) | (szPage >> 16))));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((szPage <= 32768)) {
        sqlite3Coverage(48653);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((szPage >= 65536)) {
        sqlite3Coverage(48654);
      }  
    }  
    (pWal->hdr.mxFrame = iFrame);
    if (isCommit) {
      pWal->hdr.iChange++;
      (pWal->hdr.nPage = nTruncate);
    }  
    if (isCommit) {
      walIndexWriteHdr(pWal);
      (pWal->iCallback = iFrame);
    }  
  }  
  return rc;
}
static  int sqlite3WalCheckpoint(Wal *pWal , int eMode , int ( *xBusy)(void * ) , void *pBusyArg , int sync_flags , int nBuf , u8 *zBuf , int *pnLog , int *pnCkpt )  {
  int rc;
  int isChanged =  0;
  int eMode2 =  eMode;
  ((void ) 0);
  ((void ) 0);
  if (pWal->readOnly) {
    return 8;
  }  
  (rc = walLockExclusive(pWal, 1, 1));
  if (rc) {
    return rc;
  }  
  (pWal->ckptLock = 1);
  if ((eMode != 0)) {
    (rc = walBusyLock(pWal, xBusy, pBusyArg, 0, 1));
    if ((rc == 0)) {
      (pWal->writeLock = 1);
    } 
    else if ((rc == 5)) {
      (eMode2 = 0);
      (rc = 0);
    } 
  }  
  if ((rc == 0)) {
    (rc = walIndexReadHdr(pWal, (&isChanged)));
    if ((isChanged && (pWal->pDbFd->pMethods->iVersion >= 3))) {
      sqlite3OsUnfetch(pWal->pDbFd, 0, 0);
    }  
  }  
  if ((rc == 0)) {
    if ((pWal->hdr.mxFrame && (walPagesize(pWal) != nBuf))) {
      (rc = sqlite3CorruptError(48740));
    }  
    else {
      (rc = walCheckpoint(pWal, eMode2, xBusy, pBusyArg, sync_flags, zBuf));
    }
    if (((rc == 0) || (rc == 5))) {
      if (pnLog) {
        ((*pnLog) = ((int ) pWal->hdr.mxFrame));
      }  
      if (pnCkpt) {
        ((*pnCkpt) = ((int ) walCkptInfo(pWal)->nBackfill));
      }  
    }  
  }  
  if (isChanged) {
    memset((&pWal->hdr), 0, sizeof(WalIndexHdr ));
  }  
  sqlite3WalEndWriteTransaction(pWal);
  walUnlockExclusive(pWal, 1, 1);
  (pWal->ckptLock = 0);
  return (((rc == 0) && (eMode != eMode2)) ? 5 : rc);
}
static  int sqlite3WalCallback(Wal *pWal )  {
  u32 ret =  0;
  if (pWal) {
    (ret = pWal->iCallback);
    (pWal->iCallback = 0);
  }  
  return ((int ) ret);
}
static  int sqlite3WalExclusiveMode(Wal *pWal , int op )  {
  int rc;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((op == 0)) {
    if (pWal->exclusiveMode) {
      (pWal->exclusiveMode = 0);
      if ((walLockShared(pWal, (3 + pWal->readLock)) != 0)) {
        (pWal->exclusiveMode = 1);
      }  
      (rc = (pWal->exclusiveMode == 0));
    }  
    else {
      (rc = 0);
    }
  } 
  else if ((op > 0)) {
    ((void ) 0);
    ((void ) 0);
    walUnlockShared(pWal, (3 + pWal->readLock));
    (pWal->exclusiveMode = 1);
    (rc = 1);
  } 
  else {
    (rc = (pWal->exclusiveMode == 0));
  }
  return rc;
}
static  int sqlite3WalHeapMemory(Wal *pWal )  {
  return (pWal && (pWal->exclusiveMode == 2));
}
typedef struct  MemPage   MemPage;
typedef struct  BtLock   BtLock;
struct  MemPage {
  u8 isInit ;
  u8 nOverflow ;
  u8 intKey ;
  u8 leaf ;
  u8 hasData ;
  u8 hdrOffset ;
  u8 childPtrSize ;
  u8 max1bytePayload ;
  u16 maxLocal ;
  u16 minLocal ;
  u16 cellOffset ;
  u16 nFree ;
  u16 nCell ;
  u16 maskPage ;
  u16 aiOvfl[5] ;
  u8 *apOvfl[5] ;
  BtShared *pBt ;
  u8 *aData ;
  u8 *aDataEnd ;
  u8 *aCellIdx ;
  DbPage *pDbPage ;
  Pgno pgno ;
}  ;
struct  BtLock {
  Btree *pBtree ;
  Pgno iTable ;
  u8 eLock ;
  BtLock *pNext ;
}  ;
struct  Btree {
  sqlite3 *db ;
  BtShared *pBt ;
  u8 inTrans ;
  u8 sharable ;
  u8 locked ;
  int wantToLock ;
  int nBackup ;
  Btree *pNext ;
  Btree *pPrev ;
  BtLock lock ;
}  ;
struct  BtShared {
  Pager *pPager ;
  sqlite3 *db ;
  BtCursor *pCursor ;
  MemPage *pPage1 ;
  u8 openFlags ;
  u8 _1312_autoVacuum ;
  u8 _1312_incrVacuum ;
  u8 _1312_bDoTruncate ;
  u8 inTransaction ;
  u8 max1bytePayload ;
  u16 btsFlags ;
  u16 maxLocal ;
  u16 minLocal ;
  u16 maxLeaf ;
  u16 minLeaf ;
  u32 pageSize ;
  u32 usableSize ;
  int nTransaction ;
  u32 nPage ;
  void *pSchema ;
  void ( *xFreeSchema)(void * ) ;
  sqlite3_mutex *mutex ;
  Bitvec *pHasContent ;
  int nRef ;
  BtShared *pNext ;
  BtLock *pLock ;
  Btree *pWriter ;
  u8 *pTmpSpace ;
}  ;
typedef struct  CellInfo   CellInfo;
struct  CellInfo {
  i64 nKey ;
  u8 *pCell ;
  u32 nData ;
  u32 nPayload ;
  u16 nHeader ;
  u16 nLocal ;
  u16 iOverflow ;
  u16 nSize ;
}  ;
struct  BtCursor {
  Btree *pBtree ;
  BtShared *pBt ;
  BtCursor *pNext , *pPrev ;
  struct  KeyInfo   *pKeyInfo ;
  Pgno *aOverflow ;
  Pgno pgnoRoot ;
  sqlite3_int64 cachedRowid ;
  CellInfo info ;
  i64 nKey ;
  void *pKey ;
  int skipNext ;
  u8 wrFlag ;
  u8 atLast ;
  u8 validNKey ;
  u8 eState ;
  u8 isIncrblobHandle ;
  u8 hints ;
  i16 iPage ;
  u16 aiIdx[20] ;
  MemPage *apPage[20] ;
}  ;
typedef struct  IntegrityCk   IntegrityCk;
struct  IntegrityCk {
  BtShared *pBt ;
  Pager *pPager ;
  u8 *aPgRef ;
  Pgno nPage ;
  int mxErr ;
  int nErr ;
  int mallocFailed ;
  StrAccum errMsg ;
}  ;
static  void sqlite3BtreeEnter(Btree *p )  {
  (p->pBt->db = p->db);
}
static  void sqlite3BtreeEnterAll(sqlite3 *db )  {
  int i;
  for ((i = 0); (i < db->nDb); i++) {
    Btree *p =  db->aDb[i].pBt;
    if (p) {
      (p->pBt->db = p->db);
    }  
  }
}
static const char zMagicHeader[] =  "SQLite format 3";
static BtShared *sqlite3SharedCacheList =  0;
int sqlite3_enable_shared_cache(int enable )  {
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    (_1283_sqlite3Config.sharedCacheEnabled = enable);
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    (_1284_sqlite3Config.sharedCacheEnabled = enable);
  }  
  return 0;
}
static  int querySharedCacheTableLock(Btree *p , Pgno iTab , u8 eLock )  {
  BtShared *pBt =  p->pBt;
  BtLock *pIter;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((! p->sharable)) {
    return 0;
  }  
  if (((pBt->pWriter != p) && ((pBt->btsFlags & 0x0020) != 0))) {
    return (6 | (1 << 8));
  }  
  for ((pIter = pBt->pLock); pIter; (pIter = pIter->pNext)) {
    ((void ) 0);
    ((void ) 0);
    if (((pIter->pBtree != p) && (pIter->iTable == iTab) && (pIter->eLock != eLock))) {
      if ((eLock == 2)) {
        ((void ) 0);
        (pBt->btsFlags |= 0x0040);
      }  
      return (6 | (1 << 8));
    }  
  }
  return 0;
}
static  int setSharedCacheTableLock(Btree *p , Pgno iTable , u8 eLock )  {
  BtShared *pBt =  p->pBt;
  BtLock *pLock =  0;
  BtLock *pIter;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  for ((pIter = pBt->pLock); pIter; (pIter = pIter->pNext)) {
    if (((pIter->iTable == iTable) && (pIter->pBtree == p))) {
      (pLock = pIter);
      break;
    }  
  }
  if ((! pLock)) {
    (pLock = ((BtLock *) sqlite3MallocZero(sizeof(BtLock ))));
    if ((! pLock)) {
      return 7;
    }  
    (pLock->iTable = iTable);
    (pLock->pBtree = p);
    (pLock->pNext = pBt->pLock);
    (pBt->pLock = pLock);
  }  
  ((void ) 0);
  if ((eLock > pLock->eLock)) {
    (pLock->eLock = eLock);
  }  
  return 0;
}
static  void clearAllSharedCacheTableLocks(Btree *p )  {
  BtShared *pBt =  p->pBt;
  BtLock **ppIter =  (&pBt->pLock);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  while ((*ppIter)) {
    BtLock *pLock =  (*ppIter);
    ((void ) 0);
    ((void ) 0);
    if ((pLock->pBtree == p)) {
      ((*ppIter) = pLock->pNext);
      ((void ) 0);
      if ((pLock->iTable != 1)) {
        sqlite3_free(pLock);
      }  
    }  
    else {
      (ppIter = (&pLock->pNext));
    }
  }
  ((void ) 0);
  if ((pBt->pWriter == p)) {
    (pBt->pWriter = 0);
    (pBt->btsFlags &= (~ (0x0020 | 0x0040)));
  } 
  else if ((pBt->nTransaction == 2)) {
    (pBt->btsFlags &= (~ 0x0040));
  } 
}
static  void downgradeAllSharedCacheTableLocks(Btree *p )  {
  BtShared *pBt =  p->pBt;
  if ((pBt->pWriter == p)) {
    BtLock *pLock;
    (pBt->pWriter = 0);
    (pBt->btsFlags &= (~ (0x0020 | 0x0040)));
    for ((pLock = pBt->pLock); pLock; (pLock = pLock->pNext)) {
      ((void ) 0);
      (pLock->eLock = 1);
    }
  }  
}
static void releasePage(MemPage *pPage );
static  void invalidateOverflowCache(BtCursor *pCur )  {
  ((void ) 0);
  sqlite3_free(pCur->aOverflow);
  (pCur->aOverflow = 0);
}
static  void invalidateAllOverflowCache(BtShared *pBt )  {
  BtCursor *p;
  ((void ) 0);
  for ((p = pBt->pCursor); p; (p = p->pNext)) {
    invalidateOverflowCache(p);
  }
}
static  void invalidateIncrblobCursors(Btree *pBtree , i64 iRow , int isClearTable )  {
  BtCursor *p;
  BtShared *pBt =  pBtree->pBt;
  ((void ) 0);
  for ((p = pBt->pCursor); p; (p = p->pNext)) {
    if ((p->isIncrblobHandle && (isClearTable || (p->info.nKey == iRow)))) {
      (p->eState = 0);
    }  
  }
}
static  int btreeSetHasContent(BtShared *pBt , Pgno pgno )  {
  int rc =  0;
  if ((! pBt->pHasContent)) {
    ((void ) 0);
    (pBt->pHasContent = sqlite3BitvecCreate(pBt->nPage));
    if ((! pBt->pHasContent)) {
      (rc = 7);
    }  
  }  
  if (((rc == 0) && (pgno <= sqlite3BitvecSize(pBt->pHasContent)))) {
    (rc = sqlite3BitvecSet(pBt->pHasContent, pgno));
  }  
  return rc;
}
static  int btreeGetHasContent(BtShared *pBt , Pgno pgno )  {
  Bitvec *p =  pBt->pHasContent;
  return (p && ((pgno > sqlite3BitvecSize(p)) || sqlite3BitvecTest(p, pgno)));
}
static  void btreeClearHasContent(BtShared *pBt )  {
  sqlite3BitvecDestroy(pBt->pHasContent);
  (pBt->pHasContent = 0);
}
static  void btreeReleaseAllCursorPages(BtCursor *pCur )  {
  int i;
  for ((i = 0); (i <= pCur->iPage); i++) {
    releasePage(pCur->apPage[i]);
    (pCur->apPage[i] = 0);
  }
  (pCur->iPage = (- 1));
}
static  int saveCursorPosition(BtCursor *pCur )  {
  int rc;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (rc = sqlite3BtreeKeySize(pCur, (&pCur->nKey)));
  ((void ) 0);
  if ((0 == pCur->apPage[0]->intKey)) {
    void *pKey =  sqlite3Malloc(((int ) pCur->nKey));
    if (pKey) {
      (rc = sqlite3BtreeKey(pCur, 0, ((int ) pCur->nKey), pKey));
      if ((rc == 0)) {
        (pCur->pKey = pKey);
      }  
      else {
        sqlite3_free(pKey);
      }
    }  
    else {
      (rc = 7);
    }
  }  
  ((void ) 0);
  if ((rc == 0)) {
    btreeReleaseAllCursorPages(pCur);
    (pCur->eState = 3);
  }  
  invalidateOverflowCache(pCur);
  return rc;
}
static  int saveAllCursors(BtShared *pBt , Pgno iRoot , BtCursor *pExcept )  {
  BtCursor *p;
  ((void ) 0);
  ((void ) 0);
  for ((p = pBt->pCursor); p; (p = p->pNext)) {
    if (((p != pExcept) && ((0 == iRoot) || (p->pgnoRoot == iRoot)))) {
      if ((p->eState == 1)) {
        int rc =  saveCursorPosition(p);
        if ((0 != rc)) {
          return rc;
        }  
      }  
      else {
        if (((id2i_sqlite_coverage_test ) )) {
          if ((p->iPage > 0)) {
            sqlite3Coverage(50484);
          }  
        }  
        btreeReleaseAllCursorPages(p);
      }
    }  
  }
  return 0;
}
static  void sqlite3BtreeClearCursor(BtCursor *pCur )  {
  ((void ) 0);
  sqlite3_free(pCur->pKey);
  (pCur->pKey = 0);
  (pCur->eState = 0);
}
static  int btreeMoveto(BtCursor *pCur , const  void *pKey , i64 nKey , int bias , int *pRes )  {
  int rc;
  UnpackedRecord *pIdxKey;
  char aSpace[150];
  char *pFree =  0;
  if (pKey) {
    ((void ) 0);
    (pIdxKey = sqlite3VdbeAllocUnpackedRecord(pCur->pKeyInfo, aSpace, sizeof(aSpace), (&pFree)));
    if ((pIdxKey == 0)) {
      return 7;
    }  
    sqlite3VdbeRecordUnpack(pCur->pKeyInfo, ((int ) nKey), pKey, pIdxKey);
  }  
  else {
    (pIdxKey = 0);
  }
  (rc = sqlite3BtreeMovetoUnpacked(pCur, pIdxKey, nKey, bias, pRes));
  if (pFree) {
    sqlite3DbFree(pCur->pKeyInfo->db, pFree);
  }  
  return rc;
}
static  int btreeRestoreCursorPosition(BtCursor *pCur )  {
  int rc;
  ((void ) 0);
  ((void ) 0);
  if ((pCur->eState == 4)) {
    return pCur->skipNext;
  }  
  (pCur->eState = 0);
  (rc = btreeMoveto(pCur, pCur->pKey, pCur->nKey, 0, (&pCur->skipNext)));
  if ((rc == 0)) {
    sqlite3_free(pCur->pKey);
    (pCur->pKey = 0);
    ((void ) 0);
    if ((pCur->skipNext && (pCur->eState == 1))) {
      (pCur->eState = 2);
    }  
  }  
  return rc;
}
static  int sqlite3BtreeCursorHasMoved(BtCursor *pCur , int *pHasMoved )  {
  int rc;
  (rc = ((pCur->eState >= 3) ? btreeRestoreCursorPosition(pCur) : 0));
  if (rc) {
    ((*pHasMoved) = 1);
    return rc;
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((pCur->eState != 1) || (pCur->skipNext != 0))) {
      ((*pHasMoved) = 1);
    }  
    else {
      ((*pHasMoved) = 0);
    }
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((pCur->eState != 1) || 0)) {
      ((*pHasMoved) = 1);
    }  
    else {
      ((*pHasMoved) = 0);
    }
  }  
  return 0;
}
static  Pgno ptrmapPageno(BtShared *pBt , Pgno pgno )  {
  int nPagesPerMapPage;
  Pgno iPtrMap, ret;
  ((void ) 0);
  if ((pgno < 2)) {
    return 0;
  }  
  (nPagesPerMapPage = ((pBt->usableSize / 5) + 1));
  (iPtrMap = ((pgno - 2) / nPagesPerMapPage));
  (ret = ((iPtrMap * nPagesPerMapPage) + 2));
  if ((ret == ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1)))) {
    ret++;
  }  
  return ret;
}
static  void ptrmapPut(BtShared *pBt , Pgno key , u8 eType , Pgno parent , int *pRC )  {
  DbPage *pDbPage;
  u8 *pPtrmap;
  Pgno iPtrmap;
  int offset;
  int rc;
  if ((*pRC)) {
    return;
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((key == 0)) {
    ((*pRC) = sqlite3CorruptError(50641));
    return;
  }  
  (iPtrmap = ptrmapPageno(pBt, key));
  (rc = sqlite3PagerAcquire(pBt->pPager, iPtrmap, (&pDbPage), 0));
  if ((rc != 0)) {
    ((*pRC) = rc);
    return;
  }  
  (offset = (5 * (key - iPtrmap - 1)));
  if ((offset < 0)) {
    ((*pRC) = sqlite3CorruptError(50652));
    goto _1312_ptrmap_exit;
  }  
  ((void ) 0);
  (pPtrmap = ((u8 *) sqlite3PagerGetData(pDbPage)));
  if (((eType != pPtrmap[offset]) || (sqlite3Get4byte((&pPtrmap[(offset + 1)])) != parent))) {
    ((*pRC) = (rc = sqlite3PagerWrite(pDbPage)));
    if ((rc == 0)) {
      (pPtrmap[offset] = eType);
      sqlite3Put4byte((&pPtrmap[(offset + 1)]), parent);
    }  
  }  
  _1312_ptrmap_exit:
  sqlite3PagerUnref(pDbPage);
}
static  int ptrmapGet(BtShared *pBt , Pgno key , u8 *pEType , Pgno *pPgno )  {
  DbPage *pDbPage;
  int iPtrmap;
  u8 *pPtrmap;
  int offset;
  int rc;
  ((void ) 0);
  (iPtrmap = ptrmapPageno(pBt, key));
  (rc = sqlite3PagerAcquire(pBt->pPager, iPtrmap, (&pDbPage), 0));
  if ((rc != 0)) {
    return rc;
  }  
  (pPtrmap = ((u8 *) sqlite3PagerGetData(pDbPage)));
  (offset = (5 * (key - iPtrmap - 1)));
  if ((offset < 0)) {
    sqlite3PagerUnref(pDbPage);
    return sqlite3CorruptError(50697);
  }  
  ((void ) 0);
  ((void ) 0);
  ((*pEType) = pPtrmap[offset]);
  if (pPgno) {
    ((*pPgno) = sqlite3Get4byte((&pPtrmap[(offset + 1)])));
  }  
  sqlite3PagerUnref(pDbPage);
  if ((((*pEType) < 1) || ((*pEType) > 5))) {
    return sqlite3CorruptError(50705);
  }  
  return 0;
}
static  u8 *findOverflowCell(MemPage *pPage , int iCell )  {
  int i;
  ((void ) 0);
  for ((i = (pPage->nOverflow - 1)); (i >= 0); i--) {
    int k;
    (k = pPage->aiOvfl[i]);
    if ((k <= iCell)) {
      if ((k == iCell)) {
        return pPage->apOvfl[i];
      }  
      iCell--;
    }  
  }
  return (pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * iCell)])[0] << 8) | (&pPage->aCellIdx[(2 * iCell)])[1])));
}
static  void btreeParseCellPtr(MemPage *pPage , u8 *pCell , CellInfo *pInfo )  {
  u16 n;
  u32 nPayload;
  ((void ) 0);
  (pInfo->pCell = pCell);
  ((void ) 0);
  (n = pPage->childPtrSize);
  ((void ) 0);
  if (pPage->intKey) {
    if (pPage->hasData) {
      ((void ) 0);
      (n = ((u8 ) (((*pCell) < ((u8 ) 0x80)) ? (nPayload = ((u32 ) (*pCell))), 1 : sqlite3GetVarint32(pCell, ((u32 *) (&nPayload))))));
    }  
    else {
      (nPayload = 0);
    }
    (n += sqlite3GetVarint((&pCell[n]), ((u64 *) (&pInfo->nKey))));
    (pInfo->nData = nPayload);
  }  
  else {
    (pInfo->nData = 0);
    (n += ((u8 ) (((*(&pCell[n])) < ((u8 ) 0x80)) ? (nPayload = ((u32 ) (*(&pCell[n])))), 1 : sqlite3GetVarint32((&pCell[n]), ((u32 *) (&nPayload))))));
    (pInfo->nKey = nPayload);
  }
  (pInfo->nPayload = nPayload);
  (pInfo->nHeader = n);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((nPayload == pPage->maxLocal)) {
      sqlite3Coverage(50786);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((nPayload == (pPage->maxLocal + 1))) {
      sqlite3Coverage(50787);
    }  
  }  
  if ((nPayload <= pPage->maxLocal)) {
    if (((pInfo->nSize = ((u16 ) (n + nPayload))) < 4)) {
      (pInfo->nSize = 4);
    }  
    (pInfo->nLocal = ((u16 ) nPayload));
    (pInfo->iOverflow = 0);
  }  
  else {
    int minLocal;
    int maxLocal;
    int surplus;
    (minLocal = pPage->minLocal);
    (maxLocal = pPage->maxLocal);
    (surplus = (minLocal + ((nPayload - minLocal) % (pPage->pBt->usableSize - 4))));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((surplus == maxLocal)) {
        sqlite3Coverage(50812);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((surplus == (maxLocal + 1))) {
        sqlite3Coverage(50813);
      }  
    }  
    if ((surplus <= maxLocal)) {
      (pInfo->nLocal = ((u16 ) surplus));
    }  
    else {
      (pInfo->nLocal = ((u16 ) minLocal));
    }
    (pInfo->iOverflow = ((u16 ) (pInfo->nLocal + n)));
    (pInfo->nSize = (pInfo->iOverflow + 4));
  }
}
static  void btreeParseCell(MemPage *pPage , int iCell , CellInfo *pInfo )  {
  btreeParseCellPtr(pPage, (pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * iCell)])[0] << 8) | (&pPage->aCellIdx[(2 * iCell)])[1]))), pInfo);
}
static  u16 cellSizePtr(MemPage *pPage , u8 *pCell )  {
  u8 *pIter =  (&pCell[pPage->childPtrSize]);
  u32 nSize;
  if (pPage->intKey) {
    u8 *pEnd;
    if (pPage->hasData) {
      (pIter += ((u8 ) (((*pIter) < ((u8 ) 0x80)) ? (nSize = ((u32 ) (*pIter))), 1 : sqlite3GetVarint32(pIter, ((u32 *) (&nSize))))));
    }  
    else {
      (nSize = 0);
    }
    (pEnd = (&pIter[9]));
    while ((((*pIter++) & 0x80) && (pIter < pEnd))) {
      
    }
  }  
  else {
    (pIter += ((u8 ) (((*pIter) < ((u8 ) 0x80)) ? (nSize = ((u32 ) (*pIter))), 1 : sqlite3GetVarint32(pIter, ((u32 *) (&nSize))))));
  }
  if (((id2i_sqlite_coverage_test ) )) {
    if ((nSize == pPage->maxLocal)) {
      sqlite3Coverage(50869);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((nSize == (pPage->maxLocal + 1))) {
      sqlite3Coverage(50870);
    }  
  }  
  if ((nSize > pPage->maxLocal)) {
    int minLocal =  pPage->minLocal;
    (nSize = (minLocal + ((nSize - minLocal) % (pPage->pBt->usableSize - 4))));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((nSize == pPage->maxLocal)) {
        sqlite3Coverage(50874);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((nSize == (pPage->maxLocal + 1))) {
        sqlite3Coverage(50875);
      }  
    }  
    if ((nSize > pPage->maxLocal)) {
      (nSize = minLocal);
    }  
    (nSize += 4);
  }  
  (nSize += ((u32 ) (pIter - pCell)));
  if ((nSize < 4)) {
    (nSize = 4);
  }  
  ((void ) 0);
  return ((u16 ) nSize);
}
static  void ptrmapPutOvflPtr(MemPage *pPage , u8 *pCell , int *pRC )  {
  CellInfo info;
  if ((*pRC)) {
    return;
  }  
  ((void ) 0);
  btreeParseCellPtr(pPage, pCell, (&info));
  ((void ) 0);
  if (info.iOverflow) {
    Pgno ovfl =  sqlite3Get4byte((&pCell[info.iOverflow]));
    ptrmapPut(pPage->pBt, ovfl, 3, pPage->pgno, pRC);
  }  
}
static  int defragmentPage(MemPage *pPage )  {
  int i;
  int pc;
  int hdr;
  int size;
  int usableSize;
  int cellOffset;
  int cbrk;
  int nCell;
  unsigned char *data;
  unsigned char *temp;
  int iCellFirst;
  int iCellLast;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (temp = sqlite3PagerTempSpace(pPage->pBt->pPager));
  (data = pPage->aData);
  (hdr = pPage->hdrOffset);
  (cellOffset = pPage->cellOffset);
  (nCell = pPage->nCell);
  ((void ) 0);
  (usableSize = pPage->pBt->usableSize);
  (cbrk = (((&data[(hdr + 5)])[0] << 8) | (&data[(hdr + 5)])[1]));
  memcpy((&temp[cbrk]), (&data[cbrk]), (usableSize - cbrk));
  (cbrk = usableSize);
  (iCellFirst = (cellOffset + (2 * nCell)));
  (iCellLast = (usableSize - 4));
  for ((i = 0); (i < nCell); i++) {
    u8 *pAddr;
    (pAddr = (&data[(cellOffset + (i * 2))]));
    (pc = ((pAddr[0] << 8) | pAddr[1]));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pc == iCellFirst)) {
        sqlite3Coverage(50962);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pc == iCellLast)) {
        sqlite3Coverage(50963);
      }  
    }  
    if ((((! id2i_sqlite_enable_oversize_cell_check) ) )) {
      if (((pc < iCellFirst) || (pc > iCellLast))) {
        return sqlite3CorruptError(50969);
      }  
    }  
    ((void ) 0);
    (size = cellSizePtr(pPage, (&temp[pc])));
    (cbrk -= size);
    if (((id2i_sqlite_enable_oversize_cell_check ) )) {
      if ((cbrk < iCellFirst)) {
        return sqlite3CorruptError(50977);
      }  
    }  
    if ((((! id2i_sqlite_enable_oversize_cell_check) ) )) {
      if (((cbrk < iCellFirst) || ((pc + size) > usableSize))) {
        return sqlite3CorruptError(50981);
      }  
    }  
    ((void ) 0);
    if (((id2i_sqlite_coverage_test ) )) {
      if (((cbrk + size) == usableSize)) {
        sqlite3Coverage(50985);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if (((pc + size) == usableSize)) {
        sqlite3Coverage(50986);
      }  
    }  
    memcpy((&data[cbrk]), (&temp[pc]), size);
    (pAddr[0] = ((u8 ) (cbrk >> 8))), (pAddr[1] = ((u8 ) cbrk));
  }
  ((void ) 0);
  ((&data[(hdr + 5)])[0] = ((u8 ) (cbrk >> 8))), ((&data[(hdr + 5)])[1] = ((u8 ) cbrk));
  (data[(hdr + 1)] = 0);
  (data[(hdr + 2)] = 0);
  (data[(hdr + 7)] = 0);
  memset((&data[iCellFirst]), 0, (cbrk - iCellFirst));
  ((void ) 0);
  if (((cbrk - iCellFirst) != pPage->nFree)) {
    return sqlite3CorruptError(50998);
  }  
  return 0;
}
static  int allocateSpace(MemPage *pPage , int nByte , int *pIdx )  {
  const int hdr =  pPage->hdrOffset;
  u8 *const data =  pPage->aData;
  int nFrag;
  int top;
  int gap;
  int rc;
  int usableSize;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (usableSize = pPage->pBt->usableSize);
  ((void ) 0);
  (nFrag = data[(hdr + 7)]);
  ((void ) 0);
  (gap = (pPage->cellOffset + (2 * pPage->nCell)));
  (top = (((((int ) (((&data[(hdr + 5)])[0] << 8) | (&data[(hdr + 5)])[1])) - 1) & 0xffff) + 1));
  if ((gap > top)) {
    return sqlite3CorruptError(51038);
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((gap + 2) == top)) {
      sqlite3Coverage(51039);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((gap + 1) == top)) {
      sqlite3Coverage(51040);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((gap == top)) {
      sqlite3Coverage(51041);
    }  
  }  
  if ((nFrag >= 60)) {
    (rc = defragmentPage(pPage));
    if (rc) {
      return rc;
    }  
    (top = (((((int ) (((&data[(hdr + 5)])[0] << 8) | (&data[(hdr + 5)])[1])) - 1) & 0xffff) + 1));
  } 
  else if (((gap + 2) <= top)) {
    int pc, addr;
    for ((addr = (hdr + 1)); ((pc = (((&data[addr])[0] << 8) | (&data[addr])[1])) > 0); (addr = pc)) {
      int size;
      if (((pc > (usableSize - 4)) || (pc < (addr + 4)))) {
        return sqlite3CorruptError(51057);
      }  
      (size = (((&data[(pc + 2)])[0] << 8) | (&data[(pc + 2)])[1]));
      if ((size >= nByte)) {
        int x =  (size - nByte);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((x == 4)) {
            sqlite3Coverage(51062);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((x == 3)) {
            sqlite3Coverage(51063);
          }  
        }  
        if ((x < 4)) {
          memcpy((&data[addr]), (&data[pc]), 2);
          (data[(hdr + 7)] = ((u8 ) (nFrag + x)));
        } 
        else if (((size + pc) > usableSize)) {
          return sqlite3CorruptError(51070);
        } 
        else {
          ((&data[(pc + 2)])[0] = ((u8 ) (x >> 8))), ((&data[(pc + 2)])[1] = ((u8 ) x));
        }
        ((*pIdx) = (pc + x));
        return 0;
      }  
    }
  } 
  if (((id2i_sqlite_coverage_test ) )) {
    if (((gap + 2 + nByte) == top)) {
      sqlite3Coverage(51085);
    }  
  }  
  if (((gap + 2 + nByte) > top)) {
    (rc = defragmentPage(pPage));
    if (rc) {
      return rc;
    }  
    (top = (((((int ) (((&data[(hdr + 5)])[0] << 8) | (&data[(hdr + 5)])[1])) - 1) & 0xffff) + 1));
    ((void ) 0);
  }  
  (top -= nByte);
  ((&data[(hdr + 5)])[0] = ((u8 ) (top >> 8))), ((&data[(hdr + 5)])[1] = ((u8 ) top));
  ((void ) 0);
  ((*pIdx) = top);
  return 0;
}
static  int freeSpace(MemPage *pPage , int start , int size )  {
  int addr, pbegin, hdr;
  int iLast;
  unsigned char *data =  pPage->aData;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pPage->pBt->btsFlags & 0x0004)) {
    memset((&data[start]), 0, size);
  }  
  (hdr = pPage->hdrOffset);
  (addr = (hdr + 1));
  (iLast = (pPage->pBt->usableSize - 4));
  ((void ) 0);
  while ((((pbegin = (((&data[addr])[0] << 8) | (&data[addr])[1])) < start) && (pbegin > 0))) {
    if ((pbegin < (addr + 4))) {
      return sqlite3CorruptError(51148);
    }  
    (addr = pbegin);
  }
  if ((pbegin > iLast)) {
    return sqlite3CorruptError(51153);
  }  
  ((void ) 0);
  ((&data[addr])[0] = ((u8 ) (start >> 8))), ((&data[addr])[1] = ((u8 ) start));
  ((&data[start])[0] = ((u8 ) (pbegin >> 8))), ((&data[start])[1] = ((u8 ) pbegin));
  ((&data[(start + 2)])[0] = ((u8 ) (size >> 8))), ((&data[(start + 2)])[1] = ((u8 ) size));
  (pPage->nFree = (pPage->nFree + ((u16 ) size)));
  (addr = (hdr + 1));
  while (((pbegin = (((&data[addr])[0] << 8) | (&data[addr])[1])) > 0)) {
    int pnext, psize, x;
    ((void ) 0);
    ((void ) 0);
    (pnext = (((&data[pbegin])[0] << 8) | (&data[pbegin])[1]));
    (psize = (((&data[(pbegin + 2)])[0] << 8) | (&data[(pbegin + 2)])[1]));
    if ((((pbegin + psize + 3) >= pnext) && (pnext > 0))) {
      int frag =  (pnext - (pbegin + psize));
      if (((frag < 0) || (frag > ((int ) data[(hdr + 7)])))) {
        return sqlite3CorruptError(51172);
      }  
      (data[(hdr + 7)] -= ((u8 ) frag));
      (x = (((&data[pnext])[0] << 8) | (&data[pnext])[1]));
      ((&data[pbegin])[0] = ((u8 ) (x >> 8))), ((&data[pbegin])[1] = ((u8 ) x));
      (x = (pnext + (((&data[(pnext + 2)])[0] << 8) | (&data[(pnext + 2)])[1]) - pbegin));
      ((&data[(pbegin + 2)])[0] = ((u8 ) (x >> 8))), ((&data[(pbegin + 2)])[1] = ((u8 ) x));
    }  
    else {
      (addr = pbegin);
    }
  }
  if (((data[(hdr + 1)] == data[(hdr + 5)]) && (data[(hdr + 2)] == data[(hdr + 6)]))) {
    int top;
    (pbegin = (((&data[(hdr + 1)])[0] << 8) | (&data[(hdr + 1)])[1]));
    memcpy((&data[(hdr + 1)]), (&data[pbegin]), 2);
    (top = ((((&data[(hdr + 5)])[0] << 8) | (&data[(hdr + 5)])[1]) + (((&data[(pbegin + 2)])[0] << 8) | (&data[(pbegin + 2)])[1])));
    ((&data[(hdr + 5)])[0] = ((u8 ) (top >> 8))), ((&data[(hdr + 5)])[1] = ((u8 ) top));
  }  
  ((void ) 0);
  return 0;
}
static  int decodeFlags(MemPage *pPage , int flagByte )  {
  BtShared *pBt;
  ((void ) 0);
  ((void ) 0);
  (pPage->leaf = ((u8 ) (flagByte >> 3)));
  ((void ) 0);
  (flagByte &= (~ 0x08));
  (pPage->childPtrSize = (4 - (4 * pPage->leaf)));
  (pBt = pPage->pBt);
  if ((flagByte == (0x04 | 0x01))) {
    (pPage->intKey = 1);
    (pPage->hasData = pPage->leaf);
    (pPage->maxLocal = pBt->maxLeaf);
    (pPage->minLocal = pBt->minLeaf);
  } 
  else if ((flagByte == 0x02)) {
    (pPage->intKey = 0);
    (pPage->hasData = 0);
    (pPage->maxLocal = pBt->maxLocal);
    (pPage->minLocal = pBt->minLocal);
  } 
  else {
    return sqlite3CorruptError(51228);
  }
  (pPage->max1bytePayload = pBt->max1bytePayload);
  return 0;
}
static  int btreeInitPage(MemPage *pPage )  {
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((! pPage->isInit)) {
    u16 pc;
    u8 hdr;
    u8 *data;
    BtShared *pBt;
    int usableSize;
    u16 cellOffset;
    int nFree;
    int top;
    int iCellFirst;
    int iCellLast;
    (pBt = pPage->pBt);
    (hdr = pPage->hdrOffset);
    (data = pPage->aData);
    if (decodeFlags(pPage, data[hdr])) {
      return sqlite3CorruptError(51267);
    }  
    ((void ) 0);
    (pPage->maskPage = ((u16 ) (pBt->pageSize - 1)));
    (pPage->nOverflow = 0);
    (usableSize = pBt->usableSize);
    (pPage->cellOffset = (cellOffset = (hdr + 12 - (4 * pPage->leaf))));
    (pPage->aDataEnd = (&data[usableSize]));
    (pPage->aCellIdx = (&data[cellOffset]));
    (top = (((((int ) (((&data[(hdr + 5)])[0] << 8) | (&data[(hdr + 5)])[1])) - 1) & 0xffff) + 1));
    (pPage->nCell = (((&data[(hdr + 3)])[0] << 8) | (&data[(hdr + 3)])[1]));
    if ((pPage->nCell > ((pBt->pageSize - 8) / 6))) {
      return sqlite3CorruptError(51279);
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pPage->nCell == ((pBt->pageSize - 8) / 6))) {
        sqlite3Coverage(51281);
      }  
    }  
    (iCellFirst = (cellOffset + (2 * pPage->nCell)));
    (iCellLast = (usableSize - 4));
    if (((id2i_sqlite_enable_oversize_cell_check ) )) {
      int i;
      int sz;
      if ((! pPage->leaf)) {
        iCellLast--;
      }  
      for ((i = 0); (i < pPage->nCell); i++) {
        (pc = (((&data[(cellOffset + (i * 2))])[0] << 8) | (&data[(cellOffset + (i * 2))])[1]));
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pc == iCellFirst)) {
            sqlite3Coverage(51300);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pc == iCellLast)) {
            sqlite3Coverage(51301);
          }  
        }  
        if (((pc < iCellFirst) || (pc > iCellLast))) {
          return sqlite3CorruptError(51303);
        }  
        (sz = cellSizePtr(pPage, (&data[pc])));
        if (((id2i_sqlite_coverage_test ) )) {
          if (((pc + sz) == usableSize)) {
            sqlite3Coverage(51306);
          }  
        }  
        if (((pc + sz) > usableSize)) {
          return sqlite3CorruptError(51308);
        }  
      }
      if ((! pPage->leaf)) {
        iCellLast++;
      }  
    }  
    (pc = (((&data[(hdr + 1)])[0] << 8) | (&data[(hdr + 1)])[1]));
    (nFree = (data[(hdr + 7)] + top));
    while ((pc > 0)) {
      u16 next, size;
      if (((pc < iCellFirst) || (pc > iCellLast))) {
        return sqlite3CorruptError(51322);
      }  
      (next = (((&data[pc])[0] << 8) | (&data[pc])[1]));
      (size = (((&data[(pc + 2)])[0] << 8) | (&data[(pc + 2)])[1]));
      if ((((next > 0) && (next <= (pc + size + 3))) || ((pc + size) > usableSize))) {
        return sqlite3CorruptError(51329);
      }  
      (nFree = (nFree + size));
      (pc = next);
    }
    if ((nFree > usableSize)) {
      return sqlite3CorruptError(51343);
    }  
    (pPage->nFree = ((u16 ) (nFree - iCellFirst)));
    (pPage->isInit = 1);
  }  
  return 0;
}
static  void zeroPage(MemPage *pPage , int flags )  {
  unsigned char *data =  pPage->aData;
  BtShared *pBt =  pPage->pBt;
  u8 hdr =  pPage->hdrOffset;
  u16 first;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pBt->btsFlags & 0x0004)) {
    memset((&data[hdr]), 0, (pBt->usableSize - hdr));
  }  
  (data[hdr] = ((char ) flags));
  (first = (hdr + 8 + (4 * (((flags & 0x08) == 0) ? 1 : 0))));
  memset((&data[(hdr + 1)]), 0, 4);
  (data[(hdr + 7)] = 0);
  ((&data[(hdr + 5)])[0] = ((u8 ) (pBt->usableSize >> 8))), ((&data[(hdr + 5)])[1] = ((u8 ) pBt->usableSize));
  (pPage->nFree = ((u16 ) (pBt->usableSize - first)));
  decodeFlags(pPage, flags);
  (pPage->hdrOffset = hdr);
  (pPage->cellOffset = first);
  (pPage->aDataEnd = (&data[pBt->usableSize]));
  (pPage->aCellIdx = (&data[first]));
  (pPage->nOverflow = 0);
  ((void ) 0);
  (pPage->maskPage = ((u16 ) (pBt->pageSize - 1)));
  (pPage->nCell = 0);
  (pPage->isInit = 1);
}
static  MemPage *btreePageFromDbPage(DbPage *pDbPage , Pgno pgno , BtShared *pBt )  {
  MemPage *pPage =  ((MemPage *) sqlite3PagerGetExtra(pDbPage));
  (pPage->aData = sqlite3PagerGetData(pDbPage));
  (pPage->pDbPage = pDbPage);
  (pPage->pBt = pBt);
  (pPage->pgno = pgno);
  (pPage->hdrOffset = ((pPage->pgno == 1) ? 100 : 0));
  return pPage;
}
static  int btreeGetPage(BtShared *pBt , Pgno pgno , MemPage **ppPage , int flags )  {
  int rc;
  DbPage *pDbPage;
  ((void ) 0);
  ((void ) 0);
  (rc = sqlite3PagerAcquire(pBt->pPager, pgno, ((DbPage **) (&pDbPage)), flags));
  if (rc) {
    return rc;
  }  
  ((*ppPage) = btreePageFromDbPage(pDbPage, pgno, pBt));
  return 0;
}
static  MemPage *btreePageLookup(BtShared *pBt , Pgno pgno )  {
  DbPage *pDbPage;
  ((void ) 0);
  (pDbPage = sqlite3PagerLookup(pBt->pPager, pgno));
  if (pDbPage) {
    return btreePageFromDbPage(pDbPage, pgno, pBt);
  }  
  return 0;
}
static  Pgno btreePagecount(BtShared *pBt )  {
  return pBt->nPage;
}
static  u32 sqlite3BtreeLastPage(Btree *p )  {
  ((void ) 0);
  ((void ) 0);
  return ((int ) btreePagecount(p->pBt));
}
static  int getAndInitPage(BtShared *pBt , Pgno pgno , MemPage **ppPage , int bReadonly )  {
  int rc;
  ((void ) 0);
  ((void ) 0);
  if ((pgno > btreePagecount(pBt))) {
    (rc = sqlite3CorruptError(51477));
  }  
  else {
    (rc = btreeGetPage(pBt, pgno, ppPage, bReadonly));
    if ((rc == 0)) {
      (rc = btreeInitPage((*ppPage)));
      if ((rc != 0)) {
        releasePage((*ppPage));
      }  
    }  
  }
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pgno == 0)) {
      sqlite3Coverage(51488);
    }  
  }  
  ((void ) 0);
  return rc;
}
static  void releasePage(MemPage *pPage )  {
  if (pPage) {
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    sqlite3PagerUnref(pPage->pDbPage);
  }  
}
static  void pageReinit(DbPage *pData )  {
  MemPage *pPage;
  (pPage = ((MemPage *) sqlite3PagerGetExtra(pData)));
  ((void ) 0);
  if (pPage->isInit) {
    ((void ) 0);
    (pPage->isInit = 0);
    if ((sqlite3PagerPageRefcount(pData) > 1)) {
      btreeInitPage(pPage);
    }  
  }  
}
static  int btreeInvokeBusyHandler(void *pArg )  {
  BtShared *pBt =  ((BtShared *) pArg);
  ((void ) 0);
  ((void ) 0);
  return sqlite3InvokeBusyHandler((&pBt->db->busyHandler));
}
static  int sqlite3BtreeOpen(sqlite3_vfs *pVfs , const  char *zFilename , sqlite3 *db , Btree **ppBtree , int flags , int vfsFlags )  {
  BtShared *pBt =  0;
  Btree *p;
  sqlite3_mutex *mutexOpen =  0;
  int rc =  0;
  u8 nReserve;
  unsigned char zDbHeader[100];
  const int isTempDb =  ((zFilename == 0) || (zFilename[0] == 0));
  const int isMemdb =  ((zFilename && (strcmp(zFilename, ":memory:") == 0)) || (isTempDb && sqlite3TempInMemory(db)) || ((vfsFlags & 0x00000080) != 0));
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (isMemdb) {
    (flags |= 2);
  }  
  if ((((vfsFlags & 0x00000100) != 0) && (isMemdb || isTempDb))) {
    (vfsFlags = ((vfsFlags & (~ 0x00000100)) | 0x00000200));
  }  
  (p = sqlite3MallocZero(sizeof(Btree )));
  if ((! p)) {
    return 7;
  }  
  (p->inTrans = 0);
  (p->db = db);
  (p->lock.pBtree = p);
  (p->lock.iTable = 1);
  if (((isTempDb == 0) && ((isMemdb == 0) || ((vfsFlags & 0x00000040) != 0)))) {
    if ((vfsFlags & 0x00020000)) {
      int nFullPathname =  (pVfs->mxPathname + 1);
      char *zFullPathname =  sqlite3Malloc(nFullPathname);
      (p->sharable = 1);
      if ((! zFullPathname)) {
        sqlite3_free(p);
        return 7;
      }  
      if (isMemdb) {
        memcpy(zFullPathname, zFilename, (sqlite3Strlen30(zFilename) + 1));
      }  
      else {
        (rc = sqlite3OsFullPathname(pVfs, zFilename, nFullPathname, zFullPathname));
        if (rc) {
          sqlite3_free(zFullPathname);
          sqlite3_free(p);
          return rc;
        }  
      }
      for ((pBt = sqlite3SharedCacheList); pBt; (pBt = pBt->pNext)) {
        ((void ) 0);
        if (((0 == strcmp(zFullPathname, sqlite3PagerFilename(pBt->pPager, 0))) && (sqlite3PagerVfs(pBt->pPager) == pVfs))) {
          int iDb;
          for ((iDb = (db->nDb - 1)); (iDb >= 0); iDb--) {
            Btree *pExisting =  db->aDb[iDb].pBt;
            if ((pExisting && (pExisting->pBt == pBt))) {
              sqlite3_free(zFullPathname);
              sqlite3_free(p);
              return 19;
            }  
          }
          (p->pBt = pBt);
          pBt->nRef++;
          break;
        }  
      }
      sqlite3_free(zFullPathname);
    }  
  }  
  if ((pBt == 0)) {
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    (pBt = sqlite3MallocZero(sizeof((*pBt))));
    if ((pBt == 0)) {
      (rc = 7);
      goto btree_open_out;
    }  
    (rc = sqlite3PagerOpen(pVfs, (&pBt->pPager), zFilename, sizeof(MemPage ), flags, vfsFlags, pageReinit));
    if ((rc == 0)) {
      sqlite3PagerSetMmapLimit(pBt->pPager, db->szMmap);
      (rc = sqlite3PagerReadFileheader(pBt->pPager, sizeof(zDbHeader), zDbHeader));
    }  
    if ((rc != 0)) {
      goto btree_open_out;
    }  
    (pBt->openFlags = ((u8 ) flags));
    (pBt->db = db);
    sqlite3PagerSetBusyhandler(pBt->pPager, btreeInvokeBusyHandler, pBt);
    (p->pBt = pBt);
    (pBt->pCursor = 0);
    (pBt->pPage1 = 0);
    if (sqlite3PagerIsreadonly(pBt->pPager)) {
      (pBt->btsFlags |= 0x0001);
    }  
    (pBt->pageSize = ((zDbHeader[16] << 8) | (zDbHeader[17] << 16)));
    if (((pBt->pageSize < 512) || (pBt->pageSize > 65536) || (((pBt->pageSize - 1) & pBt->pageSize) != 0))) {
      (pBt->pageSize = 0);
      if ((((! id2i_sqlite_omit_autovacuum) ) )) {
        if ((zFilename && (! isMemdb))) {
          (pBt->_1312_autoVacuum = (0 ? 1 : 0));
          (pBt->_1312_incrVacuum = ((0 == 2) ? 1 : 0));
        }  
      }  
      (nReserve = 0);
    }  
    else {
      (nReserve = zDbHeader[20]);
      (pBt->btsFlags |= 0x0002);
      if ((((! id2i_sqlite_omit_autovacuum) ) )) {
        (pBt->_1312_autoVacuum = (sqlite3Get4byte((&zDbHeader[(36 + (4 * 4))])) ? 1 : 0));
      }  
      if ((((! id2i_sqlite_omit_autovacuum) ) )) {
        (pBt->_1312_incrVacuum = (sqlite3Get4byte((&zDbHeader[(36 + (7 * 4))])) ? 1 : 0));
      }  
    }
    (rc = sqlite3PagerSetPagesize(pBt->pPager, (&pBt->pageSize), nReserve));
    if (rc) {
      goto btree_open_out;
    }  
    (pBt->usableSize = (pBt->pageSize - nReserve));
    ((void ) 0);
    if (p->sharable) {
      (pBt->nRef = 1);
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        if ((0 && _1283_sqlite3Config.bCoreMutex)) {
          (pBt->mutex = ((sqlite3_mutex *) 8));
          if ((pBt->mutex == 0)) {
            (rc = 7);
            (db->mallocFailed = 0);
            goto btree_open_out;
          }  
        }  
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        if ((0 && _1284_sqlite3Config.bCoreMutex)) {
          (pBt->mutex = ((sqlite3_mutex *) 8));
          if ((pBt->mutex == 0)) {
            (rc = 7);
            (db->mallocFailed = 0);
            goto btree_open_out;
          }  
        }  
      }  
      (pBt->pNext = sqlite3SharedCacheList);
      (sqlite3SharedCacheList = pBt);
    }  
  }  
  if (p->sharable) {
    int i;
    Btree *pSib;
    for ((i = 0); (i < db->nDb); i++) {
      if ((((pSib = db->aDb[i].pBt) != 0) && pSib->sharable)) {
        while (pSib->pPrev) {
          (pSib = pSib->pPrev);
        }
        if ((p->pBt < pSib->pBt)) {
          (p->pNext = pSib);
          (p->pPrev = 0);
          (pSib->pPrev = p);
        }  
        else {
          while ((pSib->pNext && (pSib->pNext->pBt < p->pBt))) {
            (pSib = pSib->pNext);
          }
          (p->pNext = pSib->pNext);
          (p->pPrev = pSib);
          if (p->pNext) {
            (p->pNext->pPrev = p);
          }  
          (pSib->pNext = p);
        }
        break;
      }  
    }
  }  
  ((*ppBtree) = p);
  btree_open_out:
  if ((rc != 0)) {
    if ((pBt && pBt->pPager)) {
      sqlite3PagerClose(pBt->pPager);
    }  
    sqlite3_free(pBt);
    sqlite3_free(p);
    ((*ppBtree) = 0);
  }  
  else {
    if ((sqlite3BtreeSchema(p, 0, 0) == 0)) {
      sqlite3PagerSetCachesize(p->pBt->pPager, 2000);
    }  
  }
  if (mutexOpen) {
    ((void ) 0);
  }  
  return rc;
}
static  int removeFromSharingList(BtShared *pBt )  {
  BtShared *pList;
  int removed =  0;
  ((void ) 0);
  pBt->nRef--;
  if ((pBt->nRef <= 0)) {
    if ((sqlite3SharedCacheList == pBt)) {
      (sqlite3SharedCacheList = pBt->pNext);
    }  
    else {
      (pList = sqlite3SharedCacheList);
      if (((id2i_sqlite_coverage_test ) )) {
        while ((1 && (pList->pNext != pBt))) {
          (pList = pList->pNext);
        }
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        while ((pList && (pList->pNext != pBt))) {
          (pList = pList->pNext);
        }
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if (1) {
          (pList->pNext = pBt->pNext);
        }  
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if (pList) {
          (pList->pNext = pBt->pNext);
        }  
      }  
    }
    if (0) {
      
    }  
    (removed = 1);
  }  
  return removed;
}
static  void allocateTempSpace(BtShared *pBt )  {
  if ((! pBt->pTmpSpace)) {
    (pBt->pTmpSpace = sqlite3PageMalloc(pBt->pageSize));
    if (pBt->pTmpSpace) {
      memset(pBt->pTmpSpace, 0, 4);
    }  
  }  
}
static  void freeTempSpace(BtShared *pBt )  {
  sqlite3PageFree(pBt->pTmpSpace);
  (pBt->pTmpSpace = 0);
}
static  int sqlite3BtreeClose(Btree *p )  {
  BtShared *pBt =  p->pBt;
  BtCursor *pCur;
  ((void ) 0);
  sqlite3BtreeEnter(p);
  (pCur = pBt->pCursor);
  while (pCur) {
    BtCursor *pTmp =  pCur;
    (pCur = pCur->pNext);
    if ((pTmp->pBtree == p)) {
      sqlite3BtreeCloseCursor(pTmp);
    }  
  }
  sqlite3BtreeRollback(p, 0);
  ((void ) 0);
  if (((! p->sharable) || removeFromSharingList(pBt))) {
    ((void ) 0);
    sqlite3PagerClose(pBt->pPager);
    if ((pBt->xFreeSchema && pBt->pSchema)) {
      pBt->xFreeSchema(pBt->pSchema);
    }  
    sqlite3DbFree(0, pBt->pSchema);
    freeTempSpace(pBt);
    sqlite3_free(pBt);
  }  
  ((void ) 0);
  ((void ) 0);
  if (p->pPrev) {
    (p->pPrev->pNext = p->pNext);
  }  
  if (p->pNext) {
    (p->pNext->pPrev = p->pPrev);
  }  
  sqlite3_free(p);
  return 0;
}
static  int sqlite3BtreeSetCacheSize(Btree *p , int mxPage )  {
  BtShared *pBt =  p->pBt;
  ((void ) 0);
  sqlite3BtreeEnter(p);
  sqlite3PagerSetCachesize(pBt->pPager, mxPage);
  return 0;
}
static  int sqlite3BtreeSetMmapLimit(Btree *p , sqlite3_int64 szMmap )  {
  BtShared *pBt =  p->pBt;
  ((void ) 0);
  sqlite3BtreeEnter(p);
  sqlite3PagerSetMmapLimit(pBt->pPager, szMmap);
  return 0;
}
static  int sqlite3BtreeSetPagerFlags(Btree *p , unsigned pgFlags )  {
  BtShared *pBt =  p->pBt;
  ((void ) 0);
  sqlite3BtreeEnter(p);
  sqlite3PagerSetFlags(pBt->pPager, pgFlags);
  return 0;
}
static  int sqlite3BtreeSyncDisabled(Btree *p )  {
  BtShared *pBt =  p->pBt;
  int rc;
  ((void ) 0);
  sqlite3BtreeEnter(p);
  ((void ) 0);
  (rc = sqlite3PagerNosync(pBt->pPager));
  return rc;
}
static  int sqlite3BtreeSetPageSize(Btree *p , int pageSize , int nReserve , int iFix )  {
  int rc =  0;
  BtShared *pBt =  p->pBt;
  ((void ) 0);
  sqlite3BtreeEnter(p);
  if ((pBt->btsFlags & 0x0002)) {
    return 8;
  }  
  if ((nReserve < 0)) {
    (nReserve = (pBt->pageSize - pBt->usableSize));
  }  
  ((void ) 0);
  if (((pageSize >= 512) && (pageSize <= 65536) && (((pageSize - 1) & pageSize) == 0))) {
    ((void ) 0);
    ((void ) 0);
    (pBt->pageSize = ((u32 ) pageSize));
    freeTempSpace(pBt);
  }  
  (rc = sqlite3PagerSetPagesize(pBt->pPager, (&pBt->pageSize), nReserve));
  (pBt->usableSize = (pBt->pageSize - ((u16 ) nReserve)));
  if (iFix) {
    (pBt->btsFlags |= 0x0002);
  }  
  return rc;
}
static  int sqlite3BtreeGetPageSize(Btree *p )  {
  return p->pBt->pageSize;
}
static  int sqlite3BtreeGetReserve(Btree *p )  {
  int n;
  sqlite3BtreeEnter(p);
  (n = (p->pBt->pageSize - p->pBt->usableSize));
  return n;
}
static  int sqlite3BtreeMaxPageCount(Btree *p , int mxPage )  {
  int n;
  sqlite3BtreeEnter(p);
  (n = sqlite3PagerMaxPageCount(p->pBt->pPager, mxPage));
  return n;
}
static  int sqlite3BtreeSecureDelete(Btree *p , int newFlag )  {
  int b;
  if ((p == 0)) {
    return 0;
  }  
  sqlite3BtreeEnter(p);
  if ((newFlag >= 0)) {
    (p->pBt->btsFlags &= (~ 0x0004));
    if (newFlag) {
      (p->pBt->btsFlags |= 0x0004);
    }  
  }  
  (b = ((p->pBt->btsFlags & 0x0004) != 0));
  return b;
}
static  int sqlite3BtreeSetAutoVacuum(Btree *p , int autoVacuum )  {
  if (((id2i_sqlite_omit_autovacuum ) )) {
    return 8;
  }  
  BtShared *_1312_pBt =  p->pBt;
  int _1312_rc =  0;
  u8 _1312_av =  ((u8 ) autoVacuum);
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    sqlite3BtreeEnter(p);
  }  
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    if ((((_1312_pBt->btsFlags & 0x0002) != 0) && ((_1312_av ? 1 : 0) != _1312_pBt->_1312_autoVacuum))) {
      (_1312_rc = 8);
    }  
    else {
      (_1312_pBt->_1312_autoVacuum = (_1312_av ? 1 : 0));
      (_1312_pBt->_1312_incrVacuum = ((_1312_av == 2) ? 1 : 0));
    }
  }  
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    return _1312_rc;
  }  
}
static  int sqlite3BtreeGetAutoVacuum(Btree *p )  {
  if (((id2i_sqlite_omit_autovacuum ) )) {
    return 0;
  }  
  int _1312_rc;
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    sqlite3BtreeEnter(p);
  }  
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    (_1312_rc = ((! p->pBt->_1312_autoVacuum) ? 0 : ((! p->pBt->_1312_incrVacuum) ? 1 : 2)));
  }  
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    return _1312_rc;
  }  
}
static  int lockBtree(BtShared *pBt )  {
  int rc;
  MemPage *pPage1;
  int nPage;
  int nPageFile =  0;
  int nPageHeader;
  ((void ) 0);
  ((void ) 0);
  (rc = sqlite3PagerSharedLock(pBt->pPager));
  if ((rc != 0)) {
    return rc;
  }  
  (rc = btreeGetPage(pBt, 1, (&pPage1), 0));
  if ((rc != 0)) {
    return rc;
  }  
  (nPage = (nPageHeader = sqlite3Get4byte((28 + ((u8 *) pPage1->aData)))));
  sqlite3PagerPagecount(pBt->pPager, (&nPageFile));
  if (((nPage == 0) || (memcmp((24 + ((u8 *) pPage1->aData)), (92 + ((u8 *) pPage1->aData)), 4) != 0))) {
    (nPage = nPageFile);
  }  
  if ((nPage > 0)) {
    u32 pageSize;
    u32 usableSize;
    u8 *page1 =  pPage1->aData;
    (rc = 26);
    if ((memcmp(page1, zMagicHeader, 16) != 0)) {
      goto page1_init_failed;
    }  
    if ((page1[18] > 2)) {
      (pBt->btsFlags |= 0x0001);
    }  
    if ((page1[19] > 2)) {
      goto page1_init_failed;
    }  
    if (((page1[19] == 2) && ((pBt->btsFlags & 0x0010) == 0))) {
      int isOpen =  0;
      (rc = sqlite3PagerOpenWal(pBt->pPager, (&isOpen)));
      if ((rc != 0)) {
        goto page1_init_failed;
      } 
      else if ((isOpen == 0)) {
        releasePage(pPage1);
        return 0;
      } 
      (rc = 26);
    }  
    if ((memcmp((&page1[21]), "\100\040\040", 3) != 0)) {
      goto page1_init_failed;
    }  
    (pageSize = ((page1[16] << 8) | (page1[17] << 16)));
    if (((((pageSize - 1) & pageSize) != 0) || (pageSize > 65536) || (pageSize <= 256))) {
      goto page1_init_failed;
    }  
    ((void ) 0);
    (usableSize = (pageSize - page1[20]));
    if ((((u32 ) pageSize) != pBt->pageSize)) {
      releasePage(pPage1);
      (pBt->usableSize = usableSize);
      (pBt->pageSize = pageSize);
      freeTempSpace(pBt);
      (rc = sqlite3PagerSetPagesize(pBt->pPager, (&pBt->pageSize), (pageSize - usableSize)));
      return rc;
    }  
    if ((((pBt->db->flags & 0x00010000) == 0) && (nPage > nPageFile))) {
      (rc = sqlite3CorruptError(52313));
      goto page1_init_failed;
    }  
    if ((usableSize < 480)) {
      goto page1_init_failed;
    }  
    (pBt->pageSize = pageSize);
    (pBt->usableSize = usableSize);
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      (pBt->_1312_autoVacuum = (sqlite3Get4byte((&page1[(36 + (4 * 4))])) ? 1 : 0));
    }  
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      (pBt->_1312_incrVacuum = (sqlite3Get4byte((&page1[(36 + (7 * 4))])) ? 1 : 0));
    }  
  }  
  (pBt->maxLocal = ((u16 ) (((pBt->usableSize - 12) * 64 / 255) - 23)));
  (pBt->minLocal = ((u16 ) (((pBt->usableSize - 12) * 32 / 255) - 23)));
  (pBt->maxLeaf = ((u16 ) (pBt->usableSize - 35)));
  (pBt->minLeaf = ((u16 ) (((pBt->usableSize - 12) * 32 / 255) - 23)));
  if ((pBt->maxLocal > 127)) {
    (pBt->max1bytePayload = 127);
  }  
  else {
    (pBt->max1bytePayload = ((u8 ) pBt->maxLocal));
  }
  ((void ) 0);
  (pBt->pPage1 = pPage1);
  (pBt->nPage = nPage);
  return 0;
  page1_init_failed:
  releasePage(pPage1);
  (pBt->pPage1 = 0);
  return rc;
}
static  void unlockBtreeIfUnused(BtShared *pBt )  {
  ((void ) 0);
  ((void ) 0);
  if (((pBt->inTransaction == 0) && (pBt->pPage1 != 0))) {
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    releasePage(pBt->pPage1);
    (pBt->pPage1 = 0);
  }  
}
static  int newDatabase(BtShared *pBt )  {
  MemPage *pP1;
  unsigned char *data;
  int rc;
  ((void ) 0);
  if ((pBt->nPage > 0)) {
    return 0;
  }  
  (pP1 = pBt->pPage1);
  ((void ) 0);
  (data = pP1->aData);
  (rc = sqlite3PagerWrite(pP1->pDbPage));
  if (rc) {
    return rc;
  }  
  memcpy(data, zMagicHeader, sizeof(zMagicHeader));
  ((void ) 0);
  (data[16] = ((u8 ) ((pBt->pageSize >> 8) & 0xff)));
  (data[17] = ((u8 ) ((pBt->pageSize >> 16) & 0xff)));
  (data[18] = 1);
  (data[19] = 1);
  ((void ) 0);
  (data[20] = ((u8 ) (pBt->pageSize - pBt->usableSize)));
  (data[21] = 64);
  (data[22] = 32);
  (data[23] = 32);
  memset((&data[24]), 0, (100 - 24));
  zeroPage(pP1, (0x01 | 0x08 | 0x04));
  (pBt->btsFlags |= 0x0002);
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    ((void ) 0);
  }  
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    ((void ) 0);
  }  
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    sqlite3Put4byte((&data[(36 + (4 * 4))]), pBt->_1312_autoVacuum);
  }  
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    sqlite3Put4byte((&data[(36 + (7 * 4))]), pBt->_1312_incrVacuum);
  }  
  (pBt->nPage = 1);
  (data[31] = 1);
  return 0;
}
static  int sqlite3BtreeNewDb(Btree *p )  {
  int rc;
  sqlite3BtreeEnter(p);
  (p->pBt->nPage = 0);
  (rc = newDatabase(p->pBt));
  return rc;
}
static  int sqlite3BtreeBeginTrans(Btree *p , int wrflag )  {
  sqlite3 *pBlock =  0;
  BtShared *pBt =  p->pBt;
  int rc =  0;
  sqlite3BtreeEnter(p);
  ((void ) 0);
  ((void ) 0);
  if (((p->inTrans == 2) || ((p->inTrans == 1) && (! wrflag)))) {
    goto trans_begun;
  }  
  ((void ) 0);
  if ((((pBt->btsFlags & 0x0001) != 0) && wrflag)) {
    (rc = 8);
    goto trans_begun;
  }  
  if (((wrflag && (pBt->inTransaction == 2)) || ((pBt->btsFlags & 0x0040) != 0))) {
    (pBlock = pBt->pWriter->db);
  } 
  else if ((wrflag > 1)) {
    BtLock *pIter;
    for ((pIter = pBt->pLock); pIter; (pIter = pIter->pNext)) {
      if ((pIter->pBtree != p)) {
        (pBlock = pIter->pBtree->db);
        break;
      }  
    }
  } 
  if (pBlock) {
    (rc = (6 | (1 << 8)));
    goto trans_begun;
  }  
  (rc = querySharedCacheTableLock(p, 1, 1));
  if ((0 != rc)) {
    goto trans_begun;
  }  
  (pBt->btsFlags &= (~ 0x0008));
  if ((pBt->nPage == 0)) {
    (pBt->btsFlags |= 0x0008);
  }  
  do {
    while (((pBt->pPage1 == 0) && (0 == (rc = lockBtree(pBt))))) {
      
    }
    if (((rc == 0) && wrflag)) {
      if (((pBt->btsFlags & 0x0001) != 0)) {
        (rc = 8);
      }  
      else {
        (rc = sqlite3PagerBegin(pBt->pPager, (wrflag > 1), sqlite3TempInMemory(p->db)));
        if ((rc == 0)) {
          (rc = newDatabase(pBt));
        }  
      }
    }  
    if ((rc != 0)) {
      unlockBtreeIfUnused(pBt);
    }  
  } while ((((rc & 0xFF) == 5) && (pBt->inTransaction == 0) && btreeInvokeBusyHandler(pBt)));
  if ((rc == 0)) {
    if ((p->inTrans == 0)) {
      pBt->nTransaction++;
      if (p->sharable) {
        ((void ) 0);
        (p->lock.eLock = 1);
        (p->lock.pNext = pBt->pLock);
        (pBt->pLock = (&p->lock));
      }  
    }  
    (p->inTrans = (wrflag ? 2 : 1));
    if ((p->inTrans > pBt->inTransaction)) {
      (pBt->inTransaction = p->inTrans);
    }  
    if (wrflag) {
      MemPage *pPage1 =  pBt->pPage1;
      ((void ) 0);
      (pBt->pWriter = p);
      (pBt->btsFlags &= (~ 0x0020));
      if ((wrflag > 1)) {
        (pBt->btsFlags |= 0x0020);
      }  
      if ((pBt->nPage != sqlite3Get4byte((&pPage1->aData[28])))) {
        (rc = sqlite3PagerWrite(pPage1->pDbPage));
        if ((rc == 0)) {
          sqlite3Put4byte((&pPage1->aData[28]), pBt->nPage);
        }  
      }  
    }  
  }  
  trans_begun:
  if (((rc == 0) && wrflag)) {
    (rc = sqlite3PagerOpenSavepoint(pBt->pPager, p->db->nSavepoint));
  }  
  ((void ) 0);
  ((void ) 0);
  return rc;
}
static  int setChildPtrmaps(MemPage *pPage )  {
  int i;
  int nCell;
  int rc;
  BtShared *pBt =  pPage->pBt;
  u8 isInitOrig =  pPage->isInit;
  Pgno pgno =  pPage->pgno;
  ((void ) 0);
  (rc = btreeInitPage(pPage));
  if ((rc != 0)) {
    goto _1312_set_child_ptrmaps_out;
  }  
  (nCell = pPage->nCell);
  for ((i = 0); (i < nCell); i++) {
    u8 *pCell =  (pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * i)])[0] << 8) | (&pPage->aCellIdx[(2 * i)])[1])));
    ptrmapPutOvflPtr(pPage, pCell, (&rc));
    if ((! pPage->leaf)) {
      Pgno childPgno =  sqlite3Get4byte(pCell);
      ptrmapPut(pBt, childPgno, 5, pgno, (&rc));
    }  
  }
  if ((! pPage->leaf)) {
    Pgno childPgno =  sqlite3Get4byte((&pPage->aData[(pPage->hdrOffset + 8)]));
    ptrmapPut(pBt, childPgno, 5, pgno, (&rc));
  }  
  _1312_set_child_ptrmaps_out:
  (pPage->isInit = isInitOrig);
  return rc;
}
static  int modifyPagePointer(MemPage *pPage , Pgno iFrom , Pgno iTo , u8 eType )  {
  ((void ) 0);
  ((void ) 0);
  if ((eType == 4)) {
    if ((sqlite3Get4byte(pPage->aData) != iFrom)) {
      return sqlite3CorruptError(52697);
    }  
    sqlite3Put4byte(pPage->aData, iTo);
  }  
  else {
    u8 isInitOrig =  pPage->isInit;
    int i;
    int nCell;
    btreeInitPage(pPage);
    (nCell = pPage->nCell);
    for ((i = 0); (i < nCell); i++) {
      u8 *pCell =  (pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * i)])[0] << 8) | (&pPage->aCellIdx[(2 * i)])[1])));
      if ((eType == 3)) {
        CellInfo info;
        btreeParseCellPtr(pPage, pCell, (&info));
        if ((info.iOverflow && ((pCell + info.iOverflow + 3) <= (pPage->aData + pPage->maskPage)) && (iFrom == sqlite3Get4byte((&pCell[info.iOverflow]))))) {
          sqlite3Put4byte((&pCell[info.iOverflow]), iTo);
          break;
        }  
      }  
      else {
        if ((sqlite3Get4byte(pCell) == iFrom)) {
          sqlite3Put4byte(pCell, iTo);
          break;
        }  
      }
    }
    if ((i == nCell)) {
      if (((eType != 5) || (sqlite3Get4byte((&pPage->aData[(pPage->hdrOffset + 8)])) != iFrom))) {
        return sqlite3CorruptError(52731);
      }  
      sqlite3Put4byte((&pPage->aData[(pPage->hdrOffset + 8)]), iTo);
    }  
    (pPage->isInit = isInitOrig);
  }
  return 0;
}
static  int relocatePage(BtShared *pBt , MemPage *pDbPage , u8 eType , Pgno iPtrPage , Pgno iFreePage , int isCommit )  {
  MemPage *pPtrPage;
  Pgno iDbPage =  pDbPage->pgno;
  Pager *pPager =  pBt->pPager;
  int rc;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (rc = sqlite3PagerMovepage(pPager, pDbPage->pDbPage, iFreePage, isCommit));
  if ((rc != 0)) {
    return rc;
  }  
  (pDbPage->pgno = iFreePage);
  if (((eType == 5) || (eType == 1))) {
    (rc = setChildPtrmaps(pDbPage));
    if ((rc != 0)) {
      return rc;
    }  
  }  
  else {
    Pgno nextOvfl =  sqlite3Get4byte(pDbPage->aData);
    if ((nextOvfl != 0)) {
      ptrmapPut(pBt, nextOvfl, 4, iFreePage, (&rc));
      if ((rc != 0)) {
        return rc;
      }  
    }  
  }
  if ((eType != 1)) {
    (rc = btreeGetPage(pBt, iPtrPage, (&pPtrPage), 0));
    if ((rc != 0)) {
      return rc;
    }  
    (rc = sqlite3PagerWrite(pPtrPage->pDbPage));
    if ((rc != 0)) {
      releasePage(pPtrPage);
      return rc;
    }  
    (rc = modifyPagePointer(pPtrPage, iDbPage, iFreePage, eType));
    releasePage(pPtrPage);
    if ((rc == 0)) {
      ptrmapPut(pBt, iFreePage, eType, iPtrPage, (&rc));
    }  
  }  
  return rc;
}
static int allocateBtreePage(BtShared * , MemPage ** , Pgno * , Pgno , u8 );
static  int incrVacuumStep(BtShared *pBt , Pgno nFin , Pgno iLastPg , int bCommit )  {
  Pgno nFreeList;
  int rc;
  ((void ) 0);
  ((void ) 0);
  if (((! (ptrmapPageno(pBt, iLastPg) == iLastPg)) && (iLastPg != ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1))))) {
    u8 eType;
    Pgno iPtrPage;
    (nFreeList = sqlite3Get4byte((&pBt->pPage1->aData[36])));
    if ((nFreeList == 0)) {
      return 101;
    }  
    (rc = ptrmapGet(pBt, iLastPg, (&eType), (&iPtrPage)));
    if ((rc != 0)) {
      return rc;
    }  
    if ((eType == 1)) {
      return sqlite3CorruptError(52865);
    }  
    if ((eType == 2)) {
      if ((bCommit == 0)) {
        Pgno iFreePg;
        MemPage *pFreePg;
        (rc = allocateBtreePage(pBt, (&pFreePg), (&iFreePg), iLastPg, 1));
        if ((rc != 0)) {
          return rc;
        }  
        ((void ) 0);
        releasePage(pFreePg);
      }  
    }  
    else {
      Pgno iFreePg;
      MemPage *pLastPg;
      u8 eMode =  0;
      Pgno iNear =  0;
      (rc = btreeGetPage(pBt, iLastPg, (&pLastPg), 0));
      if ((rc != 0)) {
        return rc;
      }  
      if ((bCommit == 0)) {
        (eMode = 2);
        (iNear = nFin);
      }  
      do {
        MemPage *pFreePg;
        (rc = allocateBtreePage(pBt, (&pFreePg), (&iFreePg), iNear, eMode));
        if ((rc != 0)) {
          releasePage(pLastPg);
          return rc;
        }  
        releasePage(pFreePg);
      } while ((bCommit && (iFreePg > nFin)));
      ((void ) 0);
      (rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, bCommit));
      releasePage(pLastPg);
      if ((rc != 0)) {
        return rc;
      }  
    }
  }  
  if ((bCommit == 0)) {
    do {
      iLastPg--;
    } while (((iLastPg == ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1))) || (ptrmapPageno(pBt, iLastPg) == iLastPg)));
    (pBt->_1312_bDoTruncate = 1);
    (pBt->nPage = iLastPg);
  }  
  return 0;
}
static  Pgno finalDbSize(BtShared *pBt , Pgno nOrig , Pgno nFree )  {
  int nEntry;
  Pgno nPtrmap;
  Pgno nFin;
  (nEntry = (pBt->usableSize / 5));
  (nPtrmap = ((nFree - nOrig + ptrmapPageno(pBt, nOrig) + nEntry) / nEntry));
  (nFin = (nOrig - nFree - nPtrmap));
  if (((nOrig > ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1))) && (nFin < ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1))))) {
    nFin--;
  }  
  while (((ptrmapPageno(pBt, nFin) == nFin) || (nFin == ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1))))) {
    nFin--;
  }
  return nFin;
}
static  int sqlite3BtreeIncrVacuum(Btree *p )  {
  int rc;
  BtShared *pBt =  p->pBt;
  sqlite3BtreeEnter(p);
  ((void ) 0);
  if ((! pBt->_1312_autoVacuum)) {
    (rc = 101);
  }  
  else {
    Pgno nOrig =  btreePagecount(pBt);
    Pgno nFree =  sqlite3Get4byte((&pBt->pPage1->aData[36]));
    Pgno nFin =  finalDbSize(pBt, nOrig, nFree);
    if ((nOrig < nFin)) {
      (rc = sqlite3CorruptError(52980));
    } 
    else if ((nFree > 0)) {
      (rc = saveAllCursors(pBt, 0, 0));
      if ((rc == 0)) {
        invalidateAllOverflowCache(pBt);
        (rc = incrVacuumStep(pBt, nFin, nOrig, 0));
      }  
      if ((rc == 0)) {
        (rc = sqlite3PagerWrite(pBt->pPage1->pDbPage));
        sqlite3Put4byte((&pBt->pPage1->aData[28]), pBt->nPage);
      }  
    } 
    else {
      (rc = 101);
    }
  }
  return rc;
}
static  int autoVacuumCommit(BtShared *pBt )  {
  int rc =  0;
  Pager *pPager =  pBt->pPager;
  ((void ) 0);
  invalidateAllOverflowCache(pBt);
  ((void ) 0);
  if ((! pBt->_1312_incrVacuum)) {
    Pgno nFin;
    Pgno nFree;
    Pgno iFree;
    Pgno nOrig;
    (nOrig = btreePagecount(pBt));
    if (((ptrmapPageno(pBt, nOrig) == nOrig) || (nOrig == ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1))))) {
      return sqlite3CorruptError(53028);
    }  
    (nFree = sqlite3Get4byte((&pBt->pPage1->aData[36])));
    (nFin = finalDbSize(pBt, nOrig, nFree));
    if ((nFin > nOrig)) {
      return sqlite3CorruptError(53033);
    }  
    if ((nFin < nOrig)) {
      (rc = saveAllCursors(pBt, 0, 0));
    }  
    for ((iFree = nOrig); ((iFree > nFin) && (rc == 0)); iFree--) {
      (rc = incrVacuumStep(pBt, nFin, iFree, 1));
    }
    if ((((rc == 101) || (rc == 0)) && (nFree > 0))) {
      (rc = sqlite3PagerWrite(pBt->pPage1->pDbPage));
      sqlite3Put4byte((&pBt->pPage1->aData[32]), 0);
      sqlite3Put4byte((&pBt->pPage1->aData[36]), 0);
      sqlite3Put4byte((&pBt->pPage1->aData[28]), nFin);
      (pBt->_1312_bDoTruncate = 1);
      (pBt->nPage = nFin);
    }  
    if ((rc != 0)) {
      sqlite3PagerRollback(pPager);
    }  
  }  
  ((void ) 0);
  return rc;
}
static  int sqlite3BtreeCommitPhaseOne(Btree *p , const  char *zMaster )  {
  int rc =  0;
  if ((p->inTrans == 2)) {
    BtShared *pBt =  p->pBt;
    sqlite3BtreeEnter(p);
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if (pBt->_1312_autoVacuum) {
        (rc = autoVacuumCommit(pBt));
        if ((rc != 0)) {
          return rc;
        }  
      }  
    }  
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if (pBt->_1312_bDoTruncate) {
        sqlite3PagerTruncateImage(pBt->pPager, pBt->nPage);
      }  
    }  
    (rc = sqlite3PagerCommitPhaseOne(pBt->pPager, zMaster, 0));
  }  
  return rc;
}
static  void btreeEndTransaction(Btree *p )  {
  BtShared *pBt =  p->pBt;
  sqlite3 *db =  p->db;
  ((void ) 0);
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    (pBt->_1312_bDoTruncate = 0);
  }  
  if (((p->inTrans > 0) && (db->nVdbeRead > 1))) {
    downgradeAllSharedCacheTableLocks(p);
    (p->inTrans = 1);
  }  
  else {
    if ((p->inTrans != 0)) {
      clearAllSharedCacheTableLocks(p);
      pBt->nTransaction--;
      if ((0 == pBt->nTransaction)) {
        (pBt->inTransaction = 0);
      }  
    }  
    (p->inTrans = 0);
    unlockBtreeIfUnused(pBt);
  }
  ((void ) 0);
  ((void ) 0);
}
static  int sqlite3BtreeCommitPhaseTwo(Btree *p , int bCleanup )  {
  if ((p->inTrans == 0)) {
    return 0;
  }  
  sqlite3BtreeEnter(p);
  ((void ) 0);
  ((void ) 0);
  if ((p->inTrans == 2)) {
    int rc;
    BtShared *pBt =  p->pBt;
    ((void ) 0);
    ((void ) 0);
    (rc = sqlite3PagerCommitPhaseTwo(pBt->pPager));
    if (((rc != 0) && (bCleanup == 0))) {
      return rc;
    }  
    (pBt->inTransaction = 1);
    btreeClearHasContent(pBt);
  }  
  btreeEndTransaction(p);
  return 0;
}
static  int sqlite3BtreeCommit(Btree *p )  {
  int rc;
  sqlite3BtreeEnter(p);
  (rc = sqlite3BtreeCommitPhaseOne(p, 0));
  if ((rc == 0)) {
    (rc = sqlite3BtreeCommitPhaseTwo(p, 0));
  }  
  return rc;
}
static  void sqlite3BtreeTripAllCursors(Btree *pBtree , int errCode )  {
  BtCursor *p;
  if ((pBtree == 0)) {
    return;
  }  
  sqlite3BtreeEnter(pBtree);
  for ((p = pBtree->pBt->pCursor); p; (p = p->pNext)) {
    int i;
    sqlite3BtreeClearCursor(p);
    (p->eState = 4);
    (p->skipNext = errCode);
    for ((i = 0); (i <= p->iPage); i++) {
      releasePage(p->apPage[i]);
      (p->apPage[i] = 0);
    }
  }
}
static  int sqlite3BtreeRollback(Btree *p , int tripCode )  {
  int rc;
  BtShared *pBt =  p->pBt;
  MemPage *pPage1;
  sqlite3BtreeEnter(p);
  if ((tripCode == 0)) {
    (rc = (tripCode = saveAllCursors(pBt, 0, 0)));
  }  
  else {
    (rc = 0);
  }
  if (tripCode) {
    sqlite3BtreeTripAllCursors(p, tripCode);
  }  
  ((void ) 0);
  ((void ) 0);
  if ((p->inTrans == 2)) {
    int rc2;
    ((void ) 0);
    (rc2 = sqlite3PagerRollback(pBt->pPager));
    if ((rc2 != 0)) {
      (rc = rc2);
    }  
    if ((btreeGetPage(pBt, 1, (&pPage1), 0) == 0)) {
      int nPage =  sqlite3Get4byte((28 + ((u8 *) pPage1->aData)));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((nPage == 0)) {
          sqlite3Coverage(53291);
        }  
      }  
      if ((nPage == 0)) {
        sqlite3PagerPagecount(pBt->pPager, (&nPage));
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pBt->nPage != nPage)) {
          sqlite3Coverage(53293);
        }  
      }  
      (pBt->nPage = nPage);
      releasePage(pPage1);
    }  
    ((void ) 0);
    (pBt->inTransaction = 1);
    btreeClearHasContent(pBt);
  }  
  btreeEndTransaction(p);
  return rc;
}
static  int sqlite3BtreeBeginStmt(Btree *p , int iStatement )  {
  int rc;
  BtShared *pBt =  p->pBt;
  sqlite3BtreeEnter(p);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (rc = sqlite3PagerOpenSavepoint(pBt->pPager, iStatement));
  return rc;
}
static  int sqlite3BtreeSavepoint(Btree *p , int op , int iSavepoint )  {
  int rc =  0;
  if ((p && (p->inTrans == 2))) {
    BtShared *pBt =  p->pBt;
    ((void ) 0);
    ((void ) 0);
    sqlite3BtreeEnter(p);
    (rc = sqlite3PagerSavepoint(pBt->pPager, op, iSavepoint));
    if ((rc == 0)) {
      if (((iSavepoint < 0) && ((pBt->btsFlags & 0x0008) != 0))) {
        (pBt->nPage = 0);
      }  
      (rc = newDatabase(pBt));
      (pBt->nPage = sqlite3Get4byte((28 + pBt->pPage1->aData)));
      ((void ) 0);
    }  
  }  
  return rc;
}
static  int btreeCursor(Btree *p , int iTable , int wrFlag , struct  KeyInfo   *pKeyInfo , BtCursor *pCur )  {
  BtShared *pBt =  p->pBt;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return 8;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((wrFlag && ((pBt->btsFlags & 0x0001) != 0))) {
      return 8;
    }  
  }  
  if (((iTable == 1) && (btreePagecount(pBt) == 0))) {
    ((void ) 0);
    (iTable = 0);
  }  
  (pCur->pgnoRoot = ((Pgno ) iTable));
  (pCur->iPage = (- 1));
  (pCur->pKeyInfo = pKeyInfo);
  (pCur->pBtree = p);
  (pCur->pBt = pBt);
  (pCur->wrFlag = ((u8 ) wrFlag));
  (pCur->pNext = pBt->pCursor);
  if (pCur->pNext) {
    (pCur->pNext->pPrev = pCur);
  }  
  (pBt->pCursor = pCur);
  (pCur->eState = 0);
  (pCur->cachedRowid = 0);
  return 0;
}
static  int sqlite3BtreeCursor(Btree *p , int iTable , int wrFlag , struct  KeyInfo   *pKeyInfo , BtCursor *pCur )  {
  int rc;
  sqlite3BtreeEnter(p);
  (rc = btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur));
  return rc;
}
static  int sqlite3BtreeCursorSize(void )  {
  return ((sizeof(BtCursor ) + 7) & (~ 7));
}
static  void sqlite3BtreeCursorZero(BtCursor *p )  {
  memset(p, 0, __builtin_offsetof(BtCursor , iPage));
}
static  void sqlite3BtreeSetCachedRowid(BtCursor *pCur , sqlite3_int64 iRowid )  {
  BtCursor *p;
  for ((p = pCur->pBt->pCursor); p; (p = p->pNext)) {
    if ((p->pgnoRoot == pCur->pgnoRoot)) {
      (p->cachedRowid = iRowid);
    }  
  }
  ((void ) 0);
}
static  sqlite3_int64 sqlite3BtreeGetCachedRowid(BtCursor *pCur )  {
  return pCur->cachedRowid;
}
static  int sqlite3BtreeCloseCursor(BtCursor *pCur )  {
  Btree *pBtree =  pCur->pBtree;
  if (pBtree) {
    int i;
    BtShared *pBt =  pCur->pBt;
    sqlite3BtreeEnter(pBtree);
    sqlite3BtreeClearCursor(pCur);
    if (pCur->pPrev) {
      (pCur->pPrev->pNext = pCur->pNext);
    }  
    else {
      (pBt->pCursor = pCur->pNext);
    }
    if (pCur->pNext) {
      (pCur->pNext->pPrev = pCur->pPrev);
    }  
    for ((i = 0); (i <= pCur->iPage); i++) {
      releasePage(pCur->apPage[i]);
    }
    unlockBtreeIfUnused(pBt);
    invalidateOverflowCache(pCur);
  }  
  return 0;
}
static  int sqlite3BtreeKeySize(BtCursor *pCur , i64 *pSize )  {
  ((void ) 0);
  ((void ) 0);
  if ((pCur->eState != 1)) {
    ((*pSize) = 0);
  }  
  else {
    if ((pCur->info.nSize == 0)) {
      int iPage =  pCur->iPage;
      btreeParseCell(pCur->apPage[iPage], pCur->aiIdx[iPage], (&pCur->info));
      (pCur->validNKey = 1);
    }  
    else {
      
    }
    ((*pSize) = pCur->info.nKey);
  }
  return 0;
}
static  int sqlite3BtreeDataSize(BtCursor *pCur , u32 *pSize )  {
  ((void ) 0);
  ((void ) 0);
  if ((pCur->info.nSize == 0)) {
    int iPage =  pCur->iPage;
    btreeParseCell(pCur->apPage[iPage], pCur->aiIdx[iPage], (&pCur->info));
    (pCur->validNKey = 1);
  }  
  else {
    
  }
  ((*pSize) = pCur->info.nData);
  return 0;
}
static  int getOverflowPage(BtShared *pBt , Pgno ovfl , MemPage **ppPage , Pgno *pPgnoNext )  {
  Pgno next =  0;
  MemPage *pPage =  0;
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    if (pBt->_1312_autoVacuum) {
      Pgno pgno;
      Pgno iGuess =  (ovfl + 1);
      u8 eType;
      while (((ptrmapPageno(pBt, iGuess) == iGuess) || (iGuess == ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1))))) {
        iGuess++;
      }
      if ((iGuess <= btreePagecount(pBt))) {
        (rc = ptrmapGet(pBt, iGuess, (&eType), (&pgno)));
        if (((rc == 0) && (eType == 4) && (pgno == ovfl))) {
          (next = iGuess);
          (rc = 101);
        }  
      }  
    }  
  }  
  ((void ) 0);
  if ((rc == 0)) {
    (rc = btreeGetPage(pBt, ovfl, (&pPage), ((ppPage == 0) ? 0x02 : 0)));
    ((void ) 0);
    if ((rc == 0)) {
      (next = sqlite3Get4byte(pPage->aData));
    }  
  }  
  ((*pPgnoNext) = next);
  if (ppPage) {
    ((*ppPage) = pPage);
  }  
  else {
    releasePage(pPage);
  }
  return ((rc == 101) ? 0 : rc);
}
static  int copyPayload(void *pPayload , void *pBuf , int nByte , int eOp , DbPage *pDbPage )  {
  if (eOp) {
    int rc =  sqlite3PagerWrite(pDbPage);
    if ((rc != 0)) {
      return rc;
    }  
    memcpy(pPayload, pBuf, nByte);
  }  
  else {
    memcpy(pBuf, pPayload, nByte);
  }
  return 0;
}
static  int accessPayload(BtCursor *pCur , u32 offset , u32 amt , unsigned  char *pBuf , int eOp )  {
  unsigned char *aPayload;
  int rc =  0;
  u32 nKey;
  int iIdx =  0;
  MemPage *pPage =  pCur->apPage[pCur->iPage];
  BtShared *pBt =  pCur->pBt;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pCur->info.nSize == 0)) {
    int iPage =  pCur->iPage;
    btreeParseCell(pCur->apPage[iPage], pCur->aiIdx[iPage], (&pCur->info));
    (pCur->validNKey = 1);
  }  
  else {
    
  }
  (aPayload = (pCur->info.pCell + pCur->info.nHeader));
  (nKey = (pPage->intKey ? 0 : ((int ) pCur->info.nKey)));
  if (((id2i_sqlite_coverage_test ) )) {
    if ((0 || ((&aPayload[pCur->info.nLocal]) > (&pPage->aData[pBt->usableSize])))) {
      return sqlite3CorruptError(53827);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((((offset + amt) > (nKey + pCur->info.nData)) || ((&aPayload[pCur->info.nLocal]) > (&pPage->aData[pBt->usableSize])))) {
      return sqlite3CorruptError(53827);
    }  
  }  
  if ((offset < pCur->info.nLocal)) {
    int a =  amt;
    if (((a + offset) > pCur->info.nLocal)) {
      (a = (pCur->info.nLocal - offset));
    }  
    (rc = copyPayload((&aPayload[offset]), pBuf, a, eOp, pPage->pDbPage));
    (offset = 0);
    (pBuf += a);
    (amt -= a);
  }  
  else {
    (offset -= pCur->info.nLocal);
  }
  if (((rc == 0) && (amt > 0))) {
    const u32 ovflSize =  (pBt->usableSize - 4);
    Pgno nextPage;
    (nextPage = sqlite3Get4byte((&aPayload[pCur->info.nLocal])));
    if ((pCur->isIncrblobHandle && (! pCur->aOverflow))) {
      int nOvfl =  ((pCur->info.nPayload - pCur->info.nLocal + ovflSize - 1) / ovflSize);
      (pCur->aOverflow = ((Pgno *) sqlite3MallocZero((sizeof(Pgno ) * nOvfl))));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((1 && (! pCur->aOverflow))) {
          (rc = 7);
        }  
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if ((nOvfl && (! pCur->aOverflow))) {
          (rc = 7);
        }  
      }  
    }  
    if ((pCur->aOverflow && pCur->aOverflow[(offset / ovflSize)])) {
      (iIdx = (offset / ovflSize));
      (nextPage = pCur->aOverflow[iIdx]);
      (offset = (offset % ovflSize));
    }  
    for (; ((rc == 0) && (amt > 0) && nextPage); iIdx++) {
      if (pCur->aOverflow) {
        ((void ) 0);
        (pCur->aOverflow[iIdx] = nextPage);
      }  
      if ((offset >= ovflSize)) {
        if ((pCur->aOverflow && pCur->aOverflow[(iIdx + 1)])) {
          (nextPage = pCur->aOverflow[(iIdx + 1)]);
        }  
        else {
          (rc = getOverflowPage(pBt, nextPage, 0, (&nextPage)));
        }
        (offset -= ovflSize);
      }  
      else {
        int a =  amt;
        if (((a + offset) > ovflSize)) {
          (a = (ovflSize - offset));
        }  
        {
          DbPage *pDbPage;
          (rc = sqlite3PagerAcquire(pBt->pPager, nextPage, (&pDbPage), ((eOp == 0) ? 0x02 : 0)));
          if ((rc == 0)) {
            (aPayload = sqlite3PagerGetData(pDbPage));
            (nextPage = sqlite3Get4byte(aPayload));
            (rc = copyPayload((&aPayload[(offset + 4)]), pBuf, a, eOp, pDbPage));
            sqlite3PagerUnref(pDbPage);
            (offset = 0);
          }  
        }
        (amt -= a);
        (pBuf += a);
      }
    }
  }  
  if (((rc == 0) && (amt > 0))) {
    return sqlite3CorruptError(53963);
  }  
  return rc;
}
static  int sqlite3BtreeKey(BtCursor *pCur , u32 offset , u32 amt , void *pBuf )  {
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  return accessPayload(pCur, offset, amt, ((unsigned  char *) pBuf), 0);
}
static  int sqlite3BtreeData(BtCursor *pCur , u32 offset , u32 amt , void *pBuf )  {
  int rc;
  if ((pCur->eState == 0)) {
    return 4;
  }  
  ((void ) 0);
  (rc = ((pCur->eState >= 3) ? btreeRestoreCursorPosition(pCur) : 0));
  if ((rc == 0)) {
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    (rc = accessPayload(pCur, offset, amt, pBuf, 0));
  }  
  return rc;
}
static  const  unsigned  char *fetchPayload(BtCursor *pCur , int *pAmt , int skipKey )  {
  unsigned char *aPayload;
  MemPage *pPage;
  u32 nKey;
  u32 nLocal;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (pPage = pCur->apPage[pCur->iPage]);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      btreeParseCell(pCur->apPage[pCur->iPage], pCur->aiIdx[pCur->iPage], (&pCur->info));
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pCur->info.nSize == 0)) {
      btreeParseCell(pCur->apPage[pCur->iPage], pCur->aiIdx[pCur->iPage], (&pCur->info));
    }  
  }  
  (aPayload = pCur->info.pCell);
  (aPayload += pCur->info.nHeader);
  if (pPage->intKey) {
    (nKey = 0);
  }  
  else {
    (nKey = ((int ) pCur->info.nKey));
  }
  if (skipKey) {
    (aPayload += nKey);
    (nLocal = (pCur->info.nLocal - nKey));
  }  
  else {
    (nLocal = pCur->info.nLocal);
    ((void ) 0);
  }
  ((*pAmt) = nLocal);
  return aPayload;
}
static  const  void *sqlite3BtreeKeyFetch(BtCursor *pCur , int *pAmt )  {
  const void *p =  0;
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      (p = ((const  void *) fetchPayload(pCur, pAmt, 0)));
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pCur->eState == 1)) {
      (p = ((const  void *) fetchPayload(pCur, pAmt, 0)));
    }  
  }  
  return p;
}
static  const  void *sqlite3BtreeDataFetch(BtCursor *pCur , int *pAmt )  {
  const void *p =  0;
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      (p = ((const  void *) fetchPayload(pCur, pAmt, 1)));
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pCur->eState == 1)) {
      (p = ((const  void *) fetchPayload(pCur, pAmt, 1)));
    }  
  }  
  return p;
}
static  int moveToChild(BtCursor *pCur , u32 newPgno )  {
  int rc;
  int i =  pCur->iPage;
  MemPage *pNewPage;
  BtShared *pBt =  pCur->pBt;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pCur->iPage >= (20 - 1))) {
    return sqlite3CorruptError(54128);
  }  
  (rc = getAndInitPage(pBt, newPgno, (&pNewPage), ((pCur->wrFlag == 0) ? 0x02 : 0)));
  if (rc) {
    return rc;
  }  
  (pCur->apPage[(i + 1)] = pNewPage);
  (pCur->aiIdx[(i + 1)] = 0);
  pCur->iPage++;
  (pCur->info.nSize = 0);
  (pCur->validNKey = 0);
  if (((pNewPage->nCell < 1) || (pNewPage->intKey != pCur->apPage[i]->intKey))) {
    return sqlite3CorruptError(54140);
  }  
  return 0;
}
static  void moveToParent(BtCursor *pCur )  {
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pCur->aiIdx[(pCur->iPage - 1)] > pCur->apPage[(pCur->iPage - 1)]->nCell)) {
      sqlite3Coverage(54191);
    }  
  }  
  releasePage(pCur->apPage[pCur->iPage]);
  pCur->iPage--;
  (pCur->info.nSize = 0);
  (pCur->validNKey = 0);
}
static  int moveToRoot(BtCursor *pCur )  {
  MemPage *pRoot;
  int rc =  0;
  Btree *p =  pCur->pBtree;
  BtShared *pBt =  p->pBt;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pCur->eState >= 3)) {
    if ((pCur->eState == 4)) {
      ((void ) 0);
      return pCur->skipNext;
    }  
    sqlite3BtreeClearCursor(pCur);
  }  
  if ((pCur->iPage >= 0)) {
    int i;
    for ((i = 1); (i <= pCur->iPage); i++) {
      releasePage(pCur->apPage[i]);
    }
    (pCur->iPage = 0);
  } 
  else if ((pCur->pgnoRoot == 0)) {
    (pCur->eState = 0);
    return 0;
  } 
  else {
    (rc = getAndInitPage(pBt, pCur->pgnoRoot, (&pCur->apPage[0]), ((pCur->wrFlag == 0) ? 0x02 : 0)));
    if ((rc != 0)) {
      (pCur->eState = 0);
      return rc;
    }  
    (pCur->iPage = 0);
    ((void ) 0);
    if (((pCur->pKeyInfo == 0) != pCur->apPage[0]->intKey)) {
      return sqlite3CorruptError(54262);
    }  
  }
  (pRoot = pCur->apPage[0]);
  ((void ) 0);
  ((void ) 0);
  (pCur->aiIdx[0] = 0);
  (pCur->info.nSize = 0);
  (pCur->atLast = 0);
  (pCur->validNKey = 0);
  if (((pRoot->nCell == 0) && (! pRoot->leaf))) {
    Pgno subpage;
    if ((pRoot->pgno != 1)) {
      return sqlite3CorruptError(54283);
    }  
    (subpage = sqlite3Get4byte((&pRoot->aData[(pRoot->hdrOffset + 8)])));
    (pCur->eState = 1);
    (rc = moveToChild(pCur, subpage));
  }  
  else {
    (pCur->eState = ((pRoot->nCell > 0) ? 1 : 0));
  }
  return rc;
}
static  int moveToLeftmost(BtCursor *pCur )  {
  Pgno pgno;
  int rc =  0;
  MemPage *pPage;
  ((void ) 0);
  ((void ) 0);
  while (((rc == 0) && (! (pPage = pCur->apPage[pCur->iPage])->leaf))) {
    ((void ) 0);
    (pgno = sqlite3Get4byte((pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * pCur->aiIdx[pCur->iPage])])[0] << 8) | (&pPage->aCellIdx[(2 * pCur->aiIdx[pCur->iPage])])[1])))));
    (rc = moveToChild(pCur, pgno));
  }
  return rc;
}
static  int moveToRightmost(BtCursor *pCur )  {
  Pgno pgno;
  int rc =  0;
  MemPage *pPage =  0;
  ((void ) 0);
  ((void ) 0);
  while (((rc == 0) && (! (pPage = pCur->apPage[pCur->iPage])->leaf))) {
    (pgno = sqlite3Get4byte((&pPage->aData[(pPage->hdrOffset + 8)])));
    (pCur->aiIdx[pCur->iPage] = pPage->nCell);
    (rc = moveToChild(pCur, pgno));
  }
  if ((rc == 0)) {
    (pCur->aiIdx[pCur->iPage] = (pPage->nCell - 1));
    (pCur->info.nSize = 0);
    (pCur->validNKey = 0);
  }  
  return rc;
}
static  int sqlite3BtreeFirst(BtCursor *pCur , int *pRes )  {
  int rc;
  ((void ) 0);
  ((void ) 0);
  (rc = moveToRoot(pCur));
  if ((rc == 0)) {
    if ((pCur->eState == 0)) {
      ((void ) 0);
      ((*pRes) = 1);
    }  
    else {
      ((void ) 0);
      ((*pRes) = 0);
      (rc = moveToLeftmost(pCur));
    }
  }  
  return rc;
}
static  int sqlite3BtreeLast(BtCursor *pCur , int *pRes )  {
  int rc;
  ((void ) 0);
  ((void ) 0);
  if (((1 == pCur->eState) && pCur->atLast)) {
    return 0;
  }  
  (rc = moveToRoot(pCur));
  if ((rc == 0)) {
    if ((0 == pCur->eState)) {
      ((void ) 0);
      ((*pRes) = 1);
    }  
    else {
      ((void ) 0);
      ((*pRes) = 0);
      (rc = moveToRightmost(pCur));
      (pCur->atLast = ((rc == 0) ? 1 : 0));
    }
  }  
  return rc;
}
static  int sqlite3BtreeMovetoUnpacked(BtCursor *pCur , UnpackedRecord *pIdxKey , i64 intKey , int biasRight , int *pRes )  {
  int rc;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((pCur->eState == 1) && pCur->validNKey && pCur->apPage[0]->intKey)) {
    if ((pCur->info.nKey == intKey)) {
      ((*pRes) = 0);
      return 0;
    }  
    if ((pCur->atLast && (pCur->info.nKey < intKey))) {
      ((*pRes) = (- 1));
      return 0;
    }  
  }  
  (rc = moveToRoot(pCur));
  if (rc) {
    return rc;
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pCur->eState == 0)) {
    ((*pRes) = (- 1));
    ((void ) 0);
    return 0;
  }  
  ((void ) 0);
  for (; ; ) {
    int lwr, upr, idx;
    Pgno chldPg;
    MemPage *pPage =  pCur->apPage[pCur->iPage];
    int c;
    ((void ) 0);
    ((void ) 0);
    (lwr = 0);
    (upr = (pPage->nCell - 1));
    if (biasRight) {
      (pCur->aiIdx[pCur->iPage] = ((u16 ) (idx = upr)));
    }  
    else {
      (pCur->aiIdx[pCur->iPage] = ((u16 ) (idx = ((upr + lwr) / 2))));
    }
    for (; ; ) {
      u8 *pCell;
      ((void ) 0);
      (pCur->info.nSize = 0);
      (pCell = ((pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * idx)])[0] << 8) | (&pPage->aCellIdx[(2 * idx)])[1]))) + pPage->childPtrSize));
      if (pPage->intKey) {
        i64 nCellKey;
        if (pPage->hasData) {
          u32 dummy;
          (pCell += ((u8 ) (((*pCell) < ((u8 ) 0x80)) ? (dummy = ((u32 ) (*pCell))), 1 : sqlite3GetVarint32(pCell, ((u32 *) (&dummy))))));
        }  
        sqlite3GetVarint(pCell, ((u64 *) (&nCellKey)));
        if ((nCellKey == intKey)) {
          (c = 0);
        } 
        else if ((nCellKey < intKey)) {
          (c = (- 1));
        } 
        else {
          ((void ) 0);
          (c = (+ 1));
        }
        (pCur->validNKey = 1);
        (pCur->info.nKey = nCellKey);
      }  
      else {
        int nCell =  pCell[0];
        if ((nCell <= pPage->max1bytePayload)) {
          if (((id2i_sqlite_coverage_test ) )) {
            if (((pCell + nCell + 1) == pPage->aDataEnd)) {
              sqlite3Coverage(54538);
            }  
          }  
          (c = sqlite3VdbeRecordCompare(nCell, ((void *) (&pCell[1])), pIdxKey));
        } 
        else if (((! (pCell[1] & 0x80)) && ((nCell = (((nCell & 0x7f) << 7) + pCell[1])) <= pPage->maxLocal))) {
          if (((id2i_sqlite_coverage_test ) )) {
            if (((pCell + nCell + 2) == pPage->aDataEnd)) {
              sqlite3Coverage(54546);
            }  
          }  
          (c = sqlite3VdbeRecordCompare(nCell, ((void *) (&pCell[2])), pIdxKey));
        } 
        else {
          void *pCellKey;
          u8 *const pCellBody =  (pCell - pPage->childPtrSize);
          btreeParseCellPtr(pPage, pCellBody, (&pCur->info));
          (nCell = ((int ) pCur->info.nKey));
          (pCellKey = sqlite3Malloc(nCell));
          if ((pCellKey == 0)) {
            (rc = 7);
            goto moveto_finish;
          }  
          (rc = accessPayload(pCur, 0, nCell, ((unsigned  char *) pCellKey), 0));
          if (rc) {
            sqlite3_free(pCellKey);
            goto moveto_finish;
          }  
          (c = sqlite3VdbeRecordCompare(nCell, pCellKey, pIdxKey));
          sqlite3_free(pCellKey);
        }
      }
      if ((c == 0)) {
        if ((pPage->intKey && (! pPage->leaf))) {
          (lwr = idx);
          break;
        }  
        else {
          ((*pRes) = 0);
          (rc = 0);
          goto moveto_finish;
        }
      }  
      if ((c < 0)) {
        (lwr = (idx + 1));
      }  
      else {
        (upr = (idx - 1));
      }
      if ((lwr > upr)) {
        break;
      }  
      (pCur->aiIdx[pCur->iPage] = ((u16 ) (idx = ((lwr + upr) / 2))));
    }
    ((void ) 0);
    ((void ) 0);
    if (pPage->leaf) {
      (chldPg = 0);
    } 
    else if ((lwr >= pPage->nCell)) {
      (chldPg = sqlite3Get4byte((&pPage->aData[(pPage->hdrOffset + 8)])));
    } 
    else {
      (chldPg = sqlite3Get4byte((pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * lwr)])[0] << 8) | (&pPage->aCellIdx[(2 * lwr)])[1])))));
    }
    if ((chldPg == 0)) {
      ((void ) 0);
      ((*pRes) = c);
      (rc = 0);
      goto moveto_finish;
    }  
    (pCur->aiIdx[pCur->iPage] = ((u16 ) lwr));
    (pCur->info.nSize = 0);
    (pCur->validNKey = 0);
    (rc = moveToChild(pCur, chldPg));
    if (rc) {
      goto moveto_finish;
    }  
  }
  moveto_finish:
  return rc;
}
static  int sqlite3BtreeEof(BtCursor *pCur )  {
  return (1 != pCur->eState);
}
static  int sqlite3BtreeNext(BtCursor *pCur , int *pRes )  {
  int rc;
  int idx;
  MemPage *pPage;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pCur->eState != 1)) {
    (rc = ((pCur->eState >= 3) ? btreeRestoreCursorPosition(pCur) : 0));
    if ((rc != 0)) {
      ((*pRes) = 0);
      return rc;
    }  
    if ((0 == pCur->eState)) {
      ((*pRes) = 1);
      return 0;
    }  
    if (pCur->skipNext) {
      ((void ) 0);
      (pCur->eState = 1);
      if ((pCur->skipNext > 0)) {
        (pCur->skipNext = 0);
        ((*pRes) = 0);
        return 0;
      }  
      (pCur->skipNext = 0);
    }  
  }  
  (pPage = pCur->apPage[pCur->iPage]);
  (idx = ++pCur->aiIdx[pCur->iPage]);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((idx > pPage->nCell)) {
      sqlite3Coverage(54677);
    }  
  }  
  (pCur->info.nSize = 0);
  (pCur->validNKey = 0);
  if ((idx >= pPage->nCell)) {
    if ((! pPage->leaf)) {
      (rc = moveToChild(pCur, sqlite3Get4byte((&pPage->aData[(pPage->hdrOffset + 8)]))));
      if (rc) {
        ((*pRes) = 0);
        return rc;
      }  
      (rc = moveToLeftmost(pCur));
      ((*pRes) = 0);
      return rc;
    }  
    do {
      if ((pCur->iPage == 0)) {
        ((*pRes) = 1);
        (pCur->eState = 0);
        return 0;
      }  
      moveToParent(pCur);
      (pPage = pCur->apPage[pCur->iPage]);
    } while ((pCur->aiIdx[pCur->iPage] >= pPage->nCell));
    ((*pRes) = 0);
    if (pPage->intKey) {
      (rc = sqlite3BtreeNext(pCur, pRes));
    }  
    else {
      (rc = 0);
    }
    return rc;
  }  
  ((*pRes) = 0);
  if (pPage->leaf) {
    return 0;
  }  
  (rc = moveToLeftmost(pCur));
  return rc;
}
static  int sqlite3BtreePrevious(BtCursor *pCur , int *pRes )  {
  int rc;
  MemPage *pPage;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (pCur->atLast = 0);
  if ((pCur->eState != 1)) {
    if (((id2i_sqlite_coverage_test ) )) {
      if (1) {
        (rc = btreeRestoreCursorPosition(pCur));
        if ((rc != 0)) {
          ((*pRes) = 0);
          return rc;
        }  
      }  
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      if ((pCur->eState >= 3)) {
        (rc = btreeRestoreCursorPosition(pCur));
        if ((rc != 0)) {
          ((*pRes) = 0);
          return rc;
        }  
      }  
    }  
    if ((0 == pCur->eState)) {
      ((*pRes) = 1);
      return 0;
    }  
    if (pCur->skipNext) {
      ((void ) 0);
      (pCur->eState = 1);
      if ((pCur->skipNext < 0)) {
        (pCur->skipNext = 0);
        ((*pRes) = 0);
        return 0;
      }  
      (pCur->skipNext = 0);
    }  
  }  
  (pPage = pCur->apPage[pCur->iPage]);
  ((void ) 0);
  if ((! pPage->leaf)) {
    int idx =  pCur->aiIdx[pCur->iPage];
    (rc = moveToChild(pCur, sqlite3Get4byte((pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * idx)])[0] << 8) | (&pPage->aCellIdx[(2 * idx)])[1]))))));
    if (rc) {
      ((*pRes) = 0);
      return rc;
    }  
    (rc = moveToRightmost(pCur));
  }  
  else {
    while ((pCur->aiIdx[pCur->iPage] == 0)) {
      if ((pCur->iPage == 0)) {
        (pCur->eState = 0);
        ((*pRes) = 1);
        return 0;
      }  
      moveToParent(pCur);
    }
    (pCur->info.nSize = 0);
    (pCur->validNKey = 0);
    pCur->aiIdx[pCur->iPage]--;
    (pPage = pCur->apPage[pCur->iPage]);
    if ((pPage->intKey && (! pPage->leaf))) {
      (rc = sqlite3BtreePrevious(pCur, pRes));
    }  
    else {
      (rc = 0);
    }
  }
  ((*pRes) = 0);
  return rc;
}
static  int allocateBtreePage(BtShared *pBt , MemPage **ppPage , Pgno *pPgno , Pgno nearby , u8 eMode )  {
  MemPage *pPage1;
  int rc;
  u32 n;
  u32 k;
  MemPage *pTrunk =  0;
  MemPage *pPrevTrunk =  0;
  Pgno mxPage;
  ((void ) 0);
  ((void ) 0);
  (pPage1 = pBt->pPage1);
  (mxPage = btreePagecount(pBt));
  (n = sqlite3Get4byte((&pPage1->aData[36])));
  if (((id2i_sqlite_coverage_test ) )) {
    if ((n == (mxPage - 1))) {
      sqlite3Coverage(54833);
    }  
  }  
  if ((n >= mxPage)) {
    return sqlite3CorruptError(54835);
  }  
  if ((n > 0)) {
    Pgno iTrunk;
    u8 searchList =  0;
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if ((eMode == 1)) {
        if ((nearby <= mxPage)) {
          u8 eType;
          ((void ) 0);
          ((void ) 0);
          (rc = ptrmapGet(pBt, nearby, (&eType), 0));
          if (rc) {
            return rc;
          }  
          if ((eType == 2)) {
            (searchList = 1);
          }  
        }  
      } 
      else if ((eMode == 2)) {
        (searchList = 1);
      } 
    }  
    (rc = sqlite3PagerWrite(pPage1->pDbPage));
    if (rc) {
      return rc;
    }  
    sqlite3Put4byte((&pPage1->aData[36]), (n - 1));
    do {
      (pPrevTrunk = pTrunk);
      if (pPrevTrunk) {
        (iTrunk = sqlite3Get4byte((&pPrevTrunk->aData[0])));
      }  
      else {
        (iTrunk = sqlite3Get4byte((&pPage1->aData[32])));
      }
      if (((id2i_sqlite_coverage_test ) )) {
        if ((iTrunk == mxPage)) {
          sqlite3Coverage(54882);
        }  
      }  
      if ((iTrunk > mxPage)) {
        (rc = sqlite3CorruptError(54884));
      }  
      else {
        (rc = btreeGetPage(pBt, iTrunk, (&pTrunk), 0));
      }
      if (rc) {
        (pTrunk = 0);
        goto end_allocate_page;
      }  
      ((void ) 0);
      ((void ) 0);
      (k = sqlite3Get4byte((&pTrunk->aData[4])));
      if (((k == 0) && (! searchList))) {
        ((void ) 0);
        (rc = sqlite3PagerWrite(pTrunk->pDbPage));
        if (rc) {
          goto end_allocate_page;
        }  
        ((*pPgno) = iTrunk);
        memcpy((&pPage1->aData[32]), (&pTrunk->aData[0]), 4);
        ((*ppPage) = pTrunk);
        (pTrunk = 0);
      } 
      else if ((k > ((u32 ) ((pBt->usableSize / 4) - 2)))) {
        (rc = sqlite3CorruptError(54912));
        goto end_allocate_page;
      }
      
      else if (((((! id2i_sqlite_omit_autovacuum) ) ) && (searchList && ((nearby == iTrunk) || ((iTrunk < nearby) && (eMode == 2)))))) {
        ((*pPgno) = iTrunk);
        ((*ppPage) = pTrunk);
        (searchList = 0);
        (rc = sqlite3PagerWrite(pTrunk->pDbPage));
        if (rc) {
          goto end_allocate_page;
        }  
        if ((k == 0)) {
          if ((! pPrevTrunk)) {
            memcpy((&pPage1->aData[32]), (&pTrunk->aData[0]), 4);
          }  
          else {
            (rc = sqlite3PagerWrite(pPrevTrunk->pDbPage));
            if ((rc != 0)) {
              goto end_allocate_page;
            }  
            memcpy((&pPrevTrunk->aData[0]), (&pTrunk->aData[0]), 4);
          }
        }  
        else {
          MemPage *pNewTrunk;
          Pgno iNewTrunk =  sqlite3Get4byte((&pTrunk->aData[8]));
          if ((iNewTrunk > mxPage)) {
            (rc = sqlite3CorruptError(54946));
            goto end_allocate_page;
          }  
          if (((id2i_sqlite_coverage_test ) )) {
            if ((iNewTrunk == mxPage)) {
              sqlite3Coverage(54949);
            }  
          }  
          (rc = btreeGetPage(pBt, iNewTrunk, (&pNewTrunk), 0));
          if ((rc != 0)) {
            goto end_allocate_page;
          }  
          (rc = sqlite3PagerWrite(pNewTrunk->pDbPage));
          if ((rc != 0)) {
            releasePage(pNewTrunk);
            goto end_allocate_page;
          }  
          memcpy((&pNewTrunk->aData[0]), (&pTrunk->aData[0]), 4);
          sqlite3Put4byte((&pNewTrunk->aData[4]), (k - 1));
          memcpy((&pNewTrunk->aData[8]), (&pTrunk->aData[12]), ((k - 1) * 4));
          releasePage(pNewTrunk);
          if ((! pPrevTrunk)) {
            ((void ) 0);
            sqlite3Put4byte((&pPage1->aData[32]), iNewTrunk);
          }  
          else {
            (rc = sqlite3PagerWrite(pPrevTrunk->pDbPage));
            if (rc) {
              goto end_allocate_page;
            }  
            sqlite3Put4byte((&pPrevTrunk->aData[0]), iNewTrunk);
          }
        }
        (pTrunk = 0);
      }
      
      else if ((k > 0)) {
        u32 closest;
        Pgno iPage;
        unsigned char *aData =  pTrunk->aData;
        if ((nearby > 0)) {
          u32 i;
          (closest = 0);
          if ((eMode == 2)) {
            for ((i = 0); (i < k); i++) {
              (iPage = sqlite3Get4byte((&aData[(8 + (i * 4))])));
              if ((iPage <= nearby)) {
                (closest = i);
                break;
              }  
            }
          }  
          else {
            int dist;
            (dist = sqlite3AbsInt32((sqlite3Get4byte((&aData[8])) - nearby)));
            for ((i = 1); (i < k); i++) {
              int d2 =  sqlite3AbsInt32((sqlite3Get4byte((&aData[(8 + (i * 4))])) - nearby));
              if ((d2 < dist)) {
                (closest = i);
                (dist = d2);
              }  
            }
          }
        }  
        else {
          (closest = 0);
        }
        (iPage = sqlite3Get4byte((&aData[(8 + (closest * 4))])));
        if (((id2i_sqlite_coverage_test ) )) {
          if ((iPage == mxPage)) {
            sqlite3Coverage(55009);
          }  
        }  
        if ((iPage > mxPage)) {
          (rc = sqlite3CorruptError(55011));
          goto end_allocate_page;
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((iPage == mxPage)) {
            sqlite3Coverage(55014);
          }  
        }  
        if (((! searchList) || ((iPage == nearby) || ((iPage < nearby) && (eMode == 2))))) {
          int noContent;
          ((*pPgno) = iPage);
          (rc = sqlite3PagerWrite(pTrunk->pDbPage));
          if (rc) {
            goto end_allocate_page;
          }  
          if ((closest < (k - 1))) {
            memcpy((&aData[(8 + (closest * 4))]), (&aData[(4 + (k * 4))]), 4);
          }  
          sqlite3Put4byte((&aData[4]), (k - 1));
          (noContent = ((! btreeGetHasContent(pBt, (*pPgno))) ? 0x01 : 0));
          (rc = btreeGetPage(pBt, (*pPgno), ppPage, noContent));
          if ((rc == 0)) {
            (rc = sqlite3PagerWrite((*ppPage)->pDbPage));
            if ((rc != 0)) {
              releasePage((*ppPage));
            }  
          }  
          (searchList = 0);
        }  
      } 
      releasePage(pPrevTrunk);
      (pPrevTrunk = 0);
    } while (searchList);
  }  
  else {
    int bNoContent =  ((((! id2i_sqlite_omit_autovacuum) ) ) ? ((0 == pBt->_1312_bDoTruncate) ? 0x01 : 0) : ((0 == 0) ? 0x01 : 0));
    (rc = sqlite3PagerWrite(pBt->pPage1->pDbPage));
    if (rc) {
      return rc;
    }  
    pBt->nPage++;
    if ((pBt->nPage == ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1)))) {
      pBt->nPage++;
    }  
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if ((pBt->_1312_autoVacuum && (ptrmapPageno(pBt, pBt->nPage) == pBt->nPage))) {
        MemPage *pPg =  0;
        ((void ) 0);
        (rc = btreeGetPage(pBt, pBt->nPage, (&pPg), bNoContent));
        if ((rc == 0)) {
          (rc = sqlite3PagerWrite(pPg->pDbPage));
          releasePage(pPg);
        }  
        if (rc) {
          return rc;
        }  
        pBt->nPage++;
        if ((pBt->nPage == ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1)))) {
          pBt->nPage++;
        }  
      }  
    }  
    sqlite3Put4byte((28 + ((u8 *) pBt->pPage1->aData)), pBt->nPage);
    ((*pPgno) = pBt->nPage);
    ((void ) 0);
    (rc = btreeGetPage(pBt, (*pPgno), ppPage, bNoContent));
    if (rc) {
      return rc;
    }  
    (rc = sqlite3PagerWrite((*ppPage)->pDbPage));
    if ((rc != 0)) {
      releasePage((*ppPage));
    }  
  }
  ((void ) 0);
  end_allocate_page:
  releasePage(pTrunk);
  releasePage(pPrevTrunk);
  if ((rc == 0)) {
    if ((sqlite3PagerPageRefcount((*ppPage)->pDbPage) > 1)) {
      releasePage((*ppPage));
      return sqlite3CorruptError(55109);
    }  
    ((*ppPage)->isInit = 0);
  }  
  else {
    ((*ppPage) = 0);
  }
  ((void ) 0);
  return rc;
}
static  int freePage2(BtShared *pBt , MemPage *pMemPage , Pgno iPage )  {
  MemPage *pTrunk =  0;
  Pgno iTrunk =  0;
  MemPage *pPage1 =  pBt->pPage1;
  MemPage *pPage;
  int rc;
  int nFree;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (pMemPage) {
    (pPage = pMemPage);
    sqlite3PagerRef(pPage->pDbPage);
  }  
  else {
    (pPage = btreePageLookup(pBt, iPage));
  }
  (rc = sqlite3PagerWrite(pPage1->pDbPage));
  if (rc) {
    goto freepage_out;
  }  
  (nFree = sqlite3Get4byte((&pPage1->aData[36])));
  sqlite3Put4byte((&pPage1->aData[36]), (nFree + 1));
  if ((pBt->btsFlags & 0x0004)) {
    if ((((! pPage) && ((rc = btreeGetPage(pBt, iPage, (&pPage), 0)) != 0)) || ((rc = sqlite3PagerWrite(pPage->pDbPage)) != 0))) {
      goto freepage_out;
    }  
    memset(pPage->aData, 0, pPage->pBt->pageSize);
  }  
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    if (pBt->_1312_autoVacuum) {
      ptrmapPut(pBt, iPage, 2, 0, (&rc));
      if (rc) {
        goto freepage_out;
      }  
    }  
  }  
  if (((id2i_sqlite_omit_autovacuum ) )) {
    if (0) {
      if (rc) {
        goto freepage_out;
      }  
    }  
  }  
  if ((nFree != 0)) {
    u32 nLeaf;
    (iTrunk = sqlite3Get4byte((&pPage1->aData[32])));
    (rc = btreeGetPage(pBt, iTrunk, (&pTrunk), 0));
    if ((rc != 0)) {
      goto freepage_out;
    }  
    (nLeaf = sqlite3Get4byte((&pTrunk->aData[4])));
    ((void ) 0);
    if ((nLeaf > ((((u32 ) pBt->usableSize) / 4) - 2))) {
      (rc = sqlite3CorruptError(55195));
      goto freepage_out;
    }  
    if ((nLeaf < ((((u32 ) pBt->usableSize) / 4) - 8))) {
      (rc = sqlite3PagerWrite(pTrunk->pDbPage));
      if ((rc == 0)) {
        sqlite3Put4byte((&pTrunk->aData[4]), (nLeaf + 1));
        sqlite3Put4byte((&pTrunk->aData[(8 + (nLeaf * 4))]), iPage);
        if ((pPage && ((pBt->btsFlags & 0x0004) == 0))) {
          sqlite3PagerDontWrite(pPage->pDbPage);
        }  
        (rc = btreeSetHasContent(pBt, iPage));
      }  
      goto freepage_out;
    }  
  }  
  if (((pPage == 0) && (0 != (rc = btreeGetPage(pBt, iPage, (&pPage), 0))))) {
    goto freepage_out;
  }  
  (rc = sqlite3PagerWrite(pPage->pDbPage));
  if ((rc != 0)) {
    goto freepage_out;
  }  
  sqlite3Put4byte(pPage->aData, iTrunk);
  sqlite3Put4byte((&pPage->aData[4]), 0);
  sqlite3Put4byte((&pPage1->aData[32]), iPage);
  freepage_out:
  if (pPage) {
    (pPage->isInit = 0);
  }  
  releasePage(pPage);
  releasePage(pTrunk);
  return rc;
}
static  void freePage(MemPage *pPage , int *pRC )  {
  if (((*pRC) == 0)) {
    ((*pRC) = freePage2(pPage->pBt, pPage, pPage->pgno));
  }  
}
static  int clearCell(MemPage *pPage , unsigned  char *pCell )  {
  BtShared *pBt =  pPage->pBt;
  CellInfo info;
  Pgno ovflPgno;
  int rc;
  int nOvfl;
  u32 ovflPageSize;
  ((void ) 0);
  btreeParseCellPtr(pPage, pCell, (&info));
  if ((info.iOverflow == 0)) {
    return 0;
  }  
  if (((pCell + info.iOverflow + 3) > (pPage->aData + pPage->maskPage))) {
    return sqlite3CorruptError(55276);
  }  
  (ovflPgno = sqlite3Get4byte((&pCell[info.iOverflow])));
  ((void ) 0);
  (ovflPageSize = (pBt->usableSize - 4));
  (nOvfl = ((info.nPayload - info.nLocal + ovflPageSize - 1) / ovflPageSize));
  ((void ) 0);
  while (nOvfl--) {
    Pgno iNext =  0;
    MemPage *pOvfl =  0;
    if (((ovflPgno < 2) || (ovflPgno > btreePagecount(pBt)))) {
      return sqlite3CorruptError(55290);
    }  
    if (nOvfl) {
      (rc = getOverflowPage(pBt, ovflPgno, (&pOvfl), (&iNext)));
      if (rc) {
        return rc;
      }  
    }  
    if (((pOvfl || ((pOvfl = btreePageLookup(pBt, ovflPgno)) != 0)) && (sqlite3PagerPageRefcount(pOvfl->pDbPage) != 1))) {
      (rc = sqlite3CorruptError(55310));
    }  
    else {
      (rc = freePage2(pBt, pOvfl, ovflPgno));
    }
    if (pOvfl) {
      sqlite3PagerUnref(pOvfl->pDbPage);
    }  
    if (rc) {
      return rc;
    }  
    (ovflPgno = iNext);
  }
  return 0;
}
static  int fillInCell(MemPage *pPage , unsigned  char *pCell , const  void *pKey , i64 nKey , const  void *pData , int nData , int nZero , int *pnSize )  {
  int nPayload;
  const u8 *pSrc;
  int nSrc, n, rc;
  int spaceLeft;
  MemPage *pOvfl =  0;
  MemPage *pToRelease =  0;
  unsigned char *pPrior;
  unsigned char *pPayload;
  BtShared *pBt =  pPage->pBt;
  Pgno pgnoOvfl =  0;
  int nHeader;
  CellInfo info;
  ((void ) 0);
  ((void ) 0);
  (nHeader = 0);
  if ((! pPage->leaf)) {
    (nHeader += 4);
  }  
  if (pPage->hasData) {
    (nHeader += sqlite3PutVarint((&pCell[nHeader]), (nData + nZero)));
  }  
  else {
    (nData = (nZero = 0));
  }
  (nHeader += sqlite3PutVarint((&pCell[nHeader]), (*((u64 *) (&nKey)))));
  btreeParseCellPtr(pPage, pCell, (&info));
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (nPayload = (nData + nZero));
  if (pPage->intKey) {
    (pSrc = pData);
    (nSrc = nData);
    (nData = 0);
  }  
  else {
    if (((id2i_sqlite_coverage_test ) )) {
      if (0) {
        return sqlite3CorruptError(55388);
      }  
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      if (((nKey > 0x7fffffff) || (pKey == 0))) {
        return sqlite3CorruptError(55388);
      }  
    }  
    (nPayload += ((int ) nKey));
    (pSrc = pKey);
    (nSrc = ((int ) nKey));
  }
  ((*pnSize) = info.nSize);
  (spaceLeft = info.nLocal);
  (pPayload = (&pCell[nHeader]));
  (pPrior = (&pCell[info.iOverflow]));
  while ((nPayload > 0)) {
    if ((spaceLeft == 0)) {
      Pgno pgnoPtrmap =  pgnoOvfl;
      if ((((! id2i_sqlite_omit_autovacuum) ) )) {
        if (pBt->_1312_autoVacuum) {
          do {
            pgnoOvfl++;
          } while (((ptrmapPageno(pBt, pgnoOvfl) == pgnoOvfl) || (pgnoOvfl == ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1)))));
        }  
      }  
      (rc = allocateBtreePage(pBt, (&pOvfl), (&pgnoOvfl), pgnoOvfl, 0));
      if ((((! id2i_sqlite_omit_autovacuum) ) )) {
        if ((pBt->_1312_autoVacuum && (rc == 0))) {
          u8 eType =  (pgnoPtrmap ? 4 : 3);
          ptrmapPut(pBt, pgnoOvfl, eType, pgnoPtrmap, (&rc));
          if (rc) {
            releasePage(pOvfl);
          }  
        }  
      }  
      if (rc) {
        releasePage(pToRelease);
        return rc;
      }  
      ((void ) 0);
      ((void ) 0);
      sqlite3Put4byte(pPrior, pgnoOvfl);
      releasePage(pToRelease);
      (pToRelease = pOvfl);
      (pPrior = pOvfl->aData);
      sqlite3Put4byte(pPrior, 0);
      (pPayload = (&pOvfl->aData[4]));
      (spaceLeft = (pBt->usableSize - 4));
    }  
    (n = nPayload);
    if ((n > spaceLeft)) {
      (n = spaceLeft);
    }  
    ((void ) 0);
    ((void ) 0);
    if ((nSrc > 0)) {
      if ((n > nSrc)) {
        (n = nSrc);
      }  
      ((void ) 0);
      memcpy(pPayload, pSrc, n);
    }  
    else {
      memset(pPayload, 0, n);
    }
    (nPayload -= n);
    (pPayload += n);
    (pSrc += n);
    (nSrc -= n);
    (spaceLeft -= n);
    if ((nSrc == 0)) {
      (nSrc = nData);
      (pSrc = pData);
    }  
  }
  releasePage(pToRelease);
  return 0;
}
static  void dropCell(MemPage *pPage , int idx , int sz , int *pRC )  {
  u32 pc;
  u8 *data;
  u8 *ptr;
  u8 *endPtr;
  int rc;
  int hdr;
  if ((*pRC)) {
    return;
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (data = pPage->aData);
  (ptr = (&pPage->aCellIdx[(2 * idx)]));
  (pc = ((ptr[0] << 8) | ptr[1]));
  (hdr = pPage->hdrOffset);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pc == (((&data[(hdr + 5)])[0] << 8) | (&data[(hdr + 5)])[1]))) {
      sqlite3Coverage(55512);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((pc + sz) == pPage->pBt->usableSize)) {
      sqlite3Coverage(55513);
    }  
  }  
  if (((pc < ((u32 ) (((&data[(hdr + 5)])[0] << 8) | (&data[(hdr + 5)])[1]))) || ((pc + sz) > pPage->pBt->usableSize))) {
    ((*pRC) = sqlite3CorruptError(55515));
    return;
  }  
  (rc = freeSpace(pPage, pc, sz));
  if (rc) {
    ((*pRC) = rc);
    return;
  }  
  (endPtr = (&pPage->aCellIdx[((2 * pPage->nCell) - 2)]));
  ((void ) 0);
  while ((ptr < endPtr)) {
    ((*((u16 *) ptr)) = (*((u16 *) (&ptr[2]))));
    (ptr += 2);
  }
  pPage->nCell--;
  ((&data[(hdr + 3)])[0] = ((u8 ) (pPage->nCell >> 8))), ((&data[(hdr + 3)])[1] = ((u8 ) pPage->nCell));
  (pPage->nFree += 2);
}
static  void insertCell(MemPage *pPage , int i , u8 *pCell , int sz , u8 *pTemp , Pgno iChild , int *pRC )  {
  int idx =  0;
  int j;
  int end;
  int ins;
  int cellOffset;
  u8 *data;
  u8 *ptr;
  u8 *endPtr;
  int nSkip =  (iChild ? 4 : 0);
  if ((*pRC)) {
    return;
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pPage->nOverflow || ((sz + 2) > pPage->nFree))) {
    if (pTemp) {
      memcpy((pTemp + nSkip), (pCell + nSkip), (sz - nSkip));
      (pCell = pTemp);
    }  
    if (iChild) {
      sqlite3Put4byte(pCell, iChild);
    }  
    (j = pPage->nOverflow++);
    ((void ) 0);
    (pPage->apOvfl[j] = pCell);
    (pPage->aiOvfl[j] = ((u16 ) i));
  }  
  else {
    int rc =  sqlite3PagerWrite(pPage->pDbPage);
    if ((rc != 0)) {
      ((*pRC) = rc);
      return;
    }  
    ((void ) 0);
    (data = pPage->aData);
    (cellOffset = pPage->cellOffset);
    (end = (cellOffset + (2 * pPage->nCell)));
    (ins = (cellOffset + (2 * i)));
    (rc = allocateSpace(pPage, sz, (&idx)));
    if (rc) {
      ((*pRC) = rc);
      return;
    }  
    ((void ) 0);
    ((void ) 0);
    pPage->nCell++;
    (pPage->nFree -= ((u16 ) (2 + sz)));
    memcpy((&data[(idx + nSkip)]), (pCell + nSkip), (sz - nSkip));
    if (iChild) {
      sqlite3Put4byte((&data[idx]), iChild);
    }  
    (ptr = (&data[end]));
    (endPtr = (&data[ins]));
    ((void ) 0);
    while ((ptr > endPtr)) {
      ((*((u16 *) ptr)) = (*((u16 *) (&ptr[(- 2)]))));
      (ptr -= 2);
    }
    ((&data[ins])[0] = ((u8 ) (idx >> 8))), ((&data[ins])[1] = ((u8 ) idx));
    ((&data[(pPage->hdrOffset + 3)])[0] = ((u8 ) (pPage->nCell >> 8))), ((&data[(pPage->hdrOffset + 3)])[1] = ((u8 ) pPage->nCell));
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if (pPage->pBt->_1312_autoVacuum) {
        ptrmapPutOvflPtr(pPage, pCell, pRC);
      }  
    }  
  }
}
static  void assemblePage(MemPage *pPage , int nCell , u8 **apCell , u16 *aSize )  {
  int i;
  u8 *pCellptr;
  int cellbody;
  u8 *const data =  pPage->aData;
  const int hdr =  pPage->hdrOffset;
  const int nUsable =  pPage->pBt->usableSize;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (pCellptr = (&pPage->aCellIdx[(nCell * 2)]));
  (cellbody = nUsable);
  for ((i = (nCell - 1)); (i >= 0); i--) {
    u16 sz =  aSize[i];
    (pCellptr -= 2);
    (cellbody -= sz);
    (pCellptr[0] = ((u8 ) (cellbody >> 8))), (pCellptr[1] = ((u8 ) cellbody));
    memcpy((&data[cellbody]), apCell[i], sz);
  }
  ((&data[(hdr + 3)])[0] = ((u8 ) (nCell >> 8))), ((&data[(hdr + 3)])[1] = ((u8 ) nCell));
  ((&data[(hdr + 5)])[0] = ((u8 ) (cellbody >> 8))), ((&data[(hdr + 5)])[1] = ((u8 ) cellbody));
  (pPage->nFree -= ((nCell * 2) + nUsable - cellbody));
  (pPage->nCell = ((u16 ) nCell));
}
static  int balance_quick(MemPage *pParent , MemPage *pPage , u8 *pSpace )  {
  BtShared *const pBt =  pPage->pBt;
  MemPage *pNew;
  int rc;
  Pgno pgnoNew;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pPage->nCell == 0)) {
    return sqlite3CorruptError(55732);
  }  
  (rc = allocateBtreePage(pBt, (&pNew), (&pgnoNew), 0, 0));
  if ((rc == 0)) {
    u8 *pOut =  (&pSpace[4]);
    u8 *pCell =  pPage->apOvfl[0];
    u16 szCell =  cellSizePtr(pPage, pCell);
    u8 *pStop;
    ((void ) 0);
    ((void ) 0);
    zeroPage(pNew, (0x01 | 0x04 | 0x08));
    assemblePage(pNew, 1, (&pCell), (&szCell));
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if (pBt->_1312_autoVacuum) {
        ptrmapPut(pBt, pgnoNew, 5, pParent->pgno, (&rc));
        if ((szCell > pNew->minLocal)) {
          ptrmapPutOvflPtr(pNew, pCell, (&rc));
        }  
      }  
    }  
    if (((id2i_sqlite_omit_autovacuum ) )) {
      if (0) {
        if ((szCell > pNew->minLocal)) {
          
        }  
      }  
    }  
    (pCell = (pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * (pPage->nCell - 1))])[0] << 8) | (&pPage->aCellIdx[(2 * (pPage->nCell - 1))])[1]))));
    (pStop = (&pCell[9]));
    while ((((*pCell++) & 0x80) && (pCell < pStop))) {
      
    }
    (pStop = (&pCell[9]));
    while (((((*pOut++) = (*pCell++)) & 0x80) && (pCell < pStop))) {
      
    }
    insertCell(pParent, pParent->nCell, pSpace, ((int ) (pOut - pSpace)), 0, pPage->pgno, (&rc));
    sqlite3Put4byte((&pParent->aData[(pParent->hdrOffset + 8)]), pgnoNew);
    releasePage(pNew);
  }  
  return rc;
}
static  void copyNodeContent(MemPage *pFrom , MemPage *pTo , int *pRC )  {
  if (((*pRC) == 0)) {
    BtShared *const pBt =  pFrom->pBt;
    u8 *const aFrom =  pFrom->aData;
    u8 *const aTo =  pTo->aData;
    int const iFromHdr =  pFrom->hdrOffset;
    int const iToHdr =  ((pTo->pgno == 1) ? 100 : 0);
    int rc;
    int iData;
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    (iData = (((&aFrom[(iFromHdr + 5)])[0] << 8) | (&aFrom[(iFromHdr + 5)])[1]));
    memcpy((&aTo[iData]), (&aFrom[iData]), (pBt->usableSize - iData));
    memcpy((&aTo[iToHdr]), (&aFrom[iFromHdr]), (pFrom->cellOffset + (2 * pFrom->nCell)));
    (pTo->isInit = 0);
    (rc = btreeInitPage(pTo));
    if ((rc != 0)) {
      ((*pRC) = rc);
      return;
    }  
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if (pBt->_1312_autoVacuum) {
        ((*pRC) = setChildPtrmaps(pTo));
      }  
    }  
    if (((id2i_sqlite_omit_autovacuum ) )) {
      if (0) {
        ((*pRC) = 0);
      }  
    }  
  }  
}
static  int balance_nonroot(MemPage *pParent , int iParentIdx , u8 *aOvflSpace , int isRoot , int bBulk )  {
  BtShared *pBt;
  int nCell =  0;
  int nMaxCells =  0;
  int nNew =  0;
  int nOld;
  int i, j, k;
  int nxDiv;
  int rc =  0;
  u16 leafCorrection;
  int leafData;
  int usableSpace;
  int pageFlags;
  int subtotal;
  int iSpace1 =  0;
  int iOvflSpace =  0;
  int szScratch;
  MemPage *apOld[((1 * 2) + 1)];
  MemPage *apCopy[((1 * 2) + 1)];
  MemPage *apNew[(((1 * 2) + 1) + 2)];
  u8 *pRight;
  u8 *apDiv[(((1 * 2) + 1) - 1)];
  int cntNew[(((1 * 2) + 1) + 2)];
  int szNew[(((1 * 2) + 1) + 2)];
  u8 **apCell =  0;
  u16 *szCell;
  u8 *aSpace1;
  Pgno pgno;
  (pBt = pParent->pBt);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((! aOvflSpace)) {
    return 7;
  }  
  (i = (pParent->nOverflow + pParent->nCell));
  if ((i < 2)) {
    (nxDiv = 0);
  }  
  else {
    ((void ) 0);
    if ((iParentIdx == 0)) {
      (nxDiv = 0);
    } 
    else if ((iParentIdx == i)) {
      (nxDiv = (i - 2 + bBulk));
    } 
    else {
      ((void ) 0);
      (nxDiv = (iParentIdx - 1));
    }
    (i = (2 - bBulk));
  }
  (nOld = (i + 1));
  if (((i + nxDiv - pParent->nOverflow) == pParent->nCell)) {
    (pRight = (&pParent->aData[(pParent->hdrOffset + 8)]));
  }  
  else {
    (pRight = (pParent->aData + (pParent->maskPage & (((&pParent->aCellIdx[(2 * (i + nxDiv - pParent->nOverflow))])[0] << 8) | (&pParent->aCellIdx[(2 * (i + nxDiv - pParent->nOverflow))])[1]))));
  }
  (pgno = sqlite3Get4byte(pRight));
  while (1) {
    (rc = getAndInitPage(pBt, pgno, (&apOld[i]), 0));
    if (rc) {
      memset(apOld, 0, ((i + 1) * sizeof(MemPage *)));
      goto balance_cleanup;
    }  
    (nMaxCells += (1 + apOld[i]->nCell + apOld[i]->nOverflow));
    if ((i-- == 0)) {
      break;
    }  
    if ((((i + nxDiv) == pParent->aiOvfl[0]) && pParent->nOverflow)) {
      (apDiv[i] = pParent->apOvfl[0]);
      (pgno = sqlite3Get4byte(apDiv[i]));
      (szNew[i] = cellSizePtr(pParent, apDiv[i]));
      (pParent->nOverflow = 0);
    }  
    else {
      (apDiv[i] = (pParent->aData + (pParent->maskPage & (((&pParent->aCellIdx[(2 * (i + nxDiv - pParent->nOverflow))])[0] << 8) | (&pParent->aCellIdx[(2 * (i + nxDiv - pParent->nOverflow))])[1]))));
      (pgno = sqlite3Get4byte(apDiv[i]));
      (szNew[i] = cellSizePtr(pParent, apDiv[i]));
      if ((pBt->btsFlags & 0x0004)) {
        int iOff;
        (iOff = (((int ) ((long  int ) apDiv[i])) - ((int ) ((long  int ) pParent->aData))));
        if (((iOff + szNew[i]) > ((int ) pBt->usableSize))) {
          (rc = sqlite3CorruptError(56069));
          memset(apOld, 0, ((i + 1) * sizeof(MemPage *)));
          goto balance_cleanup;
        }  
        else {
          memcpy((&aOvflSpace[iOff]), apDiv[i], szNew[i]);
          (apDiv[i] = (&aOvflSpace[(apDiv[i] - pParent->aData)]));
        }
      }  
      dropCell(pParent, (i + nxDiv - pParent->nOverflow), szNew[i], (&rc));
    }
  }
  (nMaxCells = ((nMaxCells + 3) & (~ 3)));
  (k = (pBt->pageSize + ((sizeof(MemPage ) + 7) & (~ 7))));
  (szScratch = ((nMaxCells * sizeof(u8 *)) + (nMaxCells * sizeof(u16 )) + pBt->pageSize + (k * nOld)));
  (apCell = sqlite3ScratchMalloc(szScratch));
  if ((apCell == 0)) {
    (rc = 7);
    goto balance_cleanup;
  }  
  (szCell = ((u16 *) (&apCell[nMaxCells])));
  (aSpace1 = ((u8 *) (&szCell[nMaxCells])));
  ((void ) 0);
  (leafCorrection = (apOld[0]->leaf * 4));
  (leafData = apOld[0]->hasData);
  for ((i = 0); (i < nOld); i++) {
    int limit;
    MemPage *pOld =  (apCopy[i] = ((MemPage *) (&aSpace1[(pBt->pageSize + (k * i))])));
    memcpy(pOld, apOld[i], sizeof(MemPage ));
    (pOld->aData = ((void *) (&pOld[1])));
    memcpy(pOld->aData, apOld[i]->aData, pBt->pageSize);
    (limit = (pOld->nCell + pOld->nOverflow));
    if ((pOld->nOverflow > 0)) {
      for ((j = 0); (j < limit); j++) {
        ((void ) 0);
        (apCell[nCell] = findOverflowCell(pOld, j));
        (szCell[nCell] = cellSizePtr(pOld, apCell[nCell]));
        nCell++;
      }
    }  
    else {
      u8 *aData =  pOld->aData;
      u16 maskPage =  pOld->maskPage;
      u16 cellOffset =  pOld->cellOffset;
      for ((j = 0); (j < limit); j++) {
        ((void ) 0);
        (apCell[nCell] = (aData + (maskPage & (((aData + (cellOffset + (2 * j)))[0] << 8) | (aData + (cellOffset + (2 * j)))[1]))));
        (szCell[nCell] = cellSizePtr(pOld, apCell[nCell]));
        nCell++;
      }
    }
    if (((i < (nOld - 1)) && (! leafData))) {
      u16 sz =  ((u16 ) szNew[i]);
      u8 *pTemp;
      ((void ) 0);
      (szCell[nCell] = sz);
      (pTemp = (&aSpace1[iSpace1]));
      (iSpace1 += sz);
      ((void ) 0);
      ((void ) 0);
      memcpy(pTemp, apDiv[i], sz);
      (apCell[nCell] = (pTemp + leafCorrection));
      ((void ) 0);
      (szCell[nCell] = (szCell[nCell] - leafCorrection));
      if ((! pOld->leaf)) {
        ((void ) 0);
        ((void ) 0);
        memcpy(apCell[nCell], (&pOld->aData[8]), 4);
      }  
      else {
        ((void ) 0);
        if ((szCell[nCell] < 4)) {
          (szCell[nCell] = 4);
        }  
      }
      nCell++;
    }  
  }
  (usableSpace = (pBt->usableSize - 12 + leafCorrection));
  for ((subtotal = (k = (i = 0))); (i < nCell); i++) {
    ((void ) 0);
    (subtotal += (szCell[i] + 2));
    if ((subtotal > usableSpace)) {
      (szNew[k] = (subtotal - szCell[i]));
      (cntNew[k] = i);
      if (leafData) {
        i--;
      }  
      (subtotal = 0);
      k++;
      if ((k > (((1 * 2) + 1) + 1))) {
        (rc = sqlite3CorruptError(56208));
        goto balance_cleanup;
      }  
    }  
  }
  (szNew[k] = subtotal);
  (cntNew[k] = nCell);
  k++;
  for ((i = (k - 1)); (i > 0); i--) {
    int szRight =  szNew[i];
    int szLeft =  szNew[(i - 1)];
    int r;
    int d;
    (r = (cntNew[(i - 1)] - 1));
    (d = (r + 1 - leafData));
    ((void ) 0);
    ((void ) 0);
    while (((szRight == 0) || ((! bBulk) && ((szRight + szCell[d] + 2) <= (szLeft - (szCell[r] + 2)))))) {
      (szRight += (szCell[d] + 2));
      (szLeft -= (szCell[r] + 2));
      cntNew[(i - 1)]--;
      (r = (cntNew[(i - 1)] - 1));
      (d = (r + 1 - leafData));
    }
    (szNew[i] = szRight);
    (szNew[(i - 1)] = szLeft);
  }
  if ((apOld[0]->pgno <= 1)) {
    (rc = sqlite3CorruptError(56270));
    goto balance_cleanup;
  }  
  (pageFlags = apOld[0]->aData[0]);
  for ((i = 0); (i < k); i++) {
    MemPage *pNew;
    if ((i < nOld)) {
      (pNew = (apNew[i] = apOld[i]));
      (apOld[i] = 0);
      (rc = sqlite3PagerWrite(pNew->pDbPage));
      nNew++;
      if (rc) {
        goto balance_cleanup;
      }  
    }  
    else {
      ((void ) 0);
      (rc = allocateBtreePage(pBt, (&pNew), (&pgno), (bBulk ? 1 : pgno), 0));
      if (rc) {
        goto balance_cleanup;
      }  
      (apNew[i] = pNew);
      nNew++;
      if ((((! id2i_sqlite_omit_autovacuum) ) )) {
        if (pBt->_1312_autoVacuum) {
          ptrmapPut(pBt, pNew->pgno, 5, pParent->pgno, (&rc));
          if ((rc != 0)) {
            goto balance_cleanup;
          }  
        }  
      }  
      if (((id2i_sqlite_omit_autovacuum ) )) {
        if (0) {
          if ((rc != 0)) {
            goto balance_cleanup;
          }  
        }  
      }  
    }
  }
  while ((i < nOld)) {
    freePage(apOld[i], (&rc));
    if (rc) {
      goto balance_cleanup;
    }  
    releasePage(apOld[i]);
    (apOld[i] = 0);
    i++;
  }
  for ((i = 0); (i < (k - 1)); i++) {
    int minV =  apNew[i]->pgno;
    int minI =  i;
    for ((j = (i + 1)); (j < k); j++) {
      if ((apNew[j]->pgno < ((unsigned ) minV))) {
        (minI = j);
        (minV = apNew[j]->pgno);
      }  
    }
    if ((minI > i)) {
      MemPage *pT;
      (pT = apNew[i]);
      (apNew[i] = apNew[minI]);
      (apNew[minI] = pT);
    }  
  }
  ((void ) 0);
  sqlite3Put4byte(pRight, apNew[(nNew - 1)]->pgno);
  (j = 0);
  for ((i = 0); (i < nNew); i++) {
    MemPage *pNew =  apNew[i];
    ((void ) 0);
    zeroPage(pNew, pageFlags);
    assemblePage(pNew, (cntNew[i] - j), (&apCell[j]), (&szCell[j]));
    ((void ) 0);
    ((void ) 0);
    (j = cntNew[i]);
    ((void ) 0);
    if ((j < nCell)) {
      u8 *pCell;
      u8 *pTemp;
      int sz;
      ((void ) 0);
      (pCell = apCell[j]);
      (sz = (szCell[j] + leafCorrection));
      (pTemp = (&aOvflSpace[iOvflSpace]));
      if ((! pNew->leaf)) {
        memcpy((&pNew->aData[8]), pCell, 4);
      } 
      else if (leafData) {
        CellInfo info;
        j--;
        btreeParseCellPtr(pNew, apCell[j], (&info));
        (pCell = pTemp);
        (sz = (4 + sqlite3PutVarint((&pCell[4]), info.nKey)));
        (pTemp = 0);
      } 
      else {
        (pCell -= 4);
        if ((szCell[j] == 4)) {
          ((void ) 0);
          (sz = cellSizePtr(pParent, pCell));
        }  
      }
      (iOvflSpace += sz);
      ((void ) 0);
      ((void ) 0);
      insertCell(pParent, nxDiv, pCell, sz, pTemp, pNew->pgno, (&rc));
      if ((rc != 0)) {
        goto balance_cleanup;
      }  
      ((void ) 0);
      j++;
      nxDiv++;
    }  
  }
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((pageFlags & 0x08) == 0)) {
    u8 *zChild =  (&apCopy[(nOld - 1)]->aData[8]);
    memcpy((&apNew[(nNew - 1)]->aData[8]), zChild, 4);
  }  
  if ((isRoot && (pParent->nCell == 0) && (pParent->hdrOffset <= apNew[0]->nFree))) {
    ((void ) 0);
    ((void ) 0);
    copyNodeContent(apNew[0], pParent, (&rc));
    freePage(apNew[0], (&rc));
  } 
  else if (((((! id2i_sqlite_omit_autovacuum) ) ) && pBt->_1312_autoVacuum)) {
    MemPage *pNew =  apNew[0];
    MemPage *pOld =  apCopy[0];
    int nOverflow =  pOld->nOverflow;
    int iNextOld =  (pOld->nCell + nOverflow);
    int iOverflow =  (nOverflow ? pOld->aiOvfl[0] : (- 1));
    (j = 0);
    (k = 0);
    for ((i = 0); (i < nCell); i++) {
      int isDivider =  0;
      while ((i == iNextOld)) {
        ((void ) 0);
        ((void ) 0);
        (pOld = apCopy[++j]);
        (iNextOld = (i + (! leafData) + pOld->nCell + pOld->nOverflow));
        if (pOld->nOverflow) {
          (nOverflow = pOld->nOverflow);
          (iOverflow = (i + (! leafData) + pOld->aiOvfl[0]));
        }  
        (isDivider = (! leafData));
      }
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      if ((i == iOverflow)) {
        (isDivider = 1);
        if ((--nOverflow > 0)) {
          iOverflow++;
        }  
      }  
      if ((i == cntNew[k])) {
        (pNew = apNew[++k]);
        if ((! leafData)) {
          continue;
        }  
      }  
      ((void ) 0);
      ((void ) 0);
      if ((isDivider || (pOld->pgno != pNew->pgno))) {
        if ((! leafCorrection)) {
          ptrmapPut(pBt, sqlite3Get4byte(apCell[i]), 5, pNew->pgno, (&rc));
        }  
        if ((szCell[i] > pNew->minLocal)) {
          ptrmapPutOvflPtr(pNew, apCell[i], (&rc));
        }  
      }  
    }
    if ((! leafCorrection)) {
      for ((i = 0); (i < nNew); i++) {
        u32 key =  sqlite3Get4byte((&apNew[i]->aData[8]));
        ptrmapPut(pBt, key, 5, apNew[i]->pgno, (&rc));
      }
    }  
  }
  
  else if ((((id2i_sqlite_omit_autovacuum ) ) && 0)) {
    MemPage *pNew =  apNew[0];
    MemPage *pOld =  apCopy[0];
    int nOverflow =  pOld->nOverflow;
    int iNextOld =  (pOld->nCell + nOverflow);
    int iOverflow =  (nOverflow ? pOld->aiOvfl[0] : (- 1));
    (j = 0);
    (k = 0);
    for ((i = 0); (i < nCell); i++) {
      int isDivider =  0;
      while ((i == iNextOld)) {
        ((void ) 0);
        ((void ) 0);
        (pOld = apCopy[++j]);
        (iNextOld = (i + (! leafData) + pOld->nCell + pOld->nOverflow));
        if (pOld->nOverflow) {
          (nOverflow = pOld->nOverflow);
          (iOverflow = (i + (! leafData) + pOld->aiOvfl[0]));
        }  
        (isDivider = (! leafData));
      }
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      if ((i == iOverflow)) {
        (isDivider = 1);
        if ((--nOverflow > 0)) {
          iOverflow++;
        }  
      }  
      if ((i == cntNew[k])) {
        (pNew = apNew[++k]);
        if ((! leafData)) {
          continue;
        }  
      }  
      ((void ) 0);
      ((void ) 0);
      if ((isDivider || (pOld->pgno != pNew->pgno))) {
        if ((! leafCorrection)) {
          
        }  
        if ((szCell[i] > pNew->minLocal)) {
          
        }  
      }  
    }
    if ((! leafCorrection)) {
      for ((i = 0); (i < nNew); i++) {
        u32 key =  sqlite3Get4byte((&apNew[i]->aData[8]));
      }
    }  
  } 
  ((void ) 0);
  balance_cleanup:
  sqlite3ScratchFree(apCell);
  for ((i = 0); (i < nOld); i++) {
    releasePage(apOld[i]);
  }
  for ((i = 0); (i < nNew); i++) {
    releasePage(apNew[i]);
  }
  return rc;
}
static  int balance_deeper(MemPage *pRoot , MemPage **ppChild )  {
  int rc;
  MemPage *pChild =  0;
  Pgno pgnoChild =  0;
  BtShared *pBt =  pRoot->pBt;
  ((void ) 0);
  ((void ) 0);
  (rc = sqlite3PagerWrite(pRoot->pDbPage));
  if ((rc == 0)) {
    (rc = allocateBtreePage(pBt, (&pChild), (&pgnoChild), pRoot->pgno, 0));
    copyNodeContent(pRoot, pChild, (&rc));
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if (pBt->_1312_autoVacuum) {
        ptrmapPut(pBt, pgnoChild, 5, pRoot->pgno, (&rc));
      }  
    }  
    if (((id2i_sqlite_omit_autovacuum ) )) {
      if (0) {
        
      }  
    }  
  }  
  if (rc) {
    ((*ppChild) = 0);
    releasePage(pChild);
    return rc;
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  memcpy(pChild->aiOvfl, pRoot->aiOvfl, (pRoot->nOverflow * sizeof(pRoot->aiOvfl[0])));
  memcpy(pChild->apOvfl, pRoot->apOvfl, (pRoot->nOverflow * sizeof(pRoot->apOvfl[0])));
  (pChild->nOverflow = pRoot->nOverflow);
  zeroPage(pRoot, (pChild->aData[0] & (~ 0x08)));
  sqlite3Put4byte((&pRoot->aData[(pRoot->hdrOffset + 8)]), pgnoChild);
  ((*ppChild) = pChild);
  return 0;
}
static  int balance(BtCursor *pCur )  {
  int rc =  0;
  const int nMin =  (pCur->pBt->usableSize * 2 / 3);
  u8 aBalanceQuickSpace[13];
  u8 *pFree =  0;
  int balance_quick_called =  0;
  int balance_deeper_called =  0;
  do {
    int iPage =  pCur->iPage;
    MemPage *pPage =  pCur->apPage[iPage];
    if ((iPage == 0)) {
      if (pPage->nOverflow) {
        ((void ) 0);
        (rc = balance_deeper(pPage, (&pCur->apPage[1])));
        if ((rc == 0)) {
          (pCur->iPage = 1);
          (pCur->aiIdx[0] = 0);
          (pCur->aiIdx[1] = 0);
          ((void ) 0);
        }  
      }  
      else {
        break;
      }
    } 
    else if (((pPage->nOverflow == 0) && (pPage->nFree <= nMin))) {
      break;
    } 
    else {
      MemPage *const pParent =  pCur->apPage[(iPage - 1)];
      int const iIdx =  pCur->aiIdx[(iPage - 1)];
      (rc = sqlite3PagerWrite(pParent->pDbPage));
      if ((rc == 0)) {
        if ((pPage->hasData && (pPage->nOverflow == 1) && (pPage->aiOvfl[0] == pPage->nCell) && (pParent->pgno != 1) && (pParent->nCell == iIdx))) {
          ((void ) 0);
          (rc = balance_quick(pParent, pPage, aBalanceQuickSpace));
        }  
        else {
          u8 *pSpace =  sqlite3PageMalloc(pCur->pBt->pageSize);
          (rc = balance_nonroot(pParent, iIdx, pSpace, (iPage == 1), pCur->hints));
          if (pFree) {
            sqlite3PageFree(pFree);
          }  
          (pFree = pSpace);
        }
      }  
      (pPage->nOverflow = 0);
      releasePage(pPage);
      pCur->iPage--;
    }
  } while ((rc == 0));
  if (pFree) {
    sqlite3PageFree(pFree);
  }  
  return rc;
}
static  int sqlite3BtreeInsert(BtCursor *pCur , const  void *pKey , i64 nKey , const  void *pData , int nData , int nZero , int appendBias , int seekResult )  {
  int rc;
  int loc =  seekResult;
  int szNew =  0;
  int idx;
  MemPage *pPage;
  Btree *p =  pCur->pBtree;
  BtShared *pBt =  p->pBt;
  unsigned char *oldCell;
  unsigned char *newCell =  0;
  if ((pCur->eState == 4)) {
    ((void ) 0);
    return pCur->skipNext;
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur));
  if (rc) {
    return rc;
  }  
  if ((pCur->pKeyInfo == 0)) {
    invalidateIncrblobCursors(p, nKey, 0);
  }  
  if ((! loc)) {
    (rc = btreeMoveto(pCur, pKey, nKey, appendBias, (&loc)));
    if (rc) {
      return rc;
    }  
  }  
  ((void ) 0);
  (pPage = pCur->apPage[pCur->iPage]);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  allocateTempSpace(pBt);
  (newCell = pBt->pTmpSpace);
  if ((newCell == 0)) {
    return 7;
  }  
  (rc = fillInCell(pPage, newCell, pKey, nKey, pData, nData, nZero, (&szNew)));
  if (rc) {
    goto end_insert;
  }  
  ((void ) 0);
  ((void ) 0);
  (idx = pCur->aiIdx[pCur->iPage]);
  if ((loc == 0)) {
    u16 szOld;
    ((void ) 0);
    (rc = sqlite3PagerWrite(pPage->pDbPage));
    if (rc) {
      goto end_insert;
    }  
    (oldCell = (pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * idx)])[0] << 8) | (&pPage->aCellIdx[(2 * idx)])[1]))));
    if ((! pPage->leaf)) {
      memcpy(newCell, oldCell, 4);
    }  
    (szOld = cellSizePtr(pPage, oldCell));
    (rc = clearCell(pPage, oldCell));
    dropCell(pPage, idx, szOld, (&rc));
    if (rc) {
      goto end_insert;
    }  
  } 
  else if (((loc < 0) && (pPage->nCell > 0))) {
    ((void ) 0);
    (idx = ++pCur->aiIdx[pCur->iPage]);
  } 
  else {
    ((void ) 0);
  }
  insertCell(pPage, idx, newCell, szNew, 0, 0, (&rc));
  ((void ) 0);
  (pCur->info.nSize = 0);
  (pCur->validNKey = 0);
  if (((rc == 0) && pPage->nOverflow)) {
    (rc = balance(pCur));
    (pCur->apPage[pCur->iPage]->nOverflow = 0);
    (pCur->eState = 0);
  }  
  ((void ) 0);
  end_insert:
  return rc;
}
static  int sqlite3BtreeDelete(BtCursor *pCur )  {
  Btree *p =  pCur->pBtree;
  BtShared *pBt =  p->pBt;
  int rc;
  MemPage *pPage;
  unsigned char *pCell;
  int iCellIdx;
  int iCellDepth;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((0 || 0)) {
      return 1;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((pCur->aiIdx[pCur->iPage] >= pCur->apPage[pCur->iPage]->nCell) || (pCur->eState != 1))) {
      return 1;
    }  
  }  
  (iCellDepth = pCur->iPage);
  (iCellIdx = pCur->aiIdx[iCellDepth]);
  (pPage = pCur->apPage[iCellDepth]);
  (pCell = (pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * iCellIdx)])[0] << 8) | (&pPage->aCellIdx[(2 * iCellIdx)])[1]))));
  if ((! pPage->leaf)) {
    int notUsed;
    (rc = sqlite3BtreePrevious(pCur, (&notUsed)));
    if (rc) {
      return rc;
    }  
  }  
  (rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur));
  if (rc) {
    return rc;
  }  
  if ((pCur->pKeyInfo == 0)) {
    invalidateIncrblobCursors(p, pCur->info.nKey, 0);
  }  
  (rc = sqlite3PagerWrite(pPage->pDbPage));
  if (rc) {
    return rc;
  }  
  (rc = clearCell(pPage, pCell));
  dropCell(pPage, iCellIdx, cellSizePtr(pPage, pCell), (&rc));
  if (rc) {
    return rc;
  }  
  if ((! pPage->leaf)) {
    MemPage *pLeaf =  pCur->apPage[pCur->iPage];
    int nCell;
    Pgno n =  pCur->apPage[(iCellDepth + 1)]->pgno;
    unsigned char *pTmp;
    (pCell = (pLeaf->aData + (pLeaf->maskPage & (((&pLeaf->aCellIdx[(2 * (pLeaf->nCell - 1))])[0] << 8) | (&pLeaf->aCellIdx[(2 * (pLeaf->nCell - 1))])[1]))));
    (nCell = cellSizePtr(pLeaf, pCell));
    ((void ) 0);
    allocateTempSpace(pBt);
    (pTmp = pBt->pTmpSpace);
    (rc = sqlite3PagerWrite(pLeaf->pDbPage));
    insertCell(pPage, iCellIdx, (pCell - 4), (nCell + 4), pTmp, n, (&rc));
    dropCell(pLeaf, (pLeaf->nCell - 1), nCell, (&rc));
    if (rc) {
      return rc;
    }  
  }  
  (rc = balance(pCur));
  if (((rc == 0) && (pCur->iPage > iCellDepth))) {
    while ((pCur->iPage > iCellDepth)) {
      releasePage(pCur->apPage[pCur->iPage--]);
    }
    (rc = balance(pCur));
  }  
  if ((rc == 0)) {
    moveToRoot(pCur);
  }  
  return rc;
}
static  int btreeCreateTable(Btree *p , int *piTable , int createTabFlags )  {
  BtShared *pBt =  p->pBt;
  MemPage *pRoot;
  Pgno pgnoRoot;
  int rc;
  int ptfFlags;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_omit_autovacuum ) )) {
    (rc = allocateBtreePage(pBt, (&pRoot), (&pgnoRoot), 1, 0));
  }  
  if (((id2i_sqlite_omit_autovacuum ) )) {
    if (rc) {
      return rc;
    }  
  }  
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    if (pBt->_1312_autoVacuum) {
      Pgno pgnoMove;
      MemPage *pPageMove;
      invalidateAllOverflowCache(pBt);
      sqlite3BtreeGetMeta(p, 4, (&pgnoRoot));
      pgnoRoot++;
      while (((pgnoRoot == ptrmapPageno(pBt, pgnoRoot)) || (pgnoRoot == ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1))))) {
        pgnoRoot++;
      }
      ((void ) 0);
      (rc = allocateBtreePage(pBt, (&pPageMove), (&pgnoMove), pgnoRoot, 1));
      if ((rc != 0)) {
        return rc;
      }  
      if ((pgnoMove != pgnoRoot)) {
        u8 eType =  0;
        Pgno iPtrPage =  0;
        (rc = saveAllCursors(pBt, 0, 0));
        releasePage(pPageMove);
        if ((rc != 0)) {
          return rc;
        }  
        (rc = btreeGetPage(pBt, pgnoRoot, (&pRoot), 0));
        if ((rc != 0)) {
          return rc;
        }  
        (rc = ptrmapGet(pBt, pgnoRoot, (&eType), (&iPtrPage)));
        if (((eType == 1) || (eType == 2))) {
          (rc = sqlite3CorruptError(57138));
        }  
        if ((rc != 0)) {
          releasePage(pRoot);
          return rc;
        }  
        ((void ) 0);
        ((void ) 0);
        (rc = relocatePage(pBt, pRoot, eType, iPtrPage, pgnoMove, 0));
        releasePage(pRoot);
        if ((rc != 0)) {
          return rc;
        }  
        (rc = btreeGetPage(pBt, pgnoRoot, (&pRoot), 0));
        if ((rc != 0)) {
          return rc;
        }  
        (rc = sqlite3PagerWrite(pRoot->pDbPage));
        if ((rc != 0)) {
          releasePage(pRoot);
          return rc;
        }  
      }  
      else {
        (pRoot = pPageMove);
      }
      ptrmapPut(pBt, pgnoRoot, 1, 0, (&rc));
      if (rc) {
        releasePage(pRoot);
        return rc;
      }  
      ((void ) 0);
      (rc = sqlite3BtreeUpdateMeta(p, 4, pgnoRoot));
      if (((id2i_sqlite_coverage_test ) )) {
        if (0) {
          releasePage(pRoot);
          return rc;
        }  
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if (rc) {
          releasePage(pRoot);
          return rc;
        }  
      }  
    }  
    else {
      (rc = allocateBtreePage(pBt, (&pRoot), (&pgnoRoot), 1, 0));
      if (rc) {
        return rc;
      }  
    }
  }  
  ((void ) 0);
  if ((createTabFlags & 1)) {
    (ptfFlags = (0x01 | 0x04 | 0x08));
  }  
  else {
    (ptfFlags = (0x02 | 0x08));
  }
  zeroPage(pRoot, ptfFlags);
  sqlite3PagerUnref(pRoot->pDbPage);
  ((void ) 0);
  ((*piTable) = ((int ) pgnoRoot));
  return 0;
}
static  int sqlite3BtreeCreateTable(Btree *p , int *piTable , int flags )  {
  int rc;
  sqlite3BtreeEnter(p);
  (rc = btreeCreateTable(p, piTable, flags));
  return rc;
}
static  int clearDatabasePage(BtShared *pBt , Pgno pgno , int freePageFlag , int *pnChange )  {
  MemPage *pPage;
  int rc;
  unsigned char *pCell;
  int i;
  ((void ) 0);
  if ((pgno > btreePagecount(pBt))) {
    return sqlite3CorruptError(57226);
  }  
  (rc = getAndInitPage(pBt, pgno, (&pPage), 0));
  if (rc) {
    return rc;
  }  
  for ((i = 0); (i < pPage->nCell); i++) {
    (pCell = (pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * i)])[0] << 8) | (&pPage->aCellIdx[(2 * i)])[1]))));
    if ((! pPage->leaf)) {
      (rc = clearDatabasePage(pBt, sqlite3Get4byte(pCell), 1, pnChange));
      if (rc) {
        goto cleardatabasepage_out;
      }  
    }  
    (rc = clearCell(pPage, pCell));
    if (rc) {
      goto cleardatabasepage_out;
    }  
  }
  if ((! pPage->leaf)) {
    (rc = clearDatabasePage(pBt, sqlite3Get4byte((&pPage->aData[8])), 1, pnChange));
    if (rc) {
      goto cleardatabasepage_out;
    }  
  } 
  else if (pnChange) {
    ((void ) 0);
    ((*pnChange) += pPage->nCell);
  } 
  if (freePageFlag) {
    freePage(pPage, (&rc));
  } 
  else if (((rc = sqlite3PagerWrite(pPage->pDbPage)) == 0)) {
    zeroPage(pPage, (pPage->aData[0] | 0x08));
  } 
  cleardatabasepage_out:
  releasePage(pPage);
  return rc;
}
static  int sqlite3BtreeClearTable(Btree *p , int iTable , int *pnChange )  {
  int rc;
  BtShared *pBt =  p->pBt;
  sqlite3BtreeEnter(p);
  ((void ) 0);
  (rc = saveAllCursors(pBt, ((Pgno ) iTable), 0));
  if ((0 == rc)) {
    invalidateIncrblobCursors(p, 0, 1);
    (rc = clearDatabasePage(pBt, ((Pgno ) iTable), 0, pnChange));
  }  
  return rc;
}
static  int btreeDropTable(Btree *p , Pgno iTable , int *piMoved )  {
  int rc;
  MemPage *pPage =  0;
  BtShared *pBt =  p->pBt;
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return (6 | (1 << 8));
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pBt->pCursor) {
      return (6 | (1 << 8));
    }  
  }  
  (rc = btreeGetPage(pBt, ((Pgno ) iTable), (&pPage), 0));
  if (rc) {
    return rc;
  }  
  (rc = sqlite3BtreeClearTable(p, iTable, 0));
  if (rc) {
    releasePage(pPage);
    return rc;
  }  
  ((*piMoved) = 0);
  if ((iTable > 1)) {
    if (((id2i_sqlite_omit_autovacuum ) )) {
      freePage(pPage, (&rc));
    }  
    if (((id2i_sqlite_omit_autovacuum ) )) {
      releasePage(pPage);
    }  
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if (pBt->_1312_autoVacuum) {
        Pgno maxRootPgno;
        sqlite3BtreeGetMeta(p, 4, (&maxRootPgno));
        if ((iTable == maxRootPgno)) {
          freePage(pPage, (&rc));
          releasePage(pPage);
          if ((rc != 0)) {
            return rc;
          }  
        }  
        else {
          MemPage *pMove;
          releasePage(pPage);
          (rc = btreeGetPage(pBt, maxRootPgno, (&pMove), 0));
          if ((rc != 0)) {
            return rc;
          }  
          (rc = relocatePage(pBt, pMove, 1, 0, iTable, 0));
          releasePage(pMove);
          if ((rc != 0)) {
            return rc;
          }  
          (pMove = 0);
          (rc = btreeGetPage(pBt, maxRootPgno, (&pMove), 0));
          freePage(pMove, (&rc));
          releasePage(pMove);
          if ((rc != 0)) {
            return rc;
          }  
          ((*piMoved) = maxRootPgno);
        }
        maxRootPgno--;
        while (((maxRootPgno == ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1))) || (ptrmapPageno(pBt, maxRootPgno) == maxRootPgno))) {
          maxRootPgno--;
        }
        ((void ) 0);
        (rc = sqlite3BtreeUpdateMeta(p, 4, maxRootPgno));
      }  
      else {
        freePage(pPage, (&rc));
        releasePage(pPage);
      }
    }  
  }  
  else {
    zeroPage(pPage, (0x01 | 0x08));
    releasePage(pPage);
  }
  return rc;
}
static  int sqlite3BtreeDropTable(Btree *p , int iTable , int *piMoved )  {
  int rc;
  sqlite3BtreeEnter(p);
  (rc = btreeDropTable(p, iTable, piMoved));
  return rc;
}
static  void sqlite3BtreeGetMeta(Btree *p , int idx , u32 *pMeta )  {
  BtShared *pBt =  p->pBt;
  sqlite3BtreeEnter(p);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((*pMeta) = sqlite3Get4byte((&pBt->pPage1->aData[(36 + (idx * 4))])));
  if (((id2i_sqlite_omit_autovacuum ) )) {
    if (((idx == 4) && ((*pMeta) > 0))) {
      (pBt->btsFlags |= 0x0001);
    }  
  }  
}
static  int sqlite3BtreeUpdateMeta(Btree *p , int idx , u32 iMeta )  {
  BtShared *pBt =  p->pBt;
  unsigned char *pP1;
  int rc;
  ((void ) 0);
  sqlite3BtreeEnter(p);
  ((void ) 0);
  ((void ) 0);
  (pP1 = pBt->pPage1->aData);
  (rc = sqlite3PagerWrite(pBt->pPage1->pDbPage));
  if ((rc == 0)) {
    sqlite3Put4byte((&pP1[(36 + (idx * 4))]), iMeta);
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if ((idx == 7)) {
        ((void ) 0);
        ((void ) 0);
        (pBt->_1312_incrVacuum = ((u8 ) iMeta));
      }  
    }  
  }  
  return rc;
}
static  int sqlite3BtreeCount(BtCursor *pCur , i64 *pnEntry )  {
  i64 nEntry =  0;
  int rc;
  if ((pCur->pgnoRoot == 0)) {
    ((*pnEntry) = 0);
    return 0;
  }  
  (rc = moveToRoot(pCur));
  while ((rc == 0)) {
    int iIdx;
    MemPage *pPage;
    (pPage = pCur->apPage[pCur->iPage]);
    if ((pPage->leaf || (! pPage->intKey))) {
      (nEntry += pPage->nCell);
    }  
    if (pPage->leaf) {
      do {
        if ((pCur->iPage == 0)) {
          ((*pnEntry) = nEntry);
          return 0;
        }  
        moveToParent(pCur);
      } while ((pCur->aiIdx[pCur->iPage] >= pCur->apPage[pCur->iPage]->nCell));
      pCur->aiIdx[pCur->iPage]++;
      (pPage = pCur->apPage[pCur->iPage]);
    }  
    (iIdx = pCur->aiIdx[pCur->iPage]);
    if ((iIdx == pPage->nCell)) {
      (rc = moveToChild(pCur, sqlite3Get4byte((&pPage->aData[(pPage->hdrOffset + 8)]))));
    }  
    else {
      (rc = moveToChild(pCur, sqlite3Get4byte((pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * iIdx)])[0] << 8) | (&pPage->aCellIdx[(2 * iIdx)])[1]))))));
    }
  }
  return rc;
}
static  Pager *sqlite3BtreePager(Btree *p )  {
  return p->pBt->pPager;
}
static  void checkAppendMsg(IntegrityCk *pCheck , char *zMsg1 , const  char *zFormat , ...)  {
  va_list ap;
  if ((! pCheck->mxErr)) {
    return;
  }  
  pCheck->mxErr--;
  pCheck->nErr++;
  __builtin_va_start(ap, zFormat);
  if (pCheck->errMsg.nChar) {
    sqlite3StrAccumAppend((&pCheck->errMsg), "\n", 1);
  }  
  if (zMsg1) {
    sqlite3StrAccumAppend((&pCheck->errMsg), zMsg1, (- 1));
  }  
  sqlite3VXPrintf((&pCheck->errMsg), 1, zFormat, ap);
  __builtin_va_end(ap);
  if ((pCheck->errMsg.accError == 1)) {
    (pCheck->mallocFailed = 1);
  }  
}
static  int getPageReferenced(IntegrityCk *pCheck , Pgno iPg )  {
  ((void ) 0);
  return (pCheck->aPgRef[(iPg / 8)] & (1 << (iPg & 0x07)));
}
static  void setPageReferenced(IntegrityCk *pCheck , Pgno iPg )  {
  ((void ) 0);
  (pCheck->aPgRef[(iPg / 8)] |= (1 << (iPg & 0x07)));
}
static  int checkRef(IntegrityCk *pCheck , Pgno iPage , char *zContext )  {
  if ((iPage == 0)) {
    return 1;
  }  
  if ((iPage > pCheck->nPage)) {
    checkAppendMsg(pCheck, zContext, "invalid page number %d", iPage);
    return 1;
  }  
  if (getPageReferenced(pCheck, iPage)) {
    checkAppendMsg(pCheck, zContext, "2nd reference to page %d", iPage);
    return 1;
  }  
  setPageReferenced(pCheck, iPage);
  return 0;
}
static  void checkPtrmap(IntegrityCk *pCheck , Pgno iChild , u8 eType , Pgno iParent , char *zContext )  {
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;
  (rc = ptrmapGet(pCheck->pBt, iChild, (&ePtrmapType), (&iPtrmapParent)));
  if ((rc != 0)) {
    if (((rc == 7) || (rc == (10 | (12 << 8))))) {
      (pCheck->mallocFailed = 1);
    }  
    checkAppendMsg(pCheck, zContext, "Failed to read ptrmap key=%d", iChild);
    return;
  }  
  if (((ePtrmapType != eType) || (iPtrmapParent != iParent))) {
    checkAppendMsg(pCheck, zContext, "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)", iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }  
}
static  void checkList(IntegrityCk *pCheck , int isFreeList , int iPage , int N , char *zContext )  {
  int i;
  int expected =  N;
  int iFirst =  iPage;
  while (((N-- > 0) && pCheck->mxErr)) {
    DbPage *pOvflPage;
    unsigned char *pOvflData;
    if ((iPage < 1)) {
      checkAppendMsg(pCheck, zContext, "%d of %d pages missing from overflow list starting at %d", (N + 1), expected, iFirst);
      break;
    }  
    if (checkRef(pCheck, iPage, zContext)) {
      break;
    }  
    if (sqlite3PagerAcquire(pCheck->pPager, ((Pgno ) iPage), (&pOvflPage), 0)) {
      checkAppendMsg(pCheck, zContext, "failed to get page %d", iPage);
      break;
    }  
    (pOvflData = ((unsigned  char *) sqlite3PagerGetData(pOvflPage)));
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if (isFreeList) {
        int n =  sqlite3Get4byte((&pOvflData[4]));
        if (pCheck->pBt->_1312_autoVacuum) {
          checkPtrmap(pCheck, iPage, 2, 0, zContext);
        }  
        if ((n > ((((int ) pCheck->pBt->usableSize) / 4) - 2))) {
          checkAppendMsg(pCheck, zContext, "freelist leaf count too big on page %d", iPage);
          N--;
        }  
        else {
          for ((i = 0); (i < n); i++) {
            Pgno iFreePage =  sqlite3Get4byte((&pOvflData[(8 + (i * 4))]));
            if (pCheck->pBt->_1312_autoVacuum) {
              checkPtrmap(pCheck, iFreePage, 2, 0, zContext);
            }  
            checkRef(pCheck, iFreePage, zContext);
          }
          (N -= n);
        }
      }  
      else {
        if ((pCheck->pBt->_1312_autoVacuum && (N > 0))) {
          (i = sqlite3Get4byte(pOvflData));
          checkPtrmap(pCheck, i, 4, iPage, zContext);
        }  
      }
    }  
    if (((id2i_sqlite_omit_autovacuum ) )) {
      if (isFreeList) {
        int n =  sqlite3Get4byte((&pOvflData[4]));
        if ((n > ((((int ) pCheck->pBt->usableSize) / 4) - 2))) {
          checkAppendMsg(pCheck, zContext, "freelist leaf count too big on page %d", iPage);
          N--;
        }  
        else {
          for ((i = 0); (i < n); i++) {
            Pgno iFreePage =  sqlite3Get4byte((&pOvflData[(8 + (i * 4))]));
            checkRef(pCheck, iFreePage, zContext);
          }
          (N -= n);
        }
      }  
    }  
    (iPage = sqlite3Get4byte(pOvflData));
    sqlite3PagerUnref(pOvflPage);
  }
}
static  int checkTreePage(IntegrityCk *pCheck , int iPage , char *zParentContext , i64 *pnParentMinKey , i64 *pnParentMaxKey )  {
  MemPage *pPage;
  int i, rc, depth, d2, pgno, cnt;
  int hdr, cellStart;
  int nCell;
  u8 *data;
  BtShared *pBt;
  int usableSize;
  char zContext[100];
  char *hit =  0;
  i64 nMinKey =  0;
  i64 nMaxKey =  0;
  sqlite3_snprintf(sizeof(zContext), zContext, "Page %d: ", iPage);
  (pBt = pCheck->pBt);
  (usableSize = pBt->usableSize);
  if ((iPage == 0)) {
    return 0;
  }  
  if (checkRef(pCheck, iPage, zParentContext)) {
    return 0;
  }  
  if (((rc = btreeGetPage(pBt, ((Pgno ) iPage), (&pPage), 0)) != 0)) {
    checkAppendMsg(pCheck, zContext, "unable to get the page. error code=%d", rc);
    return 0;
  }  
  (pPage->isInit = 0);
  if (((rc = btreeInitPage(pPage)) != 0)) {
    ((void ) 0);
    checkAppendMsg(pCheck, zContext, "btreeInitPage() returns error code %d", rc);
    releasePage(pPage);
    return 0;
  }  
  (depth = 0);
  for ((i = 0); ((i < pPage->nCell) && pCheck->mxErr); i++) {
    u8 *pCell;
    u32 sz;
    CellInfo info;
    sqlite3_snprintf(sizeof(zContext), zContext, "On tree page %d cell %d: ", iPage, i);
    (pCell = (pPage->aData + (pPage->maskPage & (((&pPage->aCellIdx[(2 * i)])[0] << 8) | (&pPage->aCellIdx[(2 * i)])[1]))));
    btreeParseCellPtr(pPage, pCell, (&info));
    (sz = info.nData);
    if ((! pPage->intKey)) {
      (sz += ((int ) info.nKey));
    } 
    else if ((i == 0)) {
      (nMinKey = (nMaxKey = info.nKey));
    } 
    else {
      if ((info.nKey <= nMaxKey)) {
        checkAppendMsg(pCheck, zContext, "Rowid %lld out of order (previous was %lld)", info.nKey, nMaxKey);
      }  
      (nMaxKey = info.nKey);
    }
    ((void ) 0);
    if (((sz > info.nLocal) && ((&pCell[info.iOverflow]) <= (&pPage->aData[pBt->usableSize])))) {
      int nPage =  ((sz - info.nLocal + usableSize - 5) / (usableSize - 4));
      Pgno pgnoOvfl =  sqlite3Get4byte((&pCell[info.iOverflow]));
      if ((((! id2i_sqlite_omit_autovacuum) ) )) {
        if (pBt->_1312_autoVacuum) {
          checkPtrmap(pCheck, pgnoOvfl, 3, iPage, zContext);
        }  
      }  
      checkList(pCheck, 0, pgnoOvfl, nPage, zContext);
    }  
    if ((! pPage->leaf)) {
      (pgno = sqlite3Get4byte(pCell));
      if ((((! id2i_sqlite_omit_autovacuum) ) )) {
        if (pBt->_1312_autoVacuum) {
          checkPtrmap(pCheck, pgno, 5, iPage, zContext);
        }  
      }  
      (d2 = checkTreePage(pCheck, pgno, zContext, (&nMinKey), ((i == 0) ? ((void *) 0) : (&nMaxKey))));
      if (((i > 0) && (d2 != depth))) {
        checkAppendMsg(pCheck, zContext, "Child page depth differs");
      }  
      (depth = d2);
    }  
  }
  if ((! pPage->leaf)) {
    (pgno = sqlite3Get4byte((&pPage->aData[(pPage->hdrOffset + 8)])));
    sqlite3_snprintf(sizeof(zContext), zContext, "On page %d at right child: ", iPage);
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if (pBt->_1312_autoVacuum) {
        checkPtrmap(pCheck, pgno, 5, iPage, zContext);
      }  
    }  
    checkTreePage(pCheck, pgno, zContext, ((void *) 0), ((! pPage->nCell) ? ((void *) 0) : (&nMaxKey)));
  }  
  if ((pPage->leaf && pPage->intKey)) {
    if (pnParentMinKey) {
      if ((! pnParentMaxKey)) {
        if ((nMaxKey > (*pnParentMinKey))) {
          checkAppendMsg(pCheck, zContext, "Rowid %lld out of order (max larger than parent min of %lld)", nMaxKey, (*pnParentMinKey));
        }  
      }  
      else {
        if ((nMinKey <= (*pnParentMinKey))) {
          checkAppendMsg(pCheck, zContext, "Rowid %lld out of order (min less than parent min of %lld)", nMinKey, (*pnParentMinKey));
        }  
        if ((nMaxKey > (*pnParentMaxKey))) {
          checkAppendMsg(pCheck, zContext, "Rowid %lld out of order (max larger than parent max of %lld)", nMaxKey, (*pnParentMaxKey));
        }  
        ((*pnParentMinKey) = nMaxKey);
      }
    } 
    else if (pnParentMaxKey) {
      if ((nMinKey <= (*pnParentMaxKey))) {
        checkAppendMsg(pCheck, zContext, "Rowid %lld out of order (min less than parent max of %lld)", nMinKey, (*pnParentMaxKey));
      }  
    } 
  }  
  (data = pPage->aData);
  (hdr = pPage->hdrOffset);
  (hit = sqlite3PageMalloc(pBt->pageSize));
  if ((hit == 0)) {
    (pCheck->mallocFailed = 1);
  }  
  else {
    int contentOffset =  (((((int ) (((&data[(hdr + 5)])[0] << 8) | (&data[(hdr + 5)])[1])) - 1) & 0xffff) + 1);
    ((void ) 0);
    memset((hit + contentOffset), 0, (usableSize - contentOffset));
    memset(hit, 1, contentOffset);
    (nCell = (((&data[(hdr + 3)])[0] << 8) | (&data[(hdr + 3)])[1]));
    (cellStart = (hdr + 12 - (4 * pPage->leaf)));
    for ((i = 0); (i < nCell); i++) {
      int pc =  (((&data[(cellStart + (i * 2))])[0] << 8) | (&data[(cellStart + (i * 2))])[1]);
      u32 size =  65536;
      int j;
      if ((pc <= (usableSize - 4))) {
        (size = cellSizePtr(pPage, (&data[pc])));
      }  
      if ((((int ) (pc + size - 1)) >= usableSize)) {
        checkAppendMsg(pCheck, 0, "Corruption detected in cell %d on page %d", i, iPage);
      }  
      else {
        for ((j = (pc + size - 1)); (j >= pc); j--) {
          hit[j]++;
        }
      }
    }
    (i = (((&data[(hdr + 1)])[0] << 8) | (&data[(hdr + 1)])[1]));
    while ((i > 0)) {
      int size, j;
      ((void ) 0);
      (size = (((&data[(i + 2)])[0] << 8) | (&data[(i + 2)])[1]));
      ((void ) 0);
      for ((j = (i + size - 1)); (j >= i); j--) {
        hit[j]++;
      }
      (j = (((&data[i])[0] << 8) | (&data[i])[1]));
      ((void ) 0);
      ((void ) 0);
      (i = j);
    }
    for ((i = (cnt = 0)); (i < usableSize); i++) {
      if ((hit[i] == 0)) {
        cnt++;
      } 
      else if ((hit[i] > 1)) {
        checkAppendMsg(pCheck, 0, "Multiple uses for byte %d of page %d", i, iPage);
        break;
      } 
    }
    if ((cnt != data[(hdr + 7)])) {
      checkAppendMsg(pCheck, 0, "Fragmentation of %d bytes reported as %d on page %d", cnt, data[(hdr + 7)], iPage);
    }  
  }
  sqlite3PageFree(hit);
  releasePage(pPage);
  return (depth + 1);
}
static  char *sqlite3BtreeIntegrityCheck(Btree *p , int *aRoot , int nRoot , int mxErr , int *pnErr )  {
  Pgno i;
  int nRef;
  IntegrityCk sCheck;
  BtShared *pBt =  p->pBt;
  char zErr[100];
  sqlite3BtreeEnter(p);
  ((void ) 0);
  (nRef = sqlite3PagerRefcount(pBt->pPager));
  (sCheck.pBt = pBt);
  (sCheck.pPager = pBt->pPager);
  (sCheck.nPage = btreePagecount(sCheck.pBt));
  (sCheck.mxErr = mxErr);
  (sCheck.nErr = 0);
  (sCheck.mallocFailed = 0);
  ((*pnErr) = 0);
  if ((sCheck.nPage == 0)) {
    return 0;
  }  
  (sCheck.aPgRef = sqlite3MallocZero(((sCheck.nPage / 8) + 1)));
  if ((! sCheck.aPgRef)) {
    ((*pnErr) = 1);
    return 0;
  }  
  (i = ((Pgno ) ((sqlite3PendingByte / pBt->pageSize) + 1)));
  if ((i <= sCheck.nPage)) {
    setPageReferenced((&sCheck), i);
  }  
  sqlite3StrAccumInit((&sCheck.errMsg), zErr, sizeof(zErr), 1000000000);
  (sCheck.errMsg.useMalloc = 2);
  checkList((&sCheck), 1, sqlite3Get4byte((&pBt->pPage1->aData[32])), sqlite3Get4byte((&pBt->pPage1->aData[36])), "Main freelist: ");
  for ((i = 0); ((((int ) i) < nRoot) && sCheck.mxErr); i++) {
    if ((aRoot[i] == 0)) {
      continue;
    }  
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if ((pBt->_1312_autoVacuum && (aRoot[i] > 1))) {
        checkPtrmap((&sCheck), aRoot[i], 1, 0, 0);
      }  
    }  
    checkTreePage((&sCheck), aRoot[i], "List of tree roots: ", ((void *) 0), ((void *) 0));
  }
  for ((i = 1); ((i <= sCheck.nPage) && sCheck.mxErr); i++) {
    if (((id2i_sqlite_omit_autovacuum ) )) {
      if ((getPageReferenced((&sCheck), i) == 0)) {
        checkAppendMsg((&sCheck), 0, "Page %d is never used", i);
      }  
    }  
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if (((getPageReferenced((&sCheck), i) == 0) && ((ptrmapPageno(pBt, i) != i) || (! pBt->_1312_autoVacuum)))) {
        checkAppendMsg((&sCheck), 0, "Page %d is never used", i);
      }  
    }  
    if ((((! id2i_sqlite_omit_autovacuum) ) )) {
      if (((getPageReferenced((&sCheck), i) != 0) && ((ptrmapPageno(pBt, i) == i) && pBt->_1312_autoVacuum))) {
        checkAppendMsg((&sCheck), 0, "Pointer map page %d is referenced", i);
      }  
    }  
  }
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      checkAppendMsg((&sCheck), 0, "Outstanding page count goes from %d to %d during this analysis", nRef, sqlite3PagerRefcount(pBt->pPager));
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((nRef != sqlite3PagerRefcount(pBt->pPager))) {
      checkAppendMsg((&sCheck), 0, "Outstanding page count goes from %d to %d during this analysis", nRef, sqlite3PagerRefcount(pBt->pPager));
    }  
  }  
  sqlite3_free(sCheck.aPgRef);
  if (sCheck.mallocFailed) {
    sqlite3StrAccumReset((&sCheck.errMsg));
    ((*pnErr) = (sCheck.nErr + 1));
    return 0;
  }  
  ((*pnErr) = sCheck.nErr);
  if ((sCheck.nErr == 0)) {
    sqlite3StrAccumReset((&sCheck.errMsg));
  }  
  return sqlite3StrAccumFinish((&sCheck.errMsg));
}
static  const  char *sqlite3BtreeGetFilename(Btree *p )  {
  ((void ) 0);
  return sqlite3PagerFilename(p->pBt->pPager, 1);
}
static  const  char *sqlite3BtreeGetJournalname(Btree *p )  {
  ((void ) 0);
  return sqlite3PagerJournalname(p->pBt->pPager);
}
static  int sqlite3BtreeIsInTrans(Btree *p )  {
  ((void ) 0);
  return (p && (p->inTrans == 2));
}
static  int sqlite3BtreeCheckpoint(Btree *p , int eMode , int *pnLog , int *pnCkpt )  {
  int rc =  0;
  if (p) {
    BtShared *pBt =  p->pBt;
    sqlite3BtreeEnter(p);
    if ((pBt->inTransaction != 0)) {
      (rc = 6);
    }  
    else {
      (rc = sqlite3PagerCheckpoint(pBt->pPager, eMode, pnLog, pnCkpt));
    }
  }  
  return rc;
}
static  int sqlite3BtreeIsInReadTrans(Btree *p )  {
  ((void ) 0);
  ((void ) 0);
  return (p->inTrans != 0);
}
static  int sqlite3BtreeIsInBackup(Btree *p )  {
  ((void ) 0);
  ((void ) 0);
  return (p->nBackup != 0);
}
static  void *sqlite3BtreeSchema(Btree *p , int nBytes , void ( *xFree)(void * ) )  {
  BtShared *pBt =  p->pBt;
  sqlite3BtreeEnter(p);
  if (((! pBt->pSchema) && nBytes)) {
    (pBt->pSchema = sqlite3DbMallocZero(0, nBytes));
    (pBt->xFreeSchema = xFree);
  }  
  return pBt->pSchema;
}
static  int sqlite3BtreeSchemaLocked(Btree *p )  {
  int rc;
  ((void ) 0);
  sqlite3BtreeEnter(p);
  (rc = querySharedCacheTableLock(p, 1, 1));
  ((void ) 0);
  return rc;
}
static  int sqlite3BtreeLockTable(Btree *p , int iTab , u8 isWriteLock )  {
  int rc =  0;
  ((void ) 0);
  if (p->sharable) {
    u8 lockType =  (1 + isWriteLock);
    ((void ) 0);
    ((void ) 0);
    sqlite3BtreeEnter(p);
    (rc = querySharedCacheTableLock(p, iTab, lockType));
    if ((rc == 0)) {
      (rc = setSharedCacheTableLock(p, iTab, lockType));
    }  
  }  
  return rc;
}
static  int sqlite3BtreePutData(BtCursor *pCsr , u32 offset , u32 amt , void *z )  {
  int rc;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (rc = ((pCsr->eState >= 3) ? btreeRestoreCursorPosition(pCsr) : 0));
  if ((rc != 0)) {
    return rc;
  }  
  ((void ) 0);
  if ((pCsr->eState != 1)) {
    return 4;
  }  
  saveAllCursors(pCsr->pBt, pCsr->pgnoRoot, pCsr);
  ((void ) 0);
  if ((! pCsr->wrFlag)) {
    return 8;
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  return accessPayload(pCsr, offset, amt, ((unsigned  char *) z), 1);
}
static  void sqlite3BtreeCacheOverflow(BtCursor *pCur )  {
  ((void ) 0);
  ((void ) 0);
  invalidateOverflowCache(pCur);
  (pCur->isIncrblobHandle = 1);
}
static  int sqlite3BtreeSetVersion(Btree *pBtree , int iVersion )  {
  BtShared *pBt =  pBtree->pBt;
  int rc;
  ((void ) 0);
  (pBt->btsFlags &= (~ 0x0010));
  if ((iVersion == 1)) {
    (pBt->btsFlags |= 0x0010);
  }  
  (rc = sqlite3BtreeBeginTrans(pBtree, 0));
  if ((rc == 0)) {
    u8 *aData =  pBt->pPage1->aData;
    if (((aData[18] != ((u8 ) iVersion)) || (aData[19] != ((u8 ) iVersion)))) {
      (rc = sqlite3BtreeBeginTrans(pBtree, 2));
      if ((rc == 0)) {
        (rc = sqlite3PagerWrite(pBt->pPage1->pDbPage));
        if ((rc == 0)) {
          (aData[18] = ((u8 ) iVersion));
          (aData[19] = ((u8 ) iVersion));
        }  
      }  
    }  
  }  
  (pBt->btsFlags &= (~ 0x0010));
  return rc;
}
static  void sqlite3BtreeCursorHints(BtCursor *pCsr , unsigned  int mask )  {
  ((void ) 0);
  (pCsr->hints = mask);
}
struct  sqlite3_backup {
  sqlite3 *pDestDb ;
  Btree *pDest ;
  u32 iDestSchema ;
  int bDestLocked ;
  Pgno iNext ;
  sqlite3 *pSrcDb ;
  Btree *pSrc ;
  int rc ;
  Pgno nRemaining ;
  Pgno nPagecount ;
  int isAttached ;
  sqlite3_backup *pNext ;
}  ;
static  Btree *findBtree(sqlite3 *pErrorDb , sqlite3 *pDb , const  char *zDb )  {
  int i =  sqlite3FindDbName(pDb, zDb);
  if ((i == 1)) {
    Parse *pParse;
    int rc =  0;
    (pParse = sqlite3DbMallocZero(pErrorDb, sizeof((*pParse))));
    if ((pParse == 0)) {
      sqlite3Error(pErrorDb, 7, "out of memory");
      (rc = 7);
    }  
    else {
      (pParse->db = pDb);
      if (sqlite3OpenTempDatabase(pParse)) {
        sqlite3Error(pErrorDb, pParse->rc, "%s", pParse->zErrMsg);
        (rc = 1);
      }  
      sqlite3DbFree(pErrorDb, pParse->zErrMsg);
      sqlite3DbFree(pErrorDb, pParse);
    }
    if (rc) {
      return 0;
    }  
  }  
  if ((i < 0)) {
    sqlite3Error(pErrorDb, 1, "unknown database %s", zDb);
    return 0;
  }  
  return pDb->aDb[i].pBt;
}
static  int setDestPgsz(sqlite3_backup *p )  {
  int rc;
  (rc = sqlite3BtreeSetPageSize(p->pDest, sqlite3BtreeGetPageSize(p->pSrc), (- 1), 0));
  return rc;
}
sqlite3_backup *sqlite3_backup_init(sqlite3 *pDestDb , const  char *zDestDb , sqlite3 *pSrcDb , const  char *zSrcDb )  {
  sqlite3_backup *p;
  if ((pSrcDb == pDestDb)) {
    sqlite3Error(pDestDb, 1, "source and destination must be distinct");
    (p = 0);
  }  
  else {
    (p = ((sqlite3_backup *) sqlite3MallocZero(sizeof(sqlite3_backup ))));
    if ((! p)) {
      sqlite3Error(pDestDb, 7, 0);
    }  
  }
  if (p) {
    (p->pSrc = findBtree(pDestDb, pSrcDb, zSrcDb));
    (p->pDest = findBtree(pDestDb, pDestDb, zDestDb));
    (p->pDestDb = pDestDb);
    (p->pSrcDb = pSrcDb);
    (p->iNext = 1);
    (p->isAttached = 0);
    if (((0 == p->pSrc) || (0 == p->pDest) || (setDestPgsz(p) == 7))) {
      sqlite3_free(p);
      (p = 0);
    }  
  }  
  if (p) {
    p->pSrc->nBackup++;
  }  
  return p;
}
static  int isFatalError(int rc )  {
  if ((((! id2i_sqlite_coverage_test) ) )) {
    return ((rc != 0) && (rc != 5) && (rc != 6));
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    return ((rc != 0) && (rc != 5) && 1);
  }  
}
static  int backupOnePage(sqlite3_backup *p , Pgno iSrcPg , const  u8 *zSrcData , int bUpdate )  {
  Pager *const pDestPager =  sqlite3BtreePager(p->pDest);
  const int nSrcPgsz =  sqlite3BtreeGetPageSize(p->pSrc);
  int nDestPgsz =  sqlite3BtreeGetPageSize(p->pDest);
  const int nCopy =  ((nSrcPgsz < nDestPgsz) ? nSrcPgsz : nDestPgsz);
  const i64 iEnd =  (((i64 ) iSrcPg) * ((i64 ) nSrcPgsz));
  int rc =  0;
  i64 iOff;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((nSrcPgsz != nDestPgsz) && sqlite3PagerIsMemdb(pDestPager))) {
    (rc = 8);
  }  
  for ((iOff = (iEnd - ((i64 ) nSrcPgsz))); ((rc == 0) && (iOff < iEnd)); (iOff += nDestPgsz)) {
    DbPage *pDestPg =  0;
    Pgno iDest =  (((Pgno ) (iOff / nDestPgsz)) + 1);
    if ((iDest == ((Pgno ) ((sqlite3PendingByte / p->pDest->pBt->pageSize) + 1)))) {
      continue;
    }  
    if (((0 == (rc = sqlite3PagerAcquire(pDestPager, iDest, (&pDestPg), 0))) && (0 == (rc = sqlite3PagerWrite(pDestPg))))) {
      const u8 *zIn =  (&zSrcData[(iOff % nSrcPgsz)]);
      u8 *zDestData =  sqlite3PagerGetData(pDestPg);
      u8 *zOut =  (&zDestData[(iOff % nDestPgsz)]);
      memcpy(zOut, zIn, nCopy);
      (((u8 *) sqlite3PagerGetExtra(pDestPg))[0] = 0);
      if (((iOff == 0) && (bUpdate == 0))) {
        sqlite3Put4byte((&zOut[28]), sqlite3BtreeLastPage(p->pSrc));
      }  
    }  
    sqlite3PagerUnref(pDestPg);
  }
  return rc;
}
static  int backupTruncateFile(sqlite3_file *pFile , i64 iSize )  {
  i64 iCurrent;
  int rc =  sqlite3OsFileSize(pFile, (&iCurrent));
  if (((rc == 0) && (iCurrent > iSize))) {
    (rc = sqlite3OsTruncate(pFile, iSize));
  }  
  return rc;
}
static  void attachBackupObject(sqlite3_backup *p )  {
  sqlite3_backup **pp;
  ((void ) 0);
  (pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc)));
  (p->pNext = (*pp));
  ((*pp) = p);
  (p->isAttached = 1);
}
int sqlite3_backup_step(sqlite3_backup *p , int nPage )  {
  int rc;
  int destMode;
  int pgszSrc =  0;
  int pgszDest =  0;
  sqlite3BtreeEnter(p->pSrc);
  if (p->pDestDb) {
    
  }  
  (rc = p->rc);
  if ((! isFatalError(rc))) {
    Pager *const pSrcPager =  sqlite3BtreePager(p->pSrc);
    Pager *const pDestPager =  sqlite3BtreePager(p->pDest);
    int ii;
    int nSrcPage =  (- 1);
    int bCloseTrans =  0;
    if ((p->pDestDb && (p->pSrc->pBt->inTransaction == 2))) {
      (rc = 5);
    }  
    else {
      (rc = 0);
    }
    if (((0 == rc) && (p->bDestLocked == 0) && (0 == (rc = sqlite3BtreeBeginTrans(p->pDest, 2))))) {
      (p->bDestLocked = 1);
      sqlite3BtreeGetMeta(p->pDest, 1, (&p->iDestSchema));
    }  
    if (((rc == 0) && (0 == sqlite3BtreeIsInReadTrans(p->pSrc)))) {
      (rc = sqlite3BtreeBeginTrans(p->pSrc, 0));
      (bCloseTrans = 1);
    }  
    (pgszSrc = sqlite3BtreeGetPageSize(p->pSrc));
    (pgszDest = sqlite3BtreeGetPageSize(p->pDest));
    (destMode = sqlite3PagerGetJournalMode(sqlite3BtreePager(p->pDest)));
    if (((0 == rc) && (destMode == 5) && (pgszSrc != pgszDest))) {
      (rc = 8);
    }  
    (nSrcPage = ((int ) sqlite3BtreeLastPage(p->pSrc)));
    ((void ) 0);
    for ((ii = 0); (((nPage < 0) || (ii < nPage)) && (p->iNext <= ((Pgno ) nSrcPage)) && (! rc)); ii++) {
      const Pgno iSrcPg =  p->iNext;
      if ((iSrcPg != ((Pgno ) ((sqlite3PendingByte / p->pSrc->pBt->pageSize) + 1)))) {
        DbPage *pSrcPg;
        (rc = sqlite3PagerAcquire(pSrcPager, iSrcPg, (&pSrcPg), 0x02));
        if ((rc == 0)) {
          (rc = backupOnePage(p, iSrcPg, sqlite3PagerGetData(pSrcPg), 0));
          sqlite3PagerUnref(pSrcPg);
        }  
      }  
      p->iNext++;
    }
    if ((rc == 0)) {
      (p->nPagecount = nSrcPage);
      (p->nRemaining = (nSrcPage + 1 - p->iNext));
      if ((p->iNext > ((Pgno ) nSrcPage))) {
        (rc = 101);
      } 
      else if ((! p->isAttached)) {
        attachBackupObject(p);
      } 
    }  
    if ((rc == 101)) {
      if ((nSrcPage == 0)) {
        (rc = sqlite3BtreeNewDb(p->pDest));
        (nSrcPage = 1);
      }  
      if (((rc == 0) || (rc == 101))) {
        (rc = sqlite3BtreeUpdateMeta(p->pDest, 1, (p->iDestSchema + 1)));
      }  
      if ((rc == 0)) {
        if (p->pDestDb) {
          sqlite3ResetAllSchemasOfConnection(p->pDestDb);
        }  
        if ((destMode == 5)) {
          (rc = sqlite3BtreeSetVersion(p->pDest, 2));
        }  
      }  
      if ((rc == 0)) {
        int nDestTruncate;
        ((void ) 0);
        ((void ) 0);
        if ((pgszSrc < pgszDest)) {
          int ratio =  (pgszDest / pgszSrc);
          (nDestTruncate = ((nSrcPage + ratio - 1) / ratio));
          if ((nDestTruncate == ((int ) ((Pgno ) ((sqlite3PendingByte / p->pDest->pBt->pageSize) + 1))))) {
            nDestTruncate--;
          }  
        }  
        else {
          (nDestTruncate = (nSrcPage * (pgszSrc / pgszDest)));
        }
        ((void ) 0);
        if ((pgszSrc < pgszDest)) {
          const i64 iSize =  (((i64 ) pgszSrc) * ((i64 ) nSrcPage));
          sqlite3_file *const pFile =  sqlite3PagerFile(pDestPager);
          Pgno iPg;
          int nDstPage;
          i64 iOff;
          i64 iEnd;
          ((void ) 0);
          ((void ) 0);
          sqlite3PagerPagecount(pDestPager, (&nDstPage));
          for ((iPg = nDestTruncate); ((rc == 0) && (iPg <= ((Pgno ) nDstPage))); iPg++) {
            if ((iPg != ((Pgno ) ((sqlite3PendingByte / p->pDest->pBt->pageSize) + 1)))) {
              DbPage *pPg;
              (rc = sqlite3PagerAcquire(pDestPager, iPg, (&pPg), 0));
              if ((rc == 0)) {
                (rc = sqlite3PagerWrite(pPg));
                sqlite3PagerUnref(pPg);
              }  
            }  
          }
          if ((rc == 0)) {
            (rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 1));
          }  
          (iEnd = (((sqlite3PendingByte + pgszDest) < iSize) ? (sqlite3PendingByte + pgszDest) : iSize));
          for ((iOff = (sqlite3PendingByte + pgszSrc)); ((rc == 0) && (iOff < iEnd)); (iOff += pgszSrc)) {
            PgHdr *pSrcPg =  0;
            const Pgno iSrcPg =  ((Pgno ) ((iOff / pgszSrc) + 1));
            (rc = sqlite3PagerAcquire(pSrcPager, iSrcPg, (&pSrcPg), 0));
            if ((rc == 0)) {
              u8 *zData =  sqlite3PagerGetData(pSrcPg);
              (rc = sqlite3OsWrite(pFile, zData, pgszSrc, iOff));
            }  
            sqlite3PagerUnref(pSrcPg);
          }
          if ((rc == 0)) {
            (rc = backupTruncateFile(pFile, iSize));
          }  
          if ((rc == 0)) {
            (rc = sqlite3PagerSync(pDestPager));
          }  
        }  
        else {
          sqlite3PagerTruncateImage(pDestPager, nDestTruncate);
          (rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 0));
        }
        if (((0 == rc) && (0 == (rc = sqlite3BtreeCommitPhaseTwo(p->pDest, 0))))) {
          (rc = 101);
        }  
      }  
    }  
    if (bCloseTrans) {
      int _1267_rc2;
      if (((id2i_sqlite_coverage_test ) )) {
        (_1267_rc2 = sqlite3BtreeCommitPhaseOne(p->pSrc, 0));
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        sqlite3BtreeCommitPhaseOne(p->pSrc, 0);
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        (_1267_rc2 |= sqlite3BtreeCommitPhaseTwo(p->pSrc, 0));
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        sqlite3BtreeCommitPhaseTwo(p->pSrc, 0);
      }  
      ((void ) 0);
    }  
    if ((rc == (10 | (12 << 8)))) {
      (rc = 7);
    }  
    (p->rc = rc);
  }  
  if (p->pDestDb) {
    
  }  
  return rc;
}
int sqlite3_backup_finish(sqlite3_backup *p )  {
  sqlite3_backup **pp;
  sqlite3 *pSrcDb;
  int rc;
  if ((p == 0)) {
    return 0;
  }  
  (pSrcDb = p->pSrcDb);
  sqlite3BtreeEnter(p->pSrc);
  if (p->pDestDb) {
    
  }  
  if (p->pDestDb) {
    p->pSrc->nBackup--;
  }  
  if (p->isAttached) {
    (pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc)));
    while (((*pp) != p)) {
      (pp = (&(*pp)->pNext));
    }
    ((*pp) = p->pNext);
  }  
  sqlite3BtreeRollback(p->pDest, 0);
  (rc = ((p->rc == 101) ? 0 : p->rc));
  sqlite3Error(p->pDestDb, rc, 0);
  if (p->pDestDb) {
    sqlite3LeaveMutexAndCloseZombie(p->pDestDb);
  }  
  if (p->pDestDb) {
    sqlite3_free(p);
  }  
  sqlite3LeaveMutexAndCloseZombie(pSrcDb);
  return rc;
}
int sqlite3_backup_remaining(sqlite3_backup *p )  {
  return p->nRemaining;
}
int sqlite3_backup_pagecount(sqlite3_backup *p )  {
  return p->nPagecount;
}
static  void sqlite3BackupUpdate(sqlite3_backup *pBackup , Pgno iPage , const  u8 *aData )  {
  sqlite3_backup *p;
  for ((p = pBackup); p; (p = p->pNext)) {
    ((void ) 0);
    if (((! isFatalError(p->rc)) && (iPage < p->iNext))) {
      int rc;
      ((void ) 0);
      (rc = backupOnePage(p, iPage, aData, 1));
      ((void ) 0);
      if ((rc != 0)) {
        (p->rc = rc);
      }  
    }  
  }
}
static  void sqlite3BackupRestart(sqlite3_backup *pBackup )  {
  sqlite3_backup *p;
  for ((p = pBackup); p; (p = p->pNext)) {
    ((void ) 0);
    (p->iNext = 1);
  }
}
static  int sqlite3BtreeCopyFile(Btree *pTo , Btree *pFrom )  {
  int rc;
  sqlite3_file *pFd;
  sqlite3_backup b;
  sqlite3BtreeEnter(pTo);
  sqlite3BtreeEnter(pFrom);
  ((void ) 0);
  (pFd = sqlite3PagerFile(sqlite3BtreePager(pTo)));
  if (pFd->pMethods) {
    i64 nByte =  (sqlite3BtreeGetPageSize(pFrom) * ((i64 ) sqlite3BtreeLastPage(pFrom)));
    (rc = sqlite3OsFileControl(pFd, 11, (&nByte)));
    if ((rc == 12)) {
      (rc = 0);
    }  
    if (rc) {
      goto copy_finished;
    }  
  }  
  memset((&b), 0, sizeof(b));
  (b.pSrcDb = pFrom->db);
  (b.pSrc = pFrom);
  (b.pDest = pTo);
  (b.iNext = 1);
  sqlite3_backup_step((&b), 0x7FFFFFFF);
  ((void ) 0);
  (rc = sqlite3_backup_finish((&b)));
  if ((rc == 0)) {
    (pTo->pBt->btsFlags &= (~ 0x0002));
  }  
  else {
    sqlite3PagerClearCache(sqlite3BtreePager(b.pDest));
  }
  ((void ) 0);
  copy_finished:
  return rc;
}
static  int sqlite3VdbeChangeEncoding(Mem *pMem , int desiredEnc )  {
  int rc;
  ((void ) 0);
  ((void ) 0);
  if (((! (pMem->flags & 0x0002)) || (pMem->enc == desiredEnc))) {
    return 0;
  }  
  ((void ) 0);
  (rc = sqlite3VdbeMemTranslate(pMem, ((u8 ) desiredEnc)));
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  return rc;
}
static  int sqlite3VdbeMemGrow(Mem *pMem , int n , int preserve )  {
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((n < 32)) {
    (n = 32);
  }  
  if ((sqlite3DbMallocSize(pMem->db, pMem->zMalloc) < n)) {
    if ((preserve && (pMem->z == pMem->zMalloc))) {
      (pMem->z = (pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n)));
      (preserve = 0);
    }  
    else {
      sqlite3DbFree(pMem->db, pMem->zMalloc);
      (pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, n));
    }
  }  
  if ((pMem->z && preserve && pMem->zMalloc && (pMem->z != pMem->zMalloc))) {
    memcpy(pMem->zMalloc, pMem->z, pMem->n);
  }  
  if (((pMem->flags & 0x0400) && pMem->xDel)) {
    ((void ) 0);
    pMem->xDel(((void *) pMem->z));
  }  
  (pMem->z = pMem->zMalloc);
  if ((pMem->z == 0)) {
    (pMem->flags = 0x0001);
  }  
  else {
    (pMem->flags &= (~ (0x1000 | 0x0800)));
  }
  (pMem->xDel = 0);
  return (pMem->z ? 0 : 7);
}
static  int sqlite3VdbeMemMakeWriteable(Mem *pMem )  {
  int f;
  ((void ) 0);
  ((void ) 0);
  ((pMem->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pMem) : 0);
  (f = pMem->flags);
  if (((f & (0x0002 | 0x0010)) && (pMem->z != pMem->zMalloc))) {
    if (sqlite3VdbeMemGrow(pMem, (pMem->n + 2), 1)) {
      return 7;
    }  
    (pMem->z[pMem->n] = 0);
    (pMem->z[(pMem->n + 1)] = 0);
    (pMem->flags |= 0x0200);
  }  
  return 0;
}
static  int sqlite3VdbeMemExpandBlob(Mem *pMem )  {
  if ((pMem->flags & 0x4000)) {
    int nByte;
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    (nByte = (pMem->n + pMem->u.nZero));
    if ((nByte <= 0)) {
      (nByte = 1);
    }  
    if (sqlite3VdbeMemGrow(pMem, nByte, 1)) {
      return 7;
    }  
    memset((&pMem->z[pMem->n]), 0, pMem->u.nZero);
    (pMem->n += pMem->u.nZero);
    (pMem->flags &= (~ (0x4000 | 0x0200)));
  }  
  return 0;
}
static  int sqlite3VdbeMemNulTerminate(Mem *pMem )  {
  ((void ) 0);
  if ((((pMem->flags & 0x0200) != 0) || ((pMem->flags & 0x0002) == 0))) {
    return 0;
  }  
  if (sqlite3VdbeMemGrow(pMem, (pMem->n + 2), 1)) {
    return 7;
  }  
  (pMem->z[pMem->n] = 0);
  (pMem->z[(pMem->n + 1)] = 0);
  (pMem->flags |= 0x0200);
  return 0;
}
static  int sqlite3VdbeMemStringify(Mem *pMem , int enc )  {
  int rc =  0;
  int fg =  pMem->flags;
  const int nByte =  32;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (sqlite3VdbeMemGrow(pMem, nByte, 0)) {
    return 7;
  }  
  if ((fg & 0x0004)) {
    sqlite3_snprintf(nByte, pMem->z, "%lld", pMem->u.i);
  }  
  else {
    ((void ) 0);
    sqlite3_snprintf(nByte, pMem->z, "%!.15g", pMem->r);
  }
  (pMem->n = sqlite3Strlen30(pMem->z));
  (pMem->enc = 1);
  (pMem->flags |= (0x0002 | 0x0200));
  sqlite3VdbeChangeEncoding(pMem, enc);
  return rc;
}
static  int sqlite3VdbeMemFinalize(Mem *pMem , FuncDef *pFunc )  {
  int rc =  0;
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      sqlite3_context ctx;
      ((void ) 0);
      ((void ) 0);
      memset((&ctx), 0, sizeof(ctx));
      (ctx.s.flags = 0x0001);
      (ctx.s.db = pMem->db);
      (ctx.pMem = pMem);
      (ctx.pFunc = pFunc);
      pFunc->xFinalize((&ctx));
      ((void ) 0);
      sqlite3DbFree(pMem->db, pMem->zMalloc);
      memcpy(pMem, (&ctx.s), sizeof(ctx.s));
      (rc = ctx.isError);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pFunc && pFunc->xFinalize)) {
      sqlite3_context ctx;
      ((void ) 0);
      ((void ) 0);
      memset((&ctx), 0, sizeof(ctx));
      (ctx.s.flags = 0x0001);
      (ctx.s.db = pMem->db);
      (ctx.pMem = pMem);
      (ctx.pFunc = pFunc);
      pFunc->xFinalize((&ctx));
      ((void ) 0);
      sqlite3DbFree(pMem->db, pMem->zMalloc);
      memcpy(pMem, (&ctx.s), sizeof(ctx.s));
      (rc = ctx.isError);
    }  
  }  
  return rc;
}
static  void sqlite3VdbeMemReleaseExternal(Mem *p )  {
  ((void ) 0);
  if ((p->flags & 0x2000)) {
    sqlite3VdbeMemFinalize(p, p->u.pDef);
    ((void ) 0);
    sqlite3VdbeMemRelease(p);
  } 
  else if (((p->flags & 0x0400) && p->xDel)) {
    ((void ) 0);
    ((void ) 0);
    p->xDel(((void *) p->z));
    (p->xDel = 0);
  }
  
  else if ((p->flags & 0x0020)) {
    sqlite3RowSetClear(p->u.pRowSet);
  }
  
  else if ((p->flags & 0x0040)) {
    sqlite3VdbeMemSetNull(p);
  } 
}
static  void sqlite3VdbeMemRelease(Mem *p )  {
  if ((p->flags & (0x2000 | 0x0400 | 0x0020 | 0x0040))) {
    sqlite3VdbeMemReleaseExternal(p);
  }  
  sqlite3DbFree(p->db, p->zMalloc);
  (p->z = 0);
  (p->zMalloc = 0);
  (p->xDel = 0);
}
static  i64 doubleToInt64(double r )  {
  static const i64 maxInt =  (0xffffffff | (((i64 ) 0x7fffffff) << 32));
  static const i64 minInt =  (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32)));
  if ((r < ((double ) minInt))) {
    return minInt;
  } 
  else if ((r > ((double ) maxInt))) {
    return minInt;
  } 
  else {
    return ((i64 ) r);
  }
}
static  i64 sqlite3VdbeIntValue(Mem *pMem )  {
  int flags;
  ((void ) 0);
  ((void ) 0);
  (flags = pMem->flags);
  if ((flags & 0x0004)) {
    return pMem->u.i;
  } 
  else if ((flags & 0x0008)) {
    return doubleToInt64(pMem->r);
  }
  
  else if ((flags & (0x0002 | 0x0010))) {
    i64 value =  0;
    ((void ) 0);
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pMem->z == 0)) {
        sqlite3Coverage(59468);
      }  
    }  
    sqlite3Atoi64(pMem->z, (&value), pMem->n, pMem->enc);
    return value;
  } 
  else {
    return 0;
  }
}
static  double sqlite3VdbeRealValue(Mem *pMem )  {
  ((void ) 0);
  ((void ) 0);
  if ((pMem->flags & 0x0008)) {
    return pMem->r;
  } 
  else if ((pMem->flags & 0x0004)) {
    return ((double ) pMem->u.i);
  }
  
  else if ((pMem->flags & (0x0002 | 0x0010))) {
    double val =  ((double ) 0);
    sqlite3AtoF(pMem->z, (&val), pMem->n, pMem->enc);
    return val;
  } 
  else {
    return ((double ) 0);
  }
}
static  void sqlite3VdbeIntegerAffinity(Mem *pMem )  {
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (pMem->u.i = doubleToInt64(pMem->r));
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((pMem->r == ((double ) pMem->u.i)) && (pMem->u.i > (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32)))) && (pMem->u.i < (0xffffffff | (((i64 ) 0x7fffffff) << 32))))) {
      (pMem->flags |= 0x0004);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((pMem->r == ((double ) pMem->u.i)) && (pMem->u.i > (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32)))) && 1)) {
      (pMem->flags |= 0x0004);
    }  
  }  
}
static  int sqlite3VdbeMemIntegerify(Mem *pMem )  {
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (pMem->u.i = sqlite3VdbeIntValue(pMem));
  (pMem->flags = ((pMem->flags & (~ (0x01ff | 0x4000))) | 0x0004));
  return 0;
}
static  int sqlite3VdbeMemRealify(Mem *pMem )  {
  ((void ) 0);
  ((void ) 0);
  (pMem->r = sqlite3VdbeRealValue(pMem));
  (pMem->flags = ((pMem->flags & (~ (0x01ff | 0x4000))) | 0x0008));
  return 0;
}
static  int sqlite3VdbeMemNumerify(Mem *pMem )  {
  if (((pMem->flags & (0x0004 | 0x0008 | 0x0001)) == 0)) {
    ((void ) 0);
    ((void ) 0);
    if ((0 == sqlite3Atoi64(pMem->z, (&pMem->u.i), pMem->n, pMem->enc))) {
      (pMem->flags = ((pMem->flags & (~ (0x01ff | 0x4000))) | 0x0004));
    }  
    else {
      (pMem->r = sqlite3VdbeRealValue(pMem));
      (pMem->flags = ((pMem->flags & (~ (0x01ff | 0x4000))) | 0x0008));
      sqlite3VdbeIntegerAffinity(pMem);
    }
  }  
  ((void ) 0);
  (pMem->flags &= (~ (0x0002 | 0x0010)));
  return 0;
}
static  void sqlite3VdbeMemSetNull(Mem *pMem )  {
  if ((pMem->flags & 0x0040)) {
    VdbeFrame *pFrame =  pMem->u.pFrame;
    (pFrame->pParent = pFrame->v->pDelFrame);
    (pFrame->v->pDelFrame = pFrame);
  }  
  if ((pMem->flags & 0x0020)) {
    sqlite3RowSetClear(pMem->u.pRowSet);
  }  
  (pMem->flags = ((pMem->flags & (~ (0x01ff | 0x4000))) | 0x0001));
  (pMem->type = 5);
}
static  void sqlite3VdbeMemSetZeroBlob(Mem *pMem , int n )  {
  sqlite3VdbeMemRelease(pMem);
  (pMem->flags = (0x0010 | 0x4000));
  (pMem->type = 4);
  (pMem->n = 0);
  if ((n < 0)) {
    (n = 0);
  }  
  (pMem->u.nZero = n);
  (pMem->enc = 1);
}
static  void sqlite3VdbeMemSetInt64(Mem *pMem , i64 val )  {
  sqlite3VdbeMemRelease(pMem);
  (pMem->u.i = val);
  (pMem->flags = 0x0004);
  (pMem->type = 1);
}
static  void sqlite3VdbeMemSetDouble(Mem *pMem , double val )  {
  if (sqlite3IsNaN(val)) {
    sqlite3VdbeMemSetNull(pMem);
  }  
  else {
    sqlite3VdbeMemRelease(pMem);
    (pMem->r = val);
    (pMem->flags = 0x0008);
    (pMem->type = 2);
  }
}
static  void sqlite3VdbeMemSetRowSet(Mem *pMem )  {
  sqlite3 *db =  pMem->db;
  ((void ) 0);
  ((void ) 0);
  sqlite3VdbeMemRelease(pMem);
  (pMem->zMalloc = sqlite3DbMallocRaw(db, 64));
  if (db->mallocFailed) {
    (pMem->flags = 0x0001);
  }  
  else {
    ((void ) 0);
    (pMem->u.pRowSet = sqlite3RowSetInit(db, pMem->zMalloc, sqlite3DbMallocSize(db, pMem->zMalloc)));
    ((void ) 0);
    (pMem->flags = 0x0020);
  }
}
static  int sqlite3VdbeMemTooBig(Mem *p )  {
  ((void ) 0);
  if ((p->flags & (0x0002 | 0x0010))) {
    int n =  p->n;
    if ((p->flags & 0x4000)) {
      (n += p->u.nZero);
    }  
    return (n > p->db->aLimit[0]);
  }  
  return 0;
}
static  void sqlite3VdbeMemShallowCopy(Mem *pTo , const  Mem *pFrom , int srcType )  {
  ((void ) 0);
  if ((pTo->flags & (0x2000 | 0x0400 | 0x0020 | 0x0040))) {
    sqlite3VdbeMemReleaseExternal(pTo);
  }  
  memcpy(pTo, pFrom, ((size_t ) (&((Mem *) 0)->zMalloc)));
  (pTo->xDel = 0);
  if (((pFrom->flags & 0x0800) == 0)) {
    (pTo->flags &= (~ (0x0400 | 0x0800 | 0x1000)));
    ((void ) 0);
    (pTo->flags |= srcType);
  }  
}
static  int sqlite3VdbeMemCopy(Mem *pTo , const  Mem *pFrom )  {
  int rc =  0;
  ((void ) 0);
  if ((pTo->flags & (0x2000 | 0x0400 | 0x0020 | 0x0040))) {
    sqlite3VdbeMemReleaseExternal(pTo);
  }  
  memcpy(pTo, pFrom, ((size_t ) (&((Mem *) 0)->zMalloc)));
  (pTo->flags &= (~ 0x0400));
  if ((pTo->flags & (0x0002 | 0x0010))) {
    if ((0 == (pFrom->flags & 0x0800))) {
      (pTo->flags |= 0x1000);
      (rc = sqlite3VdbeMemMakeWriteable(pTo));
    }  
  }  
  return rc;
}
static  void sqlite3VdbeMemMove(Mem *pTo , Mem *pFrom )  {
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  sqlite3VdbeMemRelease(pTo);
  memcpy(pTo, pFrom, sizeof(Mem ));
  (pFrom->flags = 0x0001);
  (pFrom->xDel = 0);
  (pFrom->zMalloc = 0);
}
static  int sqlite3VdbeMemSetStr(Mem *pMem , const  char *z , int n , u8 enc , void ( *xDel)(void * ) )  {
  int nByte =  n;
  int iLimit;
  u16 flags =  0;
  ((void ) 0);
  ((void ) 0);
  if ((! z)) {
    sqlite3VdbeMemSetNull(pMem);
    return 0;
  }  
  if (pMem->db) {
    (iLimit = pMem->db->aLimit[0]);
  }  
  else {
    (iLimit = 1000000000);
  }
  (flags = ((enc == 0) ? 0x0010 : 0x0002));
  if ((nByte < 0)) {
    ((void ) 0);
    if ((enc == 1)) {
      for ((nByte = 0); ((nByte <= iLimit) && z[nByte]); nByte++) {
        
      }
    }  
    else {
      for ((nByte = 0); ((nByte <= iLimit) && (z[nByte] | z[(nByte + 1)])); (nByte += 2)) {
        
      }
    }
    (flags |= 0x0200);
  }  
  if ((xDel == ((sqlite3_destructor_type ) (- 1)))) {
    int nAlloc =  nByte;
    if ((flags & 0x0200)) {
      (nAlloc += ((enc == 1) ? 1 : 2));
    }  
    if ((nByte > iLimit)) {
      return 18;
    }  
    if (sqlite3VdbeMemGrow(pMem, nAlloc, 0)) {
      return 7;
    }  
    memcpy(pMem->z, z, nAlloc);
  } 
  else if ((xDel == ((sqlite3_destructor_type ) sqlite3MallocSize))) {
    sqlite3VdbeMemRelease(pMem);
    (pMem->zMalloc = (pMem->z = ((char *) z)));
    (pMem->xDel = 0);
  } 
  else {
    sqlite3VdbeMemRelease(pMem);
    (pMem->z = ((char *) z));
    (pMem->xDel = xDel);
    (flags |= ((xDel == ((sqlite3_destructor_type ) 0)) ? 0x0800 : 0x0400));
  }
  (pMem->n = nByte);
  (pMem->flags = flags);
  (pMem->enc = ((enc == 0) ? 1 : enc));
  (pMem->type = ((enc == 0) ? 4 : 3));
  if (((pMem->enc != 1) && sqlite3VdbeMemHandleBom(pMem))) {
    return 7;
  }  
  if ((nByte > iLimit)) {
    return 18;
  }  
  return 0;
}
static  int sqlite3MemCompare(const  Mem *pMem1 , const  Mem *pMem2 , const  CollSeq *pColl )  {
  int rc;
  int f1, f2;
  int combined_flags;
  (f1 = pMem1->flags);
  (f2 = pMem2->flags);
  (combined_flags = (f1 | f2));
  ((void ) 0);
  if ((combined_flags & 0x0001)) {
    return ((f2 & 0x0001) - (f1 & 0x0001));
  }  
  if ((combined_flags & (0x0004 | 0x0008))) {
    double r1, r2;
    if (((f1 & f2 & 0x0004) != 0)) {
      if ((pMem1->u.i < pMem2->u.i)) {
        return (- 1);
      }  
      if ((pMem1->u.i > pMem2->u.i)) {
        return 1;
      }  
      return 0;
    }  
    if (((f1 & 0x0008) != 0)) {
      (r1 = pMem1->r);
    } 
    else if (((f1 & 0x0004) != 0)) {
      (r1 = ((double ) pMem1->u.i));
    } 
    else {
      return 1;
    }
    if (((f2 & 0x0008) != 0)) {
      (r2 = pMem2->r);
    } 
    else if (((f2 & 0x0004) != 0)) {
      (r2 = ((double ) pMem2->u.i));
    } 
    else {
      return (- 1);
    }
    if ((r1 < r2)) {
      return (- 1);
    }  
    if ((r1 > r2)) {
      return 1;
    }  
    return 0;
  }  
  if ((combined_flags & 0x0002)) {
    if (((f1 & 0x0002) == 0)) {
      return 1;
    }  
    if (((f2 & 0x0002) == 0)) {
      return (- 1);
    }  
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    if (pColl) {
      if ((pMem1->enc == pColl->enc)) {
        return pColl->xCmp(pColl->pUser, pMem1->n, pMem1->z, pMem2->n, pMem2->z);
      }  
      else {
        const void *v1, *v2;
        int n1, n2;
        Mem c1;
        Mem c2;
        memset((&c1), 0, sizeof(c1));
        memset((&c2), 0, sizeof(c2));
        sqlite3VdbeMemShallowCopy((&c1), pMem1, 0x1000);
        sqlite3VdbeMemShallowCopy((&c2), pMem2, 0x1000);
        (v1 = sqlite3ValueText(((sqlite3_value *) (&c1)), pColl->enc));
        (n1 = ((v1 == 0) ? 0 : c1.n));
        (v2 = sqlite3ValueText(((sqlite3_value *) (&c2)), pColl->enc));
        (n2 = ((v2 == 0) ? 0 : c2.n));
        (rc = pColl->xCmp(pColl->pUser, n1, v1, n2, v2));
        sqlite3VdbeMemRelease((&c1));
        sqlite3VdbeMemRelease((&c2));
        return rc;
      }
    }  
  }  
  (rc = memcmp(pMem1->z, pMem2->z, ((pMem1->n > pMem2->n) ? pMem2->n : pMem1->n)));
  if ((rc == 0)) {
    (rc = (pMem1->n - pMem2->n));
  }  
  return rc;
}
static  int sqlite3VdbeMemFromBtree(BtCursor *pCur , int offset , int amt , int key , Mem *pMem )  {
  char *zData;
  int available =  0;
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  if (key) {
    (zData = ((char *) sqlite3BtreeKeyFetch(pCur, (&available))));
  }  
  else {
    (zData = ((char *) sqlite3BtreeDataFetch(pCur, (&available))));
  }
  ((void ) 0);
  if ((((offset + amt) <= available) && ((pMem->flags & 0x0400) == 0))) {
    sqlite3VdbeMemRelease(pMem);
    (pMem->z = (&zData[offset]));
    (pMem->flags = (0x0010 | 0x1000));
  } 
  else if ((0 == (rc = sqlite3VdbeMemGrow(pMem, (amt + 2), 0)))) {
    (pMem->flags = (0x0010 | 0x0400 | 0x0200));
    (pMem->enc = 0);
    (pMem->type = 4);
    if (key) {
      (rc = sqlite3BtreeKey(pCur, offset, amt, pMem->z));
    }  
    else {
      (rc = sqlite3BtreeData(pCur, offset, amt, pMem->z));
    }
    (pMem->z[amt] = 0);
    (pMem->z[(amt + 1)] = 0);
    if ((rc != 0)) {
      sqlite3VdbeMemRelease(pMem);
    }  
  } 
  (pMem->n = amt);
  return rc;
}
static  const  void *sqlite3ValueText(sqlite3_value *pVal , u8 enc )  {
  if ((! pVal)) {
    return 0;
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((pVal->flags & 0x0001)) {
    return 0;
  }  
  ((void ) 0);
  (pVal->flags |= ((pVal->flags & 0x0010) >> 3));
  ((pVal->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pVal) : 0);
  if ((pVal->flags & 0x0002)) {
    sqlite3VdbeChangeEncoding(pVal, (enc & (~ 8)));
    if ((((enc & 8) != 0) && (1 == (1 & ((int ) ((long  int ) pVal->z)))))) {
      ((void ) 0);
      if ((sqlite3VdbeMemMakeWriteable(pVal) != 0)) {
        return 0;
      }  
    }  
    sqlite3VdbeMemNulTerminate(pVal);
  }  
  else {
    ((void ) 0);
    sqlite3VdbeMemStringify(pVal, enc);
    ((void ) 0);
  }
  ((void ) 0);
  if ((pVal->enc == (enc & (~ 8)))) {
    return pVal->z;
  }  
  else {
    return 0;
  }
}
static  sqlite3_value *sqlite3ValueNew(sqlite3 *db )  {
  Mem *p =  sqlite3DbMallocZero(db, sizeof((*p)));
  if (p) {
    (p->flags = 0x0001);
    (p->type = 5);
    (p->db = db);
  }  
  return p;
}
struct  ValueNewStat4Ctx {
  Parse *pParse ;
  Index *pIdx ;
  UnpackedRecord **ppRec ;
  int iVal ;
}  ;
static  sqlite3_value *valueNew(sqlite3 *db , struct  ValueNewStat4Ctx   *p )  {
  ((void ) p);
  return sqlite3ValueNew(db);
}
static  int valueFromExpr(sqlite3 *db , Expr *pExpr , u8 enc , u8 affinity , sqlite3_value **ppVal , struct  ValueNewStat4Ctx   *pCtx )  {
  int op;
  char *zVal =  0;
  sqlite3_value *pVal =  0;
  int negInt =  1;
  const char *zNeg =  "";
  int rc =  0;
  if ((! pExpr)) {
    ((*ppVal) = 0);
    return 0;
  }  
  (op = pExpr->op);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      (op = pExpr->op2);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((op == 132)) {
      (op = pExpr->op2);
    }  
  }  
  if (((op == 156) && ((pExpr->pLeft->op == 129) || (pExpr->pLeft->op == 130)))) {
    (pExpr = pExpr->pLeft);
    (op = pExpr->op);
    (negInt = (- 1));
    (zNeg = "-");
  }  
  if (((op == 94) || (op == 130) || (op == 129))) {
    (pVal = valueNew(db, pCtx));
    if ((pVal == 0)) {
      goto no_mem;
    }  
    if (((pExpr->flags & 0x000400) != 0)) {
      sqlite3VdbeMemSetInt64(pVal, (((i64 ) pExpr->u.iValue) * negInt));
    }  
    else {
      (zVal = sqlite3MPrintf(db, "%s%s", zNeg, pExpr->u.zToken));
      if ((zVal == 0)) {
        goto no_mem;
      }  
      sqlite3ValueSetStr(pVal, (- 1), zVal, 1, ((sqlite3_destructor_type ) sqlite3MallocSize));
      if ((op == 130)) {
        (pVal->type = 2);
      }  
    }
    if ((((op == 129) || (op == 130)) && (affinity == 'b'))) {
      sqlite3ValueApplyAffinity(pVal, 'c', 1);
    }  
    else {
      sqlite3ValueApplyAffinity(pVal, affinity, 1);
    }
    if ((pVal->flags & (0x0004 | 0x0008))) {
      (pVal->flags &= (~ 0x0002));
    }  
    if ((enc != 1)) {
      (rc = sqlite3VdbeChangeEncoding(pVal, enc));
    }  
  } 
  else if ((op == 156)) {
    if (((0 == sqlite3ValueFromExpr(db, pExpr->pLeft, enc, affinity, (&pVal))) && (pVal != 0))) {
      sqlite3VdbeMemNumerify(pVal);
      if ((pVal->u.i == (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32))))) {
        (pVal->flags &= 0x0004);
        (pVal->flags |= 0x0008);
        (pVal->r = ((double ) (0xffffffff | (((i64 ) 0x7fffffff) << 32))));
      }  
      else {
        (pVal->u.i = (- pVal->u.i));
      }
      (pVal->r = (- pVal->r));
      sqlite3ValueApplyAffinity(pVal, affinity, enc);
    }  
  }
  
  else if ((op == 98)) {
    (pVal = valueNew(db, pCtx));
    if ((pVal == 0)) {
      goto no_mem;
    }  
  }
  
  else if (((((! id2i_sqlite_omit_blob_literal) ) ) && (op == 131))) {
    int nVal;
    ((void ) 0);
    ((void ) 0);
    (pVal = valueNew(db, pCtx));
    if ((! pVal)) {
      goto no_mem;
    }  
    (zVal = (&pExpr->u.zToken[2]));
    (nVal = (sqlite3Strlen30(zVal) - 1));
    ((void ) 0);
    sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), (nVal / 2), 0, ((sqlite3_destructor_type ) sqlite3MallocSize));
  } 
  if (pVal) {
    sqlite3VdbeMemStoreType(pVal);
  }  
  ((*ppVal) = pVal);
  return rc;
  no_mem:
  (db->mallocFailed = 1);
  sqlite3DbFree(db, zVal);
  ((void ) 0);
  ((void ) 0);
  sqlite3ValueFree(pVal);
  return 7;
}
static  int sqlite3ValueFromExpr(sqlite3 *db , Expr *pExpr , u8 enc , u8 affinity , sqlite3_value **ppVal )  {
  return valueFromExpr(db, pExpr, enc, affinity, ppVal, 0);
}
static  void sqlite3ValueSetStr(sqlite3_value *v , int n , const  void *z , u8 enc , void ( *xDel)(void * ) )  {
  if (v) {
    sqlite3VdbeMemSetStr(((Mem *) v), z, n, enc, xDel);
  }  
}
static  void sqlite3ValueFree(sqlite3_value *v )  {
  if ((! v)) {
    return;
  }  
  sqlite3VdbeMemRelease(((Mem *) v));
  sqlite3DbFree(((Mem *) v)->db, v);
}
static  int sqlite3ValueBytes(sqlite3_value *pVal , u8 enc )  {
  Mem *p =  ((Mem *) pVal);
  if ((((p->flags & 0x0010) != 0) || sqlite3ValueText(pVal, enc))) {
    if ((p->flags & 0x4000)) {
      return (p->n + p->u.nZero);
    }  
    else {
      return p->n;
    }
  }  
  return 0;
}
static  Vdbe *sqlite3VdbeCreate(sqlite3 *db )  {
  Vdbe *p;
  (p = sqlite3DbMallocZero(db, sizeof(Vdbe )));
  if ((p == 0)) {
    return 0;
  }  
  (p->db = db);
  if (db->pVdbe) {
    (db->pVdbe->pPrev = p);
  }  
  (p->pNext = db->pVdbe);
  (p->pPrev = 0);
  (db->pVdbe = p);
  (p->magic = 0x26bceaa5);
  return p;
}
static  void sqlite3VdbeSetSql(Vdbe *p , const  char *z , int n , int isPrepareV2 )  {
  ((void ) 0);
  if ((p == 0)) {
    return;
  }  
  ((void ) 0);
  (p->zSql = sqlite3DbStrNDup(p->db, z, n));
  (p->isPrepareV2 = ((u8 ) isPrepareV2));
}
const  char *sqlite3_sql(sqlite3_stmt *pStmt )  {
  Vdbe *p =  ((Vdbe *) pStmt);
  return ((p && p->isPrepareV2) ? p->zSql : 0);
}
static  void sqlite3VdbeSwap(Vdbe *pA , Vdbe *pB )  {
  Vdbe tmp, *pTmp;
  char *zTmp;
  (tmp = (*pA));
  ((*pA) = (*pB));
  ((*pB) = tmp);
  (pTmp = pA->pNext);
  (pA->pNext = pB->pNext);
  (pB->pNext = pTmp);
  (pTmp = pA->pPrev);
  (pA->pPrev = pB->pPrev);
  (pB->pPrev = pTmp);
  (zTmp = pA->zSql);
  (pA->zSql = pB->zSql);
  (pB->zSql = zTmp);
  (pB->isPrepareV2 = pA->isPrepareV2);
}
static  int growOpArray(Vdbe *p )  {
  VdbeOp *pNew;
  int nNew =  (p->nOpAlloc ? (p->nOpAlloc * 2) : ((int ) (1024 / sizeof(Op ))));
  (pNew = sqlite3DbRealloc(p->db, p->aOp, (nNew * sizeof(Op ))));
  if (pNew) {
    (p->nOpAlloc = (sqlite3DbMallocSize(p->db, pNew) / sizeof(Op )));
    (p->aOp = pNew);
  }  
  return (pNew ? 0 : 7);
}
static  int sqlite3VdbeAddOp3(Vdbe *p , int op , int p1 , int p2 , int p3 )  {
  int i;
  VdbeOp *pOp;
  (i = p->nOp);
  ((void ) 0);
  ((void ) 0);
  if ((p->nOpAlloc <= i)) {
    if (growOpArray(p)) {
      return 1;
    }  
  }  
  p->nOp++;
  (pOp = (&p->aOp[i]));
  (pOp->opcode = ((u8 ) op));
  (pOp->p5 = 0);
  (pOp->p1 = p1);
  (pOp->p2 = p2);
  (pOp->p3 = p3);
  (pOp->p4.p = 0);
  (pOp->p4type = 0);
  if (((id2i_vdbe_profile ) )) {
    (pOp->_1269_cycles = 0);
  }  
  if (((id2i_vdbe_profile ) )) {
    (pOp->_1269_cnt = 0);
  }  
  return i;
}
static  int sqlite3VdbeAddOp0(Vdbe *p , int op )  {
  return sqlite3VdbeAddOp3(p, op, 0, 0, 0);
}
static  int sqlite3VdbeAddOp1(Vdbe *p , int op , int p1 )  {
  return sqlite3VdbeAddOp3(p, op, p1, 0, 0);
}
static  int sqlite3VdbeAddOp2(Vdbe *p , int op , int p1 , int p2 )  {
  return sqlite3VdbeAddOp3(p, op, p1, p2, 0);
}
static  int sqlite3VdbeAddOp4(Vdbe *p , int op , int p1 , int p2 , int p3 , const  char *zP4 , int p4type )  {
  int addr =  sqlite3VdbeAddOp3(p, op, p1, p2, p3);
  sqlite3VdbeChangeP4(p, addr, zP4, p4type);
  return addr;
}
static  void sqlite3VdbeAddParseSchemaOp(Vdbe *p , int iDb , char *zWhere )  {
  int j;
  int addr =  sqlite3VdbeAddOp3(p, 112, iDb, 0, 0);
  sqlite3VdbeChangeP4(p, addr, zWhere, (- 1));
  for ((j = 0); (j < p->db->nDb); j++) {
    sqlite3VdbeUsesBtree(p, j);
  }
}
static  int sqlite3VdbeAddOp4Int(Vdbe *p , int op , int p1 , int p2 , int p3 , int p4 )  {
  int addr =  sqlite3VdbeAddOp3(p, op, p1, p2, p3);
  sqlite3VdbeChangeP4(p, addr, ((void *) ((long  int ) p4)), (- 14));
  return addr;
}
static  int sqlite3VdbeMakeLabel(Vdbe *p )  {
  int i =  p->nLabel++;
  ((void ) 0);
  if (((i & (i - 1)) == 0)) {
    (p->aLabel = sqlite3DbReallocOrFree(p->db, p->aLabel, (((i * 2) + 1) * sizeof(p->aLabel[0]))));
  }  
  if (p->aLabel) {
    (p->aLabel[i] = (- 1));
  }  
  return ((- 1) - i);
}
static  void sqlite3VdbeResolveLabel(Vdbe *p , int x )  {
  int j =  ((- 1) - x);
  ((void ) 0);
  ((void ) 0);
  if (((j >= 0) && p->aLabel)) {
    (p->aLabel[j] = p->nOp);
  }  
}
static  void sqlite3VdbeRunOnlyOnce(Vdbe *p )  {
  (p->runOnlyOnce = 1);
}
static  void resolveP2Values(Vdbe *p , int *pMaxFuncArgs )  {
  int i;
  int nMaxArgs =  (*pMaxFuncArgs);
  Op *pOp;
  int *aLabel =  p->aLabel;
  (p->readOnly = 1);
  (p->bIsReader = 0);
  for ((pOp = p->aOp), (i = (p->nOp - 1)); (i >= 0); i--, pOp++) {
    u8 opcode =  pOp->opcode;
    switch (opcode) {
      case 1:
      case 8:
      {
        if ((pOp->p5 > nMaxArgs)) {
          (nMaxArgs = pOp->p5);
        }  
        break;
      }
      case 4:
      {
        if ((pOp->p2 != 0)) {
          (p->readOnly = 0);
        }  
      }
      case 3:
      case 2:
      {
        (p->bIsReader = 1);
        break;
      }
      case 9:
      case 11:
      case 10:
      {
        (p->readOnly = 0);
        (p->bIsReader = 1);
        break;
      }
      case 13:
      {
        if ((pOp->p2 > nMaxArgs)) {
          (nMaxArgs = pOp->p2);
        }  
        break;
      }
      case 12:
      {
        int n;
        ((void ) 0);
        ((void ) 0);
        (n = pOp[(- 1)].p1);
        if ((n > nMaxArgs)) {
          (nMaxArgs = n);
        }  
        break;
      }
      case 7:
      case 5:
      {
        (pOp->p4.xAdvance = sqlite3BtreeNext);
        (pOp->p4type = (- 19));
        break;
      }
      case 6:
      {
        (pOp->p4.xAdvance = sqlite3BtreePrevious);
        (pOp->p4type = (- 19));
        break;
      }
    }
    (pOp->opflags = sqlite3OpcodeProperty[opcode]);
    if ((((pOp->opflags & 0x0001) != 0) && (pOp->p2 < 0))) {
      ((void ) 0);
      (pOp->p2 = aLabel[((- 1) - pOp->p2)]);
    }  
  }
  sqlite3DbFree(p->db, p->aLabel);
  (p->aLabel = 0);
  ((*pMaxFuncArgs) = nMaxArgs);
  ((void ) 0);
}
static  int sqlite3VdbeCurrentAddr(Vdbe *p )  {
  ((void ) 0);
  return p->nOp;
}
static  VdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p , int *pnOp , int *pnMaxArg )  {
  VdbeOp *aOp =  p->aOp;
  ((void ) 0);
  ((void ) 0);
  resolveP2Values(p, pnMaxArg);
  ((*pnOp) = p->nOp);
  (p->aOp = 0);
  return aOp;
}
static  int sqlite3VdbeAddOpList(Vdbe *p , int nOp , VdbeOpList  const *aOp )  {
  int addr;
  ((void ) 0);
  if ((((p->nOp + nOp) > p->nOpAlloc) && growOpArray(p))) {
    return 0;
  }  
  (addr = p->nOp);
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      int i;
      VdbeOpList const *pIn =  aOp;
      for ((i = 0); (i < nOp); i++, pIn++) {
        int p2 =  pIn->p2;
        VdbeOp *pOut =  (&p->aOp[(i + addr)]);
        (pOut->opcode = pIn->opcode);
        (pOut->p1 = pIn->p1);
        if (((p2 < 0) && ((sqlite3OpcodeProperty[pOut->opcode] & 0x0001) != 0))) {
          (pOut->p2 = (addr + ((- 1) - p2)));
        }  
        else {
          (pOut->p2 = p2);
        }
        (pOut->p3 = pIn->p3);
        (pOut->p4type = 0);
        (pOut->p4.p = 0);
        (pOut->p5 = 0);
      }
      (p->nOp += nOp);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((nOp > 0)) {
      int i;
      VdbeOpList const *pIn =  aOp;
      for ((i = 0); (i < nOp); i++, pIn++) {
        int p2 =  pIn->p2;
        VdbeOp *pOut =  (&p->aOp[(i + addr)]);
        (pOut->opcode = pIn->opcode);
        (pOut->p1 = pIn->p1);
        if (((p2 < 0) && ((sqlite3OpcodeProperty[pOut->opcode] & 0x0001) != 0))) {
          (pOut->p2 = (addr + ((- 1) - p2)));
        }  
        else {
          (pOut->p2 = p2);
        }
        (pOut->p3 = pIn->p3);
        (pOut->p4type = 0);
        (pOut->p4.p = 0);
        (pOut->p5 = 0);
      }
      (p->nOp += nOp);
    }  
  }  
  return addr;
}
static  void sqlite3VdbeChangeP1(Vdbe *p , u32 addr , int val )  {
  ((void ) 0);
  if ((((u32 ) p->nOp) > addr)) {
    (p->aOp[addr].p1 = val);
  }  
}
static  void sqlite3VdbeChangeP2(Vdbe *p , u32 addr , int val )  {
  ((void ) 0);
  if ((((u32 ) p->nOp) > addr)) {
    (p->aOp[addr].p2 = val);
  }  
}
static  void sqlite3VdbeChangeP3(Vdbe *p , u32 addr , int val )  {
  ((void ) 0);
  if ((((u32 ) p->nOp) > addr)) {
    (p->aOp[addr].p3 = val);
  }  
}
static  void sqlite3VdbeChangeP5(Vdbe *p , u8 val )  {
  ((void ) 0);
  if (p->aOp) {
    ((void ) 0);
    (p->aOp[(p->nOp - 1)].p5 = val);
  }  
}
static  void sqlite3VdbeJumpHere(Vdbe *p , int addr )  {
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      sqlite3VdbeChangeP2(p, addr, p->nOp);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((addr >= 0)) {
      sqlite3VdbeChangeP2(p, addr, p->nOp);
    }  
  }  
}
static  void freeEphemeralFunction(sqlite3 *db , FuncDef *pDef )  {
  if (((id2i_sqlite_coverage_test ) )) {
    if ((1 && ((pDef->funcFlags & 0x010) != 0))) {
      sqlite3DbFree(db, pDef);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pDef && ((pDef->funcFlags & 0x010) != 0))) {
      sqlite3DbFree(db, pDef);
    }  
  }  
}
static void vdbeFreeOpArray(sqlite3 * , Op * , int );
static  void freeP4(sqlite3 *db , int p4type , void *p4 )  {
  if (p4) {
    ((void ) 0);
    switch (p4type) {
      case (- 12):
      case (- 13):
      case (- 1):
      case (- 6):
      case (- 15):
      case (- 16):
      {
        sqlite3DbFree(db, p4);
        break;
      }
      case (- 11):
      {
        if ((db->pnBytesFreed == 0)) {
          sqlite3_free(p4);
        }  
        break;
      }
      case (- 5):
      {
        freeEphemeralFunction(db, ((FuncDef *) p4));
        break;
      }
      case (- 8):
      {
        if ((db->pnBytesFreed == 0)) {
          sqlite3ValueFree(((sqlite3_value *) p4));
        }  
        else {
          Mem *p =  ((Mem *) p4);
          sqlite3DbFree(db, p->zMalloc);
          sqlite3DbFree(db, p);
        }
        break;
      }
      case (- 10):
      {
        if ((db->pnBytesFreed == 0)) {
          sqlite3VtabUnlock(((VTable *) p4));
        }  
        break;
      }
    }
  }  
}
static  void vdbeFreeOpArray(sqlite3 *db , Op *aOp , int nOp )  {
  if (aOp) {
    Op *pOp;
    for ((pOp = aOp); (pOp < (&aOp[nOp])); pOp++) {
      freeP4(db, pOp->p4type, pOp->p4.p);
    }
  }  
  sqlite3DbFree(db, aOp);
}
static  void sqlite3VdbeLinkSubProgram(Vdbe *pVdbe , SubProgram *p )  {
  (p->pNext = pVdbe->pProgram);
  (pVdbe->pProgram = p);
}
static  void sqlite3VdbeChangeToNoop(Vdbe *p , int addr )  {
  if (p->aOp) {
    VdbeOp *pOp =  (&p->aOp[addr]);
    sqlite3 *db =  p->db;
    freeP4(db, pOp->p4type, pOp->p4.p);
    memset(pOp, 0, sizeof(pOp[0]));
    (pOp->opcode = 149);
  }  
}
static  void sqlite3VdbeChangeP4(Vdbe *p , int addr , const  char *zP4 , int n )  {
  Op *pOp;
  sqlite3 *db;
  ((void ) 0);
  (db = p->db);
  ((void ) 0);
  if (((p->aOp == 0) || db->mallocFailed)) {
    if (((n != (- 6)) && (n != (- 10)))) {
      freeP4(db, n, ((void *) (*((char **) (&zP4)))));
    }  
    return;
  }  
  ((void ) 0);
  ((void ) 0);
  if ((addr < 0)) {
    (addr = (p->nOp - 1));
  }  
  (pOp = (&p->aOp[addr]));
  ((void ) 0);
  freeP4(db, pOp->p4type, pOp->p4.p);
  (pOp->p4.p = 0);
  if ((n == (- 14))) {
    (pOp->p4.i = ((int ) ((long  int ) zP4)));
    (pOp->p4type = (- 14));
  } 
  else if ((zP4 == 0)) {
    (pOp->p4.p = 0);
    (pOp->p4type = 0);
  }
  
  else if ((n == (- 6))) {
    KeyInfo *pOrig, *pNew;
    (pOrig = ((KeyInfo *) zP4));
    (pOp->p4.pKeyInfo = (pNew = sqlite3KeyInfoAlloc(db, pOrig->nField)));
    if (pNew) {
      memcpy(pNew->aColl, pOrig->aColl, (pOrig->nField * sizeof(pNew->aColl[0])));
      memcpy(pNew->aSortOrder, pOrig->aSortOrder, pOrig->nField);
      (pOp->p4type = (- 6));
    }  
    else {
      (p->db->mallocFailed = 1);
      (pOp->p4type = 0);
    }
  }
  
  else if ((n == (- 16))) {
    (pOp->p4.p = ((void *) zP4));
    (pOp->p4type = (- 6));
  }
  
  else if ((n == (- 10))) {
    (pOp->p4.p = ((void *) zP4));
    (pOp->p4type = (- 10));
    sqlite3VtabLock(((VTable *) zP4));
    ((void ) 0);
  }
  
  else if ((n < 0)) {
    (pOp->p4.p = ((void *) zP4));
    (pOp->p4type = ((signed  char ) n));
  } 
  else {
    if ((n == 0)) {
      (n = sqlite3Strlen30(zP4));
    }  
    (pOp->p4.z = sqlite3DbStrNDup(p->db, zP4, n));
    (pOp->p4type = (- 1));
  }
}
static  VdbeOp *sqlite3VdbeGetOp(Vdbe *p , int addr )  {
  static VdbeOp dummy;
  ((void ) 0);
  if ((addr < 0)) {
    (addr = (p->nOp - 1));
  }  
  ((void ) 0);
  if (p->db->mallocFailed) {
    return ((VdbeOp *) (&dummy));
  }  
  else {
    return (&p->aOp[addr]);
  }
}
static  char *displayP4(Op *pOp , char *zTemp , int nTemp )  {
  char *zP4 =  zTemp;
  ((void ) 0);
  switch (pOp->p4type) {
    case (- 17):
    case (- 6):
    {
      int i, j;
      KeyInfo *pKeyInfo =  pOp->p4.pKeyInfo;
      ((void ) 0);
      sqlite3_snprintf(nTemp, zTemp, "keyinfo(%d", pKeyInfo->nField);
      (i = sqlite3Strlen30(zTemp));
      for ((j = 0); (j < pKeyInfo->nField); j++) {
        CollSeq *pColl =  pKeyInfo->aColl[j];
        const char *zColl =  (pColl ? pColl->zName : "nil");
        int n =  sqlite3Strlen30(zColl);
        if (((i + n) > (nTemp - 6))) {
          memcpy((&zTemp[i]), ",...", 4);
          break;
        }  
        (zTemp[i++] = ',');
        if (pKeyInfo->aSortOrder[j]) {
          (zTemp[i++] = '-');
        }  
        memcpy((&zTemp[i]), zColl, (n + 1));
        (i += n);
      }
      (zTemp[i++] = ')');
      (zTemp[i] = 0);
      ((void ) 0);
      break;
    }
    case (- 4):
    {
      CollSeq *pColl =  pOp->p4.pColl;
      sqlite3_snprintf(nTemp, zTemp, "collseq(%.20s)", pColl->zName);
      break;
    }
    case (- 5):
    {
      FuncDef *pDef =  pOp->p4.pFunc;
      sqlite3_snprintf(nTemp, zTemp, "%s(%d)", pDef->zName, pDef->nArg);
      break;
    }
    case (- 13):
    {
      sqlite3_snprintf(nTemp, zTemp, "%lld", (*pOp->p4.pI64));
      break;
    }
    case (- 14):
    {
      sqlite3_snprintf(nTemp, zTemp, "%d", pOp->p4.i);
      break;
    }
    case (- 12):
    {
      sqlite3_snprintf(nTemp, zTemp, "%.16g", (*pOp->p4.pReal));
      break;
    }
    case (- 8):
    {
      Mem *pMem =  pOp->p4.pMem;
      if ((pMem->flags & 0x0002)) {
        (zP4 = pMem->z);
      } 
      else if ((pMem->flags & 0x0004)) {
        sqlite3_snprintf(nTemp, zTemp, "%lld", pMem->u.i);
      }
      
      else if ((pMem->flags & 0x0008)) {
        sqlite3_snprintf(nTemp, zTemp, "%.16g", pMem->r);
      }
      
      else if ((pMem->flags & 0x0001)) {
        sqlite3_snprintf(nTemp, zTemp, "NULL");
      } 
      else {
        ((void ) 0);
        (zP4 = "(blob)");
      }
      break;
    }
    case (- 10):
    {
      sqlite3_vtab *pVtab =  pOp->p4.pVtab->pVtab;
      sqlite3_snprintf(nTemp, zTemp, "vtab:%p:%p", pVtab, pVtab->pModule);
      break;
    }
    case (- 15):
    {
      sqlite3_snprintf(nTemp, zTemp, "intarray");
      break;
    }
    case (- 18):
    {
      sqlite3_snprintf(nTemp, zTemp, "program");
      break;
    }
    case (- 19):
    {
      (zTemp[0] = 0);
      break;
    }
    id2i_label_1:
    default:
    {
      (zP4 = pOp->p4.z);
      if ((zP4 == 0)) {
        (zP4 = zTemp);
        (zTemp[0] = 0);
      }  
    }
  }
  ((void ) 0);
  return zP4;
}
static  void sqlite3VdbeUsesBtree(Vdbe *p , int i )  {
  ((void ) 0);
  ((void ) 0);
  (p->btreeMask |= (((yDbMask ) 1) << i));
  if (((i != 1) && 0)) {
    (p->lockMask |= (((yDbMask ) 1) << i));
  }  
}
static  void sqlite3VdbePrintOp(FILE *pOut , int pc , Op *pOp )  {
  char *zP4;
  char zPtr[50];
  static const char *zFormat1 =  "%4d %-13s %4d %4d %4d %-4s %.2X %s\n";
  if ((pOut == 0)) {
    (pOut = stdout);
  }  
  (zP4 = displayP4(pOp, zPtr, sizeof(zPtr)));
  fprintf(pOut, zFormat1, pc, sqlite3OpcodeName(pOp->opcode), pOp->p1, pOp->p2, pOp->p3, zP4, pOp->p5, "");
  fflush(pOut);
}
static  void releaseMemArray(Mem *p , int N )  {
  if ((p && N)) {
    Mem *pEnd;
    sqlite3 *db =  p->db;
    u8 malloc_failed =  db->mallocFailed;
    if (db->pnBytesFreed) {
      for ((pEnd = (&p[N])); (p < pEnd); p++) {
        sqlite3DbFree(db, p->zMalloc);
      }
      return;
    }  
    for ((pEnd = (&p[N])); (p < pEnd); p++) {
      ((void ) 0);
      if ((p->flags & (0x2000 | 0x0400 | 0x0040 | 0x0020))) {
        sqlite3VdbeMemRelease(p);
      } 
      else if (p->zMalloc) {
        sqlite3DbFree(db, p->zMalloc);
        (p->zMalloc = 0);
      } 
      (p->flags = 0x0080);
    }
    (db->mallocFailed = malloc_failed);
  }  
}
static  void sqlite3VdbeFrameDelete(VdbeFrame *p )  {
  int i;
  Mem *aMem =  ((Mem *) (&((u8 *) p)[((sizeof(VdbeFrame ) + 7) & (~ 7))]));
  VdbeCursor **apCsr =  ((VdbeCursor **) (&aMem[p->nChildMem]));
  for ((i = 0); (i < p->nChildCsr); i++) {
    sqlite3VdbeFreeCursor(p->v, apCsr[i]);
  }
  releaseMemArray(aMem, p->nChildMem);
  sqlite3DbFree(p->v->db, p);
}
static  int sqlite3VdbeList(Vdbe *p )  {
  int nRow;
  int nSub =  0;
  SubProgram **apSub =  0;
  Mem *pSub =  0;
  sqlite3 *db =  p->db;
  int i;
  int rc =  0;
  Mem *pMem =  (&p->aMem[1]);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  releaseMemArray(pMem, 8);
  (p->pResultSet = 0);
  if ((p->rc == 7)) {
    (db->mallocFailed = 1);
    return 1;
  }  
  (nRow = p->nOp);
  if ((p->explain == 1)) {
    ((void ) 0);
    (pSub = (&p->aMem[9]));
    if ((pSub->flags & 0x0010)) {
      (nSub = (pSub->n / sizeof(Vdbe *)));
      (apSub = ((SubProgram **) pSub->z));
    }  
    for ((i = 0); (i < nSub); i++) {
      (nRow += apSub[i]->nOp);
    }
  }  
  do {
    (i = p->pc++);
  } while (((i < nRow) && (p->explain == 2) && (p->aOp[i].opcode != 150)));
  if ((i >= nRow)) {
    (p->rc = 0);
    (rc = 101);
  } 
  else if (db->u1.isInterrupted) {
    (p->rc = 9);
    (rc = 1);
    sqlite3SetString((&p->zErrMsg), db, "%s", sqlite3ErrStr(p->rc));
  } 
  else {
    char *z;
    Op *pOp;
    if ((i < p->nOp)) {
      (pOp = (&p->aOp[i]));
    }  
    else {
      int j;
      (i -= p->nOp);
      for ((j = 0); (i >= apSub[j]->nOp); j++) {
        (i -= apSub[j]->nOp);
      }
      (pOp = (&apSub[j]->aOp[i]));
    }
    if ((p->explain == 1)) {
      (pMem->flags = 0x0004);
      (pMem->type = 1);
      (pMem->u.i = i);
      pMem++;
      (pMem->flags = (0x0800 | 0x0002 | 0x0200));
      (pMem->z = ((char *) sqlite3OpcodeName(pOp->opcode)));
      ((void ) 0);
      (pMem->n = sqlite3Strlen30(pMem->z));
      (pMem->type = 3);
      (pMem->enc = 1);
      pMem++;
      if ((pOp->p4type == (- 18))) {
        int nByte =  ((nSub + 1) * sizeof(SubProgram *));
        int j;
        for ((j = 0); (j < nSub); j++) {
          if ((apSub[j] == pOp->p4.pProgram)) {
            break;
          }  
        }
        if (((j == nSub) && (0 == sqlite3VdbeMemGrow(pSub, nByte, (nSub != 0))))) {
          (apSub = ((SubProgram **) pSub->z));
          (apSub[nSub++] = pOp->p4.pProgram);
          (pSub->flags |= 0x0010);
          (pSub->n = (nSub * sizeof(SubProgram *)));
        }  
      }  
    }  
    (pMem->flags = 0x0004);
    (pMem->u.i = pOp->p1);
    (pMem->type = 1);
    pMem++;
    (pMem->flags = 0x0004);
    (pMem->u.i = pOp->p2);
    (pMem->type = 1);
    pMem++;
    (pMem->flags = 0x0004);
    (pMem->u.i = pOp->p3);
    (pMem->type = 1);
    pMem++;
    if (sqlite3VdbeMemGrow(pMem, 32, 0)) {
      ((void ) 0);
      return 1;
    }  
    (pMem->flags = (0x0400 | 0x0002 | 0x0200));
    (z = displayP4(pOp, pMem->z, 32));
    if ((z != pMem->z)) {
      sqlite3VdbeMemSetStr(pMem, z, (- 1), 1, 0);
    }  
    else {
      ((void ) 0);
      (pMem->n = sqlite3Strlen30(pMem->z));
      (pMem->enc = 1);
    }
    (pMem->type = 3);
    pMem++;
    if ((p->explain == 1)) {
      if (sqlite3VdbeMemGrow(pMem, 4, 0)) {
        ((void ) 0);
        return 1;
      }  
      (pMem->flags = (0x0400 | 0x0002 | 0x0200));
      (pMem->n = 2);
      sqlite3_snprintf(3, pMem->z, "%.2x", pOp->p5);
      (pMem->type = 3);
      (pMem->enc = 1);
      pMem++;
      {
        (pMem->flags = 0x0001);
        (pMem->type = 5);
      }
    }  
    (p->nResColumn = (8 - (4 * (p->explain - 1))));
    (p->pResultSet = (&p->aMem[1]));
    (p->rc = 0);
    (rc = 100);
  }
  return rc;
}
static  void sqlite3VdbeIOTraceSql(Vdbe *p )  {
  int nOp =  p->nOp;
  VdbeOp *pOp;
  if ((_1280_sqlite3IoTrace == 0)) {
    return;
  }  
  if ((nOp < 1)) {
    return;
  }  
  (pOp = (&p->aOp[0]));
  if (((pOp->opcode == 148) && (pOp->p4.z != 0))) {
    int i, j;
    char z[1000];
    sqlite3_snprintf(sizeof(z), z, "%s", pOp->p4.z);
    for ((i = 0); (sqlite3CtypeMap[((unsigned  char ) z[i])] & 0x01); i++) {
      
    }
    for ((j = 0); z[i]; i++) {
      if ((sqlite3CtypeMap[((unsigned  char ) z[i])] & 0x01)) {
        if ((z[(i - 1)] != ' ')) {
          (z[j++] = ' ');
        }  
      }  
      else {
        (z[j++] = z[i]);
      }
    }
    (z[j] = 0);
    _1280_sqlite3IoTrace("SQL %s\n", z);
  }  
}
static  void *allocSpace(void *pBuf , int nByte , u8 **ppFrom , u8 *pEnd , int *pnByte )  {
  ((void ) 0);
  if (pBuf) {
    return pBuf;
  }  
  (nByte = ((nByte + 7) & (~ 7)));
  if (((&(*ppFrom)[nByte]) <= pEnd)) {
    (pBuf = ((void *) (*ppFrom)));
    ((*ppFrom) += nByte);
  }  
  else {
    ((*pnByte) += nByte);
  }
  return pBuf;
}
static  void sqlite3VdbeRewind(Vdbe *p )  {
  int _1269_i;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (p->magic = 0xbdf20da3);
  (p->pc = (- 1));
  (p->rc = 0);
  (p->errorAction = 2);
  (p->magic = 0xbdf20da3);
  (p->nChange = 0);
  (p->cacheCtr = 1);
  (p->minWriteFileFormat = 255);
  (p->iStatement = 0);
  (p->nFkConstraint = 0);
  if (((id2i_vdbe_profile ) )) {
    for ((_1269_i = 0); (_1269_i < p->nOp); _1269_i++) {
      (p->aOp[_1269_i]._1269_cnt = 0);
      (p->aOp[_1269_i]._1269_cycles = 0);
    }
  }  
}
static  void sqlite3VdbeMakeReady(Vdbe *p , Parse *pParse )  {
  sqlite3 *db;
  int nVar;
  int nMem;
  int nCursor;
  int nArg;
  int nOnce;
  int n;
  u8 *zCsr;
  u8 *zEnd;
  int nByte;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (db = p->db);
  ((void ) 0);
  (nVar = pParse->nVar);
  (nMem = pParse->nMem);
  (nCursor = pParse->nTab);
  (nArg = pParse->nMaxArg);
  (nOnce = pParse->nOnce);
  if ((nOnce == 0)) {
    (nOnce = 1);
  }  
  (nMem += nCursor);
  (zCsr = ((u8 *) (&p->aOp[p->nOp])));
  (zEnd = ((u8 *) (&p->aOp[p->nOpAlloc])));
  resolveP2Values(p, (&nArg));
  (p->usesStmtJournal = ((u8 ) (pParse->isMultiWrite && pParse->mayAbort)));
  if ((pParse->explain && (nMem < 10))) {
    (nMem = 10);
  }  
  memset(zCsr, 0, (zEnd - zCsr));
  (zCsr += ((zCsr - ((u8 *) 0)) & 7));
  ((void ) 0);
  (p->expired = 0);
  do {
    (nByte = 0);
    (p->aMem = allocSpace(p->aMem, (nMem * sizeof(Mem )), (&zCsr), zEnd, (&nByte)));
    (p->aVar = allocSpace(p->aVar, (nVar * sizeof(Mem )), (&zCsr), zEnd, (&nByte)));
    (p->apArg = allocSpace(p->apArg, (nArg * sizeof(Mem *)), (&zCsr), zEnd, (&nByte)));
    (p->azVar = allocSpace(p->azVar, (nVar * sizeof(char *)), (&zCsr), zEnd, (&nByte)));
    (p->apCsr = allocSpace(p->apCsr, (nCursor * sizeof(VdbeCursor *)), (&zCsr), zEnd, (&nByte)));
    (p->aOnceFlag = allocSpace(p->aOnceFlag, nOnce, (&zCsr), zEnd, (&nByte)));
    if (nByte) {
      (p->pFree = sqlite3DbMallocZero(db, nByte));
    }  
    (zCsr = p->pFree);
    (zEnd = (&zCsr[nByte]));
  } while ((nByte && (! db->mallocFailed)));
  (p->nCursor = nCursor);
  (p->nOnceFlag = nOnce);
  if (p->aVar) {
    (p->nVar = ((ynVar ) nVar));
    for ((n = 0); (n < nVar); n++) {
      (p->aVar[n].flags = 0x0001);
      (p->aVar[n].db = db);
    }
  }  
  if (p->azVar) {
    (p->nzVar = pParse->nzVar);
    memcpy(p->azVar, pParse->azVar, (p->nzVar * sizeof(p->azVar[0])));
    memset(pParse->azVar, 0, (pParse->nzVar * sizeof(pParse->azVar[0])));
  }  
  if (p->aMem) {
    p->aMem--;
    (p->nMem = nMem);
    for ((n = 1); (n <= nMem); n++) {
      (p->aMem[n].flags = 0x0080);
      (p->aMem[n].db = db);
    }
  }  
  (p->explain = pParse->explain);
  sqlite3VdbeRewind(p);
}
static  void sqlite3VdbeFreeCursor(Vdbe *p , VdbeCursor *pCx )  {
  if ((pCx == 0)) {
    return;
  }  
  sqlite3VdbeSorterClose(p->db, pCx);
  if (pCx->pBt) {
    sqlite3BtreeClose(pCx->pBt);
  } 
  else if (pCx->pCursor) {
    sqlite3BtreeCloseCursor(pCx->pCursor);
  } 
  if (pCx->pVtabCursor) {
    sqlite3_vtab_cursor *pVtabCursor =  pCx->pVtabCursor;
    const sqlite3_module *pModule =  pCx->pModule;
    (p->inVtabMethod = 1);
    pModule->xClose(pVtabCursor);
    (p->inVtabMethod = 0);
  }  
}
static  int sqlite3VdbeFrameRestore(VdbeFrame *pFrame )  {
  Vdbe *v =  pFrame->v;
  (v->aOnceFlag = pFrame->aOnceFlag);
  (v->nOnceFlag = pFrame->nOnceFlag);
  (v->aOp = pFrame->aOp);
  (v->nOp = pFrame->nOp);
  (v->aMem = pFrame->aMem);
  (v->nMem = pFrame->nMem);
  (v->apCsr = pFrame->apCsr);
  (v->nCursor = pFrame->nCursor);
  (v->db->lastRowid = pFrame->lastRowid);
  (v->nChange = pFrame->nChange);
  return pFrame->pc;
}
static  void closeAllCursors(Vdbe *p )  {
  if (p->pFrame) {
    VdbeFrame *pFrame;
    for ((pFrame = p->pFrame); pFrame->pParent; (pFrame = pFrame->pParent)) {
      
    }
    sqlite3VdbeFrameRestore(pFrame);
  }  
  (p->pFrame = 0);
  (p->nFrame = 0);
  if (p->apCsr) {
    int i;
    for ((i = 0); (i < p->nCursor); i++) {
      VdbeCursor *pC =  p->apCsr[i];
      if (pC) {
        sqlite3VdbeFreeCursor(p, pC);
        (p->apCsr[i] = 0);
      }  
    }
  }  
  if (p->aMem) {
    releaseMemArray((&p->aMem[1]), p->nMem);
  }  
  while (p->pDelFrame) {
    VdbeFrame *pDel =  p->pDelFrame;
    (p->pDelFrame = pDel->pParent);
    sqlite3VdbeFrameDelete(pDel);
  }
  sqlite3VdbeDeleteAuxData(p, (- 1), 0);
  ((void ) 0);
}
static  void Cleanup(Vdbe *p )  {
  sqlite3 *db =  p->db;
  sqlite3DbFree(db, p->zErrMsg);
  (p->zErrMsg = 0);
  (p->pResultSet = 0);
}
static  void sqlite3VdbeSetNumCols(Vdbe *p , int nResColumn )  {
  Mem *pColName;
  int n;
  sqlite3 *db =  p->db;
  if ((((! id2i_sqlite_enable_column_metadata) && (! id2i_sqlite_omit_decltype)) )) {
    releaseMemArray(p->aColName, (p->nResColumn * 2));
  }  
  if ((((! id2i_sqlite_enable_column_metadata) && id2i_sqlite_omit_decltype) )) {
    releaseMemArray(p->aColName, (p->nResColumn * 1));
  }  
  if (((id2i_sqlite_enable_column_metadata ) )) {
    releaseMemArray(p->aColName, (p->nResColumn * 5));
  }  
  sqlite3DbFree(db, p->aColName);
  if ((((! id2i_sqlite_enable_column_metadata) && (! id2i_sqlite_omit_decltype)) )) {
    (n = (nResColumn * 2));
  }  
  if ((((! id2i_sqlite_enable_column_metadata) && id2i_sqlite_omit_decltype) )) {
    (n = (nResColumn * 1));
  }  
  if (((id2i_sqlite_enable_column_metadata ) )) {
    (n = (nResColumn * 5));
  }  
  (p->nResColumn = ((u16 ) nResColumn));
  (p->aColName = (pColName = ((Mem *) sqlite3DbMallocZero(db, (sizeof(Mem ) * n)))));
  if ((p->aColName == 0)) {
    return;
  }  
  while ((n-- > 0)) {
    (pColName->flags = 0x0001);
    (pColName->db = p->db);
    pColName++;
  }
}
static  int sqlite3VdbeSetColName(Vdbe *p , int idx , int var , const  char *zName , void ( *xDel)(void * ) )  {
  int rc;
  Mem *pColName;
  ((void ) 0);
  ((void ) 0);
  if (p->db->mallocFailed) {
    ((void ) 0);
    return 7;
  }  
  ((void ) 0);
  (pColName = (&p->aColName[(idx + (var * p->nResColumn))]));
  (rc = sqlite3VdbeMemSetStr(pColName, zName, (- 1), 1, xDel));
  ((void ) 0);
  return rc;
}
static  int vdbeCommit(sqlite3 *db , Vdbe *p )  {
  int i;
  int nTrans =  0;
  int rc =  0;
  int needXcommit =  0;
  (rc = sqlite3VtabSync(db, p));
  for ((i = 0); ((rc == 0) && (i < db->nDb)); i++) {
    Btree *pBt =  db->aDb[i].pBt;
    if (sqlite3BtreeIsInTrans(pBt)) {
      (needXcommit = 1);
      if ((i != 1)) {
        nTrans++;
      }  
      sqlite3BtreeEnter(pBt);
      (rc = sqlite3PagerExclusiveLock(sqlite3BtreePager(pBt)));
    }  
  }
  if ((rc != 0)) {
    return rc;
  }  
  if ((needXcommit && db->xCommitCallback)) {
    (rc = db->xCommitCallback(db->pCommitArg));
    if (rc) {
      return (19 | (2 << 8));
    }  
  }  
  if (((0 == sqlite3Strlen30(sqlite3BtreeGetFilename(db->aDb[0].pBt))) || (nTrans <= 1))) {
    for ((i = 0); ((rc == 0) && (i < db->nDb)); i++) {
      Btree *pBt =  db->aDb[i].pBt;
      if (pBt) {
        (rc = sqlite3BtreeCommitPhaseOne(pBt, 0));
      }  
    }
    for ((i = 0); ((rc == 0) && (i < db->nDb)); i++) {
      Btree *pBt =  db->aDb[i].pBt;
      if (pBt) {
        (rc = sqlite3BtreeCommitPhaseTwo(pBt, 0));
      }  
    }
    if ((rc == 0)) {
      sqlite3VtabCommit(db);
    }  
  }  
  else {
    sqlite3_vfs *pVfs =  db->pVfs;
    int needSync =  0;
    char *zMaster =  0;
    char const *zMainFile =  sqlite3BtreeGetFilename(db->aDb[0].pBt);
    sqlite3_file *pMaster =  0;
    i64 offset =  0;
    int res;
    int retryCount =  0;
    int nMainFile;
    (nMainFile = sqlite3Strlen30(zMainFile));
    (zMaster = sqlite3MPrintf(db, "%s-mjXXXXXX9XXz", zMainFile));
    if ((zMaster == 0)) {
      return 7;
    }  
    do {
      u32 iRandom;
      if (retryCount) {
        if ((retryCount > 100)) {
          sqlite3_log(13, "MJ delete: %s", zMaster);
          sqlite3OsDelete(pVfs, zMaster, 0);
          break;
        } 
        else if ((retryCount == 1)) {
          sqlite3_log(13, "MJ collide: %s", zMaster);
        } 
      }  
      retryCount++;
      sqlite3_randomness(sizeof(iRandom), (&iRandom));
      sqlite3_snprintf(13, (&zMaster[nMainFile]), "-mj%06X9%02X", ((iRandom >> 8) & 0xffffff), (iRandom & 0xff));
      ((void ) 0);
      (rc = sqlite3OsAccess(pVfs, zMaster, 0, (&res)));
    } while (((rc == 0) && res));
    if ((rc == 0)) {
      (rc = sqlite3OsOpenMalloc(pVfs, zMaster, (&pMaster), (0x00000002 | 0x00000004 | 0x00000010 | 0x00004000), 0));
    }  
    if ((rc != 0)) {
      sqlite3DbFree(db, zMaster);
      return rc;
    }  
    for ((i = 0); (i < db->nDb); i++) {
      Btree *pBt =  db->aDb[i].pBt;
      if (sqlite3BtreeIsInTrans(pBt)) {
        char const *zFile =  sqlite3BtreeGetJournalname(pBt);
        if ((zFile == 0)) {
          continue;
        }  
        ((void ) 0);
        if (((! needSync) && (! sqlite3BtreeSyncDisabled(pBt)))) {
          (needSync = 1);
        }  
        (rc = sqlite3OsWrite(pMaster, zFile, (sqlite3Strlen30(zFile) + 1), offset));
        (offset += (sqlite3Strlen30(zFile) + 1));
        if ((rc != 0)) {
          sqlite3OsCloseFree(pMaster);
          sqlite3OsDelete(pVfs, zMaster, 0);
          sqlite3DbFree(db, zMaster);
          return rc;
        }  
      }  
    }
    if ((needSync && (0 == (sqlite3OsDeviceCharacteristics(pMaster) & 0x00000400)) && (0 != (rc = sqlite3OsSync(pMaster, 0x00002))))) {
      sqlite3OsCloseFree(pMaster);
      sqlite3OsDelete(pVfs, zMaster, 0);
      sqlite3DbFree(db, zMaster);
      return rc;
    }  
    for ((i = 0); ((rc == 0) && (i < db->nDb)); i++) {
      Btree *pBt =  db->aDb[i].pBt;
      if (pBt) {
        (rc = sqlite3BtreeCommitPhaseOne(pBt, zMaster));
      }  
    }
    sqlite3OsCloseFree(pMaster);
    ((void ) 0);
    if ((rc != 0)) {
      sqlite3DbFree(db, zMaster);
      return rc;
    }  
    (rc = sqlite3OsDelete(pVfs, zMaster, 1));
    sqlite3DbFree(db, zMaster);
    (zMaster = 0);
    if (rc) {
      return rc;
    }  
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      sqlite3BeginBenignMalloc();
    }  
    for ((i = 0); (i < db->nDb); i++) {
      Btree *pBt =  db->aDb[i].pBt;
      if (pBt) {
        sqlite3BtreeCommitPhaseTwo(pBt, 1);
      }  
    }
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      sqlite3EndBenignMalloc();
    }  
    sqlite3VtabCommit(db);
  }
  return rc;
}
static  int sqlite3VdbeCloseStatement(Vdbe *p , int eOp )  {
  sqlite3 *const db =  p->db;
  int rc =  0;
  if ((db->nStatement && p->iStatement)) {
    int i;
    const int iSavepoint =  (p->iStatement - 1);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    for ((i = 0); (i < db->nDb); i++) {
      int rc2 =  0;
      Btree *pBt =  db->aDb[i].pBt;
      if (pBt) {
        if ((eOp == 2)) {
          (rc2 = sqlite3BtreeSavepoint(pBt, 2, iSavepoint));
        }  
        if ((rc2 == 0)) {
          (rc2 = sqlite3BtreeSavepoint(pBt, 1, iSavepoint));
        }  
        if ((rc == 0)) {
          (rc = rc2);
        }  
      }  
    }
    db->nStatement--;
    (p->iStatement = 0);
    if ((rc == 0)) {
      if ((eOp == 2)) {
        (rc = sqlite3VtabSavepoint(db, 2, iSavepoint));
      }  
      if ((rc == 0)) {
        (rc = sqlite3VtabSavepoint(db, 1, iSavepoint));
      }  
    }  
    if ((eOp == 2)) {
      (db->nDeferredCons = p->nStmtDefCons);
      (db->nDeferredImmCons = p->nStmtDefImmCons);
    }  
  }  
  return rc;
}
static  int sqlite3VdbeCheckFk(Vdbe *p , int deferred )  {
  sqlite3 *db =  p->db;
  if (((deferred && ((db->nDeferredCons + db->nDeferredImmCons) > 0)) || ((! deferred) && (p->nFkConstraint > 0)))) {
    (p->rc = (19 | (3 << 8)));
    (p->errorAction = 2);
    sqlite3SetString((&p->zErrMsg), db, "foreign key constraint failed");
    return 1;
  }  
  return 0;
}
static  int sqlite3VdbeHalt(Vdbe *p )  {
  int rc;
  sqlite3 *db =  p->db;
  if (p->db->mallocFailed) {
    (p->rc = 7);
  }  
  if (p->aOnceFlag) {
    memset(p->aOnceFlag, 0, p->nOnceFlag);
  }  
  closeAllCursors(p);
  if ((p->magic != 0xbdf20da3)) {
    return 0;
  }  
  if (((p->pc >= 0) && p->bIsReader)) {
    int mrc;
    int eStatementOp =  0;
    int isSpecialError;
    (mrc = (p->rc & 0xff));
    ((void ) 0);
    (isSpecialError = ((mrc == 7) || (mrc == 10) || (mrc == 9) || (mrc == 13)));
    if (isSpecialError) {
      if (((! p->readOnly) || (mrc != 9))) {
        if ((((mrc == 7) || (mrc == 13)) && p->usesStmtJournal)) {
          (eStatementOp = 2);
        }  
        else {
          sqlite3RollbackAll(db, (4 | (2 << 8)));
          sqlite3CloseSavepoints(db);
          (db->autoCommit = 1);
        }
      }  
    }  
    if ((p->rc == 0)) {
      if (((id2i_sqlite_omit_foreign_key ) )) {
        0;
      }  
      if ((((! id2i_sqlite_omit_foreign_key) ) )) {
        sqlite3VdbeCheckFk(p, 0);
      }  
    }  
    if (((! ((db->nVTrans > 0) && (db->aVTrans == 0))) && db->autoCommit && (db->nVdbeWrite == (p->readOnly == 0)))) {
      if (((p->rc == 0) || ((p->errorAction == 3) && (! isSpecialError)))) {
        if (((id2i_sqlite_omit_foreign_key ) )) {
          (rc = 0);
        }  
        if ((((! id2i_sqlite_omit_foreign_key) ) )) {
          (rc = sqlite3VdbeCheckFk(p, 1));
        }  
        if ((rc != 0)) {
          if (((id2i_sqlite_coverage_test ) )) {
            if (0) {
              return 1;
            }  
          }  
          if ((((! id2i_sqlite_coverage_test) ) )) {
            if (p->readOnly) {
              return 1;
            }  
          }  
          (rc = (19 | (3 << 8)));
        }  
        else {
          (rc = vdbeCommit(db, p));
        }
        if (((rc == 5) && p->readOnly)) {
          return 5;
        } 
        else if ((rc != 0)) {
          (p->rc = rc);
          sqlite3RollbackAll(db, 0);
        } 
        else {
          (db->nDeferredCons = 0);
          (db->nDeferredImmCons = 0);
          (db->flags &= (~ 0x01000000));
          sqlite3CommitInternalChanges(db);
        }
      }  
      else {
        sqlite3RollbackAll(db, 0);
      }
      (db->nStatement = 0);
    } 
    else if ((eStatementOp == 0)) {
      if (((p->rc == 0) || (p->errorAction == 3))) {
        (eStatementOp = 1);
      } 
      else if ((p->errorAction == 2)) {
        (eStatementOp = 2);
      } 
      else {
        sqlite3RollbackAll(db, (4 | (2 << 8)));
        sqlite3CloseSavepoints(db);
        (db->autoCommit = 1);
      }
    } 
    if (eStatementOp) {
      (rc = sqlite3VdbeCloseStatement(p, eStatementOp));
      if (rc) {
        if (((p->rc == 0) || ((p->rc & 0xff) == 19))) {
          (p->rc = rc);
          sqlite3DbFree(db, p->zErrMsg);
          (p->zErrMsg = 0);
        }  
        sqlite3RollbackAll(db, (4 | (2 << 8)));
        sqlite3CloseSavepoints(db);
        (db->autoCommit = 1);
      }  
    }  
    if (p->changeCntOn) {
      if ((eStatementOp != 2)) {
        sqlite3VdbeSetChanges(db, p->nChange);
      }  
      else {
        sqlite3VdbeSetChanges(db, 0);
      }
      (p->nChange = 0);
    }  
  }  
  if ((p->pc >= 0)) {
    db->nVdbeActive--;
    if ((! p->readOnly)) {
      db->nVdbeWrite--;
    }  
    if (p->bIsReader) {
      db->nVdbeRead--;
    }  
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
  }  
  (p->magic = 0x519c2973);
  if (p->db->mallocFailed) {
    (p->rc = 7);
  }  
  if (db->autoCommit) {
    
  }  
  ((void ) 0);
  return ((p->rc == 5) ? 5 : 0);
}
static  void sqlite3VdbeResetStepResult(Vdbe *p )  {
  (p->rc = 0);
}
static  int sqlite3VdbeTransferError(Vdbe *p )  {
  sqlite3 *db =  p->db;
  int rc =  p->rc;
  if (p->zErrMsg) {
    u8 mallocFailed =  db->mallocFailed;
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      sqlite3BeginBenignMalloc();
    }  
    sqlite3ValueSetStr(db->pErr, (- 1), p->zErrMsg, 1, ((sqlite3_destructor_type ) (- 1)));
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      sqlite3EndBenignMalloc();
    }  
    (db->mallocFailed = mallocFailed);
    (db->errCode = rc);
  }  
  else {
    sqlite3Error(db, rc, 0);
  }
  return rc;
}
static  int sqlite3VdbeReset(Vdbe *p )  {
  sqlite3 *db;
  (db = p->db);
  sqlite3VdbeHalt(p);
  if ((p->pc >= 0)) {
    sqlite3VdbeTransferError(p);
    sqlite3DbFree(db, p->zErrMsg);
    (p->zErrMsg = 0);
    if (p->runOnlyOnce) {
      (p->expired = 1);
    }  
  } 
  else if ((p->rc && p->expired)) {
    sqlite3Error(db, p->rc, 0);
    sqlite3ValueSetStr(db->pErr, (- 1), p->zErrMsg, 1, ((sqlite3_destructor_type ) (- 1)));
    sqlite3DbFree(db, p->zErrMsg);
    (p->zErrMsg = 0);
  } 
  Cleanup(p);
  if (((id2i_vdbe_profile ) )) {
    FILE *out =  fopen("vdbe_profile.out", "a");
    if (out) {
      int i;
      fprintf(out, "---- ");
      for ((i = 0); (i < p->nOp); i++) {
        fprintf(out, "%02x", p->aOp[i].opcode);
      }
      fprintf(out, "\n");
      for ((i = 0); (i < p->nOp); i++) {
        fprintf(out, "%6d %10lld %8lld ", p->aOp[i]._1269_cnt, p->aOp[i]._1269_cycles, ((p->aOp[i]._1269_cnt > 0) ? (p->aOp[i]._1269_cycles / p->aOp[i]._1269_cnt) : 0));
        sqlite3VdbePrintOp(out, i, (&p->aOp[i]));
      }
      fclose(out);
    }  
  }  
  (p->iCurrentTime = 0);
  (p->magic = 0x26bceaa5);
  return (p->rc & db->errMask);
}
static  int sqlite3VdbeFinalize(Vdbe *p )  {
  int rc =  0;
  if (((p->magic == 0xbdf20da3) || (p->magic == 0x519c2973))) {
    (rc = sqlite3VdbeReset(p));
    ((void ) 0);
  }  
  sqlite3VdbeDelete(p);
  return rc;
}
static  void sqlite3VdbeDeleteAuxData(Vdbe *pVdbe , int iOp , int mask )  {
  AuxData **pp =  (&pVdbe->pAuxData);
  while ((*pp)) {
    AuxData *pAux =  (*pp);
    if (((iOp < 0) || ((pAux->iOp == iOp) && ((pAux->iArg > 31) || (! (mask & (((u32 ) 1) << pAux->iArg))))))) {
      if (pAux->xDelete) {
        pAux->xDelete(pAux->pAux);
      }  
      ((*pp) = pAux->pNext);
      sqlite3DbFree(pVdbe->db, pAux);
    }  
    else {
      (pp = (&pAux->pNext));
    }
  }
}
static  void sqlite3VdbeClearObject(sqlite3 *db , Vdbe *p )  {
  SubProgram *pSub, *pNext;
  int i;
  ((void ) 0);
  releaseMemArray(p->aVar, p->nVar);
  if ((((! id2i_sqlite_enable_column_metadata) && (! id2i_sqlite_omit_decltype)) )) {
    releaseMemArray(p->aColName, (p->nResColumn * 2));
  }  
  if ((((! id2i_sqlite_enable_column_metadata) && id2i_sqlite_omit_decltype) )) {
    releaseMemArray(p->aColName, (p->nResColumn * 1));
  }  
  if (((id2i_sqlite_enable_column_metadata ) )) {
    releaseMemArray(p->aColName, (p->nResColumn * 5));
  }  
  for ((pSub = p->pProgram); pSub; (pSub = pNext)) {
    (pNext = pSub->pNext);
    vdbeFreeOpArray(db, pSub->aOp, pSub->nOp);
    sqlite3DbFree(db, pSub);
  }
  for ((i = (p->nzVar - 1)); (i >= 0); i--) {
    sqlite3DbFree(db, p->azVar[i]);
  }
  vdbeFreeOpArray(db, p->aOp, p->nOp);
  sqlite3DbFree(db, p->aLabel);
  sqlite3DbFree(db, p->aColName);
  sqlite3DbFree(db, p->zSql);
  sqlite3DbFree(db, p->pFree);
  if (((id2i_sqlite_enable_tree_explain ) )) {
    sqlite3DbFree(db, p->_1276_zExplain);
  }  
  if (((id2i_sqlite_enable_tree_explain ) )) {
    sqlite3DbFree(db, p->_1276_pExplain);
  }  
}
static  void sqlite3VdbeDelete(Vdbe *p )  {
  sqlite3 *db;
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((p == 0)) {
      return;
    }  
  }  
  (db = p->db);
  ((void ) 0);
  sqlite3VdbeClearObject(db, p);
  if (p->pPrev) {
    (p->pPrev->pNext = p->pNext);
  }  
  else {
    ((void ) 0);
    (db->pVdbe = p->pNext);
  }
  if (p->pNext) {
    (p->pNext->pPrev = p->pPrev);
  }  
  (p->magic = 0xb606c3c8);
  (p->db = 0);
  sqlite3DbFree(db, p);
}
static  int sqlite3VdbeCursorMoveto(VdbeCursor *p )  {
  if (p->deferredMoveto) {
    int res, rc;
    ((void ) 0);
    (rc = sqlite3BtreeMovetoUnpacked(p->pCursor, 0, p->movetoTarget, 0, (&res)));
    if (rc) {
      return rc;
    }  
    (p->lastRowid = p->movetoTarget);
    if ((res != 0)) {
      return sqlite3CorruptError(63084);
    }  
    (p->rowidIsValid = 1);
    (p->deferredMoveto = 0);
    (p->cacheStatus = 0);
  } 
  else if ((((id2i_sqlite_coverage_test ) ) && 1)) {
    int hasMoved;
    int rc =  sqlite3BtreeCursorHasMoved(p->pCursor, (&hasMoved));
    if (rc) {
      return rc;
    }  
    if (hasMoved) {
      (p->cacheStatus = 0);
      (p->nullRow = 1);
    }  
  }
  
  else if (((((! id2i_sqlite_coverage_test) ) ) && p->pCursor)) {
    int hasMoved;
    int rc =  sqlite3BtreeCursorHasMoved(p->pCursor, (&hasMoved));
    if (rc) {
      return rc;
    }  
    if (hasMoved) {
      (p->cacheStatus = 0);
      (p->nullRow = 1);
    }  
  } 
  return 0;
}
static  u32 sqlite3VdbeSerialType(Mem *pMem , int file_format )  {
  int flags =  pMem->flags;
  int n;
  if ((flags & 0x0001)) {
    return 0;
  }  
  if ((flags & 0x0004)) {
    i64 i =  pMem->u.i;
    u64 u;
    if ((i < 0)) {
      if ((i < (- ((((i64 ) 0x00008000) << 32) - 1)))) {
        return 6;
      }  
      (u = (- i));
    }  
    else {
      (u = i);
    }
    if ((u <= 127)) {
      return ((((i & 1) == i) && (file_format >= 4)) ? (8 + ((u32 ) u)) : 1);
    }  
    if ((u <= 32767)) {
      return 2;
    }  
    if ((u <= 8388607)) {
      return 3;
    }  
    if ((u <= 2147483647)) {
      return 4;
    }  
    if ((u <= ((((i64 ) 0x00008000) << 32) - 1))) {
      return 5;
    }  
    return 6;
  }  
  if ((flags & 0x0008)) {
    return 7;
  }  
  ((void ) 0);
  (n = pMem->n);
  if ((flags & 0x4000)) {
    (n += pMem->u.nZero);
  }  
  ((void ) 0);
  return ((n * 2) + 12 + ((flags & 0x0002) != 0));
}
static  u32 sqlite3VdbeSerialTypeLen(u32 serial_type )  {
  if ((serial_type >= 12)) {
    return ((serial_type - 12) / 2);
  }  
  else {
    static const u8 aSize[] =  { 0,  1,  2,  3,  4,  6,  8,  8,  0,  0,  0,  0};
    return aSize[serial_type];
  }
}
static  u32 sqlite3VdbeSerialPut(u8 *buf , int nBuf , Mem *pMem , int file_format )  {
  u32 serial_type =  sqlite3VdbeSerialType(pMem, file_format);
  u32 len;
  if (((serial_type <= 7) && (serial_type > 0))) {
    u64 v;
    u32 i;
    if ((serial_type == 7)) {
      ((void ) 0);
      memcpy((&v), (&pMem->r), sizeof(v));
    }  
    else {
      (v = pMem->u.i);
    }
    (len = (i = sqlite3VdbeSerialTypeLen(serial_type)));
    ((void ) 0);
    while (i--) {
      (buf[i] = ((u8 ) (v & 0xFF)));
      (v >>= 8);
    }
    return len;
  }  
  if ((serial_type >= 12)) {
    ((void ) 0);
    ((void ) 0);
    (len = pMem->n);
    memcpy(buf, pMem->z, len);
    if ((pMem->flags & 0x4000)) {
      (len += pMem->u.nZero);
      ((void ) 0);
      if ((len > ((u32 ) nBuf))) {
        (len = ((u32 ) nBuf));
      }  
      memset((&buf[pMem->n]), 0, (len - pMem->n));
    }  
    return len;
  }  
  return 0;
}
static  u32 sqlite3VdbeSerialGet(const  unsigned  char *buf , u32 serial_type , Mem *pMem )  {
  switch (serial_type) {
    case 10:
    case 11:
    case 0:
    {
      (pMem->flags = 0x0001);
      break;
    }
    case 1:
    {
      (pMem->u.i = ((signed  char ) buf[0]));
      (pMem->flags = 0x0004);
      return 1;
    }
    case 2:
    {
      (pMem->u.i = ((((signed  char ) buf[0]) << 8) | buf[1]));
      (pMem->flags = 0x0004);
      return 2;
    }
    case 3:
    {
      (pMem->u.i = ((((signed  char ) buf[0]) << 16) | (buf[1] << 8) | buf[2]));
      (pMem->flags = 0x0004);
      return 3;
    }
    case 4:
    {
      (pMem->u.i = ((buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3]));
      (pMem->flags = 0x0004);
      return 4;
    }
    case 5:
    {
      u64 x =  ((((signed  char ) buf[0]) << 8) | buf[1]);
      u32 y =  ((buf[2] << 24) | (buf[3] << 16) | (buf[4] << 8) | buf[5]);
      (x = ((x << 32) | y));
      (pMem->u.i = (*((i64 *) (&x))));
      (pMem->flags = 0x0004);
      return 6;
    }
    case 6:
    case 7:
    {
      u64 x;
      u32 y;
      (x = ((buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3]));
      (y = ((buf[4] << 24) | (buf[5] << 16) | (buf[6] << 8) | buf[7]));
      (x = ((x << 32) | y));
      if ((serial_type == 6)) {
        (pMem->u.i = (*((i64 *) (&x))));
        (pMem->flags = 0x0004);
      }  
      else {
        ((void ) 0);
        memcpy((&pMem->r), (&x), sizeof(x));
        (pMem->flags = (sqlite3IsNaN(pMem->r) ? 0x0001 : 0x0008));
      }
      return 8;
    }
    case 8:
    case 9:
    {
      (pMem->u.i = (serial_type - 8));
      (pMem->flags = 0x0004);
      return 0;
    }
    id2i_label_1:
    default:
    {
      u32 len =  ((serial_type - 12) / 2);
      (pMem->z = ((char *) buf));
      (pMem->n = len);
      (pMem->xDel = 0);
      if ((serial_type & 0x01)) {
        (pMem->flags = (0x0002 | 0x1000));
      }  
      else {
        (pMem->flags = (0x0010 | 0x1000));
      }
      return len;
    }
  }
  return 0;
}
static  UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(KeyInfo *pKeyInfo , char *pSpace , int szSpace , char **ppFree )  {
  UnpackedRecord *p;
  int nOff;
  int nByte;
  (nOff = ((8 - (((int ) ((long  int ) pSpace)) & 7)) & 7));
  (nByte = (((sizeof(UnpackedRecord ) + 7) & (~ 7)) + (sizeof(Mem ) * (pKeyInfo->nField + 1))));
  if ((nByte > (szSpace + nOff))) {
    (p = ((UnpackedRecord *) sqlite3DbMallocRaw(pKeyInfo->db, nByte)));
    ((*ppFree) = ((char *) p));
    if ((! p)) {
      return 0;
    }  
  }  
  else {
    (p = ((UnpackedRecord *) (&pSpace[nOff])));
    ((*ppFree) = 0);
  }
  (p->aMem = ((Mem *) (&((char *) p)[((sizeof(UnpackedRecord ) + 7) & (~ 7))])));
  ((void ) 0);
  (p->pKeyInfo = pKeyInfo);
  (p->nField = (pKeyInfo->nField + 1));
  return p;
}
static  void sqlite3VdbeRecordUnpack(KeyInfo *pKeyInfo , int nKey , const  void *pKey , UnpackedRecord *p )  {
  const unsigned char *aKey =  ((const  unsigned  char *) pKey);
  int d;
  u32 idx;
  u16 u;
  u32 szHdr;
  Mem *pMem =  p->aMem;
  (p->flags = 0);
  ((void ) 0);
  (idx = ((u8 ) (((*aKey) < ((u8 ) 0x80)) ? (szHdr = ((u32 ) (*aKey))), 1 : sqlite3GetVarint32(aKey, ((u32 *) (&szHdr))))));
  (d = szHdr);
  (u = 0);
  while (((idx < szHdr) && (u < p->nField) && (d <= nKey))) {
    u32 serial_type;
    (idx += ((u8 ) (((*(&aKey[idx])) < ((u8 ) 0x80)) ? (serial_type = ((u32 ) (*(&aKey[idx])))), 1 : sqlite3GetVarint32((&aKey[idx]), ((u32 *) (&serial_type))))));
    (pMem->enc = pKeyInfo->enc);
    (pMem->db = pKeyInfo->db);
    (pMem->zMalloc = 0);
    (d += sqlite3VdbeSerialGet((&aKey[d]), serial_type, pMem));
    pMem++;
    u++;
  }
  ((void ) 0);
  (p->nField = u);
}
static  int sqlite3VdbeRecordCompare(int nKey1 , const  void *pKey1 , UnpackedRecord *pPKey2 )  {
  u32 d1;
  u32 idx1;
  u32 szHdr1;
  int i =  0;
  int rc =  0;
  const unsigned char *aKey1 =  ((const  unsigned  char *) pKey1);
  KeyInfo *pKeyInfo;
  Mem mem1;
  (pKeyInfo = pPKey2->pKeyInfo);
  (mem1.enc = pKeyInfo->enc);
  (mem1.db = pKeyInfo->db);
  (idx1 = ((u8 ) (((*aKey1) < ((u8 ) 0x80)) ? (szHdr1 = ((u32 ) (*aKey1))), 1 : sqlite3GetVarint32(aKey1, ((u32 *) (&szHdr1))))));
  (d1 = szHdr1);
  ((void ) 0);
  ((void ) 0);
  while (((idx1 < szHdr1) && (i < pPKey2->nField))) {
    u32 serial_type1;
    (idx1 += ((u8 ) (((*(aKey1 + idx1)) < ((u8 ) 0x80)) ? (serial_type1 = ((u32 ) (*(aKey1 + idx1)))), 1 : sqlite3GetVarint32((aKey1 + idx1), ((u32 *) (&serial_type1))))));
    if ((((d1 + serial_type1 + 2) > ((u32 ) nKey1)) && ((d1 + sqlite3VdbeSerialTypeLen(serial_type1)) > ((u32 ) nKey1)))) {
      break;
    }  
    (d1 += sqlite3VdbeSerialGet((&aKey1[d1]), serial_type1, (&mem1)));
    (rc = sqlite3MemCompare((&mem1), (&pPKey2->aMem[i]), pKeyInfo->aColl[i]));
    if ((rc != 0)) {
      ((void ) 0);
      if (pKeyInfo->aSortOrder[i]) {
        (rc = (- rc));
      }  
      if (((pPKey2->flags & 0x04) && (i == (pPKey2->nField - 1)))) {
        ((void ) 0);
        ((void ) 0);
        (pPKey2->flags &= (~ 0x04));
        (pPKey2->rowid = mem1.u.i);
      }  
      return rc;
    }  
    i++;
  }
  ((void ) 0);
  ((void ) 0);
  if ((pPKey2->flags & 0x01)) {
    (rc = (- 1));
  } 
  else if ((pPKey2->flags & 0x02)) {
    
  }
  
  else if ((idx1 < szHdr1)) {
    (rc = 1);
  } 
  return rc;
}
static  int sqlite3VdbeIdxRowid(sqlite3 *db , BtCursor *pCur , i64 *rowid )  {
  i64 nCellKey =  0;
  int rc;
  u32 szHdr;
  u32 typeRowid;
  u32 lenRowid;
  Mem m, v;
  ((void ) db);
  ((void ) 0);
  sqlite3BtreeKeySize(pCur, (&nCellKey));
  ((void ) 0);
  ((void ) 0);
  memset((&m), 0, sizeof(m));
  (rc = sqlite3VdbeMemFromBtree(pCur, 0, ((int ) nCellKey), 1, (&m)));
  if (rc) {
    return rc;
  }  
  ((void ) ((u8 ) (((*((u8 *) m.z)) < ((u8 ) 0x80)) ? (szHdr = ((u32 ) (*((u8 *) m.z)))), 1 : sqlite3GetVarint32(((u8 *) m.z), ((u32 *) (&szHdr))))));
  if (((id2i_sqlite_coverage_test ) )) {
    if ((szHdr == 3)) {
      sqlite3Coverage(63661);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((szHdr == m.n)) {
      sqlite3Coverage(63662);
    }  
  }  
  if (((szHdr < 3) || (((int ) szHdr) > m.n))) {
    goto idx_rowid_corruption;
  }  
  ((void ) ((u8 ) (((*((u8 *) (&m.z[(szHdr - 1)]))) < ((u8 ) 0x80)) ? (typeRowid = ((u32 ) (*((u8 *) (&m.z[(szHdr - 1)]))))), 1 : sqlite3GetVarint32(((u8 *) (&m.z[(szHdr - 1)])), ((u32 *) (&typeRowid))))));
  if (((id2i_sqlite_coverage_test ) )) {
    if ((typeRowid == 1)) {
      sqlite3Coverage(63670);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((typeRowid == 2)) {
      sqlite3Coverage(63671);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((typeRowid == 3)) {
      sqlite3Coverage(63672);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((typeRowid == 4)) {
      sqlite3Coverage(63673);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((typeRowid == 5)) {
      sqlite3Coverage(63674);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((typeRowid == 6)) {
      sqlite3Coverage(63675);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((typeRowid == 8)) {
      sqlite3Coverage(63676);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((typeRowid == 9)) {
      sqlite3Coverage(63677);
    }  
  }  
  if (((typeRowid < 1) || (typeRowid > 9) || (typeRowid == 7))) {
    goto idx_rowid_corruption;
  }  
  (lenRowid = sqlite3VdbeSerialTypeLen(typeRowid));
  if (((id2i_sqlite_coverage_test ) )) {
    if ((((u32 ) m.n) == (szHdr + lenRowid))) {
      sqlite3Coverage(63682);
    }  
  }  
  if ((((u32 ) m.n) < (szHdr + lenRowid))) {
    goto idx_rowid_corruption;
  }  
  sqlite3VdbeSerialGet(((u8 *) (&m.z[(m.n - lenRowid)])), typeRowid, (&v));
  ((*rowid) = v.u.i);
  sqlite3VdbeMemRelease((&m));
  return 0;
  idx_rowid_corruption:
  if (((id2i_sqlite_coverage_test ) )) {
    if ((m.zMalloc != 0)) {
      sqlite3Coverage(63696);
    }  
  }  
  sqlite3VdbeMemRelease((&m));
  return sqlite3CorruptError(63698);
}
static  int sqlite3VdbeIdxKeyCompare(VdbeCursor *pC , UnpackedRecord *pUnpacked , int *res )  {
  i64 nCellKey =  0;
  int rc;
  BtCursor *pCur =  pC->pCursor;
  Mem m;
  ((void ) 0);
  sqlite3BtreeKeySize(pCur, (&nCellKey));
  ((void ) 0);
  if (((nCellKey <= 0) || (nCellKey > 0x7fffffff))) {
    ((*res) = 0);
    return sqlite3CorruptError(63729);
  }  
  memset((&m), 0, sizeof(m));
  (rc = sqlite3VdbeMemFromBtree(pC->pCursor, 0, ((int ) nCellKey), 1, (&m)));
  if (rc) {
    return rc;
  }  
  ((void ) 0);
  ((*res) = sqlite3VdbeRecordCompare(m.n, m.z, pUnpacked));
  sqlite3VdbeMemRelease((&m));
  return 0;
}
static  void sqlite3VdbeSetChanges(sqlite3 *db , int nChange )  {
  ((void ) 0);
  (db->nChange = nChange);
  (db->nTotalChange += nChange);
}
static  void sqlite3VdbeCountChanges(Vdbe *v )  {
  (v->changeCntOn = 1);
}
static  void sqlite3ExpirePreparedStatements(sqlite3 *db )  {
  Vdbe *p;
  for ((p = db->pVdbe); p; (p = p->pNext)) {
    (p->expired = 1);
  }
}
static  sqlite3 *sqlite3VdbeDb(Vdbe *v )  {
  return v->db;
}
static  sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe *v , int iVar , u8 aff )  {
  ((void ) 0);
  if (v) {
    Mem *pMem =  (&v->aVar[(iVar - 1)]);
    if ((0 == (pMem->flags & 0x0001))) {
      sqlite3_value *pRet =  sqlite3ValueNew(v->db);
      if (pRet) {
        sqlite3VdbeMemCopy(((Mem *) pRet), pMem);
        sqlite3ValueApplyAffinity(pRet, aff, 1);
        sqlite3VdbeMemStoreType(((Mem *) pRet));
      }  
      return pRet;
    }  
  }  
  return 0;
}
static  void sqlite3VdbeSetVarmask(Vdbe *v , int iVar )  {
  ((void ) 0);
  if ((iVar > 32)) {
    (v->expmask = 0xffffffff);
  }  
  else {
    (v->expmask |= (((u32 ) 1) << (iVar - 1)));
  }
}
static  void sqlite3VtabImportErrmsg(Vdbe *p , sqlite3_vtab *pVtab )  {
  sqlite3 *db =  p->db;
  sqlite3DbFree(db, p->zErrMsg);
  (p->zErrMsg = sqlite3DbStrDup(db, pVtab->zErrMsg));
  sqlite3_free(pVtab->zErrMsg);
  (pVtab->zErrMsg = 0);
}
int sqlite3_expired(sqlite3_stmt *pStmt )  {
  Vdbe *p =  ((Vdbe *) pStmt);
  return ((p == 0) || p->expired);
}
static  int vdbeSafety(Vdbe *p )  {
  if ((p->db == 0)) {
    sqlite3_log(21, "API called with finalized prepared statement");
    return 1;
  }  
  else {
    return 0;
  }
}
static  int vdbeSafetyNotNull(Vdbe *p )  {
  if ((p == 0)) {
    sqlite3_log(21, "API called with NULL prepared statement");
    return 1;
  }  
  else {
    return vdbeSafety(p);
  }
}
int sqlite3_finalize(sqlite3_stmt *pStmt )  {
  int rc;
  if ((pStmt == 0)) {
    (rc = 0);
  }  
  else {
    Vdbe *v =  ((Vdbe *) pStmt);
    sqlite3 *db =  v->db;
    if (vdbeSafety(v)) {
      return sqlite3MisuseError(63911);
    }  
    (rc = sqlite3VdbeFinalize(v));
    (rc = sqlite3ApiExit(db, rc));
    sqlite3LeaveMutexAndCloseZombie(db);
  }
  return rc;
}
int sqlite3_reset(sqlite3_stmt *pStmt )  {
  int rc;
  if ((pStmt == 0)) {
    (rc = 0);
  }  
  else {
    Vdbe *v =  ((Vdbe *) pStmt);
    (rc = sqlite3VdbeReset(v));
    sqlite3VdbeRewind(v);
    ((void ) 0);
    (rc = sqlite3ApiExit(v->db, rc));
  }
  return rc;
}
int sqlite3_clear_bindings(sqlite3_stmt *pStmt )  {
  int i;
  int rc =  0;
  Vdbe *p =  ((Vdbe *) pStmt);
  for ((i = 0); (i < p->nVar); i++) {
    sqlite3VdbeMemRelease((&p->aVar[i]));
    (p->aVar[i].flags = 0x0001);
  }
  if ((p->isPrepareV2 && p->expmask)) {
    (p->expired = 1);
  }  
  return rc;
}
const  void *sqlite3_value_blob(sqlite3_value *pVal )  {
  Mem *p =  ((Mem *) pVal);
  if ((p->flags & (0x0010 | 0x0002))) {
    sqlite3VdbeMemExpandBlob(p);
    (p->flags &= (~ 0x0002));
    (p->flags |= 0x0010);
    return (p->n ? p->z : 0);
  }  
  else {
    return sqlite3_value_text(pVal);
  }
}
int sqlite3_value_bytes(sqlite3_value *pVal )  {
  return sqlite3ValueBytes(pVal, 1);
}
int sqlite3_value_bytes16(sqlite3_value *pVal )  {
  return sqlite3ValueBytes(pVal, 2);
}
double sqlite3_value_double(sqlite3_value *pVal )  {
  return sqlite3VdbeRealValue(((Mem *) pVal));
}
int sqlite3_value_int(sqlite3_value *pVal )  {
  return ((int ) sqlite3VdbeIntValue(((Mem *) pVal)));
}
sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal )  {
  return sqlite3VdbeIntValue(((Mem *) pVal));
}
const  unsigned  char *sqlite3_value_text(sqlite3_value *pVal )  {
  return ((const  unsigned  char *) sqlite3ValueText(pVal, 1));
}
const  void *sqlite3_value_text16(sqlite3_value *pVal )  {
  return sqlite3ValueText(pVal, 2);
}
const  void *sqlite3_value_text16be(sqlite3_value *pVal )  {
  return sqlite3ValueText(pVal, 3);
}
const  void *sqlite3_value_text16le(sqlite3_value *pVal )  {
  return sqlite3ValueText(pVal, 2);
}
int sqlite3_value_type(sqlite3_value *pVal )  {
  return pVal->type;
}
static  void setResultStrOrError(sqlite3_context *pCtx , const  char *z , int n , u8 enc , void ( *xDel)(void * ) )  {
  if ((sqlite3VdbeMemSetStr((&pCtx->s), z, n, enc, xDel) == 18)) {
    sqlite3_result_error_toobig(pCtx);
  }  
}
void sqlite3_result_blob(sqlite3_context *pCtx , const  void *z , int n , void ( *xDel)(void * ) )  {
  ((void ) 0);
  ((void ) 0);
  setResultStrOrError(pCtx, z, n, 0, xDel);
}
void sqlite3_result_double(sqlite3_context *pCtx , double rVal )  {
  ((void ) 0);
  sqlite3VdbeMemSetDouble((&pCtx->s), rVal);
}
void sqlite3_result_error(sqlite3_context *pCtx , const  char *z , int n )  {
  ((void ) 0);
  (pCtx->isError = 1);
  (pCtx->fErrorOrAux = 1);
  sqlite3VdbeMemSetStr((&pCtx->s), z, n, 1, ((sqlite3_destructor_type ) (- 1)));
}
void sqlite3_result_error16(sqlite3_context *pCtx , const  void *z , int n )  {
  ((void ) 0);
  (pCtx->isError = 1);
  (pCtx->fErrorOrAux = 1);
  sqlite3VdbeMemSetStr((&pCtx->s), z, n, 2, ((sqlite3_destructor_type ) (- 1)));
}
void sqlite3_result_int(sqlite3_context *pCtx , int iVal )  {
  ((void ) 0);
  sqlite3VdbeMemSetInt64((&pCtx->s), ((i64 ) iVal));
}
void sqlite3_result_int64(sqlite3_context *pCtx , i64 iVal )  {
  ((void ) 0);
  sqlite3VdbeMemSetInt64((&pCtx->s), iVal);
}
void sqlite3_result_null(sqlite3_context *pCtx )  {
  ((void ) 0);
  sqlite3VdbeMemSetNull((&pCtx->s));
}
void sqlite3_result_text(sqlite3_context *pCtx , const  char *z , int n , void ( *xDel)(void * ) )  {
  ((void ) 0);
  setResultStrOrError(pCtx, z, n, 1, xDel);
}
void sqlite3_result_text16(sqlite3_context *pCtx , const  void *z , int n , void ( *xDel)(void * ) )  {
  ((void ) 0);
  setResultStrOrError(pCtx, z, n, 2, xDel);
}
void sqlite3_result_text16be(sqlite3_context *pCtx , const  void *z , int n , void ( *xDel)(void * ) )  {
  ((void ) 0);
  setResultStrOrError(pCtx, z, n, 3, xDel);
}
void sqlite3_result_text16le(sqlite3_context *pCtx , const  void *z , int n , void ( *xDel)(void * ) )  {
  ((void ) 0);
  setResultStrOrError(pCtx, z, n, 2, xDel);
}
void sqlite3_result_value(sqlite3_context *pCtx , sqlite3_value *pValue )  {
  ((void ) 0);
  sqlite3VdbeMemCopy((&pCtx->s), pValue);
}
void sqlite3_result_zeroblob(sqlite3_context *pCtx , int n )  {
  ((void ) 0);
  sqlite3VdbeMemSetZeroBlob((&pCtx->s), n);
}
void sqlite3_result_error_code(sqlite3_context *pCtx , int errCode )  {
  (pCtx->isError = errCode);
  (pCtx->fErrorOrAux = 1);
  if ((pCtx->s.flags & 0x0001)) {
    sqlite3VdbeMemSetStr((&pCtx->s), sqlite3ErrStr(errCode), (- 1), 1, ((sqlite3_destructor_type ) 0));
  }  
}
void sqlite3_result_error_toobig(sqlite3_context *pCtx )  {
  ((void ) 0);
  (pCtx->isError = 18);
  (pCtx->fErrorOrAux = 1);
  sqlite3VdbeMemSetStr((&pCtx->s), "string or blob too big", (- 1), 1, ((sqlite3_destructor_type ) 0));
}
void sqlite3_result_error_nomem(sqlite3_context *pCtx )  {
  ((void ) 0);
  sqlite3VdbeMemSetNull((&pCtx->s));
  (pCtx->isError = 7);
  (pCtx->fErrorOrAux = 1);
  (pCtx->s.db->mallocFailed = 1);
}
static  int doWalCallbacks(sqlite3 *db )  {
  int rc =  0;
  int i;
  for ((i = 0); (i < db->nDb); i++) {
    Btree *pBt =  db->aDb[i].pBt;
    if (pBt) {
      int nEntry =  sqlite3PagerWalCallback(sqlite3BtreePager(pBt));
      if ((db->xWalCallback && (nEntry > 0) && (rc == 0))) {
        (rc = db->xWalCallback(db->pWalArg, db, db->aDb[i].zName, nEntry));
      }  
    }  
  }
  return rc;
}
static  int sqlite3Step(Vdbe *p )  {
  sqlite3 *db;
  int rc;
  ((void ) 0);
  if ((p->magic != 0xbdf20da3)) {
    sqlite3_reset(((sqlite3_stmt *) p));
  }  
  (db = p->db);
  if (db->mallocFailed) {
    (p->rc = 7);
    return 7;
  }  
  if (((p->pc <= 0) && p->expired)) {
    (p->rc = 17);
    (rc = 1);
    goto end_of_step;
  }  
  if ((p->pc < 0)) {
    if ((db->nVdbeActive == 0)) {
      (db->u1.isInterrupted = 0);
    }  
    ((void ) 0);
    if ((db->xProfile && (! db->init.busy))) {
      sqlite3OsCurrentTimeInt64(db->pVfs, (&p->startTime));
    }  
    db->nVdbeActive++;
    if ((p->readOnly == 0)) {
      db->nVdbeWrite++;
    }  
    if (p->bIsReader) {
      db->nVdbeRead++;
    }  
    (p->pc = 0);
  }  
  if ((((! id2i_sqlite_omit_explain) ) )) {
    if (p->explain) {
      (rc = sqlite3VdbeList(p));
    }  
    else {
      db->nVdbeExec++;
      (rc = _1319_sqlite3VdbeExec(p));
      db->nVdbeExec--;
    }
  }  
  if (((id2i_sqlite_omit_explain ) )) {
    db->nVdbeExec++;
    (rc = _1319_sqlite3VdbeExec(p));
    db->nVdbeExec--;
  }  
  if (((rc != 100) && db->xProfile && (! db->init.busy) && p->zSql)) {
    sqlite3_int64 iNow;
    sqlite3OsCurrentTimeInt64(db->pVfs, (&iNow));
    db->xProfile(db->pProfileArg, p->zSql, ((iNow - p->startTime) * 1000000));
  }  
  if ((rc == 101)) {
    ((void ) 0);
    (p->rc = doWalCallbacks(db));
    if ((p->rc != 0)) {
      (rc = 1);
    }  
  }  
  (db->errCode = rc);
  if ((7 == sqlite3ApiExit(p->db, p->rc))) {
    (p->rc = 7);
  }  
  end_of_step:
  ((void ) 0);
  ((void ) 0);
  if ((p->isPrepareV2 && (rc != 100) && (rc != 101))) {
    (rc = sqlite3VdbeTransferError(p));
  }  
  return (rc & db->errMask);
}
int sqlite3_step(sqlite3_stmt *pStmt )  {
  int rc =  0;
  int rc2 =  0;
  Vdbe *v =  ((Vdbe *) pStmt);
  int cnt =  0;
  sqlite3 *db;
  if (vdbeSafetyNotNull(v)) {
    return sqlite3MisuseError(64314);
  }  
  (db = v->db);
  (v->doingRerun = 0);
  while ((((rc = sqlite3Step(v)) == 17) && (cnt++ < 50) && ((rc2 = (rc = sqlite3Reprepare(v))) == 0))) {
    sqlite3_reset(pStmt);
    (v->doingRerun = 1);
    ((void ) 0);
  }
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((rc2 != 0) && v->isPrepareV2 && db->pErr)) {
      const char *zErr =  ((const  char *) sqlite3_value_text(db->pErr));
      sqlite3DbFree(db, v->zErrMsg);
      if ((! db->mallocFailed)) {
        (v->zErrMsg = sqlite3DbStrDup(db, zErr));
        (v->rc = rc2);
      }  
      else {
        (v->zErrMsg = 0);
        (v->rc = (rc = 7));
      }
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((rc2 != 0) && 1 && 1)) {
      const char *zErr =  ((const  char *) sqlite3_value_text(db->pErr));
      sqlite3DbFree(db, v->zErrMsg);
      if ((! db->mallocFailed)) {
        (v->zErrMsg = sqlite3DbStrDup(db, zErr));
        (v->rc = rc2);
      }  
      else {
        (v->zErrMsg = 0);
        (v->rc = (rc = 7));
      }
    }  
  }  
  (rc = sqlite3ApiExit(db, rc));
  return rc;
}
void *sqlite3_user_data(sqlite3_context *p )  {
  ((void ) 0);
  return p->pFunc->pUserData;
}
sqlite3 *sqlite3_context_db_handle(sqlite3_context *p )  {
  ((void ) 0);
  return p->s.db;
}
static  sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context *p )  {
  Vdbe *v =  p->pVdbe;
  int rc;
  if ((v->iCurrentTime == 0)) {
    (rc = sqlite3OsCurrentTimeInt64(p->s.db->pVfs, (&v->iCurrentTime)));
    if (rc) {
      (v->iCurrentTime = 0);
    }  
  }  
  return v->iCurrentTime;
}
static  void sqlite3InvalidFunction(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 )  {
  const char *zName =  context->pFunc->zName;
  char *zErr;
  ((void ) NotUsed), ((void ) NotUsed2);
  (zErr = sqlite3_mprintf("unable to use function %s in the requested context", zName));
  sqlite3_result_error(context, zErr, (- 1));
  sqlite3_free(zErr);
}
void *sqlite3_aggregate_context(sqlite3_context *p , int nByte )  {
  Mem *pMem;
  ((void ) 0);
  ((void ) 0);
  (pMem = p->pMem);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((nByte < 0)) {
      sqlite3Coverage(64420);
    }  
  }  
  if (((pMem->flags & 0x2000) == 0)) {
    if ((nByte <= 0)) {
      sqlite3VdbeMemReleaseExternal(pMem);
      (pMem->flags = 0x0001);
      (pMem->z = 0);
    }  
    else {
      sqlite3VdbeMemGrow(pMem, nByte, 0);
      (pMem->flags = 0x2000);
      (pMem->u.pDef = p->pFunc);
      if (pMem->z) {
        memset(pMem->z, 0, nByte);
      }  
    }
  }  
  return ((void *) pMem->z);
}
void *sqlite3_get_auxdata(sqlite3_context *pCtx , int iArg )  {
  AuxData *pAuxData;
  ((void ) 0);
  for ((pAuxData = pCtx->pVdbe->pAuxData); pAuxData; (pAuxData = pAuxData->pNext)) {
    if (((pAuxData->iOp == pCtx->iOp) && (pAuxData->iArg == iArg))) {
      break;
    }  
  }
  return (pAuxData ? pAuxData->pAux : 0);
}
void sqlite3_set_auxdata(sqlite3_context *pCtx , int iArg , void *pAux , void ( *xDelete)(void * ) )  {
  AuxData *pAuxData;
  Vdbe *pVdbe =  pCtx->pVdbe;
  ((void ) 0);
  if ((iArg < 0)) {
    goto failed;
  }  
  for ((pAuxData = pVdbe->pAuxData); pAuxData; (pAuxData = pAuxData->pNext)) {
    if (((pAuxData->iOp == pCtx->iOp) && (pAuxData->iArg == iArg))) {
      break;
    }  
  }
  if ((pAuxData == 0)) {
    (pAuxData = sqlite3DbMallocZero(pVdbe->db, sizeof(AuxData )));
    if ((! pAuxData)) {
      goto failed;
    }  
    (pAuxData->iOp = pCtx->iOp);
    (pAuxData->iArg = iArg);
    (pAuxData->pNext = pVdbe->pAuxData);
    (pVdbe->pAuxData = pAuxData);
    if ((pCtx->fErrorOrAux == 0)) {
      (pCtx->isError = 0);
      (pCtx->fErrorOrAux = 1);
    }  
  } 
  else if (pAuxData->xDelete) {
    pAuxData->xDelete(pAuxData->pAux);
  } 
  (pAuxData->pAux = pAux);
  (pAuxData->xDelete = xDelete);
  return;
  failed:
  if (xDelete) {
    xDelete(pAux);
  }  
}
int sqlite3_aggregate_count(sqlite3_context *p )  {
  ((void ) 0);
  return p->pMem->n;
}
int sqlite3_column_count(sqlite3_stmt *pStmt )  {
  Vdbe *pVm =  ((Vdbe *) pStmt);
  return (pVm ? pVm->nResColumn : 0);
}
int sqlite3_data_count(sqlite3_stmt *pStmt )  {
  Vdbe *pVm =  ((Vdbe *) pStmt);
  if (((pVm == 0) || (pVm->pResultSet == 0))) {
    return 0;
  }  
  return pVm->nResColumn;
}
static  Mem *columnMem(sqlite3_stmt *pStmt , int i )  {
  Vdbe *pVm;
  Mem *pOut;
  (pVm = ((Vdbe *) pStmt));
  if ((pVm && (pVm->pResultSet != 0) && (i < pVm->nResColumn) && (i >= 0))) {
    (pOut = (&pVm->pResultSet[i]));
  }  
  else {
    static const Mem nullMem =  { 0,  "",  ((double ) 0),  { 0},  0,  0x0001,  5,  0,  0,  0};
    if ((((! id2i_sqlite_coverage_test) ) )) {
      if ((pVm && pVm->db)) {
        sqlite3Error(pVm->db, 25, 0);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pVm && 1)) {
        sqlite3Error(pVm->db, 25, 0);
      }  
    }  
    (pOut = ((Mem *) (&nullMem)));
  }
  return pOut;
}
static  void columnMallocFailure(sqlite3_stmt *pStmt )  {
  Vdbe *p =  ((Vdbe *) pStmt);
  if (p) {
    (p->rc = sqlite3ApiExit(p->db, p->rc));
  }  
}
const  void *sqlite3_column_blob(sqlite3_stmt *pStmt , int i )  {
  const void *val;
  (val = sqlite3_value_blob(columnMem(pStmt, i)));
  columnMallocFailure(pStmt);
  return val;
}
int sqlite3_column_bytes(sqlite3_stmt *pStmt , int i )  {
  int val =  sqlite3_value_bytes(columnMem(pStmt, i));
  columnMallocFailure(pStmt);
  return val;
}
int sqlite3_column_bytes16(sqlite3_stmt *pStmt , int i )  {
  int val =  sqlite3_value_bytes16(columnMem(pStmt, i));
  columnMallocFailure(pStmt);
  return val;
}
double sqlite3_column_double(sqlite3_stmt *pStmt , int i )  {
  double val =  sqlite3_value_double(columnMem(pStmt, i));
  columnMallocFailure(pStmt);
  return val;
}
int sqlite3_column_int(sqlite3_stmt *pStmt , int i )  {
  int val =  sqlite3_value_int(columnMem(pStmt, i));
  columnMallocFailure(pStmt);
  return val;
}
sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt , int i )  {
  sqlite_int64 val =  sqlite3_value_int64(columnMem(pStmt, i));
  columnMallocFailure(pStmt);
  return val;
}
const  unsigned  char *sqlite3_column_text(sqlite3_stmt *pStmt , int i )  {
  const unsigned char *val =  sqlite3_value_text(columnMem(pStmt, i));
  columnMallocFailure(pStmt);
  return val;
}
sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt , int i )  {
  Mem *pOut =  columnMem(pStmt, i);
  if ((pOut->flags & 0x0800)) {
    (pOut->flags &= (~ 0x0800));
    (pOut->flags |= 0x1000);
  }  
  columnMallocFailure(pStmt);
  return ((sqlite3_value *) pOut);
}
const  void *sqlite3_column_text16(sqlite3_stmt *pStmt , int i )  {
  const void *val =  sqlite3_value_text16(columnMem(pStmt, i));
  columnMallocFailure(pStmt);
  return val;
}
int sqlite3_column_type(sqlite3_stmt *pStmt , int i )  {
  int iType =  sqlite3_value_type(columnMem(pStmt, i));
  columnMallocFailure(pStmt);
  return iType;
}
static  const  void *columnName(sqlite3_stmt *pStmt , int N , const  void *( *xFunc)(Mem * ) , int useType )  {
  const void *ret =  0;
  Vdbe *p =  ((Vdbe *) pStmt);
  int n;
  sqlite3 *db =  p->db;
  ((void ) 0);
  (n = sqlite3_column_count(pStmt));
  if (((N < n) && (N >= 0))) {
    (N += (useType * n));
    ((void ) 0);
    (ret = xFunc((&p->aColName[N])));
    if (db->mallocFailed) {
      (db->mallocFailed = 0);
      (ret = 0);
    }  
  }  
  return ret;
}
const  char *sqlite3_column_name(sqlite3_stmt *pStmt , int N )  {
  return columnName(pStmt, N, ((const  void *( *)(Mem * )) sqlite3_value_text), 0);
}
const  void *sqlite3_column_name16(sqlite3_stmt *pStmt , int N )  {
  return columnName(pStmt, N, ((const  void *( *)(Mem * )) sqlite3_value_text16), 0);
}
const  char *sqlite3_column_decltype(sqlite3_stmt *pStmt , int N )  {
  return columnName(pStmt, N, ((const  void *( *)(Mem * )) sqlite3_value_text), 1);
}
const  void *sqlite3_column_decltype16(sqlite3_stmt *pStmt , int N )  {
  return columnName(pStmt, N, ((const  void *( *)(Mem * )) sqlite3_value_text16), 1);
}
const  char *sqlite3_column_database_name(sqlite3_stmt *pStmt , int N )  {
  return columnName(pStmt, N, ((const  void *( *)(Mem * )) sqlite3_value_text), 2);
}
const  void *sqlite3_column_database_name16(sqlite3_stmt *pStmt , int N )  {
  return columnName(pStmt, N, ((const  void *( *)(Mem * )) sqlite3_value_text16), 2);
}
const  char *sqlite3_column_table_name(sqlite3_stmt *pStmt , int N )  {
  return columnName(pStmt, N, ((const  void *( *)(Mem * )) sqlite3_value_text), 3);
}
const  void *sqlite3_column_table_name16(sqlite3_stmt *pStmt , int N )  {
  return columnName(pStmt, N, ((const  void *( *)(Mem * )) sqlite3_value_text16), 3);
}
const  char *sqlite3_column_origin_name(sqlite3_stmt *pStmt , int N )  {
  return columnName(pStmt, N, ((const  void *( *)(Mem * )) sqlite3_value_text), 4);
}
const  void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt , int N )  {
  return columnName(pStmt, N, ((const  void *( *)(Mem * )) sqlite3_value_text16), 4);
}
static  int vdbeUnbind(Vdbe *p , int i )  {
  Mem *pVar;
  if (vdbeSafetyNotNull(p)) {
    return sqlite3MisuseError(64832);
  }  
  if (((p->magic != 0xbdf20da3) || (p->pc >= 0))) {
    sqlite3Error(p->db, 21, 0);
    sqlite3_log(21, "bind on a busy prepared statement: [%s]", p->zSql);
    return sqlite3MisuseError(64840);
  }  
  if (((i < 1) || (i > p->nVar))) {
    sqlite3Error(p->db, 25, 0);
    return 25;
  }  
  i--;
  (pVar = (&p->aVar[i]));
  sqlite3VdbeMemRelease(pVar);
  (pVar->flags = 0x0001);
  sqlite3Error(p->db, 0, 0);
  if ((p->isPrepareV2 && (((i < 32) && (p->expmask & (((u32 ) 1) << i))) || (p->expmask == 0xffffffff)))) {
    (p->expired = 1);
  }  
  return 0;
}
static  int bindText(sqlite3_stmt *pStmt , int i , const  void *zData , int nData , void ( *xDel)(void * ) , u8 encoding )  {
  Vdbe *p =  ((Vdbe *) pStmt);
  Mem *pVar;
  int rc;
  (rc = vdbeUnbind(p, i));
  if ((rc == 0)) {
    if ((zData != 0)) {
      (pVar = (&p->aVar[(i - 1)]));
      (rc = sqlite3VdbeMemSetStr(pVar, zData, nData, encoding, xDel));
      if (((rc == 0) && (encoding != 0))) {
        (rc = sqlite3VdbeChangeEncoding(pVar, p->db->aDb[0].pSchema->enc));
      }  
      sqlite3Error(p->db, rc, 0);
      (rc = sqlite3ApiExit(p->db, rc));
    }  
  } 
  else if (((xDel != ((sqlite3_destructor_type ) 0)) && (xDel != ((sqlite3_destructor_type ) (- 1))))) {
    xDel(((void *) zData));
  } 
  return rc;
}
int sqlite3_bind_blob(sqlite3_stmt *pStmt , int i , const  void *zData , int nData , void ( *xDel)(void * ) )  {
  return bindText(pStmt, i, zData, nData, xDel, 0);
}
int sqlite3_bind_double(sqlite3_stmt *pStmt , int i , double rValue )  {
  int rc;
  Vdbe *p =  ((Vdbe *) pStmt);
  (rc = vdbeUnbind(p, i));
  if ((rc == 0)) {
    sqlite3VdbeMemSetDouble((&p->aVar[(i - 1)]), rValue);
  }  
  return rc;
}
int sqlite3_bind_int(sqlite3_stmt *p , int i , int iValue )  {
  return sqlite3_bind_int64(p, i, ((i64 ) iValue));
}
int sqlite3_bind_int64(sqlite3_stmt *pStmt , int i , sqlite_int64 iValue )  {
  int rc;
  Vdbe *p =  ((Vdbe *) pStmt);
  (rc = vdbeUnbind(p, i));
  if ((rc == 0)) {
    sqlite3VdbeMemSetInt64((&p->aVar[(i - 1)]), iValue);
  }  
  return rc;
}
int sqlite3_bind_null(sqlite3_stmt *pStmt , int i )  {
  int rc;
  Vdbe *p =  ((Vdbe *) pStmt);
  (rc = vdbeUnbind(p, i));
  if ((rc == 0)) {
    
  }  
  return rc;
}
int sqlite3_bind_text(sqlite3_stmt *pStmt , int i , const  char *zData , int nData , void ( *xDel)(void * ) )  {
  return bindText(pStmt, i, zData, nData, xDel, 1);
}
int sqlite3_bind_text16(sqlite3_stmt *pStmt , int i , const  void *zData , int nData , void ( *xDel)(void * ) )  {
  return bindText(pStmt, i, zData, nData, xDel, 2);
}
int sqlite3_bind_value(sqlite3_stmt *pStmt , int i , const  sqlite3_value *pValue )  {
  int rc;
  switch (pValue->type) {
    case 1:
    {
      (rc = sqlite3_bind_int64(pStmt, i, pValue->u.i));
      break;
    }
    case 2:
    {
      (rc = sqlite3_bind_double(pStmt, i, pValue->r));
      break;
    }
    case 4:
    {
      if ((pValue->flags & 0x4000)) {
        (rc = sqlite3_bind_zeroblob(pStmt, i, pValue->u.nZero));
      }  
      else {
        (rc = sqlite3_bind_blob(pStmt, i, pValue->z, pValue->n, ((sqlite3_destructor_type ) (- 1))));
      }
      break;
    }
    case 3:
    {
      (rc = bindText(pStmt, i, pValue->z, pValue->n, ((sqlite3_destructor_type ) (- 1)), pValue->enc));
      break;
    }
    id2i_label_1:
    default:
    {
      (rc = sqlite3_bind_null(pStmt, i));
      break;
    }
  }
  return rc;
}
int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt , int i , int n )  {
  int rc;
  Vdbe *p =  ((Vdbe *) pStmt);
  (rc = vdbeUnbind(p, i));
  if ((rc == 0)) {
    sqlite3VdbeMemSetZeroBlob((&p->aVar[(i - 1)]), n);
  }  
  return rc;
}
int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt )  {
  Vdbe *p =  ((Vdbe *) pStmt);
  return (p ? p->nVar : 0);
}
const  char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt , int i )  {
  Vdbe *p =  ((Vdbe *) pStmt);
  if (((p == 0) || (i < 1) || (i > p->nzVar))) {
    return 0;
  }  
  return p->azVar[(i - 1)];
}
static  int sqlite3VdbeParameterIndex(Vdbe *p , const  char *zName , int nName )  {
  int i;
  if ((p == 0)) {
    return 0;
  }  
  if (zName) {
    for ((i = 0); (i < p->nzVar); i++) {
      const char *z =  p->azVar[i];
      if ((z && (strncmp(z, zName, nName) == 0) && (z[nName] == 0))) {
        return (i + 1);
      }  
    }
  }  
  return 0;
}
int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt , const  char *zName )  {
  return sqlite3VdbeParameterIndex(((Vdbe *) pStmt), zName, sqlite3Strlen30(zName));
}
static  int sqlite3TransferBindings(sqlite3_stmt *pFromStmt , sqlite3_stmt *pToStmt )  {
  Vdbe *pFrom =  ((Vdbe *) pFromStmt);
  Vdbe *pTo =  ((Vdbe *) pToStmt);
  int i;
  ((void ) 0);
  ((void ) 0);
  for ((i = 0); (i < pFrom->nVar); i++) {
    sqlite3VdbeMemMove((&pTo->aVar[i]), (&pFrom->aVar[i]));
  }
  return 0;
}
int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt , sqlite3_stmt *pToStmt )  {
  Vdbe *pFrom =  ((Vdbe *) pFromStmt);
  Vdbe *pTo =  ((Vdbe *) pToStmt);
  if ((pFrom->nVar != pTo->nVar)) {
    return 1;
  }  
  if ((pTo->isPrepareV2 && pTo->expmask)) {
    (pTo->expired = 1);
  }  
  if ((pFrom->isPrepareV2 && pFrom->expmask)) {
    (pFrom->expired = 1);
  }  
  return sqlite3TransferBindings(pFromStmt, pToStmt);
}
sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt )  {
  return (pStmt ? ((Vdbe *) pStmt)->db : 0);
}
int sqlite3_stmt_readonly(sqlite3_stmt *pStmt )  {
  return (pStmt ? ((Vdbe *) pStmt)->readOnly : 1);
}
int sqlite3_stmt_busy(sqlite3_stmt *pStmt )  {
  Vdbe *v =  ((Vdbe *) pStmt);
  return ((v != 0) && (v->pc > 0) && (v->magic == 0xbdf20da3));
}
sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb , sqlite3_stmt *pStmt )  {
  sqlite3_stmt *pNext;
  if ((pStmt == 0)) {
    (pNext = ((sqlite3_stmt *) pDb->pVdbe));
  }  
  else {
    (pNext = ((sqlite3_stmt *) ((Vdbe *) pStmt)->pNext));
  }
  return pNext;
}
int sqlite3_stmt_status(sqlite3_stmt *pStmt , int op , int resetFlag )  {
  Vdbe *pVdbe =  ((Vdbe *) pStmt);
  u32 v =  pVdbe->aCounter[op];
  if (resetFlag) {
    (pVdbe->aCounter[op] = 0);
  }  
  return ((int ) v);
}
static  int findNextHostParameter(const  char *zSql , int *pnToken )  {
  int tokenType;
  int nTotal =  0;
  int n;
  ((*pnToken) = 0);
  while (zSql[0]) {
    (n = sqlite3GetToken(((u8 *) zSql), (&tokenType)));
    ((void ) 0);
    if ((tokenType == 133)) {
      ((*pnToken) = n);
      break;
    }  
    (nTotal += n);
    (zSql += n);
  }
  return nTotal;
}
static  char *sqlite3VdbeExpandSql(Vdbe *p , const  char *zRawSql )  {
  sqlite3 *db;
  int idx =  0;
  int nextIndex =  1;
  int n;
  int nToken;
  int i;
  Mem *pVar;
  StrAccum out;
  char zBase[100];
  (db = p->db);
  sqlite3StrAccumInit((&out), zBase, sizeof(zBase), db->aLimit[0]);
  (out.db = db);
  if ((db->nVdbeExec > 1)) {
    while ((*zRawSql)) {
      const char *zStart =  zRawSql;
      while ((((*zRawSql++) != '\n') && (*zRawSql))) {
        
      }
      sqlite3StrAccumAppend((&out), "-- ", 3);
      sqlite3StrAccumAppend((&out), zStart, ((int ) (zRawSql - zStart)));
    }
  }  
  else {
    while (zRawSql[0]) {
      (n = findNextHostParameter(zRawSql, (&nToken)));
      ((void ) 0);
      sqlite3StrAccumAppend((&out), zRawSql, n);
      (zRawSql += n);
      ((void ) 0);
      if ((nToken == 0)) {
        break;
      }  
      if ((zRawSql[0] == '?')) {
        if ((nToken > 1)) {
          ((void ) 0);
          sqlite3GetInt32((&zRawSql[1]), (&idx));
        }  
        else {
          (idx = nextIndex);
        }
      }  
      else {
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((zRawSql[0] == ':')) {
            sqlite3Coverage(65270);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((zRawSql[0] == '$')) {
            sqlite3Coverage(65271);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((zRawSql[0] == '@')) {
            sqlite3Coverage(65272);
          }  
        }  
        (idx = sqlite3VdbeParameterIndex(p, zRawSql, nToken));
        ((void ) 0);
      }
      (zRawSql += nToken);
      (nextIndex = (idx + 1));
      ((void ) 0);
      (pVar = (&p->aVar[(idx - 1)]));
      if ((pVar->flags & 0x0001)) {
        sqlite3StrAccumAppend((&out), "NULL", 4);
      } 
      else if ((pVar->flags & 0x0004)) {
        sqlite3XPrintf((&out), "%lld", pVar->u.i);
      }
      
      else if ((pVar->flags & 0x0008)) {
        sqlite3XPrintf((&out), "%!.15g", pVar->r);
      }
      
      else if ((pVar->flags & 0x0002)) {
        int nOut;
        u8 enc =  db->aDb[0].pSchema->enc;
        Mem utf8;
        if ((enc != 1)) {
          memset((&utf8), 0, sizeof(utf8));
          (utf8.db = db);
          sqlite3VdbeMemSetStr((&utf8), pVar->z, pVar->n, enc, ((sqlite3_destructor_type ) 0));
          sqlite3VdbeChangeEncoding((&utf8), 1);
          (pVar = (&utf8));
        }  
        (nOut = pVar->n);
        sqlite3XPrintf((&out), "'%.*q'", nOut, pVar->z);
        if ((enc != 1)) {
          sqlite3VdbeMemRelease((&utf8));
        }  
      }
      
      else if ((pVar->flags & 0x4000)) {
        sqlite3XPrintf((&out), "zeroblob(%d)", pVar->u.nZero);
      } 
      else {
        int nOut;
        ((void ) 0);
        sqlite3StrAccumAppend((&out), "x'", 2);
        (nOut = pVar->n);
        for ((i = 0); (i < nOut); i++) {
          sqlite3XPrintf((&out), "%02x", (pVar->z[i] & 0xff));
        }
        sqlite3StrAccumAppend((&out), "'", 1);
      }
    }
  }
  return sqlite3StrAccumFinish((&out));
}
static  void sqlite3ExplainBegin(Vdbe *pVdbe )  {
  if (pVdbe) {
    Explain *p;
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      sqlite3BeginBenignMalloc();
    }  
    (p = ((Explain *) sqlite3MallocZero(sizeof(Explain ))));
    if (p) {
      (p->pVdbe = pVdbe);
      sqlite3_free(pVdbe->_1276_pExplain);
      (pVdbe->_1276_pExplain = p);
      sqlite3StrAccumInit((&p->str), p->zBase, sizeof(p->zBase), 1000000000);
      (p->str.useMalloc = 2);
    }  
    else {
      if ((((! id2i_sqlite_omit_builtin_test) ) )) {
        sqlite3EndBenignMalloc();
      }  
    }
  }  
}
static  int endsWithNL(Explain *p )  {
  return (p && p->str.zText && p->str.nChar && (p->str.zText[(p->str.nChar - 1)] == '\n'));
}
static  void sqlite3ExplainPrintf(Vdbe *pVdbe , const  char *zFormat , ...)  {
  Explain *p;
  if ((pVdbe && ((p = pVdbe->_1276_pExplain) != 0))) {
    va_list ap;
    if ((p->nIndent && endsWithNL(p))) {
      int n =  p->nIndent;
      if ((n > ((int ) (sizeof(p->aIndent) / sizeof(p->aIndent[0]))))) {
        (n = ((int ) (sizeof(p->aIndent) / sizeof(p->aIndent[0]))));
      }  
      sqlite3AppendSpace((&p->str), p->aIndent[(n - 1)]);
    }  
    __builtin_va_start(ap, zFormat);
    sqlite3VXPrintf((&p->str), 1, zFormat, ap);
    __builtin_va_end(ap);
  }  
}
static  void sqlite3ExplainNL(Vdbe *pVdbe )  {
  Explain *p;
  if ((pVdbe && ((p = pVdbe->_1276_pExplain) != 0) && (! endsWithNL(p)))) {
    sqlite3StrAccumAppend((&p->str), "\n", 1);
  }  
}
static  void sqlite3ExplainPush(Vdbe *pVdbe )  {
  Explain *p;
  if ((pVdbe && ((p = pVdbe->_1276_pExplain) != 0))) {
    if ((p->str.zText && (p->nIndent < ((int ) (sizeof(p->aIndent) / sizeof(p->aIndent[0])))))) {
      const char *z =  p->str.zText;
      int i =  (p->str.nChar - 1);
      int x;
      while (((i >= 0) && (z[i] != '\n'))) {
        i--;
      }
      (x = ((p->str.nChar - 1) - i));
      if ((p->nIndent && (x < p->aIndent[(p->nIndent - 1)]))) {
        (x = p->aIndent[(p->nIndent - 1)]);
      }  
      (p->aIndent[p->nIndent] = x);
    }  
    p->nIndent++;
  }  
}
static  void sqlite3ExplainPop(Vdbe *p )  {
  if ((p && p->_1276_pExplain)) {
    p->_1276_pExplain->nIndent--;
  }  
}
static  void sqlite3ExplainFinish(Vdbe *pVdbe )  {
  if ((pVdbe && pVdbe->_1276_pExplain)) {
    sqlite3_free(pVdbe->_1276_zExplain);
    sqlite3ExplainNL(pVdbe);
    (pVdbe->_1276_zExplain = sqlite3StrAccumFinish((&pVdbe->_1276_pExplain->str)));
    sqlite3_free(pVdbe->_1276_pExplain);
    (pVdbe->_1276_pExplain = 0);
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      sqlite3EndBenignMalloc();
    }  
  }  
}
static  const  char *sqlite3VdbeExplanation(Vdbe *pVdbe )  {
  return ((pVdbe && pVdbe->_1276_zExplain) ? pVdbe->_1276_zExplain : 0);
}
static  void sqlite3VdbeMemStoreType(Mem *pMem )  {
  int flags =  pMem->flags;
  if ((flags & 0x0001)) {
    (pMem->type = 5);
  } 
  else if ((flags & 0x0004)) {
    (pMem->type = 1);
  }
  
  else if ((flags & 0x0008)) {
    (pMem->type = 2);
  }
  
  else if ((flags & 0x0002)) {
    (pMem->type = 3);
  } 
  else {
    (pMem->type = 4);
  }
}
static  VdbeCursor *allocateCursor(Vdbe *p , int iCur , int nField , int iDb , int isBtreeCursor )  {
  Mem *pMem =  (&p->aMem[(p->nMem - iCur)]);
  int nByte;
  VdbeCursor *pCx =  0;
  (nByte = (((sizeof(VdbeCursor ) + 7) & (~ 7)) + (isBtreeCursor ? sqlite3BtreeCursorSize() : 0) + (2 * nField * sizeof(u32 ))));
  ((void ) 0);
  if (p->apCsr[iCur]) {
    sqlite3VdbeFreeCursor(p, p->apCsr[iCur]);
    (p->apCsr[iCur] = 0);
  }  
  if ((0 == sqlite3VdbeMemGrow(pMem, nByte, 0))) {
    (p->apCsr[iCur] = (pCx = ((VdbeCursor *) pMem->z)));
    memset(pCx, 0, sizeof(VdbeCursor ));
    (pCx->iDb = iDb);
    (pCx->nField = nField);
    if (nField) {
      (pCx->aType = ((u32 *) (&pMem->z[((sizeof(VdbeCursor ) + 7) & (~ 7))])));
    }  
    if (isBtreeCursor) {
      (pCx->pCursor = ((BtCursor *) (&pMem->z[(((sizeof(VdbeCursor ) + 7) & (~ 7)) + (2 * nField * sizeof(u32 )))])));
      sqlite3BtreeCursorZero(pCx->pCursor);
    }  
  }  
  return pCx;
}
static  void applyNumericAffinity(Mem *pRec )  {
  if (((pRec->flags & (0x0008 | 0x0004)) == 0)) {
    double rValue;
    i64 iValue;
    u8 enc =  pRec->enc;
    if (((pRec->flags & 0x0002) == 0)) {
      return;
    }  
    if ((sqlite3AtoF(pRec->z, (&rValue), pRec->n, enc) == 0)) {
      return;
    }  
    if ((0 == sqlite3Atoi64(pRec->z, (&iValue), pRec->n, enc))) {
      (pRec->u.i = iValue);
      (pRec->flags |= 0x0004);
    }  
    else {
      (pRec->r = rValue);
      (pRec->flags |= 0x0008);
    }
  }  
}
static  void applyAffinity(Mem *pRec , char affinity , u8 enc )  {
  if ((affinity == 'a')) {
    if (((0 == (pRec->flags & 0x0002)) && (pRec->flags & (0x0008 | 0x0004)))) {
      sqlite3VdbeMemStringify(pRec, enc);
    }  
    (pRec->flags &= (~ (0x0008 | 0x0004)));
  } 
  else if ((affinity != 'b')) {
    ((void ) 0);
    applyNumericAffinity(pRec);
    if ((pRec->flags & 0x0008)) {
      sqlite3VdbeIntegerAffinity(pRec);
    }  
  } 
}
int sqlite3_value_numeric_type(sqlite3_value *pVal )  {
  Mem *pMem =  ((Mem *) pVal);
  if ((pMem->type == 3)) {
    applyNumericAffinity(pMem);
    sqlite3VdbeMemStoreType(pMem);
  }  
  return pMem->type;
}
static  void sqlite3ValueApplyAffinity(sqlite3_value *pVal , u8 affinity , u8 enc )  {
  applyAffinity(((Mem *) pVal), affinity, enc);
}
inline  sqlite_uint64 _1317_sqlite3Hwtime(void )  {
  unsigned int lo, hi;
  asm volatile ("rdtsc");
  return ((((sqlite_uint64 ) hi) << 32) | lo);
}
inline  sqlite_uint64 _1318_sqlite3Hwtime(void )  {
  unsigned long val;
  asm volatile ("rdtsc");
  return val;
}
static  int _1319_sqlite3VdbeExec(Vdbe *p )  {
  int pc =  0;
  Op *aOp =  p->aOp;
  Op *pOp;
  int rc =  0;
  sqlite3 *db =  p->db;
  u8 resetSchemaOnFault =  0;
  u8 encoding =  db->aDb[0].pSchema->enc;
  int iCompare =  0;
  unsigned nVmStep =  0;
  unsigned nProgressLimit =  0;
  Mem *aMem =  p->aMem;
  Mem *pIn1 =  0;
  Mem *pIn2 =  0;
  Mem *pIn3 =  0;
  Mem *pOut =  0;
  int *aPermute =  0;
  i64 lastRowid =  db->lastRowid;
  union  vdbeExecUnion {
    struct  OP_Yield_stack_vars {
      int pcDest ;
    }  aa ;
    struct  OP_Null_stack_vars {
      int cnt ;
      u16 nullFlag ;
    }  ab ;
    struct  OP_Variable_stack_vars {
      Mem *pVar ;
    }  ac ;
    struct  OP_Move_stack_vars {
      char *zMalloc ;
      int n ;
      int p1 ;
      int p2 ;
    }  ad ;
    struct  OP_Copy_stack_vars {
      int n ;
    }  ae ;
    struct  OP_ResultRow_stack_vars {
      Mem *pMem ;
      int i ;
    }  af ;
    struct  OP_Concat_stack_vars {
      i64 nByte ;
    }  ag ;
    struct  OP_Remainder_stack_vars {
      char bIntint ;
      int flags ;
      i64 iA ;
      i64 iB ;
      double rA ;
      double rB ;
    }  ah ;
    struct  OP_Function_stack_vars {
      int i ;
      Mem *pArg ;
      sqlite3_context ctx ;
      sqlite3_value **apVal ;
      int n ;
    }  ai ;
    struct  OP_ShiftRight_stack_vars {
      i64 iA ;
      u64 uA ;
      i64 iB ;
      u8 op ;
    }  aj ;
    struct  OP_Ge_stack_vars {
      int res ;
      char affinity ;
      u16 flags1 ;
      u16 flags3 ;
    }  ak ;
    struct  OP_Compare_stack_vars {
      int n ;
      int i ;
      int p1 ;
      int p2 ;
      const  KeyInfo *pKeyInfo ;
      int idx ;
      CollSeq *pColl ;
      int bRev ;
    }  al ;
    struct  OP_Or_stack_vars {
      int v1 ;
      int v2 ;
    }  am ;
    struct  OP_IfNot_stack_vars {
      int c ;
    }  an ;
    struct  OP_Column_stack_vars {
      u32 payloadSize ;
      i64 payloadSize64 ;
      int p1 ;
      int p2 ;
      VdbeCursor *pC ;
      char *zRec ;
      BtCursor *pCrsr ;
      u32 *aType ;
      u32 *aOffset ;
      int nField ;
      int len ;
      int i ;
      char *zData ;
      Mem *pDest ;
      Mem sMem ;
      u8 *zIdx ;
      u8 *zEndHdr ;
      u32 offset ;
      u32 szField ;
      int szHdr ;
      int avail ;
      u32 t ;
      Mem *pReg ;
    }  ao ;
    struct  OP_Affinity_stack_vars {
      const  char *zAffinity ;
      char cAff ;
    }  ap ;
    struct  OP_MakeRecord_stack_vars {
      u8 *zNewRecord ;
      Mem *pRec ;
      u64 nData ;
      int nHdr ;
      i64 nByte ;
      int nZero ;
      int nVarint ;
      u32 serial_type ;
      Mem *pData0 ;
      Mem *pLast ;
      int nField ;
      char *zAffinity ;
      int file_format ;
      int i ;
      int len ;
    }  aq ;
    struct  OP_Count_stack_vars {
      i64 nEntry ;
      BtCursor *pCrsr ;
    }  ar ;
    struct  OP_Savepoint_stack_vars {
      int p1 ;
      char *zName ;
      int nName ;
      Savepoint *pNew ;
      Savepoint *pSavepoint ;
      Savepoint *pTmp ;
      int iSavepoint ;
      int ii ;
    }  as ;
    struct  OP_AutoCommit_stack_vars {
      int desiredAutoCommit ;
      int iRollback ;
      int turnOnAC ;
    }  at ;
    struct  OP_Transaction_stack_vars {
      Btree *pBt ;
    }  au ;
    struct  OP_ReadCookie_stack_vars {
      int iMeta ;
      int iDb ;
      int iCookie ;
    }  av ;
    struct  OP_SetCookie_stack_vars {
      Db *pDb ;
    }  aw ;
    struct  OP_VerifyCookie_stack_vars {
      int iMeta ;
      int iGen ;
      Btree *pBt ;
    }  ax ;
    struct  OP_OpenWrite_stack_vars {
      int nField ;
      KeyInfo *pKeyInfo ;
      int p2 ;
      int iDb ;
      int wrFlag ;
      Btree *pX ;
      VdbeCursor *pCur ;
      Db *pDb ;
    }  ay ;
    struct  OP_OpenEphemeral_stack_vars {
      VdbeCursor *pCx ;
    }  az ;
    struct  OP_SorterOpen_stack_vars {
      VdbeCursor *pCx ;
    }  ba ;
    struct  OP_OpenPseudo_stack_vars {
      VdbeCursor *pCx ;
    }  bb ;
    struct  OP_SeekGt_stack_vars {
      int res ;
      int oc ;
      VdbeCursor *pC ;
      UnpackedRecord r ;
      int nField ;
      i64 iKey ;
    }  bc ;
    struct  OP_Seek_stack_vars {
      VdbeCursor *pC ;
    }  bd ;
    struct  OP_Found_stack_vars {
      int alreadyExists ;
      VdbeCursor *pC ;
      int res ;
      char *pFree ;
      UnpackedRecord *pIdxKey ;
      UnpackedRecord r ;
      char aTempRec[(((sizeof(UnpackedRecord ) + 7) & (~ 7)) + (sizeof(Mem ) * 3) + 7)] ;
    }  be ;
    struct  OP_IsUnique_stack_vars {
      u16 ii ;
      VdbeCursor *pCx ;
      BtCursor *pCrsr ;
      u16 nField ;
      Mem *aMx ;
      UnpackedRecord r ;
      i64 R ;
    }  bf ;
    struct  OP_NotExists_stack_vars {
      VdbeCursor *pC ;
      BtCursor *pCrsr ;
      int res ;
      u64 iKey ;
    }  bg ;
    struct  OP_NewRowid_stack_vars {
      i64 v ;
      VdbeCursor *pC ;
      int res ;
      int cnt ;
      Mem *pMem ;
      VdbeFrame *pFrame ;
    }  bh ;
    struct  OP_InsertInt_stack_vars {
      Mem *pData ;
      Mem *pKey ;
      i64 iKey ;
      VdbeCursor *pC ;
      int nZero ;
      int seekResult ;
      const  char *zDb ;
      const  char *zTbl ;
      int op ;
    }  bi ;
    struct  OP_Delete_stack_vars {
      i64 iKey ;
      VdbeCursor *pC ;
    }  bj ;
    struct  OP_SorterCompare_stack_vars {
      VdbeCursor *pC ;
      int res ;
    }  bk ;
    struct  OP_SorterData_stack_vars {
      VdbeCursor *pC ;
    }  bl ;
    struct  OP_RowData_stack_vars {
      VdbeCursor *pC ;
      BtCursor *pCrsr ;
      u32 n ;
      i64 n64 ;
    }  bm ;
    struct  OP_Rowid_stack_vars {
      VdbeCursor *pC ;
      i64 v ;
      sqlite3_vtab *pVtab ;
      const  sqlite3_module *pModule ;
    }  bn ;
    struct  OP_NullRow_stack_vars {
      VdbeCursor *pC ;
    }  bo ;
    struct  OP_Last_stack_vars {
      VdbeCursor *pC ;
      BtCursor *pCrsr ;
      int res ;
    }  bp ;
    struct  OP_Rewind_stack_vars {
      VdbeCursor *pC ;
      BtCursor *pCrsr ;
      int res ;
    }  bq ;
    struct  OP_Next_stack_vars {
      VdbeCursor *pC ;
      int res ;
    }  br ;
    struct  OP_IdxInsert_stack_vars {
      VdbeCursor *pC ;
      BtCursor *pCrsr ;
      int nKey ;
      const  char *zKey ;
    }  bs ;
    struct  OP_IdxDelete_stack_vars {
      VdbeCursor *pC ;
      BtCursor *pCrsr ;
      int res ;
      UnpackedRecord r ;
    }  bt ;
    struct  OP_IdxRowid_stack_vars {
      BtCursor *pCrsr ;
      VdbeCursor *pC ;
      i64 rowid ;
    }  bu ;
    struct  OP_IdxGE_stack_vars {
      VdbeCursor *pC ;
      int res ;
      UnpackedRecord r ;
    }  bv ;
    struct  OP_Destroy_stack_vars {
      int iMoved ;
      int iCnt ;
      Vdbe *pVdbe ;
      int iDb ;
    }  bw ;
    struct  OP_Clear_stack_vars {
      int nChange ;
    }  bx ;
    struct  OP_CreateTable_stack_vars {
      int pgno ;
      int flags ;
      Db *pDb ;
    }  by ;
    struct  OP_ParseSchema_stack_vars {
      int iDb ;
      const  char *zMaster ;
      char *zSql ;
      InitData initData ;
    }  bz ;
    struct  OP_IntegrityCk_stack_vars {
      int nRoot ;
      int *aRoot ;
      int j ;
      int nErr ;
      char *z ;
      Mem *pnErr ;
    }  ca ;
    struct  OP_RowSetRead_stack_vars {
      i64 val ;
    }  cb ;
    struct  OP_RowSetTest_stack_vars {
      int iSet ;
      int exists ;
    }  cc ;
    struct  OP_Program_stack_vars {
      int nMem ;
      int nByte ;
      Mem *pRt ;
      Mem *pMem ;
      Mem *pEnd ;
      VdbeFrame *pFrame ;
      SubProgram *pProgram ;
      void *t ;
    }  cd ;
    struct  OP_Param_stack_vars {
      VdbeFrame *pFrame ;
      Mem *pIn ;
    }  ce ;
    struct  OP_MemMax_stack_vars {
      Mem *pIn1 ;
      VdbeFrame *pFrame ;
    }  cf ;
    struct  OP_AggStep_stack_vars {
      int n ;
      int i ;
      Mem *pMem ;
      Mem *pRec ;
      sqlite3_context ctx ;
      sqlite3_value **apVal ;
    }  cg ;
    struct  OP_AggFinal_stack_vars {
      Mem *pMem ;
    }  ch ;
    struct  OP_Checkpoint_stack_vars {
      int i ;
      int aRes[3] ;
      Mem *pMem ;
    }  ci ;
    struct  OP_JournalMode_stack_vars {
      Btree *pBt ;
      Pager *pPager ;
      int eNew ;
      int eOld ;
      const  char *zFilename ;
    }  cj ;
    struct  OP_IncrVacuum_stack_vars {
      Btree *pBt ;
    }  ck ;
    struct  OP_VBegin_stack_vars {
      VTable *pVTab ;
    }  cl ;
    struct  OP_VOpen_stack_vars {
      VdbeCursor *pCur ;
      sqlite3_vtab_cursor *pVtabCursor ;
      sqlite3_vtab *pVtab ;
      sqlite3_module *pModule ;
    }  cm ;
    struct  OP_VFilter_stack_vars {
      int nArg ;
      int iQuery ;
      const  sqlite3_module *pModule ;
      Mem *pQuery ;
      Mem *pArgc ;
      sqlite3_vtab_cursor *pVtabCursor ;
      sqlite3_vtab *pVtab ;
      VdbeCursor *pCur ;
      int res ;
      int i ;
      Mem **apArg ;
    }  cn ;
    struct  OP_VColumn_stack_vars {
      sqlite3_vtab *pVtab ;
      const  sqlite3_module *pModule ;
      Mem *pDest ;
      sqlite3_context sContext ;
    }  co ;
    struct  OP_VNext_stack_vars {
      sqlite3_vtab *pVtab ;
      const  sqlite3_module *pModule ;
      int res ;
      VdbeCursor *pCur ;
    }  cp ;
    struct  OP_VRename_stack_vars {
      sqlite3_vtab *pVtab ;
      Mem *pName ;
    }  cq ;
    struct  OP_VUpdate_stack_vars {
      sqlite3_vtab *pVtab ;
      sqlite3_module *pModule ;
      int nArg ;
      int i ;
      sqlite_int64 rowid ;
      Mem **apArg ;
      Mem *pX ;
    }  cr ;
    struct  OP_Trace_stack_vars {
      char *zTrace ;
      char *z ;
    }  cs ;
  }  u;
  ((void ) 0);
  if ((p->rc == 7)) {
    goto _1319_no_mem;
  }  
  ((void ) 0);
  ((void ) 0);
  (p->rc = 0);
  (p->iCurrentTime = 0);
  ((void ) 0);
  (p->pResultSet = 0);
  (db->busyHandler.nBusy = 0);
  if (db->u1.isInterrupted) {
    goto _1319_abort_due_to_interrupt;
  }  
  if (((id2i_sqlite_enable_iotrace ) )) {
    sqlite3VdbeIOTraceSql(p);
  }  
  if (db->xProgress) {
    ((void ) 0);
    (nProgressLimit = ((unsigned ) p->aCounter[4]));
    if ((nProgressLimit == 0)) {
      (nProgressLimit = db->nProgressOps);
    }  
    else {
      (nProgressLimit %= ((unsigned ) db->nProgressOps));
    }
  }  
  for ((pc = p->pc); (rc == 0); pc++) {
    ((void ) 0);
    if (db->mallocFailed) {
      goto _1319_no_mem;
    }  
    nVmStep++;
    (pOp = (&aOp[pc]));
    ((void ) 0);
    if ((pOp->opflags & 0x0002)) {
      ((void ) 0);
      ((void ) 0);
      (pOut = (&aMem[pOp->p2]));
      if ((pOut->flags & (0x2000 | 0x0400 | 0x0020 | 0x0040))) {
        sqlite3VdbeMemReleaseExternal(pOut);
      }  
      (pOut->flags = 0x0004);
    }  
    switch (pOp->opcode) {
      case 14:
      {
        (pc = (pOp->p2 - 1));
        _1319_check_for_interrupt:
        if (db->u1.isInterrupted) {
          goto _1319_abort_due_to_interrupt;
        }  
        if (((db->xProgress != 0) && (nVmStep >= nProgressLimit))) {
          int prc;
          (prc = db->xProgress(db->pProgressArg));
          if ((prc != 0)) {
            (rc = 9);
            goto _1319_vdbe_error_halt;
          }  
          if ((db->xProgress != 0)) {
            (nProgressLimit = (nVmStep + db->nProgressOps - (nVmStep % db->nProgressOps)));
          }  
        }  
        break;
      }
      case 15:
      {
        ((void ) 0);
        (pIn1 = (&aMem[pOp->p1]));
        ((void ) 0);
        (pIn1->flags = 0x0004);
        (pIn1->u.i = pc);
        (pc = (pOp->p2 - 1));
        break;
      }
      case 16:
      {
        (pIn1 = (&aMem[pOp->p1]));
        ((void ) 0);
        (pc = ((int ) pIn1->u.i));
        break;
      }
      case 17:
      {
        (pIn1 = (&aMem[pOp->p1]));
        ((void ) 0);
        (pIn1->flags = 0x0004);
        (u.aa.pcDest = ((int ) pIn1->u.i));
        (pIn1->u.i = pc);
        (pc = u.aa.pcDest);
        break;
      }
      case 18:
      {
        (pIn3 = (&aMem[pOp->p3]));
        if (((pIn3->flags & 0x0001) == 0)) {
          break;
        }  
      }
      case 20:
      {
        if (((pOp->p1 == 0) && p->pFrame)) {
          VdbeFrame *pFrame =  p->pFrame;
          (p->pFrame = pFrame->pParent);
          p->nFrame--;
          sqlite3VdbeSetChanges(db, p->nChange);
          (pc = sqlite3VdbeFrameRestore(pFrame));
          (lastRowid = db->lastRowid);
          if ((pOp->p2 == 4)) {
            (pc = (p->aOp[pc].p2 - 1));
          }  
          (aOp = p->aOp);
          (aMem = p->aMem);
          break;
        }  
        (p->rc = pOp->p1);
        (p->errorAction = ((u8 ) pOp->p2));
        (p->pc = pc);
        if (pOp->p4.z) {
          ((void ) 0);
          sqlite3SetString((&p->zErrMsg), db, "%s", pOp->p4.z);
          if (((id2i_sqlite_coverage_test ) )) {
            if ((((! id2i_sqlite_default_memstatus) ) )) {
              if ((_1283_sqlite3Config.xLog != 0)) {
                sqlite3Coverage(66838);
              }  
            }  
            if (((id2i_sqlite_default_memstatus ) )) {
              if ((_1284_sqlite3Config.xLog != 0)) {
                sqlite3Coverage(66838);
              }  
            }  
          }  
          sqlite3_log(pOp->p1, "abort at %d in [%s]: %s", pc, p->zSql, pOp->p4.z);
        } 
        else if (p->rc) {
          if (((id2i_sqlite_coverage_test ) )) {
            if ((((! id2i_sqlite_default_memstatus) ) )) {
              if ((_1283_sqlite3Config.xLog != 0)) {
                sqlite3Coverage(66841);
              }  
            }  
            if (((id2i_sqlite_default_memstatus ) )) {
              if ((_1284_sqlite3Config.xLog != 0)) {
                sqlite3Coverage(66841);
              }  
            }  
          }  
          sqlite3_log(pOp->p1, "constraint failed at %d in [%s]", pc, p->zSql);
        } 
        (rc = sqlite3VdbeHalt(p));
        ((void ) 0);
        if ((rc == 5)) {
          (p->rc = (rc = 5));
        }  
        else {
          ((void ) 0);
          ((void ) 0);
          (rc = (p->rc ? 1 : 101));
        }
        goto _1319_vdbe_return;
      }
      case 21:
      {
        (pOut->u.i = pOp->p1);
        break;
      }
      case 22:
      {
        ((void ) 0);
        (pOut->u.i = (*pOp->p4.pI64));
        break;
      }
      case 130:
      {
        (pOut->flags = 0x0008);
        ((void ) 0);
        (pOut->r = (*pOp->p4.pReal));
        break;
      }
      case 94:
      {
        ((void ) 0);
        (pOp->opcode = 23);
        (pOp->p1 = sqlite3Strlen30(pOp->p4.z));
        if ((encoding != 1)) {
          (rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, (- 1), 1, ((sqlite3_destructor_type ) 0)));
          if ((rc == 18)) {
            goto _1319_too_big;
          }  
          if ((0 != sqlite3VdbeChangeEncoding(pOut, encoding))) {
            goto _1319_no_mem;
          }  
          ((void ) 0);
          ((void ) 0);
          (pOut->zMalloc = 0);
          (pOut->flags |= 0x0800);
          (pOut->flags &= (~ 0x0400));
          if ((pOp->p4type == (- 1))) {
            sqlite3DbFree(db, pOp->p4.z);
          }  
          (pOp->p4type = (- 1));
          (pOp->p4.z = pOut->z);
          (pOp->p1 = pOut->n);
        }  
        if ((pOp->p1 > db->aLimit[0])) {
          goto _1319_too_big;
        }  
      }
      case 23:
      {
        ((void ) 0);
        (pOut->flags = (0x0002 | 0x0800 | 0x0200));
        (pOut->z = pOp->p4.z);
        (pOut->n = pOp->p1);
        (pOut->enc = encoding);
        break;
      }
      case 24:
      {
        (u.ab.cnt = (pOp->p3 - pOp->p2));
        ((void ) 0);
        (pOut->flags = (u.ab.nullFlag = (pOp->p1 ? (0x0001 | 0x0100) : 0x0001)));
        while ((u.ab.cnt > 0)) {
          pOut++;
          if ((pOut->flags & (0x2000 | 0x0400 | 0x0020 | 0x0040))) {
            sqlite3VdbeMemReleaseExternal(pOut);
          }  
          (pOut->flags = u.ab.nullFlag);
          u.ab.cnt--;
        }
        break;
      }
      case 25:
      {
        ((void ) 0);
        sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);
        (pOut->enc = encoding);
        break;
      }
      case 26:
      {
        ((void ) 0);
        ((void ) 0);
        (u.ac.pVar = (&p->aVar[(pOp->p1 - 1)]));
        if (sqlite3VdbeMemTooBig(u.ac.pVar)) {
          goto _1319_too_big;
        }  
        sqlite3VdbeMemShallowCopy(pOut, u.ac.pVar, 0x0800);
        break;
      }
      case 27:
      {
        (u.ad.n = (pOp->p3 + 1));
        (u.ad.p1 = pOp->p1);
        (u.ad.p2 = pOp->p2);
        ((void ) 0);
        ((void ) 0);
        (pIn1 = (&aMem[u.ad.p1]));
        (pOut = (&aMem[u.ad.p2]));
        while (u.ad.n--) {
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (u.ad.zMalloc = pOut->zMalloc);
          (pOut->zMalloc = 0);
          sqlite3VdbeMemMove(pOut, pIn1);
          (pIn1->zMalloc = u.ad.zMalloc);
          pIn1++;
          pOut++;
        }
        break;
      }
      case 28:
      {
        (u.ae.n = pOp->p3);
        (pIn1 = (&aMem[pOp->p1]));
        (pOut = (&aMem[pOp->p2]));
        ((void ) 0);
        while (1) {
          sqlite3VdbeMemShallowCopy(pOut, pIn1, 0x1000);
          if ((((pOut->flags & 0x1000) != 0) && sqlite3VdbeMemMakeWriteable(pOut))) {
            goto _1319_no_mem;
          }  
          if ((u.ae.n-- == 0)) {
            break;
          }  
          pOut++;
          pIn1++;
        }
        break;
      }
      case 29:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pOut = (&aMem[pOp->p2]));
        ((void ) 0);
        sqlite3VdbeMemShallowCopy(pOut, pIn1, 0x1000);
        break;
      }
      case 30:
      {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if ((((! id2i_sqlite_omit_foreign_key) ) )) {
          if ((0 != (rc = sqlite3VdbeCheckFk(p, 0)))) {
            ((void ) 0);
            ((void ) 0);
            break;
          }  
        }  
        if (((id2i_sqlite_omit_foreign_key ) )) {
          if ((0 != (rc = 0))) {
            ((void ) 0);
            ((void ) 0);
            break;
          }  
        }  
        ((void ) 0);
        (rc = sqlite3VdbeCloseStatement(p, 1));
        if (((id2i_sqlite_coverage_test ) )) {
          if (0) {
            break;
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((rc != 0)) {
            break;
          }  
        }  
        (p->cacheCtr = ((p->cacheCtr + 2) | 1));
        (u.af.pMem = (p->pResultSet = (&aMem[pOp->p1])));
        for ((u.af.i = 0); (u.af.i < pOp->p2); u.af.i++) {
          ((void ) 0);
          if (((((&u.af.pMem[u.af.i])->flags & 0x1000) != 0) && sqlite3VdbeMemMakeWriteable((&u.af.pMem[u.af.i])))) {
            goto _1319_no_mem;
          }  
          ((void ) 0);
          sqlite3VdbeMemNulTerminate((&u.af.pMem[u.af.i]));
          sqlite3VdbeMemStoreType((&u.af.pMem[u.af.i]));
        }
        if (db->mallocFailed) {
          goto _1319_no_mem;
        }  
        (p->pc = (pc + 1));
        (rc = 100);
        goto _1319_vdbe_return;
      }
      case 91:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pIn2 = (&aMem[pOp->p2]));
        (pOut = (&aMem[pOp->p3]));
        ((void ) 0);
        if (((pIn1->flags | pIn2->flags) & 0x0001)) {
          sqlite3VdbeMemSetNull(pOut);
          break;
        }  
        if ((((pIn1->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn1) : 0) || ((pIn2->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn2) : 0))) {
          goto _1319_no_mem;
        }  
        if ((((pIn1->flags & (0x0002 | 0x0010)) == 0) && sqlite3VdbeMemStringify(pIn1, encoding))) {
          goto _1319_no_mem;
        }  
        if ((((pIn2->flags & (0x0002 | 0x0010)) == 0) && sqlite3VdbeMemStringify(pIn2, encoding))) {
          goto _1319_no_mem;
        }  
        (u.ag.nByte = (pIn1->n + pIn2->n));
        if ((u.ag.nByte > db->aLimit[0])) {
          goto _1319_too_big;
        }  
        (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0002));
        if (sqlite3VdbeMemGrow(pOut, (((int ) u.ag.nByte) + 2), (pOut == pIn2))) {
          goto _1319_no_mem;
        }  
        if ((pOut != pIn2)) {
          memcpy(pOut->z, pIn2->z, pIn2->n);
        }  
        memcpy((&pOut->z[pIn2->n]), pIn1->z, pIn1->n);
        (pOut->z[u.ag.nByte] = 0);
        (pOut->z[(u.ag.nByte + 1)] = 0);
        (pOut->flags |= 0x0200);
        (pOut->n = ((int ) u.ag.nByte));
        (pOut->enc = encoding);
        break;
      }
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      {
        (pIn1 = (&aMem[pOp->p1]));
        applyNumericAffinity(pIn1);
        (pIn2 = (&aMem[pOp->p2]));
        applyNumericAffinity(pIn2);
        (pOut = (&aMem[pOp->p3]));
        (u.ah.flags = (pIn1->flags | pIn2->flags));
        if (((u.ah.flags & 0x0001) != 0)) {
          goto _1319_arithmetic_result_is_null;
        }  
        if (((pIn1->flags & pIn2->flags & 0x0004) == 0x0004)) {
          (u.ah.iA = pIn1->u.i);
          (u.ah.iB = pIn2->u.i);
          (u.ah.bIntint = 1);
          switch (pOp->opcode) {
            case 86:
            if (sqlite3AddInt64((&u.ah.iB), u.ah.iA)) {
              goto _1319_fp_math;
            }  
            break;
            case 87:
            if (sqlite3SubInt64((&u.ah.iB), u.ah.iA)) {
              goto _1319_fp_math;
            }  
            break;
            case 88:
            if (sqlite3MulInt64((&u.ah.iB), u.ah.iA)) {
              goto _1319_fp_math;
            }  
            break;
            case 89:
            {
              if ((u.ah.iA == 0)) {
                goto _1319_arithmetic_result_is_null;
              }  
              if (((u.ah.iA == (- 1)) && (u.ah.iB == (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32)))))) {
                goto _1319_fp_math;
              }  
              (u.ah.iB /= u.ah.iA);
              break;
            }
            id2i_label_2:
            default:
            {
              if ((u.ah.iA == 0)) {
                goto _1319_arithmetic_result_is_null;
              }  
              if ((u.ah.iA == (- 1))) {
                (u.ah.iA = 1);
              }  
              (u.ah.iB %= u.ah.iA);
              break;
            }
          }
          (pOut->u.i = u.ah.iB);
          (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0004));
        }  
        else {
          (u.ah.bIntint = 0);
          _1319_fp_math:
          (u.ah.rA = sqlite3VdbeRealValue(pIn1));
          (u.ah.rB = sqlite3VdbeRealValue(pIn2));
          switch (pOp->opcode) {
            case 86:
            (u.ah.rB += u.ah.rA);
            break;
            case 87:
            (u.ah.rB -= u.ah.rA);
            break;
            case 88:
            (u.ah.rB *= u.ah.rA);
            break;
            case 89:
            {
              if ((u.ah.rA == ((double ) 0))) {
                goto _1319_arithmetic_result_is_null;
              }  
              (u.ah.rB /= u.ah.rA);
              break;
            }
            id2i_label_3:
            default:
            {
              (u.ah.iA = ((i64 ) u.ah.rA));
              (u.ah.iB = ((i64 ) u.ah.rB));
              if ((u.ah.iA == 0)) {
                goto _1319_arithmetic_result_is_null;
              }  
              if ((u.ah.iA == (- 1))) {
                (u.ah.iA = 1);
              }  
              (u.ah.rB = ((double ) (u.ah.iB % u.ah.iA)));
              break;
            }
          }
          if (sqlite3IsNaN(u.ah.rB)) {
            goto _1319_arithmetic_result_is_null;
          }  
          (pOut->r = u.ah.rB);
          (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0008));
          if ((((u.ah.flags & 0x0008) == 0) && (! u.ah.bIntint))) {
            sqlite3VdbeIntegerAffinity(pOut);
          }  
        }
        break;
        _1319_arithmetic_result_is_null:
        sqlite3VdbeMemSetNull(pOut);
        break;
      }
      case 31:
      {
        ((void ) 0);
        if (pOp->p1) {
          sqlite3VdbeMemSetInt64((&aMem[pOp->p1]), 0);
        }  
        break;
      }
      case 1:
      {
        (u.ai.n = pOp->p5);
        (u.ai.apVal = p->apArg);
        ((void ) 0);
        ((void ) 0);
        (pOut = (&aMem[pOp->p3]));
        ((void ) 0);
        ((void ) 0);
        (u.ai.pArg = (&aMem[pOp->p2]));
        for ((u.ai.i = 0); (u.ai.i < u.ai.n); u.ai.i++, u.ai.pArg++) {
          ((void ) 0);
          (u.ai.apVal[u.ai.i] = u.ai.pArg);
          if ((((u.ai.pArg->flags & 0x1000) != 0) && sqlite3VdbeMemMakeWriteable(u.ai.pArg))) {
            goto _1319_no_mem;
          }  
          sqlite3VdbeMemStoreType(u.ai.pArg);
        }
        ((void ) 0);
        (u.ai.ctx.pFunc = pOp->p4.pFunc);
        (u.ai.ctx.s.flags = 0x0001);
        (u.ai.ctx.s.db = db);
        (u.ai.ctx.s.xDel = 0);
        (u.ai.ctx.s.zMalloc = 0);
        (u.ai.ctx.iOp = pc);
        (u.ai.ctx.pVdbe = p);
        sqlite3VdbeMemMove((&u.ai.ctx.s), pOut);
        ((&u.ai.ctx.s)->flags = (((&u.ai.ctx.s)->flags & (~ (0x01ff | 0x4000))) | 0x0001));
        (u.ai.ctx.fErrorOrAux = 0);
        if ((u.ai.ctx.pFunc->funcFlags & 0x020)) {
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (u.ai.ctx.pColl = pOp[(- 1)].p4.pColl);
        }  
        (db->lastRowid = lastRowid);
        (*u.ai.ctx.pFunc->xFunc)((&u.ai.ctx), u.ai.n, u.ai.apVal);
        (lastRowid = db->lastRowid);
        if (db->mallocFailed) {
          sqlite3VdbeMemRelease((&u.ai.ctx.s));
          goto _1319_no_mem;
        }  
        if (u.ai.ctx.fErrorOrAux) {
          if (u.ai.ctx.isError) {
            sqlite3SetString((&p->zErrMsg), db, "%s", sqlite3_value_text((&u.ai.ctx.s)));
            (rc = u.ai.ctx.isError);
          }  
          sqlite3VdbeDeleteAuxData(p, pc, pOp->p1);
        }  
        sqlite3VdbeChangeEncoding((&u.ai.ctx.s), encoding);
        sqlite3VdbeMemMove(pOut, (&u.ai.ctx.s));
        if (sqlite3VdbeMemTooBig(pOut)) {
          goto _1319_too_big;
        }  
        break;
      }
      case 82:
      case 83:
      case 84:
      case 85:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pIn2 = (&aMem[pOp->p2]));
        (pOut = (&aMem[pOp->p3]));
        if (((pIn1->flags | pIn2->flags) & 0x0001)) {
          sqlite3VdbeMemSetNull(pOut);
          break;
        }  
        (u.aj.iA = sqlite3VdbeIntValue(pIn2));
        (u.aj.iB = sqlite3VdbeIntValue(pIn1));
        (u.aj.op = pOp->opcode);
        if ((u.aj.op == 82)) {
          (u.aj.iA &= u.aj.iB);
        } 
        else if ((u.aj.op == 83)) {
          (u.aj.iA |= u.aj.iB);
        }
        
        else if ((u.aj.iB != 0)) {
          ((void ) 0);
          if ((u.aj.iB < 0)) {
            ((void ) 0);
            (u.aj.op = ((2 * 84) + 1 - u.aj.op));
            (u.aj.iB = ((u.aj.iB > (- 64)) ? (- u.aj.iB) : 64));
          }  
          if ((u.aj.iB >= 64)) {
            (u.aj.iA = (((u.aj.iA >= 0) || (u.aj.op == 84)) ? 0 : (- 1)));
          }  
          else {
            memcpy((&u.aj.uA), (&u.aj.iA), sizeof(u.aj.uA));
            if ((u.aj.op == 84)) {
              (u.aj.uA <<= u.aj.iB);
            }  
            else {
              (u.aj.uA >>= u.aj.iB);
              if ((u.aj.iA < 0)) {
                (u.aj.uA |= (((((u64 ) 0xffffffff) << 32) | 0xffffffff) << (64 - u.aj.iB)));
              }  
            }
            memcpy((&u.aj.iA), (&u.aj.uA), sizeof(u.aj.iA));
          }
        } 
        (pOut->u.i = u.aj.iA);
        (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0004));
        break;
      }
      case 32:
      {
        (pIn1 = (&aMem[pOp->p1]));
        sqlite3VdbeMemIntegerify(pIn1);
        (pIn1->u.i += pOp->p2);
        break;
      }
      case 33:
      {
        (pIn1 = (&aMem[pOp->p1]));
        applyAffinity(pIn1, 'c', encoding);
        if (((pIn1->flags & 0x0004) == 0)) {
          if ((pOp->p2 == 0)) {
            (rc = 20);
            goto _1319_abort_due_to_error;
          }  
          else {
            (pc = (pOp->p2 - 1));
          }
        }  
        else {
          (pIn1->flags = ((pIn1->flags & (~ (0x01ff | 0x4000))) | 0x0004));
        }
        break;
      }
      case 34:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if ((pIn1->flags & 0x0004)) {
          sqlite3VdbeMemRealify(pIn1);
        }  
        break;
      }
      case 141:
      if ((((! id2i_sqlite_omit_cast) ) )) {
        (pIn1 = (&aMem[pOp->p1]));
        if ((pIn1->flags & 0x0001)) {
          break;
        }  
        ((void ) 0);
        (pIn1->flags |= ((pIn1->flags & 0x0010) >> 3));
        applyAffinity(pIn1, 'a', encoding);
        (rc = ((pIn1->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn1) : 0));
        ((void ) 0);
        (pIn1->flags &= (~ (0x0004 | 0x0008 | 0x0010 | 0x4000)));
        break;
      }  
      if (((id2i_sqlite_omit_cast ) )) {
        if ((pOp->opcode == 141)) {
          goto id2i_label_1;
        }  
      }  
      case 142:
      if ((((! id2i_sqlite_omit_cast) ) )) {
        (pIn1 = (&aMem[pOp->p1]));
        if ((pIn1->flags & 0x0001)) {
          break;
        }  
        if (((pIn1->flags & 0x0010) == 0)) {
          applyAffinity(pIn1, 'a', encoding);
          ((void ) 0);
          (pIn1->flags = ((pIn1->flags & (~ (0x01ff | 0x4000))) | 0x0010));
        }  
        else {
          (pIn1->flags &= (~ (0x01ff & (~ 0x0010))));
        }
        break;
      }  
      if (((id2i_sqlite_omit_cast ) )) {
        if ((pOp->opcode == 142)) {
          goto id2i_label_1;
        }  
      }  
      case 143:
      if ((((! id2i_sqlite_omit_cast) ) )) {
        (pIn1 = (&aMem[pOp->p1]));
        sqlite3VdbeMemNumerify(pIn1);
        break;
      }  
      if (((id2i_sqlite_omit_cast ) )) {
        if ((pOp->opcode == 143)) {
          goto id2i_label_1;
        }  
      }  
      case 144:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if (((pIn1->flags & 0x0001) == 0)) {
          sqlite3VdbeMemIntegerify(pIn1);
        }  
        break;
      }
      case 145:
      if ((((! id2i_sqlite_omit_cast) ) )) {
        (pIn1 = (&aMem[pOp->p1]));
        if (((pIn1->flags & 0x0001) == 0)) {
          sqlite3VdbeMemRealify(pIn1);
        }  
        break;
      }  
      if (((id2i_sqlite_omit_cast ) )) {
        if ((pOp->opcode == 145)) {
          goto id2i_label_1;
        }  
      }  
      case 76:
      case 75:
      case 79:
      case 78:
      case 77:
      case 80:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pIn3 = (&aMem[pOp->p3]));
        (u.ak.flags1 = pIn1->flags);
        (u.ak.flags3 = pIn3->flags);
        if (((u.ak.flags1 | u.ak.flags3) & 0x0001)) {
          if ((pOp->p5 & 0x80)) {
            ((void ) 0);
            ((void ) 0);
            if ((((u.ak.flags1 & 0x0001) != 0) && ((u.ak.flags3 & 0x0001) != 0) && ((u.ak.flags3 & 0x0100) == 0))) {
              (u.ak.res = 0);
            }  
            else {
              (u.ak.res = 1);
            }
          }  
          else {
            if ((pOp->p5 & 0x08)) {
              (pc = (pOp->p2 - 1));
            } 
            else if ((pOp->p5 & 0x10)) {
              (pOut = (&aMem[pOp->p2]));
              (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0001));
            } 
            break;
          }
        }  
        else {
          (u.ak.affinity = (pOp->p5 & 0x67));
          if (u.ak.affinity) {
            applyAffinity(pIn1, u.ak.affinity, encoding);
            applyAffinity(pIn3, u.ak.affinity, encoding);
            if (db->mallocFailed) {
              goto _1319_no_mem;
            }  
          }  
          ((void ) 0);
          ((pIn1->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn1) : 0);
          ((pIn3->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn3) : 0);
          (u.ak.res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl));
        }
        switch (pOp->opcode) {
          case 76:
          (u.ak.res = (u.ak.res == 0));
          break;
          case 75:
          (u.ak.res = (u.ak.res != 0));
          break;
          case 79:
          (u.ak.res = (u.ak.res < 0));
          break;
          case 78:
          (u.ak.res = (u.ak.res <= 0));
          break;
          case 77:
          (u.ak.res = (u.ak.res > 0));
          break;
          id2i_label_4:
          default:
          (u.ak.res = (u.ak.res >= 0));
          break;
        }
        if ((pOp->p5 & 0x10)) {
          (pOut = (&aMem[pOp->p2]));
          (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0004));
          (pOut->u.i = u.ak.res);
        } 
        else if (u.ak.res) {
          (pc = (pOp->p2 - 1));
        } 
        (pIn1->flags = ((pIn1->flags & (~ 0x01ff)) | (u.ak.flags1 & 0x01ff)));
        (pIn3->flags = ((pIn3->flags & (~ 0x01ff)) | (u.ak.flags3 & 0x01ff)));
        break;
      }
      case 35:
      {
        ((void ) 0);
        ((void ) 0);
        (aPermute = pOp->p4.ai);
        break;
      }
      case 36:
      {
        if (((pOp->p5 & 0x01) == 0)) {
          (aPermute = 0);
        }  
        (u.al.n = pOp->p3);
        (u.al.pKeyInfo = pOp->p4.pKeyInfo);
        ((void ) 0);
        ((void ) 0);
        (u.al.p1 = pOp->p1);
        (u.al.p2 = pOp->p2);
        for ((u.al.i = 0); (u.al.i < u.al.n); u.al.i++) {
          (u.al.idx = (aPermute ? aPermute[u.al.i] : u.al.i));
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (u.al.pColl = u.al.pKeyInfo->aColl[u.al.i]);
          (u.al.bRev = u.al.pKeyInfo->aSortOrder[u.al.i]);
          (iCompare = sqlite3MemCompare((&aMem[(u.al.p1 + u.al.idx)]), (&aMem[(u.al.p2 + u.al.idx)]), u.al.pColl));
          if (iCompare) {
            if (u.al.bRev) {
              (iCompare = (- iCompare));
            }  
            break;
          }  
        }
        (aPermute = 0);
        break;
      }
      case 37:
      {
        if ((iCompare < 0)) {
          (pc = (pOp->p1 - 1));
        } 
        else if ((iCompare == 0)) {
          (pc = (pOp->p2 - 1));
        } 
        else {
          (pc = (pOp->p3 - 1));
        }
        break;
      }
      case 69:
      case 68:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if ((pIn1->flags & 0x0001)) {
          (u.am.v1 = 2);
        }  
        else {
          (u.am.v1 = (sqlite3VdbeIntValue(pIn1) != 0));
        }
        (pIn2 = (&aMem[pOp->p2]));
        if ((pIn2->flags & 0x0001)) {
          (u.am.v2 = 2);
        }  
        else {
          (u.am.v2 = (sqlite3VdbeIntValue(pIn2) != 0));
        }
        if ((pOp->opcode == 69)) {
          static const unsigned char and_logic[] =  { 0,  0,  0,  0,  1,  2,  0,  2,  2};
          (u.am.v1 = and_logic[((u.am.v1 * 3) + u.am.v2)]);
        }  
        else {
          static const unsigned char or_logic[] =  { 0,  1,  2,  1,  1,  1,  2,  1,  2};
          (u.am.v1 = or_logic[((u.am.v1 * 3) + u.am.v2)]);
        }
        (pOut = (&aMem[pOp->p3]));
        if ((u.am.v1 == 2)) {
          (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0001));
        }  
        else {
          (pOut->u.i = u.am.v1);
          (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0004));
        }
        break;
      }
      case 19:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pOut = (&aMem[pOp->p2]));
        if ((pIn1->flags & 0x0001)) {
          sqlite3VdbeMemSetNull(pOut);
        }  
        else {
          sqlite3VdbeMemSetInt64(pOut, (! sqlite3VdbeIntValue(pIn1)));
        }
        break;
      }
      case 93:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pOut = (&aMem[pOp->p2]));
        if ((pIn1->flags & 0x0001)) {
          sqlite3VdbeMemSetNull(pOut);
        }  
        else {
          sqlite3VdbeMemSetInt64(pOut, (~ sqlite3VdbeIntValue(pIn1)));
        }
        break;
      }
      case 38:
      {
        ((void ) 0);
        if (p->aOnceFlag[pOp->p1]) {
          (pc = (pOp->p2 - 1));
        }  
        else {
          (p->aOnceFlag[pOp->p1] = 1);
        }
        break;
      }
      case 39:
      case 40:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if ((pIn1->flags & 0x0001)) {
          (u.an.c = pOp->p3);
        }  
        else {
          (u.an.c = (sqlite3VdbeRealValue(pIn1) != 0.0));
          if ((pOp->opcode == 40)) {
            (u.an.c = (! u.an.c));
          }  
        }
        if (u.an.c) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 73:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if (((pIn1->flags & 0x0001) != 0)) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 74:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if (((pIn1->flags & 0x0001) == 0)) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 41:
      {
        (u.ao.p1 = pOp->p1);
        (u.ao.p2 = pOp->p2);
        (u.ao.pC = 0);
        memset((&u.ao.sMem), 0, sizeof(u.ao.sMem));
        ((void ) 0);
        ((void ) 0);
        (u.ao.pDest = (&aMem[pOp->p3]));
        (u.ao.zRec = 0);
        (u.ao.pC = p->apCsr[u.ao.p1]);
        ((void ) 0);
        ((void ) 0);
        (u.ao.pCrsr = u.ao.pC->pCursor);
        if ((u.ao.pCrsr != 0)) {
          (rc = sqlite3VdbeCursorMoveto(u.ao.pC));
          if (rc) {
            goto _1319_abort_due_to_error;
          }  
          if (u.ao.pC->nullRow) {
            (u.ao.payloadSize = 0);
          } 
          else if ((u.ao.pC->cacheStatus == p->cacheCtr)) {
            (u.ao.payloadSize = u.ao.pC->payloadSize);
            (u.ao.zRec = ((char *) u.ao.pC->aRow));
          }
          
          else if (u.ao.pC->isIndex) {
            ((void ) 0);
            sqlite3BtreeKeySize(u.ao.pCrsr, (&u.ao.payloadSize64));
            ((void ) 0);
            ((void ) 0);
            (u.ao.payloadSize = ((u32 ) u.ao.payloadSize64));
          } 
          else {
            ((void ) 0);
            sqlite3BtreeDataSize(u.ao.pCrsr, (&u.ao.payloadSize));
            ((void ) 0);
          }
        } 
        else if ((((id2i_sqlite_coverage_test ) ) && 1)) {
          (u.ao.pReg = (&aMem[u.ao.pC->pseudoTableReg]));
          if (u.ao.pC->multiPseudo) {
            sqlite3VdbeMemShallowCopy(u.ao.pDest, (u.ao.pReg + u.ao.p2), 0x1000);
            if ((((u.ao.pDest->flags & 0x1000) != 0) && sqlite3VdbeMemMakeWriteable(u.ao.pDest))) {
              goto _1319_no_mem;
            }  
            goto _1319_op_column_out;
          }  
          ((void ) 0);
          ((void ) 0);
          (u.ao.payloadSize = u.ao.pReg->n);
          (u.ao.zRec = u.ao.pReg->z);
          (u.ao.pC->cacheStatus = ((pOp->p5 & 0x20) ? 0 : p->cacheCtr));
          ((void ) 0);
        }
        
        else if (((((! id2i_sqlite_coverage_test) ) ) && (u.ao.pC->pseudoTableReg > 0))) {
          (u.ao.pReg = (&aMem[u.ao.pC->pseudoTableReg]));
          if (u.ao.pC->multiPseudo) {
            sqlite3VdbeMemShallowCopy(u.ao.pDest, (u.ao.pReg + u.ao.p2), 0x1000);
            if ((((u.ao.pDest->flags & 0x1000) != 0) && sqlite3VdbeMemMakeWriteable(u.ao.pDest))) {
              goto _1319_no_mem;
            }  
            goto _1319_op_column_out;
          }  
          ((void ) 0);
          ((void ) 0);
          (u.ao.payloadSize = u.ao.pReg->n);
          (u.ao.zRec = u.ao.pReg->z);
          (u.ao.pC->cacheStatus = ((pOp->p5 & 0x20) ? 0 : p->cacheCtr));
          ((void ) 0);
        } 
        else {
          (u.ao.payloadSize = 0);
        }
        if ((u.ao.payloadSize == 0)) {
          (u.ao.pDest->flags = ((u.ao.pDest->flags & (~ (0x01ff | 0x4000))) | 0x0001));
          goto _1319_op_column_out;
        }  
        ((void ) 0);
        if ((u.ao.payloadSize > ((u32 ) db->aLimit[0]))) {
          goto _1319_too_big;
        }  
        (u.ao.nField = u.ao.pC->nField);
        ((void ) 0);
        (u.ao.aType = u.ao.pC->aType);
        if ((u.ao.pC->cacheStatus == p->cacheCtr)) {
          (u.ao.aOffset = u.ao.pC->aOffset);
        }  
        else {
          ((void ) 0);
          (u.ao.avail = 0);
          (u.ao.pC->aOffset = (u.ao.aOffset = (&u.ao.aType[u.ao.nField])));
          (u.ao.pC->payloadSize = u.ao.payloadSize);
          (u.ao.pC->cacheStatus = p->cacheCtr);
          if (u.ao.zRec) {
            (u.ao.zData = u.ao.zRec);
          }  
          else {
            if (u.ao.pC->isIndex) {
              (u.ao.zData = ((char *) sqlite3BtreeKeyFetch(u.ao.pCrsr, (&u.ao.avail))));
            }  
            else {
              (u.ao.zData = ((char *) sqlite3BtreeDataFetch(u.ao.pCrsr, (&u.ao.avail))));
            }
            ((void ) 0);
            if ((u.ao.payloadSize <= ((u32 ) u.ao.avail))) {
              (u.ao.zRec = u.ao.zData);
              (u.ao.pC->aRow = ((u8 *) u.ao.zData));
            }  
            else {
              (u.ao.pC->aRow = 0);
            }
          }
          (u.ao.szHdr = ((u8 ) (((*((u8 *) u.ao.zData)) < ((u8 ) 0x80)) ? (u.ao.offset = ((u32 ) (*((u8 *) u.ao.zData)))), 1 : sqlite3GetVarint32(((u8 *) u.ao.zData), ((u32 *) (&u.ao.offset))))));
          if ((u.ao.offset > 98307)) {
            (rc = sqlite3CorruptError(68326));
            goto _1319_op_column_out;
          }  
          (u.ao.len = ((u.ao.nField * 5) + 3));
          if ((u.ao.len > ((int ) u.ao.offset))) {
            (u.ao.len = ((int ) u.ao.offset));
          }  
          if (((! u.ao.zRec) && (u.ao.avail < u.ao.len))) {
            (u.ao.sMem.flags = 0);
            (u.ao.sMem.db = 0);
            (rc = sqlite3VdbeMemFromBtree(u.ao.pCrsr, 0, u.ao.len, u.ao.pC->isIndex, (&u.ao.sMem)));
            if ((rc != 0)) {
              goto _1319_op_column_out;
            }  
            (u.ao.zData = u.ao.sMem.z);
          }  
          (u.ao.zEndHdr = ((u8 *) (&u.ao.zData[u.ao.len])));
          (u.ao.zIdx = ((u8 *) (&u.ao.zData[u.ao.szHdr])));
          for ((u.ao.i = 0); (u.ao.i < u.ao.nField); u.ao.i++) {
            if ((u.ao.zIdx < u.ao.zEndHdr)) {
              (u.ao.aOffset[u.ao.i] = u.ao.offset);
              if ((u.ao.zIdx[0] < 0x80)) {
                (u.ao.t = u.ao.zIdx[0]);
                u.ao.zIdx++;
              }  
              else {
                (u.ao.zIdx += sqlite3GetVarint32(u.ao.zIdx, (&u.ao.t)));
              }
              (u.ao.aType[u.ao.i] = u.ao.t);
              (u.ao.szField = sqlite3VdbeSerialTypeLen(u.ao.t));
              (u.ao.offset += u.ao.szField);
              if ((u.ao.offset < u.ao.szField)) {
                (u.ao.zIdx = (&u.ao.zEndHdr[1]));
                break;
              }  
            }  
            else {
              (u.ao.aOffset[u.ao.i] = 0);
            }
          }
          sqlite3VdbeMemRelease((&u.ao.sMem));
          (u.ao.sMem.flags = 0x0001);
          if (((u.ao.zIdx > u.ao.zEndHdr) || (u.ao.offset > u.ao.payloadSize) || ((u.ao.zIdx == u.ao.zEndHdr) && (u.ao.offset != u.ao.payloadSize)))) {
            (rc = sqlite3CorruptError(68406));
            goto _1319_op_column_out;
          }  
        }
        if (u.ao.aOffset[u.ao.p2]) {
          ((void ) 0);
          if (u.ao.zRec) {
            if ((u.ao.pDest->flags & (0x2000 | 0x0400 | 0x0020 | 0x0040))) {
              sqlite3VdbeMemReleaseExternal(u.ao.pDest);
            }  
            sqlite3VdbeSerialGet(((u8 *) (&u.ao.zRec[u.ao.aOffset[u.ao.p2]])), u.ao.aType[u.ao.p2], u.ao.pDest);
          }  
          else {
            (u.ao.t = u.ao.aType[u.ao.p2]);
            if ((((pOp->p5 & (0x40 | 0x80)) != 0) && (((u.ao.t >= 12) && ((u.ao.t & 1) == 0)) || ((pOp->p5 & 0x80) != 0)))) {
              (u.ao.zData = ((u.ao.t < 12) ? ((char *) (&u.ao.payloadSize64)) : 0));
            }  
            else {
              (u.ao.len = sqlite3VdbeSerialTypeLen(u.ao.t));
              sqlite3VdbeMemMove((&u.ao.sMem), u.ao.pDest);
              (rc = sqlite3VdbeMemFromBtree(u.ao.pCrsr, u.ao.aOffset[u.ao.p2], u.ao.len, u.ao.pC->isIndex, (&u.ao.sMem)));
              if ((rc != 0)) {
                goto _1319_op_column_out;
              }  
              (u.ao.zData = u.ao.sMem.z);
            }
            sqlite3VdbeSerialGet(((u8 *) u.ao.zData), u.ao.t, u.ao.pDest);
          }
          (u.ao.pDest->enc = encoding);
        }  
        else {
          if ((pOp->p4type == (- 8))) {
            sqlite3VdbeMemShallowCopy(u.ao.pDest, pOp->p4.pMem, 0x0800);
          }  
          else {
            (u.ao.pDest->flags = ((u.ao.pDest->flags & (~ (0x01ff | 0x4000))) | 0x0001));
          }
        }
        if (u.ao.sMem.zMalloc) {
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (u.ao.pDest->flags &= (~ (0x1000 | 0x0800)));
          (u.ao.pDest->flags |= 0x0200);
          (u.ao.pDest->z = u.ao.sMem.z);
          (u.ao.pDest->zMalloc = u.ao.sMem.zMalloc);
        }  
        (rc = sqlite3VdbeMemMakeWriteable(u.ao.pDest));
        _1319_op_column_out:
        break;
      }
      case 42:
      {
        (u.ap.zAffinity = pOp->p4.z);
        ((void ) 0);
        ((void ) 0);
        (pIn1 = (&aMem[pOp->p1]));
        while (((u.ap.cAff = (*u.ap.zAffinity++)) != 0)) {
          ((void ) 0);
          ((void ) 0);
          ((pIn1->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn1) : 0);
          applyAffinity(pIn1, u.ap.cAff, encoding);
          pIn1++;
        }
        break;
      }
      case 43:
      {
        (u.aq.nData = 0);
        (u.aq.nHdr = 0);
        (u.aq.nZero = 0);
        (u.aq.nField = pOp->p1);
        (u.aq.zAffinity = pOp->p4.z);
        ((void ) 0);
        (u.aq.pData0 = (&aMem[u.aq.nField]));
        (u.aq.nField = pOp->p2);
        (u.aq.pLast = (&u.aq.pData0[(u.aq.nField - 1)]));
        (u.aq.file_format = p->minWriteFileFormat);
        ((void ) 0);
        (pOut = (&aMem[pOp->p3]));
        for ((u.aq.pRec = u.aq.pData0); (u.aq.pRec <= u.aq.pLast); u.aq.pRec++) {
          ((void ) 0);
          if (u.aq.zAffinity) {
            applyAffinity(u.aq.pRec, u.aq.zAffinity[(u.aq.pRec - u.aq.pData0)], encoding);
          }  
          if (((u.aq.pRec->flags & 0x4000) && (u.aq.pRec->n > 0))) {
            sqlite3VdbeMemExpandBlob(u.aq.pRec);
          }  
          (u.aq.serial_type = sqlite3VdbeSerialType(u.aq.pRec, u.aq.file_format));
          (u.aq.len = sqlite3VdbeSerialTypeLen(u.aq.serial_type));
          (u.aq.nData += u.aq.len);
          (u.aq.nHdr += sqlite3VarintLen(u.aq.serial_type));
          if ((u.aq.pRec->flags & 0x4000)) {
            (u.aq.nZero += u.aq.pRec->u.nZero);
          } 
          else if (u.aq.len) {
            (u.aq.nZero = 0);
          } 
        }
        (u.aq.nHdr += (u.aq.nVarint = sqlite3VarintLen(u.aq.nHdr)));
        if ((u.aq.nVarint < sqlite3VarintLen(u.aq.nHdr))) {
          u.aq.nHdr++;
        }  
        (u.aq.nByte = (u.aq.nHdr + u.aq.nData - u.aq.nZero));
        if ((u.aq.nByte > db->aLimit[0])) {
          goto _1319_too_big;
        }  
        if (sqlite3VdbeMemGrow(pOut, ((int ) u.aq.nByte), 0)) {
          goto _1319_no_mem;
        }  
        (u.aq.zNewRecord = ((u8 *) pOut->z));
        (u.aq.i = ((u8 ) ((((u32 ) u.aq.nHdr) < ((u32 ) 0x80)) ? ((*u.aq.zNewRecord) = ((unsigned  char ) u.aq.nHdr)), 1 : sqlite3PutVarint32(u.aq.zNewRecord, u.aq.nHdr))));
        for ((u.aq.pRec = u.aq.pData0); (u.aq.pRec <= u.aq.pLast); u.aq.pRec++) {
          (u.aq.serial_type = sqlite3VdbeSerialType(u.aq.pRec, u.aq.file_format));
          (u.aq.i += ((u8 ) ((((u32 ) u.aq.serial_type) < ((u32 ) 0x80)) ? ((*(&u.aq.zNewRecord[u.aq.i])) = ((unsigned  char ) u.aq.serial_type)), 1 : sqlite3PutVarint32((&u.aq.zNewRecord[u.aq.i]), u.aq.serial_type))));
        }
        for ((u.aq.pRec = u.aq.pData0); (u.aq.pRec <= u.aq.pLast); u.aq.pRec++) {
          (u.aq.i += sqlite3VdbeSerialPut((&u.aq.zNewRecord[u.aq.i]), ((int ) (u.aq.nByte - u.aq.i)), u.aq.pRec, u.aq.file_format));
        }
        ((void ) 0);
        ((void ) 0);
        (pOut->n = ((int ) u.aq.nByte));
        (pOut->flags = (0x0010 | 0x0400));
        (pOut->xDel = 0);
        if (u.aq.nZero) {
          (pOut->u.nZero = u.aq.nZero);
          (pOut->flags |= 0x4000);
        }  
        (pOut->enc = 1);
        break;
      }
      case 44:
      {
        (u.ar.pCrsr = p->apCsr[pOp->p1]->pCursor);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            (rc = sqlite3BtreeCount(u.ar.pCrsr, (&u.ar.nEntry)));
          }  
          else {
            (u.ar.nEntry = 0);
          }
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if (u.ar.pCrsr) {
            (rc = sqlite3BtreeCount(u.ar.pCrsr, (&u.ar.nEntry)));
          }  
          else {
            (u.ar.nEntry = 0);
          }
        }  
        (pOut->u.i = u.ar.nEntry);
        break;
      }
      case 2:
      {
        (u.as.p1 = pOp->p1);
        (u.as.zName = pOp->p4.z);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if ((u.as.p1 == 0)) {
          if ((db->nVdbeWrite > 0)) {
            sqlite3SetString((&p->zErrMsg), db, "cannot open savepoint - " "SQL statements in progress");
            (rc = 5);
          }  
          else {
            (u.as.nName = sqlite3Strlen30(u.as.zName));
            ((void ) 0);
            (rc = sqlite3VtabSavepoint(db, 0, (db->nStatement + db->nSavepoint)));
            if ((rc != 0)) {
              goto _1319_abort_due_to_error;
            }  
            (u.as.pNew = sqlite3DbMallocRaw(db, (sizeof(Savepoint ) + u.as.nName + 1)));
            if (u.as.pNew) {
              (u.as.pNew->zName = ((char *) (&u.as.pNew[1])));
              memcpy(u.as.pNew->zName, u.as.zName, (u.as.nName + 1));
              if (db->autoCommit) {
                (db->autoCommit = 0);
                (db->isTransactionSavepoint = 1);
              }  
              else {
                db->nSavepoint++;
              }
              (u.as.pNew->pNext = db->pSavepoint);
              (db->pSavepoint = u.as.pNew);
              (u.as.pNew->nDeferredCons = db->nDeferredCons);
              (u.as.pNew->nDeferredImmCons = db->nDeferredImmCons);
            }  
          }
        }  
        else {
          (u.as.iSavepoint = 0);
          for ((u.as.pSavepoint = db->pSavepoint); (u.as.pSavepoint && sqlite3_stricmp(u.as.pSavepoint->zName, u.as.zName)); (u.as.pSavepoint = u.as.pSavepoint->pNext)) {
            u.as.iSavepoint++;
          }
          if ((! u.as.pSavepoint)) {
            sqlite3SetString((&p->zErrMsg), db, "no such savepoint: %s", u.as.zName);
            (rc = 1);
          } 
          else if (((db->nVdbeWrite > 0) && (u.as.p1 == 1))) {
            sqlite3SetString((&p->zErrMsg), db, "cannot release savepoint - SQL statements in progress");
            (rc = 5);
          } 
          else {
            int isTransaction =  ((u.as.pSavepoint->pNext == 0) && db->isTransactionSavepoint);
            if ((isTransaction && (u.as.p1 == 1))) {
              if (((id2i_sqlite_omit_foreign_key ) )) {
                if (((rc = 0) != 0)) {
                  goto _1319_vdbe_return;
                }  
              }  
              if ((((! id2i_sqlite_omit_foreign_key) ) )) {
                if (((rc = sqlite3VdbeCheckFk(p, 1)) != 0)) {
                  goto _1319_vdbe_return;
                }  
              }  
              (db->autoCommit = 1);
              if ((sqlite3VdbeHalt(p) == 5)) {
                (p->pc = pc);
                (db->autoCommit = 0);
                (p->rc = (rc = 5));
                goto _1319_vdbe_return;
              }  
              (db->isTransactionSavepoint = 0);
              (rc = p->rc);
            }  
            else {
              (u.as.iSavepoint = (db->nSavepoint - u.as.iSavepoint - 1));
              if ((u.as.p1 == 2)) {
                for ((u.as.ii = 0); (u.as.ii < db->nDb); u.as.ii++) {
                  sqlite3BtreeTripAllCursors(db->aDb[u.as.ii].pBt, 4);
                }
              }  
              for ((u.as.ii = 0); (u.as.ii < db->nDb); u.as.ii++) {
                (rc = sqlite3BtreeSavepoint(db->aDb[u.as.ii].pBt, u.as.p1, u.as.iSavepoint));
                if ((rc != 0)) {
                  goto _1319_abort_due_to_error;
                }  
              }
              if (((u.as.p1 == 2) && ((db->flags & 0x00000002) != 0))) {
                sqlite3ExpirePreparedStatements(db);
                sqlite3ResetAllSchemasOfConnection(db);
                (db->flags = (db->flags | 0x00000002));
              }  
            }
            while ((db->pSavepoint != u.as.pSavepoint)) {
              (u.as.pTmp = db->pSavepoint);
              (db->pSavepoint = u.as.pTmp->pNext);
              sqlite3DbFree(db, u.as.pTmp);
              db->nSavepoint--;
            }
            if ((u.as.p1 == 1)) {
              ((void ) 0);
              (db->pSavepoint = u.as.pSavepoint->pNext);
              sqlite3DbFree(db, u.as.pSavepoint);
              if ((! isTransaction)) {
                db->nSavepoint--;
              }  
            }  
            else {
              (db->nDeferredCons = u.as.pSavepoint->nDeferredCons);
              (db->nDeferredImmCons = u.as.pSavepoint->nDeferredImmCons);
            }
            if ((! isTransaction)) {
              (rc = sqlite3VtabSavepoint(db, u.as.p1, u.as.iSavepoint));
              if ((rc != 0)) {
                goto _1319_abort_due_to_error;
              }  
            }  
          }
        }
        break;
      }
      case 3:
      {
        (u.at.desiredAutoCommit = pOp->p1);
        (u.at.iRollback = pOp->p2);
        (u.at.turnOnAC = (u.at.desiredAutoCommit && (! db->autoCommit)));
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if ((u.at.turnOnAC && (! u.at.iRollback) && (db->nVdbeWrite > 0))) {
          sqlite3SetString((&p->zErrMsg), db, "cannot commit transaction - " "SQL statements in progress");
          (rc = 5);
        } 
        else if ((u.at.desiredAutoCommit != db->autoCommit)) {
          if (u.at.iRollback) {
            ((void ) 0);
            sqlite3RollbackAll(db, (4 | (2 << 8)));
            (db->autoCommit = 1);
          } 
          else if ((((id2i_sqlite_omit_foreign_key ) ) && ((rc = 0) != 0))) {
            goto _1319_vdbe_return;
          }
          
          else if (((((! id2i_sqlite_omit_foreign_key) ) ) && ((rc = sqlite3VdbeCheckFk(p, 1)) != 0))) {
            goto _1319_vdbe_return;
          } 
          else {
            (db->autoCommit = ((u8 ) u.at.desiredAutoCommit));
            if ((sqlite3VdbeHalt(p) == 5)) {
              (p->pc = pc);
              (db->autoCommit = ((u8 ) (1 - u.at.desiredAutoCommit)));
              (p->rc = (rc = 5));
              goto _1319_vdbe_return;
            }  
          }
          ((void ) 0);
          sqlite3CloseSavepoints(db);
          if ((p->rc == 0)) {
            (rc = 101);
          }  
          else {
            (rc = 1);
          }
          goto _1319_vdbe_return;
        } 
        else {
          sqlite3SetString((&p->zErrMsg), db, ((! u.at.desiredAutoCommit) ? "cannot start a transaction within a transaction" : (u.at.iRollback ? "cannot rollback - no transaction is active" : "cannot commit - no transaction is active")));
          (rc = 1);
        }
        break;
      }
      case 4:
      {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if ((pOp->p2 && ((db->flags & 0x02000000) != 0))) {
          (rc = 8);
          goto _1319_abort_due_to_error;
        }  
        (u.au.pBt = db->aDb[pOp->p1].pBt);
        if (u.au.pBt) {
          (rc = sqlite3BtreeBeginTrans(u.au.pBt, pOp->p2));
          if ((rc == 5)) {
            (p->pc = pc);
            (p->rc = (rc = 5));
            goto _1319_vdbe_return;
          }  
          if ((rc != 0)) {
            goto _1319_abort_due_to_error;
          }  
          if ((pOp->p2 && p->usesStmtJournal && ((db->autoCommit == 0) || (db->nVdbeRead > 1)))) {
            ((void ) 0);
            if ((p->iStatement == 0)) {
              ((void ) 0);
              db->nStatement++;
              (p->iStatement = (db->nSavepoint + db->nStatement));
            }  
            (rc = sqlite3VtabSavepoint(db, 0, (p->iStatement - 1)));
            if ((rc == 0)) {
              (rc = sqlite3BtreeBeginStmt(u.au.pBt, p->iStatement));
            }  
            (p->nStmtDefCons = db->nDeferredCons);
            (p->nStmtDefImmCons = db->nDeferredImmCons);
          }  
        }  
        break;
      }
      case 45:
      {
        ((void ) 0);
        (u.av.iDb = pOp->p1);
        (u.av.iCookie = pOp->p3);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        sqlite3BtreeGetMeta(db->aDb[u.av.iDb].pBt, u.av.iCookie, ((u32 *) (&u.av.iMeta)));
        (pOut->u.i = u.av.iMeta);
        break;
      }
      case 46:
      {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.aw.pDb = (&db->aDb[pOp->p1]));
        ((void ) 0);
        ((void ) 0);
        (pIn3 = (&aMem[pOp->p3]));
        sqlite3VdbeMemIntegerify(pIn3);
        (rc = sqlite3BtreeUpdateMeta(u.aw.pDb->pBt, pOp->p2, ((int ) pIn3->u.i)));
        if ((pOp->p2 == 1)) {
          (u.aw.pDb->pSchema->schema_cookie = ((int ) pIn3->u.i));
          (db->flags |= 0x00000002);
        } 
        else if ((pOp->p2 == 2)) {
          (u.aw.pDb->pSchema->file_format = ((u8 ) pIn3->u.i));
        } 
        if ((pOp->p1 == 1)) {
          sqlite3ExpirePreparedStatements(db);
          (p->expired = 0);
        }  
        break;
      }
      case 47:
      {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.ax.pBt = db->aDb[pOp->p1].pBt);
        if (u.ax.pBt) {
          sqlite3BtreeGetMeta(u.ax.pBt, 1, ((u32 *) (&u.ax.iMeta)));
          (u.ax.iGen = db->aDb[pOp->p1].pSchema->iGeneration);
        }  
        else {
          (u.ax.iGen = (u.ax.iMeta = 0));
        }
        if (((u.ax.iMeta != pOp->p2) || (u.ax.iGen != pOp->p3))) {
          sqlite3DbFree(db, p->zErrMsg);
          (p->zErrMsg = sqlite3DbStrDup(db, "database schema has changed"));
          if ((db->aDb[pOp->p1].pSchema->schema_cookie != u.ax.iMeta)) {
            sqlite3ResetOneSchema(db, pOp->p1);
          }  
          (p->expired = 1);
          (rc = 17);
        }  
        break;
      }
      case 48:
      case 49:
      {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if (p->expired) {
          (rc = 4);
          break;
        }  
        (u.ay.nField = 0);
        (u.ay.pKeyInfo = 0);
        (u.ay.p2 = pOp->p2);
        (u.ay.iDb = pOp->p3);
        ((void ) 0);
        ((void ) 0);
        (u.ay.pDb = (&db->aDb[u.ay.iDb]));
        (u.ay.pX = u.ay.pDb->pBt);
        ((void ) 0);
        if ((pOp->opcode == 49)) {
          (u.ay.wrFlag = 1);
          ((void ) 0);
          if ((u.ay.pDb->pSchema->file_format < p->minWriteFileFormat)) {
            (p->minWriteFileFormat = u.ay.pDb->pSchema->file_format);
          }  
        }  
        else {
          (u.ay.wrFlag = 0);
        }
        if ((pOp->p5 & 0x02)) {
          ((void ) 0);
          ((void ) 0);
          (pIn2 = (&aMem[u.ay.p2]));
          ((void ) 0);
          ((void ) 0);
          sqlite3VdbeMemIntegerify(pIn2);
          (u.ay.p2 = ((int ) pIn2->u.i));
          if (((id2i_sqlite_coverage_test ) )) {
            if (0) {
              (rc = sqlite3CorruptError(69234));
              goto _1319_abort_due_to_error;
            }  
          }  
          if ((((! id2i_sqlite_coverage_test) ) )) {
            if ((u.ay.p2 < 2)) {
              (rc = sqlite3CorruptError(69234));
              goto _1319_abort_due_to_error;
            }  
          }  
        }  
        if ((pOp->p4type == (- 6))) {
          (u.ay.pKeyInfo = pOp->p4.pKeyInfo);
          (u.ay.pKeyInfo->enc = p->db->aDb[0].pSchema->enc);
          (u.ay.nField = (u.ay.pKeyInfo->nField + 1));
        } 
        else if ((pOp->p4type == (- 14))) {
          (u.ay.nField = pOp->p4.i);
        } 
        ((void ) 0);
        (u.ay.pCur = allocateCursor(p, pOp->p1, u.ay.nField, u.ay.iDb, 1));
        if ((u.ay.pCur == 0)) {
          goto _1319_no_mem;
        }  
        (u.ay.pCur->nullRow = 1);
        (u.ay.pCur->isOrdered = 1);
        (rc = sqlite3BtreeCursor(u.ay.pX, u.ay.p2, u.ay.wrFlag, u.ay.pKeyInfo, u.ay.pCur->pCursor));
        (u.ay.pCur->pKeyInfo = u.ay.pKeyInfo);
        ((void ) 0);
        sqlite3BtreeCursorHints(u.ay.pCur->pCursor, (pOp->p5 & 0x01));
        ((void ) 0);
        (u.ay.pCur->isTable = (pOp->p4type != (- 6)));
        (u.ay.pCur->isIndex = (! u.ay.pCur->isTable));
        break;
      }
      case 50:
      case 51:
      {
        static const int vfsFlags =  (0x00000002 | 0x00000004 | 0x00000010 | 0x00000008 | 0x00000400);
        ((void ) 0);
        (u.az.pCx = allocateCursor(p, pOp->p1, pOp->p2, (- 1), 1));
        if ((u.az.pCx == 0)) {
          goto _1319_no_mem;
        }  
        (u.az.pCx->nullRow = 1);
        (rc = sqlite3BtreeOpen(db->pVfs, 0, db, (&u.az.pCx->pBt), (1 | 4 | pOp->p5), vfsFlags));
        if ((rc == 0)) {
          (rc = sqlite3BtreeBeginTrans(u.az.pCx->pBt, 1));
        }  
        if ((rc == 0)) {
          if (pOp->p4.pKeyInfo) {
            int pgno;
            ((void ) 0);
            (rc = sqlite3BtreeCreateTable(u.az.pCx->pBt, (&pgno), (2 | pOp->p5)));
            if ((rc == 0)) {
              ((void ) 0);
              (rc = sqlite3BtreeCursor(u.az.pCx->pBt, pgno, 1, ((KeyInfo *) pOp->p4.z), u.az.pCx->pCursor));
              (u.az.pCx->pKeyInfo = pOp->p4.pKeyInfo);
              (u.az.pCx->pKeyInfo->enc = p->db->aDb[0].pSchema->enc);
            }  
            (u.az.pCx->isTable = 0);
          }  
          else {
            (rc = sqlite3BtreeCursor(u.az.pCx->pBt, 1, 1, 0, u.az.pCx->pCursor));
            (u.az.pCx->isTable = 1);
          }
        }  
        (u.az.pCx->isOrdered = (pOp->p5 != 8));
        (u.az.pCx->isIndex = (! u.az.pCx->isTable));
        break;
      }
      case 52:
      {
        (u.ba.pCx = allocateCursor(p, pOp->p1, pOp->p2, (- 1), 1));
        if ((u.ba.pCx == 0)) {
          goto _1319_no_mem;
        }  
        (u.ba.pCx->pKeyInfo = pOp->p4.pKeyInfo);
        (u.ba.pCx->pKeyInfo->enc = p->db->aDb[0].pSchema->enc);
        (u.ba.pCx->isSorter = 1);
        (rc = sqlite3VdbeSorterInit(db, u.ba.pCx));
        break;
      }
      case 53:
      {
        ((void ) 0);
        (u.bb.pCx = allocateCursor(p, pOp->p1, pOp->p3, (- 1), 0));
        if ((u.bb.pCx == 0)) {
          goto _1319_no_mem;
        }  
        (u.bb.pCx->nullRow = 1);
        (u.bb.pCx->pseudoTableReg = pOp->p2);
        (u.bb.pCx->isTable = 1);
        (u.bb.pCx->isIndex = 0);
        (u.bb.pCx->multiPseudo = pOp->p5);
        break;
      }
      case 54:
      {
        ((void ) 0);
        sqlite3VdbeFreeCursor(p, p->apCsr[pOp->p1]);
        (p->apCsr[pOp->p1] = 0);
        break;
      }
      case 55:
      case 56:
      case 57:
      case 58:
      {
        ((void ) 0);
        ((void ) 0);
        (u.bc.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            (u.bc.oc = pOp->opcode);
            (u.bc.pC->nullRow = 0);
            if (u.bc.pC->isTable) {
              (pIn3 = (&aMem[pOp->p3]));
              applyNumericAffinity(pIn3);
              (u.bc.iKey = sqlite3VdbeIntValue(pIn3));
              (u.bc.pC->rowidIsValid = 0);
              if (((pIn3->flags & 0x0004) == 0)) {
                if (((pIn3->flags & 0x0008) == 0)) {
                  (pc = (pOp->p2 - 1));
                  break;
                }  
                ((void ) 0);
                if (((u.bc.iKey == (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32)))) && ((pIn3->r < ((double ) u.bc.iKey)) || (pIn3->r > 0)))) {
                  (u.bc.res = 1);
                  if ((pIn3->r < 0)) {
                    if ((u.bc.oc >= 57)) {
                      ((void ) 0);
                      (rc = sqlite3BtreeFirst(u.bc.pC->pCursor, (&u.bc.res)));
                      if ((rc != 0)) {
                        goto _1319_abort_due_to_error;
                      }  
                    }  
                  }  
                  else {
                    if ((u.bc.oc <= 56)) {
                      ((void ) 0);
                      (rc = sqlite3BtreeLast(u.bc.pC->pCursor, (&u.bc.res)));
                      if ((rc != 0)) {
                        goto _1319_abort_due_to_error;
                      }  
                    }  
                  }
                  if (u.bc.res) {
                    (pc = (pOp->p2 - 1));
                  }  
                  break;
                } 
                else if (((u.bc.oc == 55) || (u.bc.oc == 57))) {
                  if ((pIn3->r > ((double ) u.bc.iKey))) {
                    u.bc.iKey++;
                  }  
                } 
                else {
                  ((void ) 0);
                  if ((pIn3->r < ((double ) u.bc.iKey))) {
                    u.bc.iKey--;
                  }  
                }
              }  
              (rc = sqlite3BtreeMovetoUnpacked(u.bc.pC->pCursor, 0, ((u64 ) u.bc.iKey), 0, (&u.bc.res)));
              if ((rc != 0)) {
                goto _1319_abort_due_to_error;
              }  
              if ((u.bc.res == 0)) {
                (u.bc.pC->rowidIsValid = 1);
                (u.bc.pC->lastRowid = u.bc.iKey);
              }  
            }  
            else {
              (u.bc.nField = pOp->p4.i);
              ((void ) 0);
              ((void ) 0);
              (u.bc.r.pKeyInfo = u.bc.pC->pKeyInfo);
              (u.bc.r.nField = ((u16 ) u.bc.nField));
              (u.bc.r.flags = ((u8 ) (0x01 * (1 & (u.bc.oc - 55)))));
              ((void ) 0);
              ((void ) 0);
              ((void ) 0);
              ((void ) 0);
              (u.bc.r.aMem = (&aMem[pOp->p3]));
              ((u.bc.r.aMem->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(u.bc.r.aMem) : 0);
              (rc = sqlite3BtreeMovetoUnpacked(u.bc.pC->pCursor, (&u.bc.r), 0, 0, (&u.bc.res)));
              if ((rc != 0)) {
                goto _1319_abort_due_to_error;
              }  
              (u.bc.pC->rowidIsValid = 0);
            }
            (u.bc.pC->deferredMoveto = 0);
            (u.bc.pC->cacheStatus = 0);
            if ((u.bc.oc >= 57)) {
              ((void ) 0);
              if (((u.bc.res < 0) || ((u.bc.res == 0) && (u.bc.oc == 58)))) {
                (rc = sqlite3BtreeNext(u.bc.pC->pCursor, (&u.bc.res)));
                if ((rc != 0)) {
                  goto _1319_abort_due_to_error;
                }  
                (u.bc.pC->rowidIsValid = 0);
              }  
              else {
                (u.bc.res = 0);
              }
            }  
            else {
              ((void ) 0);
              if (((u.bc.res > 0) || ((u.bc.res == 0) && (u.bc.oc == 55)))) {
                (rc = sqlite3BtreePrevious(u.bc.pC->pCursor, (&u.bc.res)));
                if ((rc != 0)) {
                  goto _1319_abort_due_to_error;
                }  
                (u.bc.pC->rowidIsValid = 0);
              }  
              else {
                (u.bc.res = sqlite3BtreeEof(u.bc.pC->pCursor));
              }
            }
            ((void ) 0);
            if (u.bc.res) {
              (pc = (pOp->p2 - 1));
            }  
          }  
          else {
            (pc = (pOp->p2 - 1));
          }
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bc.pC->pCursor != 0)) {
            (u.bc.oc = pOp->opcode);
            (u.bc.pC->nullRow = 0);
            if (u.bc.pC->isTable) {
              (pIn3 = (&aMem[pOp->p3]));
              applyNumericAffinity(pIn3);
              (u.bc.iKey = sqlite3VdbeIntValue(pIn3));
              (u.bc.pC->rowidIsValid = 0);
              if (((pIn3->flags & 0x0004) == 0)) {
                if (((pIn3->flags & 0x0008) == 0)) {
                  (pc = (pOp->p2 - 1));
                  break;
                }  
                ((void ) 0);
                if (((u.bc.iKey == (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32)))) && ((pIn3->r < ((double ) u.bc.iKey)) || (pIn3->r > 0)))) {
                  (u.bc.res = 1);
                  if ((pIn3->r < 0)) {
                    if ((u.bc.oc >= 57)) {
                      ((void ) 0);
                      (rc = sqlite3BtreeFirst(u.bc.pC->pCursor, (&u.bc.res)));
                      if ((rc != 0)) {
                        goto _1319_abort_due_to_error;
                      }  
                    }  
                  }  
                  else {
                    if ((u.bc.oc <= 56)) {
                      ((void ) 0);
                      (rc = sqlite3BtreeLast(u.bc.pC->pCursor, (&u.bc.res)));
                      if ((rc != 0)) {
                        goto _1319_abort_due_to_error;
                      }  
                    }  
                  }
                  if (u.bc.res) {
                    (pc = (pOp->p2 - 1));
                  }  
                  break;
                } 
                else if (((u.bc.oc == 55) || (u.bc.oc == 57))) {
                  if ((pIn3->r > ((double ) u.bc.iKey))) {
                    u.bc.iKey++;
                  }  
                } 
                else {
                  ((void ) 0);
                  if ((pIn3->r < ((double ) u.bc.iKey))) {
                    u.bc.iKey--;
                  }  
                }
              }  
              (rc = sqlite3BtreeMovetoUnpacked(u.bc.pC->pCursor, 0, ((u64 ) u.bc.iKey), 0, (&u.bc.res)));
              if ((rc != 0)) {
                goto _1319_abort_due_to_error;
              }  
              if ((u.bc.res == 0)) {
                (u.bc.pC->rowidIsValid = 1);
                (u.bc.pC->lastRowid = u.bc.iKey);
              }  
            }  
            else {
              (u.bc.nField = pOp->p4.i);
              ((void ) 0);
              ((void ) 0);
              (u.bc.r.pKeyInfo = u.bc.pC->pKeyInfo);
              (u.bc.r.nField = ((u16 ) u.bc.nField));
              (u.bc.r.flags = ((u8 ) (0x01 * (1 & (u.bc.oc - 55)))));
              ((void ) 0);
              ((void ) 0);
              ((void ) 0);
              ((void ) 0);
              (u.bc.r.aMem = (&aMem[pOp->p3]));
              ((u.bc.r.aMem->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(u.bc.r.aMem) : 0);
              (rc = sqlite3BtreeMovetoUnpacked(u.bc.pC->pCursor, (&u.bc.r), 0, 0, (&u.bc.res)));
              if ((rc != 0)) {
                goto _1319_abort_due_to_error;
              }  
              (u.bc.pC->rowidIsValid = 0);
            }
            (u.bc.pC->deferredMoveto = 0);
            (u.bc.pC->cacheStatus = 0);
            if ((u.bc.oc >= 57)) {
              ((void ) 0);
              if (((u.bc.res < 0) || ((u.bc.res == 0) && (u.bc.oc == 58)))) {
                (rc = sqlite3BtreeNext(u.bc.pC->pCursor, (&u.bc.res)));
                if ((rc != 0)) {
                  goto _1319_abort_due_to_error;
                }  
                (u.bc.pC->rowidIsValid = 0);
              }  
              else {
                (u.bc.res = 0);
              }
            }  
            else {
              ((void ) 0);
              if (((u.bc.res > 0) || ((u.bc.res == 0) && (u.bc.oc == 55)))) {
                (rc = sqlite3BtreePrevious(u.bc.pC->pCursor, (&u.bc.res)));
                if ((rc != 0)) {
                  goto _1319_abort_due_to_error;
                }  
                (u.bc.pC->rowidIsValid = 0);
              }  
              else {
                (u.bc.res = sqlite3BtreeEof(u.bc.pC->pCursor));
              }
            }
            ((void ) 0);
            if (u.bc.res) {
              (pc = (pOp->p2 - 1));
            }  
          }  
          else {
            (pc = (pOp->p2 - 1));
          }
        }  
        break;
      }
      case 59:
      {
        ((void ) 0);
        (u.bd.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            ((void ) 0);
            (u.bd.pC->nullRow = 0);
            (pIn2 = (&aMem[pOp->p2]));
            (u.bd.pC->movetoTarget = sqlite3VdbeIntValue(pIn2));
            (u.bd.pC->rowidIsValid = 0);
            (u.bd.pC->deferredMoveto = 1);
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bd.pC->pCursor != 0)) {
            ((void ) 0);
            (u.bd.pC->nullRow = 0);
            (pIn2 = (&aMem[pOp->p2]));
            (u.bd.pC->movetoTarget = sqlite3VdbeIntValue(pIn2));
            (u.bd.pC->rowidIsValid = 0);
            (u.bd.pC->deferredMoveto = 1);
          }  
        }  
        break;
      }
      case 60:
      case 61:
      {
        (u.be.alreadyExists = 0);
        ((void ) 0);
        ((void ) 0);
        (u.be.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (pIn3 = (&aMem[pOp->p3]));
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            ((void ) 0);
            if ((pOp->p4.i > 0)) {
              (u.be.r.pKeyInfo = u.be.pC->pKeyInfo);
              (u.be.r.nField = ((u16 ) pOp->p4.i));
              (u.be.r.aMem = pIn3);
              (u.be.r.flags = 0x02);
              (u.be.pIdxKey = (&u.be.r));
            }  
            else {
              (u.be.pIdxKey = sqlite3VdbeAllocUnpackedRecord(u.be.pC->pKeyInfo, u.be.aTempRec, sizeof(u.be.aTempRec), (&u.be.pFree)));
              if ((u.be.pIdxKey == 0)) {
                goto _1319_no_mem;
              }  
              ((void ) 0);
              ((void ) 0);
              sqlite3VdbeRecordUnpack(u.be.pC->pKeyInfo, pIn3->n, pIn3->z, u.be.pIdxKey);
              (u.be.pIdxKey->flags |= 0x02);
            }
            (rc = sqlite3BtreeMovetoUnpacked(u.be.pC->pCursor, u.be.pIdxKey, 0, 0, (&u.be.res)));
            if ((pOp->p4.i == 0)) {
              sqlite3DbFree(db, u.be.pFree);
            }  
            if ((rc != 0)) {
              break;
            }  
            (u.be.alreadyExists = (u.be.res == 0));
            (u.be.pC->deferredMoveto = 0);
            (u.be.pC->cacheStatus = 0);
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.be.pC->pCursor != 0)) {
            ((void ) 0);
            if ((pOp->p4.i > 0)) {
              (u.be.r.pKeyInfo = u.be.pC->pKeyInfo);
              (u.be.r.nField = ((u16 ) pOp->p4.i));
              (u.be.r.aMem = pIn3);
              (u.be.r.flags = 0x02);
              (u.be.pIdxKey = (&u.be.r));
            }  
            else {
              (u.be.pIdxKey = sqlite3VdbeAllocUnpackedRecord(u.be.pC->pKeyInfo, u.be.aTempRec, sizeof(u.be.aTempRec), (&u.be.pFree)));
              if ((u.be.pIdxKey == 0)) {
                goto _1319_no_mem;
              }  
              ((void ) 0);
              ((void ) 0);
              sqlite3VdbeRecordUnpack(u.be.pC->pKeyInfo, pIn3->n, pIn3->z, u.be.pIdxKey);
              (u.be.pIdxKey->flags |= 0x02);
            }
            (rc = sqlite3BtreeMovetoUnpacked(u.be.pC->pCursor, u.be.pIdxKey, 0, 0, (&u.be.res)));
            if ((pOp->p4.i == 0)) {
              sqlite3DbFree(db, u.be.pFree);
            }  
            if ((rc != 0)) {
              break;
            }  
            (u.be.alreadyExists = (u.be.res == 0));
            (u.be.pC->deferredMoveto = 0);
            (u.be.pC->cacheStatus = 0);
          }  
        }  
        if ((pOp->opcode == 61)) {
          if (u.be.alreadyExists) {
            (pc = (pOp->p2 - 1));
          }  
        }  
        else {
          if ((! u.be.alreadyExists)) {
            (pc = (pOp->p2 - 1));
          }  
        }
        break;
      }
      case 62:
      {
        (pIn3 = (&aMem[pOp->p3]));
        (u.bf.aMx = (&aMem[pOp->p4.i]));
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.bf.pCx = p->apCsr[pOp->p1]);
        ((void ) 0);
        (u.bf.pCx->seekResult = 0);
        (u.bf.pCx->cacheStatus = 0);
        (u.bf.pCrsr = u.bf.pCx->pCursor);
        (u.bf.nField = u.bf.pCx->pKeyInfo->nField);
        for ((u.bf.ii = 0); (u.bf.ii < u.bf.nField); u.bf.ii++) {
          if ((u.bf.aMx[u.bf.ii].flags & 0x0001)) {
            (pc = (pOp->p2 - 1));
            (u.bf.pCrsr = 0);
            break;
          }  
        }
        ((void ) 0);
        if ((u.bf.pCrsr != 0)) {
          (u.bf.r.pKeyInfo = u.bf.pCx->pKeyInfo);
          (u.bf.r.nField = (u.bf.nField + 1));
          (u.bf.r.flags = 0x04);
          (u.bf.r.aMem = u.bf.aMx);
          sqlite3VdbeMemIntegerify(pIn3);
          (u.bf.R = pIn3->u.i);
          (rc = sqlite3BtreeMovetoUnpacked(u.bf.pCrsr, (&u.bf.r), 0, 0, (&u.bf.pCx->seekResult)));
          if (((u.bf.r.flags & 0x04) || (u.bf.r.rowid == u.bf.R))) {
            (pc = (pOp->p2 - 1));
          }  
          else {
            (pIn3->u.i = u.bf.r.rowid);
          }
        }  
        break;
      }
      case 63:
      {
        (pIn3 = (&aMem[pOp->p3]));
        ((void ) 0);
        ((void ) 0);
        (u.bg.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.bg.pCrsr = u.bg.pC->pCursor);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            (u.bg.res = 0);
            (u.bg.iKey = pIn3->u.i);
            (rc = sqlite3BtreeMovetoUnpacked(u.bg.pCrsr, 0, u.bg.iKey, 0, (&u.bg.res)));
            (u.bg.pC->lastRowid = pIn3->u.i);
            (u.bg.pC->rowidIsValid = ((u.bg.res == 0) ? 1 : 0));
            (u.bg.pC->nullRow = 0);
            (u.bg.pC->cacheStatus = 0);
            (u.bg.pC->deferredMoveto = 0);
            if ((u.bg.res != 0)) {
              (pc = (pOp->p2 - 1));
              ((void ) 0);
            }  
            (u.bg.pC->seekResult = u.bg.res);
          }  
          else {
            (pc = (pOp->p2 - 1));
            ((void ) 0);
            (u.bg.pC->seekResult = 0);
          }
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bg.pCrsr != 0)) {
            (u.bg.res = 0);
            (u.bg.iKey = pIn3->u.i);
            (rc = sqlite3BtreeMovetoUnpacked(u.bg.pCrsr, 0, u.bg.iKey, 0, (&u.bg.res)));
            (u.bg.pC->lastRowid = pIn3->u.i);
            (u.bg.pC->rowidIsValid = ((u.bg.res == 0) ? 1 : 0));
            (u.bg.pC->nullRow = 0);
            (u.bg.pC->cacheStatus = 0);
            (u.bg.pC->deferredMoveto = 0);
            if ((u.bg.res != 0)) {
              (pc = (pOp->p2 - 1));
              ((void ) 0);
            }  
            (u.bg.pC->seekResult = u.bg.res);
          }  
          else {
            (pc = (pOp->p2 - 1));
            ((void ) 0);
            (u.bg.pC->seekResult = 0);
          }
        }  
        break;
      }
      case 64:
      {
        ((void ) 0);
        ((void ) 0);
        (pOut->u.i = p->apCsr[pOp->p1]->seqCount++);
        break;
      }
      case 65:
      {
        (u.bh.v = 0);
        (u.bh.res = 0);
        ((void ) 0);
        (u.bh.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if (0) {
            
          }  
          else {
            ((void ) 0);
            if ((! u.bh.pC->useRandomRowid)) {
              (u.bh.v = sqlite3BtreeGetCachedRowid(u.bh.pC->pCursor));
              if ((u.bh.v == 0)) {
                (rc = sqlite3BtreeLast(u.bh.pC->pCursor, (&u.bh.res)));
                if ((rc != 0)) {
                  goto _1319_abort_due_to_error;
                }  
                if (u.bh.res) {
                  (u.bh.v = 1);
                }  
                else {
                  ((void ) 0);
                  (rc = sqlite3BtreeKeySize(u.bh.pC->pCursor, (&u.bh.v)));
                  ((void ) 0);
                  if ((u.bh.v >= ((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff))))) {
                    (u.bh.pC->useRandomRowid = 1);
                  }  
                  else {
                    u.bh.v++;
                  }
                }
              }  
              if (pOp->p3) {
                ((void ) 0);
                if (p->pFrame) {
                  for ((u.bh.pFrame = p->pFrame); u.bh.pFrame->pParent; (u.bh.pFrame = u.bh.pFrame->pParent)) {
                    
                  }
                  ((void ) 0);
                  (u.bh.pMem = (&u.bh.pFrame->aMem[pOp->p3]));
                }  
                else {
                  ((void ) 0);
                  (u.bh.pMem = (&aMem[pOp->p3]));
                }
                ((void ) 0);
                sqlite3VdbeMemIntegerify(u.bh.pMem);
                ((void ) 0);
                if (((u.bh.pMem->u.i == ((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff)))) || u.bh.pC->useRandomRowid)) {
                  (rc = 13);
                  goto _1319_abort_due_to_error;
                }  
                if ((u.bh.v < (u.bh.pMem->u.i + 1))) {
                  (u.bh.v = (u.bh.pMem->u.i + 1));
                }  
                (u.bh.pMem->u.i = u.bh.v);
              }  
              sqlite3BtreeSetCachedRowid(u.bh.pC->pCursor, ((u.bh.v < ((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff)))) ? (u.bh.v + 1) : 0));
            }  
            if (u.bh.pC->useRandomRowid) {
              ((void ) 0);
              (u.bh.v = lastRowid);
              (u.bh.v &= (((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff))) >> 1));
              u.bh.v++;
              (u.bh.cnt = 0);
              while ((((rc = sqlite3BtreeMovetoUnpacked(u.bh.pC->pCursor, 0, ((u64 ) u.bh.v), 0, (&u.bh.res))) == 0) && (u.bh.res == 0) && (++u.bh.cnt < 100))) {
                sqlite3_randomness(sizeof(u.bh.v), (&u.bh.v));
                if ((u.bh.cnt < 5)) {
                  (u.bh.v &= 0xffffff);
                }  
                else {
                  (u.bh.v &= (((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff))) >> 1));
                }
                u.bh.v++;
              }
              if (((rc == 0) && (u.bh.res == 0))) {
                (rc = 13);
                goto _1319_abort_due_to_error;
              }  
              ((void ) 0);
            }  
            (u.bh.pC->rowidIsValid = 0);
            (u.bh.pC->deferredMoveto = 0);
            (u.bh.pC->cacheStatus = 0);
          }
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bh.pC->pCursor == 0)) {
            
          }  
          else {
            ((void ) 0);
            if ((! u.bh.pC->useRandomRowid)) {
              (u.bh.v = sqlite3BtreeGetCachedRowid(u.bh.pC->pCursor));
              if ((u.bh.v == 0)) {
                (rc = sqlite3BtreeLast(u.bh.pC->pCursor, (&u.bh.res)));
                if ((rc != 0)) {
                  goto _1319_abort_due_to_error;
                }  
                if (u.bh.res) {
                  (u.bh.v = 1);
                }  
                else {
                  ((void ) 0);
                  (rc = sqlite3BtreeKeySize(u.bh.pC->pCursor, (&u.bh.v)));
                  ((void ) 0);
                  if ((u.bh.v >= ((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff))))) {
                    (u.bh.pC->useRandomRowid = 1);
                  }  
                  else {
                    u.bh.v++;
                  }
                }
              }  
              if (pOp->p3) {
                ((void ) 0);
                if (p->pFrame) {
                  for ((u.bh.pFrame = p->pFrame); u.bh.pFrame->pParent; (u.bh.pFrame = u.bh.pFrame->pParent)) {
                    
                  }
                  ((void ) 0);
                  (u.bh.pMem = (&u.bh.pFrame->aMem[pOp->p3]));
                }  
                else {
                  ((void ) 0);
                  (u.bh.pMem = (&aMem[pOp->p3]));
                }
                ((void ) 0);
                sqlite3VdbeMemIntegerify(u.bh.pMem);
                ((void ) 0);
                if (((u.bh.pMem->u.i == ((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff)))) || u.bh.pC->useRandomRowid)) {
                  (rc = 13);
                  goto _1319_abort_due_to_error;
                }  
                if ((u.bh.v < (u.bh.pMem->u.i + 1))) {
                  (u.bh.v = (u.bh.pMem->u.i + 1));
                }  
                (u.bh.pMem->u.i = u.bh.v);
              }  
              sqlite3BtreeSetCachedRowid(u.bh.pC->pCursor, ((u.bh.v < ((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff)))) ? (u.bh.v + 1) : 0));
            }  
            if (u.bh.pC->useRandomRowid) {
              ((void ) 0);
              (u.bh.v = lastRowid);
              (u.bh.v &= (((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff))) >> 1));
              u.bh.v++;
              (u.bh.cnt = 0);
              while ((((rc = sqlite3BtreeMovetoUnpacked(u.bh.pC->pCursor, 0, ((u64 ) u.bh.v), 0, (&u.bh.res))) == 0) && (u.bh.res == 0) && (++u.bh.cnt < 100))) {
                sqlite3_randomness(sizeof(u.bh.v), (&u.bh.v));
                if ((u.bh.cnt < 5)) {
                  (u.bh.v &= 0xffffff);
                }  
                else {
                  (u.bh.v &= (((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff))) >> 1));
                }
                u.bh.v++;
              }
              if (((rc == 0) && (u.bh.res == 0))) {
                (rc = 13);
                goto _1319_abort_due_to_error;
              }  
              ((void ) 0);
            }  
            (u.bh.pC->rowidIsValid = 0);
            (u.bh.pC->deferredMoveto = 0);
            (u.bh.pC->cacheStatus = 0);
          }
        }  
        (pOut->u.i = u.bh.v);
        break;
      }
      case 66:
      case 67:
      {
        (u.bi.pData = (&aMem[pOp->p2]));
        ((void ) 0);
        ((void ) 0);
        (u.bi.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if ((pOp->opcode == 66)) {
          (u.bi.pKey = (&aMem[pOp->p3]));
          ((void ) 0);
          ((void ) 0);
          (u.bi.iKey = u.bi.pKey->u.i);
        }  
        else {
          ((void ) 0);
          (u.bi.iKey = pOp->p3);
        }
        if ((pOp->p5 & 0x01)) {
          p->nChange++;
        }  
        if ((pOp->p5 & 0x02)) {
          (db->lastRowid = (lastRowid = u.bi.iKey));
        }  
        if ((u.bi.pData->flags & 0x0001)) {
          (u.bi.pData->z = 0);
          (u.bi.pData->n = 0);
        }  
        else {
          ((void ) 0);
        }
        (u.bi.seekResult = ((pOp->p5 & 0x10) ? u.bi.pC->seekResult : 0));
        if ((u.bi.pData->flags & 0x4000)) {
          (u.bi.nZero = u.bi.pData->u.nZero);
        }  
        else {
          (u.bi.nZero = 0);
        }
        sqlite3BtreeSetCachedRowid(u.bi.pC->pCursor, 0);
        (rc = sqlite3BtreeInsert(u.bi.pC->pCursor, 0, u.bi.iKey, u.bi.pData->z, u.bi.pData->n, u.bi.nZero, (pOp->p5 & 0x08), u.bi.seekResult));
        (u.bi.pC->rowidIsValid = 0);
        (u.bi.pC->deferredMoveto = 0);
        (u.bi.pC->cacheStatus = 0);
        if (((rc == 0) && db->xUpdateCallback && pOp->p4.z)) {
          (u.bi.zDb = db->aDb[u.bi.pC->iDb].zName);
          (u.bi.zTbl = pOp->p4.z);
          (u.bi.op = ((pOp->p5 & 0x04) ? 23 : 18));
          ((void ) 0);
          db->xUpdateCallback(db->pUpdateArg, u.bi.op, u.bi.zDb, u.bi.zTbl, u.bi.iKey);
          ((void ) 0);
        }  
        break;
      }
      case 70:
      {
        (u.bj.iKey = 0);
        ((void ) 0);
        (u.bj.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        if ((db->xUpdateCallback && pOp->p4.z)) {
          ((void ) 0);
          ((void ) 0);
          (u.bj.iKey = u.bj.pC->lastRowid);
        }  
        ((void ) 0);
        (rc = sqlite3VdbeCursorMoveto(u.bj.pC));
        if (((id2i_sqlite_coverage_test ) )) {
          if (0) {
            goto _1319_abort_due_to_error;
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((rc != 0)) {
            goto _1319_abort_due_to_error;
          }  
        }  
        sqlite3BtreeSetCachedRowid(u.bj.pC->pCursor, 0);
        (rc = sqlite3BtreeDelete(u.bj.pC->pCursor));
        (u.bj.pC->cacheStatus = 0);
        if (((rc == 0) && db->xUpdateCallback && pOp->p4.z)) {
          const char *zDb =  db->aDb[u.bj.pC->iDb].zName;
          const char *zTbl =  pOp->p4.z;
          db->xUpdateCallback(db->pUpdateArg, 9, zDb, zTbl, u.bj.iKey);
          ((void ) 0);
        }  
        if ((pOp->p2 & 0x01)) {
          p->nChange++;
        }  
        break;
      }
      case 71:
      {
        sqlite3VdbeSetChanges(db, p->nChange);
        (p->nChange = 0);
        break;
      }
      case 72:
      {
        (u.bk.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (pIn3 = (&aMem[pOp->p3]));
        (rc = sqlite3VdbeSorterCompare(u.bk.pC, pIn3, (&u.bk.res)));
        if (u.bk.res) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 81:
      {
        (pOut = (&aMem[pOp->p2]));
        (u.bl.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (rc = sqlite3VdbeSorterRowkey(u.bl.pC, pOut));
        break;
      }
      case 92:
      case 95:
      {
        (pOut = (&aMem[pOp->p2]));
        ((void ) 0);
        (u.bm.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.bm.pCrsr = u.bm.pC->pCursor);
        ((void ) 0);
        ((void ) 0);
        (rc = sqlite3VdbeCursorMoveto(u.bm.pC));
        if (((id2i_sqlite_coverage_test ) )) {
          if (0) {
            goto _1319_abort_due_to_error;
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((rc != 0)) {
            goto _1319_abort_due_to_error;
          }  
        }  
        if (u.bm.pC->isIndex) {
          ((void ) 0);
          sqlite3BtreeKeySize(u.bm.pCrsr, (&u.bm.n64));
          ((void ) 0);
          if ((u.bm.n64 > db->aLimit[0])) {
            goto _1319_too_big;
          }  
          (u.bm.n = ((u32 ) u.bm.n64));
        }  
        else {
          sqlite3BtreeDataSize(u.bm.pCrsr, (&u.bm.n));
          ((void ) 0);
          if ((u.bm.n > ((u32 ) db->aLimit[0]))) {
            goto _1319_too_big;
          }  
        }
        if (sqlite3VdbeMemGrow(pOut, u.bm.n, 0)) {
          goto _1319_no_mem;
        }  
        (pOut->n = u.bm.n);
        (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0010));
        if (u.bm.pC->isIndex) {
          (rc = sqlite3BtreeKey(u.bm.pCrsr, 0, u.bm.n, pOut->z));
        }  
        else {
          (rc = sqlite3BtreeData(u.bm.pCrsr, 0, u.bm.n, pOut->z));
        }
        (pOut->enc = 1);
        break;
      }
      case 96:
      {
        ((void ) 0);
        (u.bn.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        if (u.bn.pC->nullRow) {
          (pOut->flags = 0x0001);
          break;
        } 
        else if (u.bn.pC->deferredMoveto) {
          (u.bn.v = u.bn.pC->movetoTarget);
        }
        
        else if (u.bn.pC->pVtabCursor) {
          (u.bn.pVtab = u.bn.pC->pVtabCursor->pVtab);
          (u.bn.pModule = u.bn.pVtab->pModule);
          ((void ) 0);
          (rc = u.bn.pModule->xRowid(u.bn.pC->pVtabCursor, (&u.bn.v)));
          sqlite3VtabImportErrmsg(p, u.bn.pVtab);
        } 
        else {
          ((void ) 0);
          (rc = sqlite3VdbeCursorMoveto(u.bn.pC));
          if (rc) {
            goto _1319_abort_due_to_error;
          }  
          if (u.bn.pC->rowidIsValid) {
            (u.bn.v = u.bn.pC->lastRowid);
          }  
          else {
            (rc = sqlite3BtreeKeySize(u.bn.pC->pCursor, (&u.bn.v)));
            ((void ) 0);
          }
        }
        (pOut->u.i = u.bn.v);
        break;
      }
      case 97:
      {
        ((void ) 0);
        (u.bo.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (u.bo.pC->nullRow = 1);
        (u.bo.pC->rowidIsValid = 0);
        ((void ) 0);
        if (u.bo.pC->pCursor) {
          sqlite3BtreeClearCursor(u.bo.pC->pCursor);
        }  
        break;
      }
      case 98:
      {
        ((void ) 0);
        (u.bp.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (u.bp.pCrsr = u.bp.pC->pCursor);
        (u.bp.res = 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            (rc = sqlite3BtreeLast(u.bp.pCrsr, (&u.bp.res)));
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bp.pCrsr != 0)) {
            (rc = sqlite3BtreeLast(u.bp.pCrsr, (&u.bp.res)));
          }  
        }  
        (u.bp.pC->nullRow = ((u8 ) u.bp.res));
        (u.bp.pC->deferredMoveto = 0);
        (u.bp.pC->rowidIsValid = 0);
        (u.bp.pC->cacheStatus = 0);
        if (((pOp->p2 > 0) && u.bp.res)) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 99:
      case 100:
      {
        p->aCounter[2]++;
      }
      case 101:
      {
        ((void ) 0);
        (u.bq.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        (u.bq.res = 1);
        if ((u.bq.pC->pSorter != 0)) {
          (rc = sqlite3VdbeSorterRewind(db, u.bq.pC, (&u.bq.res)));
        }  
        else {
          (u.bq.pCrsr = u.bq.pC->pCursor);
          ((void ) 0);
          (rc = sqlite3BtreeFirst(u.bq.pCrsr, (&u.bq.res)));
          (u.bq.pC->atFirst = ((u.bq.res == 0) ? 1 : 0));
          (u.bq.pC->deferredMoveto = 0);
          (u.bq.pC->cacheStatus = 0);
          (u.bq.pC->rowidIsValid = 0);
        }
        (u.bq.pC->nullRow = ((u8 ) u.bq.res));
        ((void ) 0);
        if (u.bq.res) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 5:
      case 6:
      case 7:
      {
        ((void ) 0);
        ((void ) 0);
        (u.br.pC = p->apCsr[pOp->p1]);
        if ((u.br.pC == 0)) {
          break;
        }  
        ((void ) 0);
        if ((u.br.pC->pSorter != 0)) {
          ((void ) 0);
          (rc = sqlite3VdbeSorterNext(db, u.br.pC, (&u.br.res)));
        }  
        else {
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (rc = pOp->p4.xAdvance(u.br.pC->pCursor, (&u.br.res)));
        }
        (u.br.pC->nullRow = ((u8 ) u.br.res));
        (u.br.pC->cacheStatus = 0);
        if ((u.br.res == 0)) {
          (pc = (pOp->p2 - 1));
          p->aCounter[pOp->p5]++;
        }  
        (u.br.pC->rowidIsValid = 0);
        goto _1319_check_for_interrupt;
      }
      case 102:
      case 103:
      {
        ((void ) 0);
        (u.bs.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        (pIn2 = (&aMem[pOp->p2]));
        ((void ) 0);
        (u.bs.pCrsr = u.bs.pC->pCursor);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            ((void ) 0);
            (rc = ((pIn2->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn2) : 0));
            if ((rc == 0)) {
              if ((u.bs.pC->pSorter != 0)) {
                (rc = sqlite3VdbeSorterWrite(db, u.bs.pC, pIn2));
              }  
              else {
                (u.bs.nKey = pIn2->n);
                (u.bs.zKey = pIn2->z);
                (rc = sqlite3BtreeInsert(u.bs.pCrsr, u.bs.zKey, u.bs.nKey, "", 0, 0, pOp->p3, ((pOp->p5 & 0x10) ? u.bs.pC->seekResult : 0)));
                ((void ) 0);
                (u.bs.pC->cacheStatus = 0);
              }
            }  
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bs.pCrsr != 0)) {
            ((void ) 0);
            (rc = ((pIn2->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn2) : 0));
            if ((rc == 0)) {
              if ((u.bs.pC->pSorter != 0)) {
                (rc = sqlite3VdbeSorterWrite(db, u.bs.pC, pIn2));
              }  
              else {
                (u.bs.nKey = pIn2->n);
                (u.bs.zKey = pIn2->z);
                (rc = sqlite3BtreeInsert(u.bs.pCrsr, u.bs.zKey, u.bs.nKey, "", 0, 0, pOp->p3, ((pOp->p5 & 0x10) ? u.bs.pC->seekResult : 0)));
                ((void ) 0);
                (u.bs.pC->cacheStatus = 0);
              }
            }  
          }  
        }  
        break;
      }
      case 104:
      {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.bt.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (u.bt.pCrsr = u.bt.pC->pCursor);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            (u.bt.r.pKeyInfo = u.bt.pC->pKeyInfo);
            (u.bt.r.nField = ((u16 ) pOp->p3));
            (u.bt.r.flags = 0);
            (u.bt.r.aMem = (&aMem[pOp->p2]));
            (rc = sqlite3BtreeMovetoUnpacked(u.bt.pCrsr, (&u.bt.r), 0, 0, (&u.bt.res)));
            if (((rc == 0) && (u.bt.res == 0))) {
              (rc = sqlite3BtreeDelete(u.bt.pCrsr));
            }  
            ((void ) 0);
            (u.bt.pC->cacheStatus = 0);
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bt.pCrsr != 0)) {
            (u.bt.r.pKeyInfo = u.bt.pC->pKeyInfo);
            (u.bt.r.nField = ((u16 ) pOp->p3));
            (u.bt.r.flags = 0);
            (u.bt.r.aMem = (&aMem[pOp->p2]));
            (rc = sqlite3BtreeMovetoUnpacked(u.bt.pCrsr, (&u.bt.r), 0, 0, (&u.bt.res)));
            if (((rc == 0) && (u.bt.res == 0))) {
              (rc = sqlite3BtreeDelete(u.bt.pCrsr));
            }  
            ((void ) 0);
            (u.bt.pC->cacheStatus = 0);
          }  
        }  
        break;
      }
      case 105:
      {
        ((void ) 0);
        (u.bu.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (u.bu.pCrsr = u.bu.pC->pCursor);
        (pOut->flags = 0x0001);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            (rc = sqlite3VdbeCursorMoveto(u.bu.pC));
            if (0) {
              goto _1319_abort_due_to_error;
            }  
            ((void ) 0);
            ((void ) 0);
            if ((! u.bu.pC->nullRow)) {
              (rc = sqlite3VdbeIdxRowid(db, u.bu.pCrsr, (&u.bu.rowid)));
              if ((rc != 0)) {
                goto _1319_abort_due_to_error;
              }  
              (pOut->u.i = u.bu.rowid);
              (pOut->flags = 0x0004);
            }  
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bu.pCrsr != 0)) {
            (rc = sqlite3VdbeCursorMoveto(u.bu.pC));
            if (rc) {
              goto _1319_abort_due_to_error;
            }  
            ((void ) 0);
            ((void ) 0);
            if ((! u.bu.pC->nullRow)) {
              (rc = sqlite3VdbeIdxRowid(db, u.bu.pCrsr, (&u.bu.rowid)));
              if ((rc != 0)) {
                goto _1319_abort_due_to_error;
              }  
              (pOut->u.i = u.bu.rowid);
              (pOut->flags = 0x0004);
            }  
          }  
        }  
        break;
      }
      case 106:
      case 107:
      {
        ((void ) 0);
        (u.bv.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            ((void ) 0);
            ((void ) 0);
            ((void ) 0);
            (u.bv.r.pKeyInfo = u.bv.pC->pKeyInfo);
            (u.bv.r.nField = ((u16 ) pOp->p4.i));
            if (pOp->p5) {
              (u.bv.r.flags = (0x01 | 0x02));
            }  
            else {
              (u.bv.r.flags = 0x02);
            }
            (u.bv.r.aMem = (&aMem[pOp->p3]));
            (rc = sqlite3VdbeIdxKeyCompare(u.bv.pC, (&u.bv.r), (&u.bv.res)));
            if ((pOp->opcode == 106)) {
              (u.bv.res = (- u.bv.res));
            }  
            else {
              ((void ) 0);
              u.bv.res++;
            }
            if ((u.bv.res > 0)) {
              (pc = (pOp->p2 - 1));
            }  
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bv.pC->pCursor != 0)) {
            ((void ) 0);
            ((void ) 0);
            ((void ) 0);
            (u.bv.r.pKeyInfo = u.bv.pC->pKeyInfo);
            (u.bv.r.nField = ((u16 ) pOp->p4.i));
            if (pOp->p5) {
              (u.bv.r.flags = (0x01 | 0x02));
            }  
            else {
              (u.bv.r.flags = 0x02);
            }
            (u.bv.r.aMem = (&aMem[pOp->p3]));
            (rc = sqlite3VdbeIdxKeyCompare(u.bv.pC, (&u.bv.r), (&u.bv.res)));
            if ((pOp->opcode == 106)) {
              (u.bv.res = (- u.bv.res));
            }  
            else {
              ((void ) 0);
              u.bv.res++;
            }
            if ((u.bv.res > 0)) {
              (pc = (pOp->p2 - 1));
            }  
          }  
        }  
        break;
      }
      case 108:
      {
        ((void ) 0);
        (u.bw.iCnt = 0);
        for ((u.bw.pVdbe = db->pVdbe); u.bw.pVdbe; (u.bw.pVdbe = u.bw.pVdbe->pNext)) {
          if (((u.bw.pVdbe->magic == 0xbdf20da3) && u.bw.pVdbe->bIsReader && (u.bw.pVdbe->inVtabMethod < 2) && (u.bw.pVdbe->pc >= 0))) {
            u.bw.iCnt++;
          }  
        }
        (pOut->flags = 0x0001);
        if ((u.bw.iCnt > 1)) {
          (rc = 6);
          (p->errorAction = 2);
        }  
        else {
          (u.bw.iDb = pOp->p3);
          ((void ) 0);
          ((void ) 0);
          (rc = sqlite3BtreeDropTable(db->aDb[u.bw.iDb].pBt, pOp->p1, (&u.bw.iMoved)));
          (pOut->flags = 0x0004);
          (pOut->u.i = u.bw.iMoved);
          if ((((! id2i_sqlite_omit_autovacuum) ) )) {
            if (((rc == 0) && (u.bw.iMoved != 0))) {
              sqlite3RootPageMoved(db, u.bw.iDb, u.bw.iMoved, pOp->p1);
              ((void ) 0);
              (resetSchemaOnFault = (u.bw.iDb + 1));
            }  
          }  
        }
        break;
      }
      case 109:
      {
        (u.bx.nChange = 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (rc = sqlite3BtreeClearTable(db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? (&u.bx.nChange) : 0)));
        if (pOp->p3) {
          (p->nChange += u.bx.nChange);
          if ((pOp->p3 > 0)) {
            ((void ) 0);
            (aMem[pOp->p3].u.i += u.bx.nChange);
          }  
        }  
        break;
      }
      case 110:
      case 111:
      {
        (u.by.pgno = 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.by.pDb = (&db->aDb[pOp->p1]));
        ((void ) 0);
        if ((pOp->opcode == 111)) {
          (u.by.flags = 1);
        }  
        else {
          (u.by.flags = 2);
        }
        (rc = sqlite3BtreeCreateTable(u.by.pDb->pBt, (&u.by.pgno), u.by.flags));
        (pOut->u.i = u.by.pgno);
        break;
      }
      case 112:
      {
        (u.bz.iDb = pOp->p1);
        ((void ) 0);
        ((void ) 0);
        {
          (u.bz.zMaster = (((! 0) && (u.bz.iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"));
          (u.bz.initData.db = db);
          (u.bz.initData.iDb = pOp->p1);
          (u.bz.initData.pzErrMsg = (&p->zErrMsg));
          (u.bz.zSql = sqlite3MPrintf(db, "SELECT name, rootpage, sql FROM '%q'.%s WHERE %s ORDER BY rowid", db->aDb[u.bz.iDb].zName, u.bz.zMaster, pOp->p4.z));
          if ((u.bz.zSql == 0)) {
            (rc = 7);
          }  
          else {
            ((void ) 0);
            (db->init.busy = 1);
            (u.bz.initData.rc = 0);
            ((void ) 0);
            (rc = sqlite3_exec(db, u.bz.zSql, sqlite3InitCallback, (&u.bz.initData), 0));
            if ((rc == 0)) {
              (rc = u.bz.initData.rc);
            }  
            sqlite3DbFree(db, u.bz.zSql);
            (db->init.busy = 0);
          }
        }
        if (rc) {
          sqlite3ResetAllSchemasOfConnection(db);
        }  
        if ((rc == 7)) {
          goto _1319_no_mem;
        }  
        break;
      }
      case 113:
      if ((((! id2i_sqlite_omit_analyze) ) )) {
        ((void ) 0);
        (rc = sqlite3AnalysisLoad(db, pOp->p1));
        break;
      }  
      if (((id2i_sqlite_omit_analyze ) )) {
        if ((pOp->opcode == 113)) {
          goto id2i_label_1;
        }  
      }  
      case 114:
      {
        sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z);
        break;
      }
      case 115:
      {
        sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z);
        break;
      }
      case 116:
      {
        sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z);
        break;
      }
      case 117:
      {
        ((void ) 0);
        (u.ca.nRoot = pOp->p2);
        ((void ) 0);
        (u.ca.aRoot = sqlite3DbMallocRaw(db, (sizeof(int ) * (u.ca.nRoot + 1))));
        if ((u.ca.aRoot == 0)) {
          goto _1319_no_mem;
        }  
        ((void ) 0);
        (u.ca.pnErr = (&aMem[pOp->p3]));
        ((void ) 0);
        ((void ) 0);
        (pIn1 = (&aMem[pOp->p1]));
        for ((u.ca.j = 0); (u.ca.j < u.ca.nRoot); u.ca.j++) {
          (u.ca.aRoot[u.ca.j] = ((int ) sqlite3VdbeIntValue((&pIn1[u.ca.j]))));
        }
        (u.ca.aRoot[u.ca.j] = 0);
        ((void ) 0);
        ((void ) 0);
        (u.ca.z = sqlite3BtreeIntegrityCheck(db->aDb[pOp->p5].pBt, u.ca.aRoot, u.ca.nRoot, ((int ) u.ca.pnErr->u.i), (&u.ca.nErr)));
        sqlite3DbFree(db, u.ca.aRoot);
        (u.ca.pnErr->u.i -= u.ca.nErr);
        sqlite3VdbeMemSetNull(pIn1);
        if ((u.ca.nErr == 0)) {
          ((void ) 0);
        } 
        else if ((u.ca.z == 0)) {
          goto _1319_no_mem;
        } 
        else {
          sqlite3VdbeMemSetStr(pIn1, u.ca.z, (- 1), 1, sqlite3_free);
        }
        sqlite3VdbeChangeEncoding(pIn1, encoding);
        break;
      }
      case 118:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pIn2 = (&aMem[pOp->p2]));
        ((void ) 0);
        if (((pIn1->flags & 0x0020) == 0)) {
          sqlite3VdbeMemSetRowSet(pIn1);
          if (((pIn1->flags & 0x0020) == 0)) {
            goto _1319_no_mem;
          }  
        }  
        sqlite3RowSetInsert(pIn1->u.pRowSet, pIn2->u.i);
        break;
      }
      case 119:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if ((((pIn1->flags & 0x0020) == 0) || (sqlite3RowSetNext(pIn1->u.pRowSet, (&u.cb.val)) == 0))) {
          sqlite3VdbeMemSetNull(pIn1);
          (pc = (pOp->p2 - 1));
        }  
        else {
          sqlite3VdbeMemSetInt64((&aMem[pOp->p3]), u.cb.val);
        }
        goto _1319_check_for_interrupt;
      }
      case 120:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pIn3 = (&aMem[pOp->p3]));
        (u.cc.iSet = pOp->p4.i);
        ((void ) 0);
        if (((pIn1->flags & 0x0020) == 0)) {
          sqlite3VdbeMemSetRowSet(pIn1);
          if (((pIn1->flags & 0x0020) == 0)) {
            goto _1319_no_mem;
          }  
        }  
        ((void ) 0);
        ((void ) 0);
        if (u.cc.iSet) {
          (u.cc.exists = sqlite3RowSetTest(pIn1->u.pRowSet, ((u8 ) ((u.cc.iSet >= 0) ? (u.cc.iSet & 0xf) : 0xff)), pIn3->u.i));
          if (u.cc.exists) {
            (pc = (pOp->p2 - 1));
            break;
          }  
        }  
        if ((u.cc.iSet >= 0)) {
          sqlite3RowSetInsert(pIn1->u.pRowSet, pIn3->u.i);
        }  
        break;
      }
      case 121:
      {
        (u.cd.pProgram = pOp->p4.pProgram);
        (u.cd.pRt = (&aMem[pOp->p3]));
        ((void ) 0);
        if (pOp->p5) {
          (u.cd.t = u.cd.pProgram->token);
          for ((u.cd.pFrame = p->pFrame); (u.cd.pFrame && (u.cd.pFrame->token != u.cd.t)); (u.cd.pFrame = u.cd.pFrame->pParent)) {
            
          }
          if (u.cd.pFrame) {
            break;
          }  
        }  
        if ((p->nFrame >= db->aLimit[10])) {
          (rc = 1);
          sqlite3SetString((&p->zErrMsg), db, "too many levels of trigger recursion");
          break;
        }  
        if (((u.cd.pRt->flags & 0x0040) == 0)) {
          (u.cd.nMem = (u.cd.pProgram->nMem + u.cd.pProgram->nCsr));
          (u.cd.nByte = (((sizeof(VdbeFrame ) + 7) & (~ 7)) + (u.cd.nMem * sizeof(Mem )) + (u.cd.pProgram->nCsr * sizeof(VdbeCursor *)) + (u.cd.pProgram->nOnce * sizeof(u8 ))));
          (u.cd.pFrame = sqlite3DbMallocZero(db, u.cd.nByte));
          if ((! u.cd.pFrame)) {
            goto _1319_no_mem;
          }  
          sqlite3VdbeMemRelease(u.cd.pRt);
          (u.cd.pRt->flags = 0x0040);
          (u.cd.pRt->u.pFrame = u.cd.pFrame);
          (u.cd.pFrame->v = p);
          (u.cd.pFrame->nChildMem = u.cd.nMem);
          (u.cd.pFrame->nChildCsr = u.cd.pProgram->nCsr);
          (u.cd.pFrame->pc = pc);
          (u.cd.pFrame->aMem = p->aMem);
          (u.cd.pFrame->nMem = p->nMem);
          (u.cd.pFrame->apCsr = p->apCsr);
          (u.cd.pFrame->nCursor = p->nCursor);
          (u.cd.pFrame->aOp = p->aOp);
          (u.cd.pFrame->nOp = p->nOp);
          (u.cd.pFrame->token = u.cd.pProgram->token);
          (u.cd.pFrame->aOnceFlag = p->aOnceFlag);
          (u.cd.pFrame->nOnceFlag = p->nOnceFlag);
          (u.cd.pEnd = (&((Mem *) (&((u8 *) u.cd.pFrame)[((sizeof(VdbeFrame ) + 7) & (~ 7))]))[u.cd.pFrame->nChildMem]));
          for ((u.cd.pMem = ((Mem *) (&((u8 *) u.cd.pFrame)[((sizeof(VdbeFrame ) + 7) & (~ 7))]))); (u.cd.pMem != u.cd.pEnd); u.cd.pMem++) {
            (u.cd.pMem->flags = 0x0080);
            (u.cd.pMem->db = db);
          }
        }  
        else {
          (u.cd.pFrame = u.cd.pRt->u.pFrame);
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
        }
        p->nFrame++;
        (u.cd.pFrame->pParent = p->pFrame);
        (u.cd.pFrame->lastRowid = lastRowid);
        (u.cd.pFrame->nChange = p->nChange);
        (p->nChange = 0);
        (p->pFrame = u.cd.pFrame);
        (p->aMem = (aMem = (&((Mem *) (&((u8 *) u.cd.pFrame)[((sizeof(VdbeFrame ) + 7) & (~ 7))]))[(- 1)])));
        (p->nMem = u.cd.pFrame->nChildMem);
        (p->nCursor = ((u16 ) u.cd.pFrame->nChildCsr));
        (p->apCsr = ((VdbeCursor **) (&aMem[(p->nMem + 1)])));
        (p->aOp = (aOp = u.cd.pProgram->aOp));
        (p->nOp = u.cd.pProgram->nOp);
        (p->aOnceFlag = ((u8 *) (&p->apCsr[p->nCursor])));
        (p->nOnceFlag = u.cd.pProgram->nOnce);
        (pc = (- 1));
        memset(p->aOnceFlag, 0, p->nOnceFlag);
        break;
      }
      case 122:
      {
        (u.ce.pFrame = p->pFrame);
        (u.ce.pIn = (&u.ce.pFrame->aMem[(pOp->p1 + u.ce.pFrame->aOp[u.ce.pFrame->pc].p1)]));
        sqlite3VdbeMemShallowCopy(pOut, u.ce.pIn, 0x1000);
        break;
      }
      case 123:
      if ((((! id2i_sqlite_omit_foreign_key) ) )) {
        if ((db->flags & 0x01000000)) {
          (db->nDeferredImmCons += pOp->p2);
        } 
        else if (pOp->p1) {
          (db->nDeferredCons += pOp->p2);
        } 
        else {
          (p->nFkConstraint += pOp->p2);
        }
        break;
      }  
      if (((id2i_sqlite_omit_foreign_key ) )) {
        if ((pOp->opcode == 123)) {
          goto id2i_label_1;
        }  
      }  
      case 124:
      if ((((! id2i_sqlite_omit_foreign_key) ) )) {
        if (pOp->p1) {
          if (((db->nDeferredCons == 0) && (db->nDeferredImmCons == 0))) {
            (pc = (pOp->p2 - 1));
          }  
        }  
        else {
          if (((p->nFkConstraint == 0) && (db->nDeferredImmCons == 0))) {
            (pc = (pOp->p2 - 1));
          }  
        }
        break;
      }  
      if (((id2i_sqlite_omit_foreign_key ) )) {
        if ((pOp->opcode == 124)) {
          goto id2i_label_1;
        }  
      }  
      case 125:
      {
        if (p->pFrame) {
          for ((u.cf.pFrame = p->pFrame); u.cf.pFrame->pParent; (u.cf.pFrame = u.cf.pFrame->pParent)) {
            
          }
          (u.cf.pIn1 = (&u.cf.pFrame->aMem[pOp->p1]));
        }  
        else {
          (u.cf.pIn1 = (&aMem[pOp->p1]));
        }
        ((void ) 0);
        sqlite3VdbeMemIntegerify(u.cf.pIn1);
        (pIn2 = (&aMem[pOp->p2]));
        sqlite3VdbeMemIntegerify(pIn2);
        if ((u.cf.pIn1->u.i < pIn2->u.i)) {
          (u.cf.pIn1->u.i = pIn2->u.i);
        }  
        break;
      }
      case 126:
      {
        (pIn1 = (&aMem[pOp->p1]));
        ((void ) 0);
        if ((pIn1->u.i > 0)) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 127:
      {
        (pIn1 = (&aMem[pOp->p1]));
        ((void ) 0);
        if ((pIn1->u.i < 0)) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 128:
      {
        (pIn1 = (&aMem[pOp->p1]));
        ((void ) 0);
        (pIn1->u.i += pOp->p3);
        if ((pIn1->u.i == 0)) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 8:
      {
        (u.cg.n = pOp->p5);
        ((void ) 0);
        (u.cg.pRec = (&aMem[pOp->p2]));
        (u.cg.apVal = p->apArg);
        ((void ) 0);
        for ((u.cg.i = 0); (u.cg.i < u.cg.n); u.cg.i++, u.cg.pRec++) {
          ((void ) 0);
          (u.cg.apVal[u.cg.i] = u.cg.pRec);
          sqlite3VdbeMemStoreType(u.cg.pRec);
        }
        (u.cg.ctx.pFunc = pOp->p4.pFunc);
        ((void ) 0);
        (u.cg.ctx.pMem = (u.cg.pMem = (&aMem[pOp->p3])));
        u.cg.pMem->n++;
        (u.cg.ctx.s.flags = 0x0001);
        (u.cg.ctx.s.z = 0);
        (u.cg.ctx.s.zMalloc = 0);
        (u.cg.ctx.s.xDel = 0);
        (u.cg.ctx.s.db = db);
        (u.cg.ctx.isError = 0);
        (u.cg.ctx.pColl = 0);
        (u.cg.ctx.skipFlag = 0);
        if ((u.cg.ctx.pFunc->funcFlags & 0x020)) {
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (u.cg.ctx.pColl = pOp[(- 1)].p4.pColl);
        }  
        u.cg.ctx.pFunc->xStep((&u.cg.ctx), u.cg.n, u.cg.apVal);
        if (u.cg.ctx.isError) {
          sqlite3SetString((&p->zErrMsg), db, "%s", sqlite3_value_text((&u.cg.ctx.s)));
          (rc = u.cg.ctx.isError);
        }  
        if (u.cg.ctx.skipFlag) {
          ((void ) 0);
          (u.cg.i = pOp[(- 1)].p1);
          if (u.cg.i) {
            sqlite3VdbeMemSetInt64((&aMem[u.cg.i]), 1);
          }  
        }  
        sqlite3VdbeMemRelease((&u.cg.ctx.s));
        break;
      }
      case 129:
      {
        ((void ) 0);
        (u.ch.pMem = (&aMem[pOp->p1]));
        ((void ) 0);
        (rc = sqlite3VdbeMemFinalize(u.ch.pMem, pOp->p4.pFunc));
        if (rc) {
          sqlite3SetString((&p->zErrMsg), db, "%s", sqlite3_value_text(u.ch.pMem));
        }  
        sqlite3VdbeChangeEncoding(u.ch.pMem, encoding);
        if (sqlite3VdbeMemTooBig(u.ch.pMem)) {
          goto _1319_too_big;
        }  
        break;
      }
      case 9:
      {
        ((void ) 0);
        (u.ci.aRes[0] = 0);
        (u.ci.aRes[1] = (u.ci.aRes[2] = (- 1)));
        ((void ) 0);
        (rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, (&u.ci.aRes[1]), (&u.ci.aRes[2])));
        if ((rc == 5)) {
          (rc = 0);
          (u.ci.aRes[0] = 1);
        }  
        for ((u.ci.i = 0), (u.ci.pMem = (&aMem[pOp->p3])); (u.ci.i < 3); u.ci.i++, u.ci.pMem++) {
          sqlite3VdbeMemSetInt64(u.ci.pMem, ((i64 ) u.ci.aRes[u.ci.i]));
        }
        break;
      }
      case 10:
      {
        (u.cj.eNew = pOp->p3);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.cj.pBt = db->aDb[pOp->p1].pBt);
        (u.cj.pPager = sqlite3BtreePager(u.cj.pBt));
        (u.cj.eOld = sqlite3PagerGetJournalMode(u.cj.pPager));
        if ((u.cj.eNew == (- 1))) {
          (u.cj.eNew = u.cj.eOld);
        }  
        if ((! sqlite3PagerOkToChangeJournalMode(u.cj.pPager))) {
          (u.cj.eNew = u.cj.eOld);
        }  
        (u.cj.zFilename = sqlite3PagerFilename(u.cj.pPager, 1));
        if (((u.cj.eNew == 5) && ((sqlite3Strlen30(u.cj.zFilename) == 0) || (! sqlite3PagerWalSupported(u.cj.pPager))))) {
          (u.cj.eNew = u.cj.eOld);
        }  
        if (((u.cj.eNew != u.cj.eOld) && ((u.cj.eOld == 5) || (u.cj.eNew == 5)))) {
          if (((! db->autoCommit) || (db->nVdbeRead > 1))) {
            (rc = 1);
            sqlite3SetString((&p->zErrMsg), db, "cannot change %s wal mode from within a transaction", ((u.cj.eNew == 5) ? "into" : "out of"));
            break;
          }  
          else {
            if ((u.cj.eOld == 5)) {
              (rc = sqlite3PagerCloseWal(u.cj.pPager));
              if ((rc == 0)) {
                sqlite3PagerSetJournalMode(u.cj.pPager, u.cj.eNew);
              }  
            } 
            else if ((u.cj.eOld == 4)) {
              sqlite3PagerSetJournalMode(u.cj.pPager, 2);
            } 
            ((void ) 0);
            if ((rc == 0)) {
              (rc = sqlite3BtreeSetVersion(u.cj.pBt, ((u.cj.eNew == 5) ? 2 : 1)));
            }  
          }
        }  
        if (rc) {
          (u.cj.eNew = u.cj.eOld);
        }  
        (u.cj.eNew = sqlite3PagerSetJournalMode(u.cj.pPager, u.cj.eNew));
        (pOut = (&aMem[pOp->p2]));
        (pOut->flags = (0x0002 | 0x0800 | 0x0200));
        (pOut->z = ((char *) sqlite3JournalModename(u.cj.eNew)));
        (pOut->n = sqlite3Strlen30(pOut->z));
        (pOut->enc = 1);
        sqlite3VdbeChangeEncoding(pOut, encoding);
        break;
      }
      case 11:
      {
        ((void ) 0);
        (rc = sqlite3RunVacuum((&p->zErrMsg), db));
        break;
      }
      case 131:
      if ((((! id2i_sqlite_omit_autovacuum) ) )) {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.ck.pBt = db->aDb[pOp->p1].pBt);
        (rc = sqlite3BtreeIncrVacuum(u.ck.pBt));
        if ((rc == 101)) {
          (pc = (pOp->p2 - 1));
          (rc = 0);
        }  
        break;
      }  
      if (((id2i_sqlite_omit_autovacuum ) )) {
        if ((pOp->opcode == 131)) {
          goto id2i_label_1;
        }  
      }  
      case 132:
      {
        if ((! pOp->p1)) {
          sqlite3ExpirePreparedStatements(db);
        }  
        else {
          (p->expired = 1);
        }
        break;
      }
      case 133:
      {
        u8 isWriteLock =  ((u8 ) pOp->p3);
        if ((isWriteLock || (0 == (db->flags & 0x0004000)))) {
          int p1 =  pOp->p1;
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock));
          if (((rc & 0xFF) == 6)) {
            const char *z =  pOp->p4.z;
            sqlite3SetString((&p->zErrMsg), db, "database table is locked: %s", z);
          }  
        }  
        break;
      }
      case 134:
      {
        (u.cl.pVTab = pOp->p4.pVtab);
        (rc = sqlite3VtabBegin(db, u.cl.pVTab));
        if (u.cl.pVTab) {
          sqlite3VtabImportErrmsg(p, u.cl.pVTab->pVtab);
        }  
        break;
      }
      case 135:
      {
        (rc = sqlite3VtabCallCreate(db, pOp->p1, pOp->p4.z, (&p->zErrMsg)));
        break;
      }
      case 136:
      {
        (p->inVtabMethod = 2);
        (rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z));
        (p->inVtabMethod = 0);
        break;
      }
      case 137:
      {
        ((void ) 0);
        (u.cm.pCur = 0);
        (u.cm.pVtabCursor = 0);
        (u.cm.pVtab = pOp->p4.pVtab->pVtab);
        (u.cm.pModule = ((sqlite3_module *) u.cm.pVtab->pModule));
        ((void ) 0);
        (rc = u.cm.pModule->xOpen(u.cm.pVtab, (&u.cm.pVtabCursor)));
        sqlite3VtabImportErrmsg(p, u.cm.pVtab);
        if ((0 == rc)) {
          (u.cm.pVtabCursor->pVtab = u.cm.pVtab);
          (u.cm.pCur = allocateCursor(p, pOp->p1, 0, (- 1), 0));
          if (u.cm.pCur) {
            (u.cm.pCur->pVtabCursor = u.cm.pVtabCursor);
            (u.cm.pCur->pModule = u.cm.pVtabCursor->pVtab->pModule);
          }  
          else {
            (db->mallocFailed = 1);
            u.cm.pModule->xClose(u.cm.pVtabCursor);
          }
        }  
        break;
      }
      case 12:
      {
        (u.cn.pQuery = (&aMem[pOp->p3]));
        (u.cn.pArgc = (&u.cn.pQuery[1]));
        (u.cn.pCur = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        (u.cn.pVtabCursor = u.cn.pCur->pVtabCursor);
        (u.cn.pVtab = u.cn.pVtabCursor->pVtab);
        (u.cn.pModule = u.cn.pVtab->pModule);
        ((void ) 0);
        (u.cn.nArg = ((int ) u.cn.pArgc->u.i));
        (u.cn.iQuery = ((int ) u.cn.pQuery->u.i));
        {
          (u.cn.res = 0);
          (u.cn.apArg = p->apArg);
          for ((u.cn.i = 0); (u.cn.i < u.cn.nArg); u.cn.i++) {
            (u.cn.apArg[u.cn.i] = (&u.cn.pArgc[(u.cn.i + 1)]));
            sqlite3VdbeMemStoreType(u.cn.apArg[u.cn.i]);
          }
          (p->inVtabMethod = 1);
          (rc = u.cn.pModule->xFilter(u.cn.pVtabCursor, u.cn.iQuery, pOp->p4.z, u.cn.nArg, u.cn.apArg));
          (p->inVtabMethod = 0);
          sqlite3VtabImportErrmsg(p, u.cn.pVtab);
          if ((rc == 0)) {
            (u.cn.res = u.cn.pModule->xEof(u.cn.pVtabCursor));
          }  
          if (u.cn.res) {
            (pc = (pOp->p2 - 1));
          }  
        }
        (u.cn.pCur->nullRow = 0);
        break;
      }
      case 138:
      {
        VdbeCursor *pCur =  p->apCsr[pOp->p1];
        ((void ) 0);
        ((void ) 0);
        (u.co.pDest = (&aMem[pOp->p3]));
        if (pCur->nullRow) {
          sqlite3VdbeMemSetNull(u.co.pDest);
          break;
        }  
        (u.co.pVtab = pCur->pVtabCursor->pVtab);
        (u.co.pModule = u.co.pVtab->pModule);
        ((void ) 0);
        memset((&u.co.sContext), 0, sizeof(u.co.sContext));
        sqlite3VdbeMemMove((&u.co.sContext.s), u.co.pDest);
        ((&u.co.sContext.s)->flags = (((&u.co.sContext.s)->flags & (~ (0x01ff | 0x4000))) | 0x0001));
        (rc = u.co.pModule->xColumn(pCur->pVtabCursor, (&u.co.sContext), pOp->p2));
        sqlite3VtabImportErrmsg(p, u.co.pVtab);
        if (u.co.sContext.isError) {
          (rc = u.co.sContext.isError);
        }  
        sqlite3VdbeChangeEncoding((&u.co.sContext.s), encoding);
        sqlite3VdbeMemMove(u.co.pDest, (&u.co.sContext.s));
        if (sqlite3VdbeMemTooBig(u.co.pDest)) {
          goto _1319_too_big;
        }  
        break;
      }
      case 139:
      {
        (u.cp.res = 0);
        (u.cp.pCur = p->apCsr[pOp->p1]);
        ((void ) 0);
        if (u.cp.pCur->nullRow) {
          break;
        }  
        (u.cp.pVtab = u.cp.pCur->pVtabCursor->pVtab);
        (u.cp.pModule = u.cp.pVtab->pModule);
        ((void ) 0);
        (p->inVtabMethod = 1);
        (rc = u.cp.pModule->xNext(u.cp.pCur->pVtabCursor));
        (p->inVtabMethod = 0);
        sqlite3VtabImportErrmsg(p, u.cp.pVtab);
        if ((rc == 0)) {
          (u.cp.res = u.cp.pModule->xEof(u.cp.pCur->pVtabCursor));
        }  
        if ((! u.cp.res)) {
          (pc = (pOp->p2 - 1));
        }  
        goto _1319_check_for_interrupt;
      }
      case 140:
      {
        (u.cq.pVtab = pOp->p4.pVtab->pVtab);
        (u.cq.pName = (&aMem[pOp->p1]));
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((u.cq.pName->enc == 1)) {
            sqlite3Coverage(72107);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((u.cq.pName->enc == 3)) {
            sqlite3Coverage(72108);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((u.cq.pName->enc == 2)) {
            sqlite3Coverage(72109);
          }  
        }  
        (rc = sqlite3VdbeChangeEncoding(u.cq.pName, 1));
        if ((rc == 0)) {
          (rc = u.cq.pVtab->pModule->xRename(u.cq.pVtab, u.cq.pName->z));
          sqlite3VtabImportErrmsg(p, u.cq.pVtab);
          (p->expired = 0);
        }  
        break;
      }
      case 13:
      {
        ((void ) 0);
        ((void ) 0);
        (u.cr.pVtab = pOp->p4.pVtab->pVtab);
        (u.cr.pModule = ((sqlite3_module *) u.cr.pVtab->pModule));
        (u.cr.nArg = pOp->p2);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            u8 vtabOnConflict =  db->vtabOnConflict;
            (u.cr.apArg = p->apArg);
            (u.cr.pX = (&aMem[pOp->p3]));
            for ((u.cr.i = 0); (u.cr.i < u.cr.nArg); u.cr.i++) {
              ((void ) 0);
              sqlite3VdbeMemStoreType(u.cr.pX);
              (u.cr.apArg[u.cr.i] = u.cr.pX);
              u.cr.pX++;
            }
            (db->vtabOnConflict = pOp->p5);
            (rc = u.cr.pModule->xUpdate(u.cr.pVtab, u.cr.nArg, u.cr.apArg, (&u.cr.rowid)));
            (db->vtabOnConflict = vtabOnConflict);
            sqlite3VtabImportErrmsg(p, u.cr.pVtab);
            if (((rc == 0) && pOp->p1)) {
              ((void ) 0);
              (db->lastRowid = (lastRowid = u.cr.rowid));
            }  
            if ((((rc & 0xff) == 19) && pOp->p4.pVtab->bConstraint)) {
              if ((pOp->p5 == 4)) {
                (rc = 0);
              }  
              else {
                (p->errorAction = ((pOp->p5 == 5) ? 2 : pOp->p5));
              }
            }  
            else {
              p->nChange++;
            }
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if (u.cr.pModule->xUpdate) {
            u8 vtabOnConflict =  db->vtabOnConflict;
            (u.cr.apArg = p->apArg);
            (u.cr.pX = (&aMem[pOp->p3]));
            for ((u.cr.i = 0); (u.cr.i < u.cr.nArg); u.cr.i++) {
              ((void ) 0);
              sqlite3VdbeMemStoreType(u.cr.pX);
              (u.cr.apArg[u.cr.i] = u.cr.pX);
              u.cr.pX++;
            }
            (db->vtabOnConflict = pOp->p5);
            (rc = u.cr.pModule->xUpdate(u.cr.pVtab, u.cr.nArg, u.cr.apArg, (&u.cr.rowid)));
            (db->vtabOnConflict = vtabOnConflict);
            sqlite3VtabImportErrmsg(p, u.cr.pVtab);
            if (((rc == 0) && pOp->p1)) {
              ((void ) 0);
              (db->lastRowid = (lastRowid = u.cr.rowid));
            }  
            if ((((rc & 0xff) == 19) && pOp->p4.pVtab->bConstraint)) {
              if ((pOp->p5 == 4)) {
                (rc = 0);
              }  
              else {
                (p->errorAction = ((pOp->p5 == 5) ? 2 : pOp->p5));
              }
            }  
            else {
              p->nChange++;
            }
          }  
        }  
        break;
      }
      case 146:
      if ((((! id2i_sqlite_omit_pager_pragmas) ) )) {
        (pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt));
        break;
      }  
      if (((id2i_sqlite_omit_pager_pragmas ) )) {
        if ((pOp->opcode == 146)) {
          goto id2i_label_1;
        }  
      }  
      case 147:
      if ((((! id2i_sqlite_omit_pager_pragmas) ) )) {
        unsigned int newMax;
        Btree *pBt;
        (pBt = db->aDb[pOp->p1].pBt);
        (newMax = 0);
        if (pOp->p3) {
          (newMax = sqlite3BtreeLastPage(pBt));
          if ((newMax < ((unsigned ) pOp->p3))) {
            (newMax = ((unsigned ) pOp->p3));
          }  
        }  
        (pOut->u.i = sqlite3BtreeMaxPageCount(pBt, newMax));
        break;
      }  
      if (((id2i_sqlite_omit_pager_pragmas ) )) {
        if ((pOp->opcode == 147)) {
          goto id2i_label_1;
        }  
      }  
      case 148:
      {
        if ((db->xTrace && (! p->doingRerun) && ((u.cs.zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql)) != 0))) {
          (u.cs.z = sqlite3VdbeExpandSql(p, u.cs.zTrace));
          db->xTrace(db->pTraceArg, u.cs.z);
          sqlite3DbFree(db, u.cs.z);
        }  
        break;
      }
      id2i_label_1:
      default:
      {
        ((void ) 0);
        break;
      }
    }
  }
  _1319_vdbe_error_halt:
  ((void ) 0);
  (p->rc = rc);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      if ((_1283_sqlite3Config.xLog != 0)) {
        sqlite3Coverage(72329);
      }  
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      if ((_1284_sqlite3Config.xLog != 0)) {
        sqlite3Coverage(72329);
      }  
    }  
  }  
  sqlite3_log(rc, "statement aborts at %d: [%s] %s", pc, p->zSql, p->zErrMsg);
  sqlite3VdbeHalt(p);
  if ((rc == (10 | (12 << 8)))) {
    (db->mallocFailed = 1);
  }  
  (rc = 1);
  if ((resetSchemaOnFault > 0)) {
    sqlite3ResetOneSchema(db, (resetSchemaOnFault - 1));
  }  
  _1319_vdbe_return:
  (db->lastRowid = lastRowid);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((nVmStep > 0)) {
      sqlite3Coverage(72344);
    }  
  }  
  (p->aCounter[4] += ((int ) nVmStep));
  return rc;
  _1319_too_big:
  sqlite3SetString((&p->zErrMsg), db, "string or blob too big");
  (rc = 18);
  goto _1319_vdbe_error_halt;
  _1319_no_mem:
  (db->mallocFailed = 1);
  sqlite3SetString((&p->zErrMsg), db, "out of memory");
  (rc = 7);
  goto _1319_vdbe_error_halt;
  _1319_abort_due_to_error:
  ((void ) 0);
  if (db->mallocFailed) {
    (rc = 7);
  }  
  if ((rc != (10 | (12 << 8)))) {
    sqlite3SetString((&p->zErrMsg), db, "%s", sqlite3ErrStr(rc));
  }  
  goto _1319_vdbe_error_halt;
  _1319_abort_due_to_interrupt:
  ((void ) 0);
  (rc = 9);
  (p->rc = rc);
  sqlite3SetString((&p->zErrMsg), db, "%s", sqlite3ErrStr(rc));
  goto _1319_vdbe_error_halt;
}
static  int _1269_sqlite3VdbeExec(Vdbe *p )  {
  int pc =  0;
  Op *aOp =  p->aOp;
  Op *pOp;
  int rc =  0;
  sqlite3 *db =  p->db;
  u8 resetSchemaOnFault =  0;
  u8 encoding =  db->aDb[0].pSchema->enc;
  int iCompare =  0;
  unsigned nVmStep =  0;
  unsigned nProgressLimit =  0;
  Mem *aMem =  p->aMem;
  Mem *pIn1 =  0;
  Mem *pIn2 =  0;
  Mem *pIn3 =  0;
  Mem *pOut =  0;
  int *aPermute =  0;
  i64 lastRowid =  db->lastRowid;
  u64 start;
  int origPc;
  union  vdbeExecUnion {
    struct  OP_Yield_stack_vars {
      int pcDest ;
    }  aa ;
    struct  OP_Null_stack_vars {
      int cnt ;
      u16 nullFlag ;
    }  ab ;
    struct  OP_Variable_stack_vars {
      Mem *pVar ;
    }  ac ;
    struct  OP_Move_stack_vars {
      char *zMalloc ;
      int n ;
      int p1 ;
      int p2 ;
    }  ad ;
    struct  OP_Copy_stack_vars {
      int n ;
    }  ae ;
    struct  OP_ResultRow_stack_vars {
      Mem *pMem ;
      int i ;
    }  af ;
    struct  OP_Concat_stack_vars {
      i64 nByte ;
    }  ag ;
    struct  OP_Remainder_stack_vars {
      char bIntint ;
      int flags ;
      i64 iA ;
      i64 iB ;
      double rA ;
      double rB ;
    }  ah ;
    struct  OP_Function_stack_vars {
      int i ;
      Mem *pArg ;
      sqlite3_context ctx ;
      sqlite3_value **apVal ;
      int n ;
    }  ai ;
    struct  OP_ShiftRight_stack_vars {
      i64 iA ;
      u64 uA ;
      i64 iB ;
      u8 op ;
    }  aj ;
    struct  OP_Ge_stack_vars {
      int res ;
      char affinity ;
      u16 flags1 ;
      u16 flags3 ;
    }  ak ;
    struct  OP_Compare_stack_vars {
      int n ;
      int i ;
      int p1 ;
      int p2 ;
      const  KeyInfo *pKeyInfo ;
      int idx ;
      CollSeq *pColl ;
      int bRev ;
    }  al ;
    struct  OP_Or_stack_vars {
      int v1 ;
      int v2 ;
    }  am ;
    struct  OP_IfNot_stack_vars {
      int c ;
    }  an ;
    struct  OP_Column_stack_vars {
      u32 payloadSize ;
      i64 payloadSize64 ;
      int p1 ;
      int p2 ;
      VdbeCursor *pC ;
      char *zRec ;
      BtCursor *pCrsr ;
      u32 *aType ;
      u32 *aOffset ;
      int nField ;
      int len ;
      int i ;
      char *zData ;
      Mem *pDest ;
      Mem sMem ;
      u8 *zIdx ;
      u8 *zEndHdr ;
      u32 offset ;
      u32 szField ;
      int szHdr ;
      int avail ;
      u32 t ;
      Mem *pReg ;
    }  ao ;
    struct  OP_Affinity_stack_vars {
      const  char *zAffinity ;
      char cAff ;
    }  ap ;
    struct  OP_MakeRecord_stack_vars {
      u8 *zNewRecord ;
      Mem *pRec ;
      u64 nData ;
      int nHdr ;
      i64 nByte ;
      int nZero ;
      int nVarint ;
      u32 serial_type ;
      Mem *pData0 ;
      Mem *pLast ;
      int nField ;
      char *zAffinity ;
      int file_format ;
      int i ;
      int len ;
    }  aq ;
    struct  OP_Count_stack_vars {
      i64 nEntry ;
      BtCursor *pCrsr ;
    }  ar ;
    struct  OP_Savepoint_stack_vars {
      int p1 ;
      char *zName ;
      int nName ;
      Savepoint *pNew ;
      Savepoint *pSavepoint ;
      Savepoint *pTmp ;
      int iSavepoint ;
      int ii ;
    }  as ;
    struct  OP_AutoCommit_stack_vars {
      int desiredAutoCommit ;
      int iRollback ;
      int turnOnAC ;
    }  at ;
    struct  OP_Transaction_stack_vars {
      Btree *pBt ;
    }  au ;
    struct  OP_ReadCookie_stack_vars {
      int iMeta ;
      int iDb ;
      int iCookie ;
    }  av ;
    struct  OP_SetCookie_stack_vars {
      Db *pDb ;
    }  aw ;
    struct  OP_VerifyCookie_stack_vars {
      int iMeta ;
      int iGen ;
      Btree *pBt ;
    }  ax ;
    struct  OP_OpenWrite_stack_vars {
      int nField ;
      KeyInfo *pKeyInfo ;
      int p2 ;
      int iDb ;
      int wrFlag ;
      Btree *pX ;
      VdbeCursor *pCur ;
      Db *pDb ;
    }  ay ;
    struct  OP_OpenEphemeral_stack_vars {
      VdbeCursor *pCx ;
    }  az ;
    struct  OP_SorterOpen_stack_vars {
      VdbeCursor *pCx ;
    }  ba ;
    struct  OP_OpenPseudo_stack_vars {
      VdbeCursor *pCx ;
    }  bb ;
    struct  OP_SeekGt_stack_vars {
      int res ;
      int oc ;
      VdbeCursor *pC ;
      UnpackedRecord r ;
      int nField ;
      i64 iKey ;
    }  bc ;
    struct  OP_Seek_stack_vars {
      VdbeCursor *pC ;
    }  bd ;
    struct  OP_Found_stack_vars {
      int alreadyExists ;
      VdbeCursor *pC ;
      int res ;
      char *pFree ;
      UnpackedRecord *pIdxKey ;
      UnpackedRecord r ;
      char aTempRec[(((sizeof(UnpackedRecord ) + 7) & (~ 7)) + (sizeof(Mem ) * 3) + 7)] ;
    }  be ;
    struct  OP_IsUnique_stack_vars {
      u16 ii ;
      VdbeCursor *pCx ;
      BtCursor *pCrsr ;
      u16 nField ;
      Mem *aMx ;
      UnpackedRecord r ;
      i64 R ;
    }  bf ;
    struct  OP_NotExists_stack_vars {
      VdbeCursor *pC ;
      BtCursor *pCrsr ;
      int res ;
      u64 iKey ;
    }  bg ;
    struct  OP_NewRowid_stack_vars {
      i64 v ;
      VdbeCursor *pC ;
      int res ;
      int cnt ;
      Mem *pMem ;
      VdbeFrame *pFrame ;
    }  bh ;
    struct  OP_InsertInt_stack_vars {
      Mem *pData ;
      Mem *pKey ;
      i64 iKey ;
      VdbeCursor *pC ;
      int nZero ;
      int seekResult ;
      const  char *zDb ;
      const  char *zTbl ;
      int op ;
    }  bi ;
    struct  OP_Delete_stack_vars {
      i64 iKey ;
      VdbeCursor *pC ;
    }  bj ;
    struct  OP_SorterCompare_stack_vars {
      VdbeCursor *pC ;
      int res ;
    }  bk ;
    struct  OP_SorterData_stack_vars {
      VdbeCursor *pC ;
    }  bl ;
    struct  OP_RowData_stack_vars {
      VdbeCursor *pC ;
      BtCursor *pCrsr ;
      u32 n ;
      i64 n64 ;
    }  bm ;
    struct  OP_Rowid_stack_vars {
      VdbeCursor *pC ;
      i64 v ;
      sqlite3_vtab *pVtab ;
      const  sqlite3_module *pModule ;
    }  bn ;
    struct  OP_NullRow_stack_vars {
      VdbeCursor *pC ;
    }  bo ;
    struct  OP_Last_stack_vars {
      VdbeCursor *pC ;
      BtCursor *pCrsr ;
      int res ;
    }  bp ;
    struct  OP_Rewind_stack_vars {
      VdbeCursor *pC ;
      BtCursor *pCrsr ;
      int res ;
    }  bq ;
    struct  OP_Next_stack_vars {
      VdbeCursor *pC ;
      int res ;
    }  br ;
    struct  OP_IdxInsert_stack_vars {
      VdbeCursor *pC ;
      BtCursor *pCrsr ;
      int nKey ;
      const  char *zKey ;
    }  bs ;
    struct  OP_IdxDelete_stack_vars {
      VdbeCursor *pC ;
      BtCursor *pCrsr ;
      int res ;
      UnpackedRecord r ;
    }  bt ;
    struct  OP_IdxRowid_stack_vars {
      BtCursor *pCrsr ;
      VdbeCursor *pC ;
      i64 rowid ;
    }  bu ;
    struct  OP_IdxGE_stack_vars {
      VdbeCursor *pC ;
      int res ;
      UnpackedRecord r ;
    }  bv ;
    struct  OP_Destroy_stack_vars {
      int iMoved ;
      int iCnt ;
      Vdbe *pVdbe ;
      int iDb ;
    }  bw ;
    struct  OP_Clear_stack_vars {
      int nChange ;
    }  bx ;
    struct  OP_CreateTable_stack_vars {
      int pgno ;
      int flags ;
      Db *pDb ;
    }  by ;
    struct  OP_ParseSchema_stack_vars {
      int iDb ;
      const  char *zMaster ;
      char *zSql ;
      InitData initData ;
    }  bz ;
    struct  OP_IntegrityCk_stack_vars {
      int nRoot ;
      int *aRoot ;
      int j ;
      int nErr ;
      char *z ;
      Mem *pnErr ;
    }  ca ;
    struct  OP_RowSetRead_stack_vars {
      i64 val ;
    }  cb ;
    struct  OP_RowSetTest_stack_vars {
      int iSet ;
      int exists ;
    }  cc ;
    struct  OP_Program_stack_vars {
      int nMem ;
      int nByte ;
      Mem *pRt ;
      Mem *pMem ;
      Mem *pEnd ;
      VdbeFrame *pFrame ;
      SubProgram *pProgram ;
      void *t ;
    }  cd ;
    struct  OP_Param_stack_vars {
      VdbeFrame *pFrame ;
      Mem *pIn ;
    }  ce ;
    struct  OP_MemMax_stack_vars {
      Mem *pIn1 ;
      VdbeFrame *pFrame ;
    }  cf ;
    struct  OP_AggStep_stack_vars {
      int n ;
      int i ;
      Mem *pMem ;
      Mem *pRec ;
      sqlite3_context ctx ;
      sqlite3_value **apVal ;
    }  cg ;
    struct  OP_AggFinal_stack_vars {
      Mem *pMem ;
    }  ch ;
    struct  OP_Checkpoint_stack_vars {
      int i ;
      int aRes[3] ;
      Mem *pMem ;
    }  ci ;
    struct  OP_JournalMode_stack_vars {
      Btree *pBt ;
      Pager *pPager ;
      int eNew ;
      int eOld ;
      const  char *zFilename ;
    }  cj ;
    struct  OP_IncrVacuum_stack_vars {
      Btree *pBt ;
    }  ck ;
    struct  OP_VBegin_stack_vars {
      VTable *pVTab ;
    }  cl ;
    struct  OP_VOpen_stack_vars {
      VdbeCursor *pCur ;
      sqlite3_vtab_cursor *pVtabCursor ;
      sqlite3_vtab *pVtab ;
      sqlite3_module *pModule ;
    }  cm ;
    struct  OP_VFilter_stack_vars {
      int nArg ;
      int iQuery ;
      const  sqlite3_module *pModule ;
      Mem *pQuery ;
      Mem *pArgc ;
      sqlite3_vtab_cursor *pVtabCursor ;
      sqlite3_vtab *pVtab ;
      VdbeCursor *pCur ;
      int res ;
      int i ;
      Mem **apArg ;
    }  cn ;
    struct  OP_VColumn_stack_vars {
      sqlite3_vtab *pVtab ;
      const  sqlite3_module *pModule ;
      Mem *pDest ;
      sqlite3_context sContext ;
    }  co ;
    struct  OP_VNext_stack_vars {
      sqlite3_vtab *pVtab ;
      const  sqlite3_module *pModule ;
      int res ;
      VdbeCursor *pCur ;
    }  cp ;
    struct  OP_VRename_stack_vars {
      sqlite3_vtab *pVtab ;
      Mem *pName ;
    }  cq ;
    struct  OP_VUpdate_stack_vars {
      sqlite3_vtab *pVtab ;
      sqlite3_module *pModule ;
      int nArg ;
      int i ;
      sqlite_int64 rowid ;
      Mem **apArg ;
      Mem *pX ;
    }  cr ;
    struct  OP_Trace_stack_vars {
      char *zTrace ;
      char *z ;
    }  cs ;
  }  u;
  ((void ) 0);
  if ((p->rc == 7)) {
    goto _1269_no_mem;
  }  
  ((void ) 0);
  ((void ) 0);
  (p->rc = 0);
  (p->iCurrentTime = 0);
  ((void ) 0);
  (p->pResultSet = 0);
  (db->busyHandler.nBusy = 0);
  if (db->u1.isInterrupted) {
    goto _1269_abort_due_to_interrupt;
  }  
  if (((id2i_sqlite_enable_iotrace ) )) {
    sqlite3VdbeIOTraceSql(p);
  }  
  if (db->xProgress) {
    ((void ) 0);
    (nProgressLimit = ((unsigned ) p->aCounter[4]));
    if ((nProgressLimit == 0)) {
      (nProgressLimit = db->nProgressOps);
    }  
    else {
      (nProgressLimit %= ((unsigned ) db->nProgressOps));
    }
  }  
  for ((pc = p->pc); (rc == 0); pc++) {
    ((void ) 0);
    if (db->mallocFailed) {
      goto _1269_no_mem;
    }  
    (origPc = pc);
    if ((((! id2i_i386) && (! id2i___i386__) && id2i__m_ix86) || ((! id2i_i386) && id2i___i386__) || (id2i_i386 ))) {
      (start = _1317_sqlite3Hwtime());
    }  
    if ((((! id2i_i386) && (! id2i___i386__) && (! id2i__m_ix86)) )) {
      (start = _1318_sqlite3Hwtime());
    }  
    nVmStep++;
    (pOp = (&aOp[pc]));
    ((void ) 0);
    if ((pOp->opflags & 0x0002)) {
      ((void ) 0);
      ((void ) 0);
      (pOut = (&aMem[pOp->p2]));
      if ((pOut->flags & (0x2000 | 0x0400 | 0x0020 | 0x0040))) {
        sqlite3VdbeMemReleaseExternal(pOut);
      }  
      (pOut->flags = 0x0004);
    }  
    switch (pOp->opcode) {
      case 14:
      {
        (pc = (pOp->p2 - 1));
        _1269_check_for_interrupt:
        if (db->u1.isInterrupted) {
          goto _1269_abort_due_to_interrupt;
        }  
        if (((db->xProgress != 0) && (nVmStep >= nProgressLimit))) {
          int prc;
          (prc = db->xProgress(db->pProgressArg));
          if ((prc != 0)) {
            (rc = 9);
            goto _1269_vdbe_error_halt;
          }  
          if ((db->xProgress != 0)) {
            (nProgressLimit = (nVmStep + db->nProgressOps - (nVmStep % db->nProgressOps)));
          }  
        }  
        break;
      }
      case 15:
      {
        ((void ) 0);
        (pIn1 = (&aMem[pOp->p1]));
        ((void ) 0);
        (pIn1->flags = 0x0004);
        (pIn1->u.i = pc);
        (pc = (pOp->p2 - 1));
        break;
      }
      case 16:
      {
        (pIn1 = (&aMem[pOp->p1]));
        ((void ) 0);
        (pc = ((int ) pIn1->u.i));
        break;
      }
      case 17:
      {
        (pIn1 = (&aMem[pOp->p1]));
        ((void ) 0);
        (pIn1->flags = 0x0004);
        (u.aa.pcDest = ((int ) pIn1->u.i));
        (pIn1->u.i = pc);
        (pc = u.aa.pcDest);
        break;
      }
      case 18:
      {
        (pIn3 = (&aMem[pOp->p3]));
        if (((pIn3->flags & 0x0001) == 0)) {
          break;
        }  
      }
      case 20:
      {
        if (((pOp->p1 == 0) && p->pFrame)) {
          VdbeFrame *pFrame =  p->pFrame;
          (p->pFrame = pFrame->pParent);
          p->nFrame--;
          sqlite3VdbeSetChanges(db, p->nChange);
          (pc = sqlite3VdbeFrameRestore(pFrame));
          (lastRowid = db->lastRowid);
          if ((pOp->p2 == 4)) {
            (pc = (p->aOp[pc].p2 - 1));
          }  
          (aOp = p->aOp);
          (aMem = p->aMem);
          break;
        }  
        (p->rc = pOp->p1);
        (p->errorAction = ((u8 ) pOp->p2));
        (p->pc = pc);
        if (pOp->p4.z) {
          ((void ) 0);
          sqlite3SetString((&p->zErrMsg), db, "%s", pOp->p4.z);
          if (((id2i_sqlite_coverage_test ) )) {
            if ((((! id2i_sqlite_default_memstatus) ) )) {
              if ((_1283_sqlite3Config.xLog != 0)) {
                sqlite3Coverage(66838);
              }  
            }  
            if (((id2i_sqlite_default_memstatus ) )) {
              if ((_1284_sqlite3Config.xLog != 0)) {
                sqlite3Coverage(66838);
              }  
            }  
          }  
          sqlite3_log(pOp->p1, "abort at %d in [%s]: %s", pc, p->zSql, pOp->p4.z);
        } 
        else if (p->rc) {
          if (((id2i_sqlite_coverage_test ) )) {
            if ((((! id2i_sqlite_default_memstatus) ) )) {
              if ((_1283_sqlite3Config.xLog != 0)) {
                sqlite3Coverage(66841);
              }  
            }  
            if (((id2i_sqlite_default_memstatus ) )) {
              if ((_1284_sqlite3Config.xLog != 0)) {
                sqlite3Coverage(66841);
              }  
            }  
          }  
          sqlite3_log(pOp->p1, "constraint failed at %d in [%s]", pc, p->zSql);
        } 
        (rc = sqlite3VdbeHalt(p));
        ((void ) 0);
        if ((rc == 5)) {
          (p->rc = (rc = 5));
        }  
        else {
          ((void ) 0);
          ((void ) 0);
          (rc = (p->rc ? 1 : 101));
        }
        goto _1269_vdbe_return;
      }
      case 21:
      {
        (pOut->u.i = pOp->p1);
        break;
      }
      case 22:
      {
        ((void ) 0);
        (pOut->u.i = (*pOp->p4.pI64));
        break;
      }
      case 130:
      {
        (pOut->flags = 0x0008);
        ((void ) 0);
        (pOut->r = (*pOp->p4.pReal));
        break;
      }
      case 94:
      {
        ((void ) 0);
        (pOp->opcode = 23);
        (pOp->p1 = sqlite3Strlen30(pOp->p4.z));
        if ((encoding != 1)) {
          (rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, (- 1), 1, ((sqlite3_destructor_type ) 0)));
          if ((rc == 18)) {
            goto _1269_too_big;
          }  
          if ((0 != sqlite3VdbeChangeEncoding(pOut, encoding))) {
            goto _1269_no_mem;
          }  
          ((void ) 0);
          ((void ) 0);
          (pOut->zMalloc = 0);
          (pOut->flags |= 0x0800);
          (pOut->flags &= (~ 0x0400));
          if ((pOp->p4type == (- 1))) {
            sqlite3DbFree(db, pOp->p4.z);
          }  
          (pOp->p4type = (- 1));
          (pOp->p4.z = pOut->z);
          (pOp->p1 = pOut->n);
        }  
        if ((pOp->p1 > db->aLimit[0])) {
          goto _1269_too_big;
        }  
      }
      case 23:
      {
        ((void ) 0);
        (pOut->flags = (0x0002 | 0x0800 | 0x0200));
        (pOut->z = pOp->p4.z);
        (pOut->n = pOp->p1);
        (pOut->enc = encoding);
        break;
      }
      case 24:
      {
        (u.ab.cnt = (pOp->p3 - pOp->p2));
        ((void ) 0);
        (pOut->flags = (u.ab.nullFlag = (pOp->p1 ? (0x0001 | 0x0100) : 0x0001)));
        while ((u.ab.cnt > 0)) {
          pOut++;
          if ((pOut->flags & (0x2000 | 0x0400 | 0x0020 | 0x0040))) {
            sqlite3VdbeMemReleaseExternal(pOut);
          }  
          (pOut->flags = u.ab.nullFlag);
          u.ab.cnt--;
        }
        break;
      }
      case 25:
      {
        ((void ) 0);
        sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);
        (pOut->enc = encoding);
        break;
      }
      case 26:
      {
        ((void ) 0);
        ((void ) 0);
        (u.ac.pVar = (&p->aVar[(pOp->p1 - 1)]));
        if (sqlite3VdbeMemTooBig(u.ac.pVar)) {
          goto _1269_too_big;
        }  
        sqlite3VdbeMemShallowCopy(pOut, u.ac.pVar, 0x0800);
        break;
      }
      case 27:
      {
        (u.ad.n = (pOp->p3 + 1));
        (u.ad.p1 = pOp->p1);
        (u.ad.p2 = pOp->p2);
        ((void ) 0);
        ((void ) 0);
        (pIn1 = (&aMem[u.ad.p1]));
        (pOut = (&aMem[u.ad.p2]));
        while (u.ad.n--) {
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (u.ad.zMalloc = pOut->zMalloc);
          (pOut->zMalloc = 0);
          sqlite3VdbeMemMove(pOut, pIn1);
          (pIn1->zMalloc = u.ad.zMalloc);
          pIn1++;
          pOut++;
        }
        break;
      }
      case 28:
      {
        (u.ae.n = pOp->p3);
        (pIn1 = (&aMem[pOp->p1]));
        (pOut = (&aMem[pOp->p2]));
        ((void ) 0);
        while (1) {
          sqlite3VdbeMemShallowCopy(pOut, pIn1, 0x1000);
          if ((((pOut->flags & 0x1000) != 0) && sqlite3VdbeMemMakeWriteable(pOut))) {
            goto _1269_no_mem;
          }  
          if ((u.ae.n-- == 0)) {
            break;
          }  
          pOut++;
          pIn1++;
        }
        break;
      }
      case 29:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pOut = (&aMem[pOp->p2]));
        ((void ) 0);
        sqlite3VdbeMemShallowCopy(pOut, pIn1, 0x1000);
        break;
      }
      case 30:
      {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if ((((! id2i_sqlite_omit_foreign_key) ) )) {
          if ((0 != (rc = sqlite3VdbeCheckFk(p, 0)))) {
            ((void ) 0);
            ((void ) 0);
            break;
          }  
        }  
        if (((id2i_sqlite_omit_foreign_key ) )) {
          if ((0 != (rc = 0))) {
            ((void ) 0);
            ((void ) 0);
            break;
          }  
        }  
        ((void ) 0);
        (rc = sqlite3VdbeCloseStatement(p, 1));
        if (((id2i_sqlite_coverage_test ) )) {
          if (0) {
            break;
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((rc != 0)) {
            break;
          }  
        }  
        (p->cacheCtr = ((p->cacheCtr + 2) | 1));
        (u.af.pMem = (p->pResultSet = (&aMem[pOp->p1])));
        for ((u.af.i = 0); (u.af.i < pOp->p2); u.af.i++) {
          ((void ) 0);
          if (((((&u.af.pMem[u.af.i])->flags & 0x1000) != 0) && sqlite3VdbeMemMakeWriteable((&u.af.pMem[u.af.i])))) {
            goto _1269_no_mem;
          }  
          ((void ) 0);
          sqlite3VdbeMemNulTerminate((&u.af.pMem[u.af.i]));
          sqlite3VdbeMemStoreType((&u.af.pMem[u.af.i]));
        }
        if (db->mallocFailed) {
          goto _1269_no_mem;
        }  
        (p->pc = (pc + 1));
        (rc = 100);
        goto _1269_vdbe_return;
      }
      case 91:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pIn2 = (&aMem[pOp->p2]));
        (pOut = (&aMem[pOp->p3]));
        ((void ) 0);
        if (((pIn1->flags | pIn2->flags) & 0x0001)) {
          sqlite3VdbeMemSetNull(pOut);
          break;
        }  
        if ((((pIn1->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn1) : 0) || ((pIn2->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn2) : 0))) {
          goto _1269_no_mem;
        }  
        if ((((pIn1->flags & (0x0002 | 0x0010)) == 0) && sqlite3VdbeMemStringify(pIn1, encoding))) {
          goto _1269_no_mem;
        }  
        if ((((pIn2->flags & (0x0002 | 0x0010)) == 0) && sqlite3VdbeMemStringify(pIn2, encoding))) {
          goto _1269_no_mem;
        }  
        (u.ag.nByte = (pIn1->n + pIn2->n));
        if ((u.ag.nByte > db->aLimit[0])) {
          goto _1269_too_big;
        }  
        (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0002));
        if (sqlite3VdbeMemGrow(pOut, (((int ) u.ag.nByte) + 2), (pOut == pIn2))) {
          goto _1269_no_mem;
        }  
        if ((pOut != pIn2)) {
          memcpy(pOut->z, pIn2->z, pIn2->n);
        }  
        memcpy((&pOut->z[pIn2->n]), pIn1->z, pIn1->n);
        (pOut->z[u.ag.nByte] = 0);
        (pOut->z[(u.ag.nByte + 1)] = 0);
        (pOut->flags |= 0x0200);
        (pOut->n = ((int ) u.ag.nByte));
        (pOut->enc = encoding);
        break;
      }
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      {
        (pIn1 = (&aMem[pOp->p1]));
        applyNumericAffinity(pIn1);
        (pIn2 = (&aMem[pOp->p2]));
        applyNumericAffinity(pIn2);
        (pOut = (&aMem[pOp->p3]));
        (u.ah.flags = (pIn1->flags | pIn2->flags));
        if (((u.ah.flags & 0x0001) != 0)) {
          goto _1269_arithmetic_result_is_null;
        }  
        if (((pIn1->flags & pIn2->flags & 0x0004) == 0x0004)) {
          (u.ah.iA = pIn1->u.i);
          (u.ah.iB = pIn2->u.i);
          (u.ah.bIntint = 1);
          switch (pOp->opcode) {
            case 86:
            if (sqlite3AddInt64((&u.ah.iB), u.ah.iA)) {
              goto _1269_fp_math;
            }  
            break;
            case 87:
            if (sqlite3SubInt64((&u.ah.iB), u.ah.iA)) {
              goto _1269_fp_math;
            }  
            break;
            case 88:
            if (sqlite3MulInt64((&u.ah.iB), u.ah.iA)) {
              goto _1269_fp_math;
            }  
            break;
            case 89:
            {
              if ((u.ah.iA == 0)) {
                goto _1269_arithmetic_result_is_null;
              }  
              if (((u.ah.iA == (- 1)) && (u.ah.iB == (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32)))))) {
                goto _1269_fp_math;
              }  
              (u.ah.iB /= u.ah.iA);
              break;
            }
            id2i_label_2:
            default:
            {
              if ((u.ah.iA == 0)) {
                goto _1269_arithmetic_result_is_null;
              }  
              if ((u.ah.iA == (- 1))) {
                (u.ah.iA = 1);
              }  
              (u.ah.iB %= u.ah.iA);
              break;
            }
          }
          (pOut->u.i = u.ah.iB);
          (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0004));
        }  
        else {
          (u.ah.bIntint = 0);
          _1269_fp_math:
          (u.ah.rA = sqlite3VdbeRealValue(pIn1));
          (u.ah.rB = sqlite3VdbeRealValue(pIn2));
          switch (pOp->opcode) {
            case 86:
            (u.ah.rB += u.ah.rA);
            break;
            case 87:
            (u.ah.rB -= u.ah.rA);
            break;
            case 88:
            (u.ah.rB *= u.ah.rA);
            break;
            case 89:
            {
              if ((u.ah.rA == ((double ) 0))) {
                goto _1269_arithmetic_result_is_null;
              }  
              (u.ah.rB /= u.ah.rA);
              break;
            }
            id2i_label_3:
            default:
            {
              (u.ah.iA = ((i64 ) u.ah.rA));
              (u.ah.iB = ((i64 ) u.ah.rB));
              if ((u.ah.iA == 0)) {
                goto _1269_arithmetic_result_is_null;
              }  
              if ((u.ah.iA == (- 1))) {
                (u.ah.iA = 1);
              }  
              (u.ah.rB = ((double ) (u.ah.iB % u.ah.iA)));
              break;
            }
          }
          if (sqlite3IsNaN(u.ah.rB)) {
            goto _1269_arithmetic_result_is_null;
          }  
          (pOut->r = u.ah.rB);
          (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0008));
          if ((((u.ah.flags & 0x0008) == 0) && (! u.ah.bIntint))) {
            sqlite3VdbeIntegerAffinity(pOut);
          }  
        }
        break;
        _1269_arithmetic_result_is_null:
        sqlite3VdbeMemSetNull(pOut);
        break;
      }
      case 31:
      {
        ((void ) 0);
        if (pOp->p1) {
          sqlite3VdbeMemSetInt64((&aMem[pOp->p1]), 0);
        }  
        break;
      }
      case 1:
      {
        (u.ai.n = pOp->p5);
        (u.ai.apVal = p->apArg);
        ((void ) 0);
        ((void ) 0);
        (pOut = (&aMem[pOp->p3]));
        ((void ) 0);
        ((void ) 0);
        (u.ai.pArg = (&aMem[pOp->p2]));
        for ((u.ai.i = 0); (u.ai.i < u.ai.n); u.ai.i++, u.ai.pArg++) {
          ((void ) 0);
          (u.ai.apVal[u.ai.i] = u.ai.pArg);
          if ((((u.ai.pArg->flags & 0x1000) != 0) && sqlite3VdbeMemMakeWriteable(u.ai.pArg))) {
            goto _1269_no_mem;
          }  
          sqlite3VdbeMemStoreType(u.ai.pArg);
        }
        ((void ) 0);
        (u.ai.ctx.pFunc = pOp->p4.pFunc);
        (u.ai.ctx.s.flags = 0x0001);
        (u.ai.ctx.s.db = db);
        (u.ai.ctx.s.xDel = 0);
        (u.ai.ctx.s.zMalloc = 0);
        (u.ai.ctx.iOp = pc);
        (u.ai.ctx.pVdbe = p);
        sqlite3VdbeMemMove((&u.ai.ctx.s), pOut);
        ((&u.ai.ctx.s)->flags = (((&u.ai.ctx.s)->flags & (~ (0x01ff | 0x4000))) | 0x0001));
        (u.ai.ctx.fErrorOrAux = 0);
        if ((u.ai.ctx.pFunc->funcFlags & 0x020)) {
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (u.ai.ctx.pColl = pOp[(- 1)].p4.pColl);
        }  
        (db->lastRowid = lastRowid);
        (*u.ai.ctx.pFunc->xFunc)((&u.ai.ctx), u.ai.n, u.ai.apVal);
        (lastRowid = db->lastRowid);
        if (db->mallocFailed) {
          sqlite3VdbeMemRelease((&u.ai.ctx.s));
          goto _1269_no_mem;
        }  
        if (u.ai.ctx.fErrorOrAux) {
          if (u.ai.ctx.isError) {
            sqlite3SetString((&p->zErrMsg), db, "%s", sqlite3_value_text((&u.ai.ctx.s)));
            (rc = u.ai.ctx.isError);
          }  
          sqlite3VdbeDeleteAuxData(p, pc, pOp->p1);
        }  
        sqlite3VdbeChangeEncoding((&u.ai.ctx.s), encoding);
        sqlite3VdbeMemMove(pOut, (&u.ai.ctx.s));
        if (sqlite3VdbeMemTooBig(pOut)) {
          goto _1269_too_big;
        }  
        break;
      }
      case 82:
      case 83:
      case 84:
      case 85:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pIn2 = (&aMem[pOp->p2]));
        (pOut = (&aMem[pOp->p3]));
        if (((pIn1->flags | pIn2->flags) & 0x0001)) {
          sqlite3VdbeMemSetNull(pOut);
          break;
        }  
        (u.aj.iA = sqlite3VdbeIntValue(pIn2));
        (u.aj.iB = sqlite3VdbeIntValue(pIn1));
        (u.aj.op = pOp->opcode);
        if ((u.aj.op == 82)) {
          (u.aj.iA &= u.aj.iB);
        } 
        else if ((u.aj.op == 83)) {
          (u.aj.iA |= u.aj.iB);
        }
        
        else if ((u.aj.iB != 0)) {
          ((void ) 0);
          if ((u.aj.iB < 0)) {
            ((void ) 0);
            (u.aj.op = ((2 * 84) + 1 - u.aj.op));
            (u.aj.iB = ((u.aj.iB > (- 64)) ? (- u.aj.iB) : 64));
          }  
          if ((u.aj.iB >= 64)) {
            (u.aj.iA = (((u.aj.iA >= 0) || (u.aj.op == 84)) ? 0 : (- 1)));
          }  
          else {
            memcpy((&u.aj.uA), (&u.aj.iA), sizeof(u.aj.uA));
            if ((u.aj.op == 84)) {
              (u.aj.uA <<= u.aj.iB);
            }  
            else {
              (u.aj.uA >>= u.aj.iB);
              if ((u.aj.iA < 0)) {
                (u.aj.uA |= (((((u64 ) 0xffffffff) << 32) | 0xffffffff) << (64 - u.aj.iB)));
              }  
            }
            memcpy((&u.aj.iA), (&u.aj.uA), sizeof(u.aj.iA));
          }
        } 
        (pOut->u.i = u.aj.iA);
        (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0004));
        break;
      }
      case 32:
      {
        (pIn1 = (&aMem[pOp->p1]));
        sqlite3VdbeMemIntegerify(pIn1);
        (pIn1->u.i += pOp->p2);
        break;
      }
      case 33:
      {
        (pIn1 = (&aMem[pOp->p1]));
        applyAffinity(pIn1, 'c', encoding);
        if (((pIn1->flags & 0x0004) == 0)) {
          if ((pOp->p2 == 0)) {
            (rc = 20);
            goto _1269_abort_due_to_error;
          }  
          else {
            (pc = (pOp->p2 - 1));
          }
        }  
        else {
          (pIn1->flags = ((pIn1->flags & (~ (0x01ff | 0x4000))) | 0x0004));
        }
        break;
      }
      case 34:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if ((pIn1->flags & 0x0004)) {
          sqlite3VdbeMemRealify(pIn1);
        }  
        break;
      }
      case 141:
      if ((((! id2i_sqlite_omit_cast) ) )) {
        (pIn1 = (&aMem[pOp->p1]));
        if ((pIn1->flags & 0x0001)) {
          break;
        }  
        ((void ) 0);
        (pIn1->flags |= ((pIn1->flags & 0x0010) >> 3));
        applyAffinity(pIn1, 'a', encoding);
        (rc = ((pIn1->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn1) : 0));
        ((void ) 0);
        (pIn1->flags &= (~ (0x0004 | 0x0008 | 0x0010 | 0x4000)));
        break;
      }  
      if (((id2i_sqlite_omit_cast ) )) {
        if ((pOp->opcode == 141)) {
          goto id2i_label_1;
        }  
      }  
      case 142:
      if ((((! id2i_sqlite_omit_cast) ) )) {
        (pIn1 = (&aMem[pOp->p1]));
        if ((pIn1->flags & 0x0001)) {
          break;
        }  
        if (((pIn1->flags & 0x0010) == 0)) {
          applyAffinity(pIn1, 'a', encoding);
          ((void ) 0);
          (pIn1->flags = ((pIn1->flags & (~ (0x01ff | 0x4000))) | 0x0010));
        }  
        else {
          (pIn1->flags &= (~ (0x01ff & (~ 0x0010))));
        }
        break;
      }  
      if (((id2i_sqlite_omit_cast ) )) {
        if ((pOp->opcode == 142)) {
          goto id2i_label_1;
        }  
      }  
      case 143:
      if ((((! id2i_sqlite_omit_cast) ) )) {
        (pIn1 = (&aMem[pOp->p1]));
        sqlite3VdbeMemNumerify(pIn1);
        break;
      }  
      if (((id2i_sqlite_omit_cast ) )) {
        if ((pOp->opcode == 143)) {
          goto id2i_label_1;
        }  
      }  
      case 144:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if (((pIn1->flags & 0x0001) == 0)) {
          sqlite3VdbeMemIntegerify(pIn1);
        }  
        break;
      }
      case 145:
      if ((((! id2i_sqlite_omit_cast) ) )) {
        (pIn1 = (&aMem[pOp->p1]));
        if (((pIn1->flags & 0x0001) == 0)) {
          sqlite3VdbeMemRealify(pIn1);
        }  
        break;
      }  
      if (((id2i_sqlite_omit_cast ) )) {
        if ((pOp->opcode == 145)) {
          goto id2i_label_1;
        }  
      }  
      case 76:
      case 75:
      case 79:
      case 78:
      case 77:
      case 80:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pIn3 = (&aMem[pOp->p3]));
        (u.ak.flags1 = pIn1->flags);
        (u.ak.flags3 = pIn3->flags);
        if (((u.ak.flags1 | u.ak.flags3) & 0x0001)) {
          if ((pOp->p5 & 0x80)) {
            ((void ) 0);
            ((void ) 0);
            if ((((u.ak.flags1 & 0x0001) != 0) && ((u.ak.flags3 & 0x0001) != 0) && ((u.ak.flags3 & 0x0100) == 0))) {
              (u.ak.res = 0);
            }  
            else {
              (u.ak.res = 1);
            }
          }  
          else {
            if ((pOp->p5 & 0x08)) {
              (pc = (pOp->p2 - 1));
            } 
            else if ((pOp->p5 & 0x10)) {
              (pOut = (&aMem[pOp->p2]));
              (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0001));
            } 
            break;
          }
        }  
        else {
          (u.ak.affinity = (pOp->p5 & 0x67));
          if (u.ak.affinity) {
            applyAffinity(pIn1, u.ak.affinity, encoding);
            applyAffinity(pIn3, u.ak.affinity, encoding);
            if (db->mallocFailed) {
              goto _1269_no_mem;
            }  
          }  
          ((void ) 0);
          ((pIn1->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn1) : 0);
          ((pIn3->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn3) : 0);
          (u.ak.res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl));
        }
        switch (pOp->opcode) {
          case 76:
          (u.ak.res = (u.ak.res == 0));
          break;
          case 75:
          (u.ak.res = (u.ak.res != 0));
          break;
          case 79:
          (u.ak.res = (u.ak.res < 0));
          break;
          case 78:
          (u.ak.res = (u.ak.res <= 0));
          break;
          case 77:
          (u.ak.res = (u.ak.res > 0));
          break;
          id2i_label_4:
          default:
          (u.ak.res = (u.ak.res >= 0));
          break;
        }
        if ((pOp->p5 & 0x10)) {
          (pOut = (&aMem[pOp->p2]));
          (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0004));
          (pOut->u.i = u.ak.res);
        } 
        else if (u.ak.res) {
          (pc = (pOp->p2 - 1));
        } 
        (pIn1->flags = ((pIn1->flags & (~ 0x01ff)) | (u.ak.flags1 & 0x01ff)));
        (pIn3->flags = ((pIn3->flags & (~ 0x01ff)) | (u.ak.flags3 & 0x01ff)));
        break;
      }
      case 35:
      {
        ((void ) 0);
        ((void ) 0);
        (aPermute = pOp->p4.ai);
        break;
      }
      case 36:
      {
        if (((pOp->p5 & 0x01) == 0)) {
          (aPermute = 0);
        }  
        (u.al.n = pOp->p3);
        (u.al.pKeyInfo = pOp->p4.pKeyInfo);
        ((void ) 0);
        ((void ) 0);
        (u.al.p1 = pOp->p1);
        (u.al.p2 = pOp->p2);
        for ((u.al.i = 0); (u.al.i < u.al.n); u.al.i++) {
          (u.al.idx = (aPermute ? aPermute[u.al.i] : u.al.i));
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (u.al.pColl = u.al.pKeyInfo->aColl[u.al.i]);
          (u.al.bRev = u.al.pKeyInfo->aSortOrder[u.al.i]);
          (iCompare = sqlite3MemCompare((&aMem[(u.al.p1 + u.al.idx)]), (&aMem[(u.al.p2 + u.al.idx)]), u.al.pColl));
          if (iCompare) {
            if (u.al.bRev) {
              (iCompare = (- iCompare));
            }  
            break;
          }  
        }
        (aPermute = 0);
        break;
      }
      case 37:
      {
        if ((iCompare < 0)) {
          (pc = (pOp->p1 - 1));
        } 
        else if ((iCompare == 0)) {
          (pc = (pOp->p2 - 1));
        } 
        else {
          (pc = (pOp->p3 - 1));
        }
        break;
      }
      case 69:
      case 68:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if ((pIn1->flags & 0x0001)) {
          (u.am.v1 = 2);
        }  
        else {
          (u.am.v1 = (sqlite3VdbeIntValue(pIn1) != 0));
        }
        (pIn2 = (&aMem[pOp->p2]));
        if ((pIn2->flags & 0x0001)) {
          (u.am.v2 = 2);
        }  
        else {
          (u.am.v2 = (sqlite3VdbeIntValue(pIn2) != 0));
        }
        if ((pOp->opcode == 69)) {
          static const unsigned char and_logic[] =  { 0,  0,  0,  0,  1,  2,  0,  2,  2};
          (u.am.v1 = and_logic[((u.am.v1 * 3) + u.am.v2)]);
        }  
        else {
          static const unsigned char or_logic[] =  { 0,  1,  2,  1,  1,  1,  2,  1,  2};
          (u.am.v1 = or_logic[((u.am.v1 * 3) + u.am.v2)]);
        }
        (pOut = (&aMem[pOp->p3]));
        if ((u.am.v1 == 2)) {
          (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0001));
        }  
        else {
          (pOut->u.i = u.am.v1);
          (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0004));
        }
        break;
      }
      case 19:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pOut = (&aMem[pOp->p2]));
        if ((pIn1->flags & 0x0001)) {
          sqlite3VdbeMemSetNull(pOut);
        }  
        else {
          sqlite3VdbeMemSetInt64(pOut, (! sqlite3VdbeIntValue(pIn1)));
        }
        break;
      }
      case 93:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pOut = (&aMem[pOp->p2]));
        if ((pIn1->flags & 0x0001)) {
          sqlite3VdbeMemSetNull(pOut);
        }  
        else {
          sqlite3VdbeMemSetInt64(pOut, (~ sqlite3VdbeIntValue(pIn1)));
        }
        break;
      }
      case 38:
      {
        ((void ) 0);
        if (p->aOnceFlag[pOp->p1]) {
          (pc = (pOp->p2 - 1));
        }  
        else {
          (p->aOnceFlag[pOp->p1] = 1);
        }
        break;
      }
      case 39:
      case 40:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if ((pIn1->flags & 0x0001)) {
          (u.an.c = pOp->p3);
        }  
        else {
          (u.an.c = (sqlite3VdbeRealValue(pIn1) != 0.0));
          if ((pOp->opcode == 40)) {
            (u.an.c = (! u.an.c));
          }  
        }
        if (u.an.c) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 73:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if (((pIn1->flags & 0x0001) != 0)) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 74:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if (((pIn1->flags & 0x0001) == 0)) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 41:
      {
        (u.ao.p1 = pOp->p1);
        (u.ao.p2 = pOp->p2);
        (u.ao.pC = 0);
        memset((&u.ao.sMem), 0, sizeof(u.ao.sMem));
        ((void ) 0);
        ((void ) 0);
        (u.ao.pDest = (&aMem[pOp->p3]));
        (u.ao.zRec = 0);
        (u.ao.pC = p->apCsr[u.ao.p1]);
        ((void ) 0);
        ((void ) 0);
        (u.ao.pCrsr = u.ao.pC->pCursor);
        if ((u.ao.pCrsr != 0)) {
          (rc = sqlite3VdbeCursorMoveto(u.ao.pC));
          if (rc) {
            goto _1269_abort_due_to_error;
          }  
          if (u.ao.pC->nullRow) {
            (u.ao.payloadSize = 0);
          } 
          else if ((u.ao.pC->cacheStatus == p->cacheCtr)) {
            (u.ao.payloadSize = u.ao.pC->payloadSize);
            (u.ao.zRec = ((char *) u.ao.pC->aRow));
          }
          
          else if (u.ao.pC->isIndex) {
            ((void ) 0);
            sqlite3BtreeKeySize(u.ao.pCrsr, (&u.ao.payloadSize64));
            ((void ) 0);
            ((void ) 0);
            (u.ao.payloadSize = ((u32 ) u.ao.payloadSize64));
          } 
          else {
            ((void ) 0);
            sqlite3BtreeDataSize(u.ao.pCrsr, (&u.ao.payloadSize));
            ((void ) 0);
          }
        } 
        else if ((((id2i_sqlite_coverage_test ) ) && 1)) {
          (u.ao.pReg = (&aMem[u.ao.pC->pseudoTableReg]));
          if (u.ao.pC->multiPseudo) {
            sqlite3VdbeMemShallowCopy(u.ao.pDest, (u.ao.pReg + u.ao.p2), 0x1000);
            if ((((u.ao.pDest->flags & 0x1000) != 0) && sqlite3VdbeMemMakeWriteable(u.ao.pDest))) {
              goto _1269_no_mem;
            }  
            goto _1269_op_column_out;
          }  
          ((void ) 0);
          ((void ) 0);
          (u.ao.payloadSize = u.ao.pReg->n);
          (u.ao.zRec = u.ao.pReg->z);
          (u.ao.pC->cacheStatus = ((pOp->p5 & 0x20) ? 0 : p->cacheCtr));
          ((void ) 0);
        }
        
        else if (((((! id2i_sqlite_coverage_test) ) ) && (u.ao.pC->pseudoTableReg > 0))) {
          (u.ao.pReg = (&aMem[u.ao.pC->pseudoTableReg]));
          if (u.ao.pC->multiPseudo) {
            sqlite3VdbeMemShallowCopy(u.ao.pDest, (u.ao.pReg + u.ao.p2), 0x1000);
            if ((((u.ao.pDest->flags & 0x1000) != 0) && sqlite3VdbeMemMakeWriteable(u.ao.pDest))) {
              goto _1269_no_mem;
            }  
            goto _1269_op_column_out;
          }  
          ((void ) 0);
          ((void ) 0);
          (u.ao.payloadSize = u.ao.pReg->n);
          (u.ao.zRec = u.ao.pReg->z);
          (u.ao.pC->cacheStatus = ((pOp->p5 & 0x20) ? 0 : p->cacheCtr));
          ((void ) 0);
        } 
        else {
          (u.ao.payloadSize = 0);
        }
        if ((u.ao.payloadSize == 0)) {
          (u.ao.pDest->flags = ((u.ao.pDest->flags & (~ (0x01ff | 0x4000))) | 0x0001));
          goto _1269_op_column_out;
        }  
        ((void ) 0);
        if ((u.ao.payloadSize > ((u32 ) db->aLimit[0]))) {
          goto _1269_too_big;
        }  
        (u.ao.nField = u.ao.pC->nField);
        ((void ) 0);
        (u.ao.aType = u.ao.pC->aType);
        if ((u.ao.pC->cacheStatus == p->cacheCtr)) {
          (u.ao.aOffset = u.ao.pC->aOffset);
        }  
        else {
          ((void ) 0);
          (u.ao.avail = 0);
          (u.ao.pC->aOffset = (u.ao.aOffset = (&u.ao.aType[u.ao.nField])));
          (u.ao.pC->payloadSize = u.ao.payloadSize);
          (u.ao.pC->cacheStatus = p->cacheCtr);
          if (u.ao.zRec) {
            (u.ao.zData = u.ao.zRec);
          }  
          else {
            if (u.ao.pC->isIndex) {
              (u.ao.zData = ((char *) sqlite3BtreeKeyFetch(u.ao.pCrsr, (&u.ao.avail))));
            }  
            else {
              (u.ao.zData = ((char *) sqlite3BtreeDataFetch(u.ao.pCrsr, (&u.ao.avail))));
            }
            ((void ) 0);
            if ((u.ao.payloadSize <= ((u32 ) u.ao.avail))) {
              (u.ao.zRec = u.ao.zData);
              (u.ao.pC->aRow = ((u8 *) u.ao.zData));
            }  
            else {
              (u.ao.pC->aRow = 0);
            }
          }
          (u.ao.szHdr = ((u8 ) (((*((u8 *) u.ao.zData)) < ((u8 ) 0x80)) ? (u.ao.offset = ((u32 ) (*((u8 *) u.ao.zData)))), 1 : sqlite3GetVarint32(((u8 *) u.ao.zData), ((u32 *) (&u.ao.offset))))));
          if ((u.ao.offset > 98307)) {
            (rc = sqlite3CorruptError(68326));
            goto _1269_op_column_out;
          }  
          (u.ao.len = ((u.ao.nField * 5) + 3));
          if ((u.ao.len > ((int ) u.ao.offset))) {
            (u.ao.len = ((int ) u.ao.offset));
          }  
          if (((! u.ao.zRec) && (u.ao.avail < u.ao.len))) {
            (u.ao.sMem.flags = 0);
            (u.ao.sMem.db = 0);
            (rc = sqlite3VdbeMemFromBtree(u.ao.pCrsr, 0, u.ao.len, u.ao.pC->isIndex, (&u.ao.sMem)));
            if ((rc != 0)) {
              goto _1269_op_column_out;
            }  
            (u.ao.zData = u.ao.sMem.z);
          }  
          (u.ao.zEndHdr = ((u8 *) (&u.ao.zData[u.ao.len])));
          (u.ao.zIdx = ((u8 *) (&u.ao.zData[u.ao.szHdr])));
          for ((u.ao.i = 0); (u.ao.i < u.ao.nField); u.ao.i++) {
            if ((u.ao.zIdx < u.ao.zEndHdr)) {
              (u.ao.aOffset[u.ao.i] = u.ao.offset);
              if ((u.ao.zIdx[0] < 0x80)) {
                (u.ao.t = u.ao.zIdx[0]);
                u.ao.zIdx++;
              }  
              else {
                (u.ao.zIdx += sqlite3GetVarint32(u.ao.zIdx, (&u.ao.t)));
              }
              (u.ao.aType[u.ao.i] = u.ao.t);
              (u.ao.szField = sqlite3VdbeSerialTypeLen(u.ao.t));
              (u.ao.offset += u.ao.szField);
              if ((u.ao.offset < u.ao.szField)) {
                (u.ao.zIdx = (&u.ao.zEndHdr[1]));
                break;
              }  
            }  
            else {
              (u.ao.aOffset[u.ao.i] = 0);
            }
          }
          sqlite3VdbeMemRelease((&u.ao.sMem));
          (u.ao.sMem.flags = 0x0001);
          if (((u.ao.zIdx > u.ao.zEndHdr) || (u.ao.offset > u.ao.payloadSize) || ((u.ao.zIdx == u.ao.zEndHdr) && (u.ao.offset != u.ao.payloadSize)))) {
            (rc = sqlite3CorruptError(68406));
            goto _1269_op_column_out;
          }  
        }
        if (u.ao.aOffset[u.ao.p2]) {
          ((void ) 0);
          if (u.ao.zRec) {
            if ((u.ao.pDest->flags & (0x2000 | 0x0400 | 0x0020 | 0x0040))) {
              sqlite3VdbeMemReleaseExternal(u.ao.pDest);
            }  
            sqlite3VdbeSerialGet(((u8 *) (&u.ao.zRec[u.ao.aOffset[u.ao.p2]])), u.ao.aType[u.ao.p2], u.ao.pDest);
          }  
          else {
            (u.ao.t = u.ao.aType[u.ao.p2]);
            if ((((pOp->p5 & (0x40 | 0x80)) != 0) && (((u.ao.t >= 12) && ((u.ao.t & 1) == 0)) || ((pOp->p5 & 0x80) != 0)))) {
              (u.ao.zData = ((u.ao.t < 12) ? ((char *) (&u.ao.payloadSize64)) : 0));
            }  
            else {
              (u.ao.len = sqlite3VdbeSerialTypeLen(u.ao.t));
              sqlite3VdbeMemMove((&u.ao.sMem), u.ao.pDest);
              (rc = sqlite3VdbeMemFromBtree(u.ao.pCrsr, u.ao.aOffset[u.ao.p2], u.ao.len, u.ao.pC->isIndex, (&u.ao.sMem)));
              if ((rc != 0)) {
                goto _1269_op_column_out;
              }  
              (u.ao.zData = u.ao.sMem.z);
            }
            sqlite3VdbeSerialGet(((u8 *) u.ao.zData), u.ao.t, u.ao.pDest);
          }
          (u.ao.pDest->enc = encoding);
        }  
        else {
          if ((pOp->p4type == (- 8))) {
            sqlite3VdbeMemShallowCopy(u.ao.pDest, pOp->p4.pMem, 0x0800);
          }  
          else {
            (u.ao.pDest->flags = ((u.ao.pDest->flags & (~ (0x01ff | 0x4000))) | 0x0001));
          }
        }
        if (u.ao.sMem.zMalloc) {
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (u.ao.pDest->flags &= (~ (0x1000 | 0x0800)));
          (u.ao.pDest->flags |= 0x0200);
          (u.ao.pDest->z = u.ao.sMem.z);
          (u.ao.pDest->zMalloc = u.ao.sMem.zMalloc);
        }  
        (rc = sqlite3VdbeMemMakeWriteable(u.ao.pDest));
        _1269_op_column_out:
        break;
      }
      case 42:
      {
        (u.ap.zAffinity = pOp->p4.z);
        ((void ) 0);
        ((void ) 0);
        (pIn1 = (&aMem[pOp->p1]));
        while (((u.ap.cAff = (*u.ap.zAffinity++)) != 0)) {
          ((void ) 0);
          ((void ) 0);
          ((pIn1->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn1) : 0);
          applyAffinity(pIn1, u.ap.cAff, encoding);
          pIn1++;
        }
        break;
      }
      case 43:
      {
        (u.aq.nData = 0);
        (u.aq.nHdr = 0);
        (u.aq.nZero = 0);
        (u.aq.nField = pOp->p1);
        (u.aq.zAffinity = pOp->p4.z);
        ((void ) 0);
        (u.aq.pData0 = (&aMem[u.aq.nField]));
        (u.aq.nField = pOp->p2);
        (u.aq.pLast = (&u.aq.pData0[(u.aq.nField - 1)]));
        (u.aq.file_format = p->minWriteFileFormat);
        ((void ) 0);
        (pOut = (&aMem[pOp->p3]));
        for ((u.aq.pRec = u.aq.pData0); (u.aq.pRec <= u.aq.pLast); u.aq.pRec++) {
          ((void ) 0);
          if (u.aq.zAffinity) {
            applyAffinity(u.aq.pRec, u.aq.zAffinity[(u.aq.pRec - u.aq.pData0)], encoding);
          }  
          if (((u.aq.pRec->flags & 0x4000) && (u.aq.pRec->n > 0))) {
            sqlite3VdbeMemExpandBlob(u.aq.pRec);
          }  
          (u.aq.serial_type = sqlite3VdbeSerialType(u.aq.pRec, u.aq.file_format));
          (u.aq.len = sqlite3VdbeSerialTypeLen(u.aq.serial_type));
          (u.aq.nData += u.aq.len);
          (u.aq.nHdr += sqlite3VarintLen(u.aq.serial_type));
          if ((u.aq.pRec->flags & 0x4000)) {
            (u.aq.nZero += u.aq.pRec->u.nZero);
          } 
          else if (u.aq.len) {
            (u.aq.nZero = 0);
          } 
        }
        (u.aq.nHdr += (u.aq.nVarint = sqlite3VarintLen(u.aq.nHdr)));
        if ((u.aq.nVarint < sqlite3VarintLen(u.aq.nHdr))) {
          u.aq.nHdr++;
        }  
        (u.aq.nByte = (u.aq.nHdr + u.aq.nData - u.aq.nZero));
        if ((u.aq.nByte > db->aLimit[0])) {
          goto _1269_too_big;
        }  
        if (sqlite3VdbeMemGrow(pOut, ((int ) u.aq.nByte), 0)) {
          goto _1269_no_mem;
        }  
        (u.aq.zNewRecord = ((u8 *) pOut->z));
        (u.aq.i = ((u8 ) ((((u32 ) u.aq.nHdr) < ((u32 ) 0x80)) ? ((*u.aq.zNewRecord) = ((unsigned  char ) u.aq.nHdr)), 1 : sqlite3PutVarint32(u.aq.zNewRecord, u.aq.nHdr))));
        for ((u.aq.pRec = u.aq.pData0); (u.aq.pRec <= u.aq.pLast); u.aq.pRec++) {
          (u.aq.serial_type = sqlite3VdbeSerialType(u.aq.pRec, u.aq.file_format));
          (u.aq.i += ((u8 ) ((((u32 ) u.aq.serial_type) < ((u32 ) 0x80)) ? ((*(&u.aq.zNewRecord[u.aq.i])) = ((unsigned  char ) u.aq.serial_type)), 1 : sqlite3PutVarint32((&u.aq.zNewRecord[u.aq.i]), u.aq.serial_type))));
        }
        for ((u.aq.pRec = u.aq.pData0); (u.aq.pRec <= u.aq.pLast); u.aq.pRec++) {
          (u.aq.i += sqlite3VdbeSerialPut((&u.aq.zNewRecord[u.aq.i]), ((int ) (u.aq.nByte - u.aq.i)), u.aq.pRec, u.aq.file_format));
        }
        ((void ) 0);
        ((void ) 0);
        (pOut->n = ((int ) u.aq.nByte));
        (pOut->flags = (0x0010 | 0x0400));
        (pOut->xDel = 0);
        if (u.aq.nZero) {
          (pOut->u.nZero = u.aq.nZero);
          (pOut->flags |= 0x4000);
        }  
        (pOut->enc = 1);
        break;
      }
      case 44:
      {
        (u.ar.pCrsr = p->apCsr[pOp->p1]->pCursor);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            (rc = sqlite3BtreeCount(u.ar.pCrsr, (&u.ar.nEntry)));
          }  
          else {
            (u.ar.nEntry = 0);
          }
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if (u.ar.pCrsr) {
            (rc = sqlite3BtreeCount(u.ar.pCrsr, (&u.ar.nEntry)));
          }  
          else {
            (u.ar.nEntry = 0);
          }
        }  
        (pOut->u.i = u.ar.nEntry);
        break;
      }
      case 2:
      {
        (u.as.p1 = pOp->p1);
        (u.as.zName = pOp->p4.z);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if ((u.as.p1 == 0)) {
          if ((db->nVdbeWrite > 0)) {
            sqlite3SetString((&p->zErrMsg), db, "cannot open savepoint - " "SQL statements in progress");
            (rc = 5);
          }  
          else {
            (u.as.nName = sqlite3Strlen30(u.as.zName));
            ((void ) 0);
            (rc = sqlite3VtabSavepoint(db, 0, (db->nStatement + db->nSavepoint)));
            if ((rc != 0)) {
              goto _1269_abort_due_to_error;
            }  
            (u.as.pNew = sqlite3DbMallocRaw(db, (sizeof(Savepoint ) + u.as.nName + 1)));
            if (u.as.pNew) {
              (u.as.pNew->zName = ((char *) (&u.as.pNew[1])));
              memcpy(u.as.pNew->zName, u.as.zName, (u.as.nName + 1));
              if (db->autoCommit) {
                (db->autoCommit = 0);
                (db->isTransactionSavepoint = 1);
              }  
              else {
                db->nSavepoint++;
              }
              (u.as.pNew->pNext = db->pSavepoint);
              (db->pSavepoint = u.as.pNew);
              (u.as.pNew->nDeferredCons = db->nDeferredCons);
              (u.as.pNew->nDeferredImmCons = db->nDeferredImmCons);
            }  
          }
        }  
        else {
          (u.as.iSavepoint = 0);
          for ((u.as.pSavepoint = db->pSavepoint); (u.as.pSavepoint && sqlite3_stricmp(u.as.pSavepoint->zName, u.as.zName)); (u.as.pSavepoint = u.as.pSavepoint->pNext)) {
            u.as.iSavepoint++;
          }
          if ((! u.as.pSavepoint)) {
            sqlite3SetString((&p->zErrMsg), db, "no such savepoint: %s", u.as.zName);
            (rc = 1);
          } 
          else if (((db->nVdbeWrite > 0) && (u.as.p1 == 1))) {
            sqlite3SetString((&p->zErrMsg), db, "cannot release savepoint - SQL statements in progress");
            (rc = 5);
          } 
          else {
            int isTransaction =  ((u.as.pSavepoint->pNext == 0) && db->isTransactionSavepoint);
            if ((isTransaction && (u.as.p1 == 1))) {
              if (((id2i_sqlite_omit_foreign_key ) )) {
                if (((rc = 0) != 0)) {
                  goto _1269_vdbe_return;
                }  
              }  
              if ((((! id2i_sqlite_omit_foreign_key) ) )) {
                if (((rc = sqlite3VdbeCheckFk(p, 1)) != 0)) {
                  goto _1269_vdbe_return;
                }  
              }  
              (db->autoCommit = 1);
              if ((sqlite3VdbeHalt(p) == 5)) {
                (p->pc = pc);
                (db->autoCommit = 0);
                (p->rc = (rc = 5));
                goto _1269_vdbe_return;
              }  
              (db->isTransactionSavepoint = 0);
              (rc = p->rc);
            }  
            else {
              (u.as.iSavepoint = (db->nSavepoint - u.as.iSavepoint - 1));
              if ((u.as.p1 == 2)) {
                for ((u.as.ii = 0); (u.as.ii < db->nDb); u.as.ii++) {
                  sqlite3BtreeTripAllCursors(db->aDb[u.as.ii].pBt, 4);
                }
              }  
              for ((u.as.ii = 0); (u.as.ii < db->nDb); u.as.ii++) {
                (rc = sqlite3BtreeSavepoint(db->aDb[u.as.ii].pBt, u.as.p1, u.as.iSavepoint));
                if ((rc != 0)) {
                  goto _1269_abort_due_to_error;
                }  
              }
              if (((u.as.p1 == 2) && ((db->flags & 0x00000002) != 0))) {
                sqlite3ExpirePreparedStatements(db);
                sqlite3ResetAllSchemasOfConnection(db);
                (db->flags = (db->flags | 0x00000002));
              }  
            }
            while ((db->pSavepoint != u.as.pSavepoint)) {
              (u.as.pTmp = db->pSavepoint);
              (db->pSavepoint = u.as.pTmp->pNext);
              sqlite3DbFree(db, u.as.pTmp);
              db->nSavepoint--;
            }
            if ((u.as.p1 == 1)) {
              ((void ) 0);
              (db->pSavepoint = u.as.pSavepoint->pNext);
              sqlite3DbFree(db, u.as.pSavepoint);
              if ((! isTransaction)) {
                db->nSavepoint--;
              }  
            }  
            else {
              (db->nDeferredCons = u.as.pSavepoint->nDeferredCons);
              (db->nDeferredImmCons = u.as.pSavepoint->nDeferredImmCons);
            }
            if ((! isTransaction)) {
              (rc = sqlite3VtabSavepoint(db, u.as.p1, u.as.iSavepoint));
              if ((rc != 0)) {
                goto _1269_abort_due_to_error;
              }  
            }  
          }
        }
        break;
      }
      case 3:
      {
        (u.at.desiredAutoCommit = pOp->p1);
        (u.at.iRollback = pOp->p2);
        (u.at.turnOnAC = (u.at.desiredAutoCommit && (! db->autoCommit)));
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if ((u.at.turnOnAC && (! u.at.iRollback) && (db->nVdbeWrite > 0))) {
          sqlite3SetString((&p->zErrMsg), db, "cannot commit transaction - " "SQL statements in progress");
          (rc = 5);
        } 
        else if ((u.at.desiredAutoCommit != db->autoCommit)) {
          if (u.at.iRollback) {
            ((void ) 0);
            sqlite3RollbackAll(db, (4 | (2 << 8)));
            (db->autoCommit = 1);
          } 
          else if ((((id2i_sqlite_omit_foreign_key ) ) && ((rc = 0) != 0))) {
            goto _1269_vdbe_return;
          }
          
          else if (((((! id2i_sqlite_omit_foreign_key) ) ) && ((rc = sqlite3VdbeCheckFk(p, 1)) != 0))) {
            goto _1269_vdbe_return;
          } 
          else {
            (db->autoCommit = ((u8 ) u.at.desiredAutoCommit));
            if ((sqlite3VdbeHalt(p) == 5)) {
              (p->pc = pc);
              (db->autoCommit = ((u8 ) (1 - u.at.desiredAutoCommit)));
              (p->rc = (rc = 5));
              goto _1269_vdbe_return;
            }  
          }
          ((void ) 0);
          sqlite3CloseSavepoints(db);
          if ((p->rc == 0)) {
            (rc = 101);
          }  
          else {
            (rc = 1);
          }
          goto _1269_vdbe_return;
        } 
        else {
          sqlite3SetString((&p->zErrMsg), db, ((! u.at.desiredAutoCommit) ? "cannot start a transaction within a transaction" : (u.at.iRollback ? "cannot rollback - no transaction is active" : "cannot commit - no transaction is active")));
          (rc = 1);
        }
        break;
      }
      case 4:
      {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if ((pOp->p2 && ((db->flags & 0x02000000) != 0))) {
          (rc = 8);
          goto _1269_abort_due_to_error;
        }  
        (u.au.pBt = db->aDb[pOp->p1].pBt);
        if (u.au.pBt) {
          (rc = sqlite3BtreeBeginTrans(u.au.pBt, pOp->p2));
          if ((rc == 5)) {
            (p->pc = pc);
            (p->rc = (rc = 5));
            goto _1269_vdbe_return;
          }  
          if ((rc != 0)) {
            goto _1269_abort_due_to_error;
          }  
          if ((pOp->p2 && p->usesStmtJournal && ((db->autoCommit == 0) || (db->nVdbeRead > 1)))) {
            ((void ) 0);
            if ((p->iStatement == 0)) {
              ((void ) 0);
              db->nStatement++;
              (p->iStatement = (db->nSavepoint + db->nStatement));
            }  
            (rc = sqlite3VtabSavepoint(db, 0, (p->iStatement - 1)));
            if ((rc == 0)) {
              (rc = sqlite3BtreeBeginStmt(u.au.pBt, p->iStatement));
            }  
            (p->nStmtDefCons = db->nDeferredCons);
            (p->nStmtDefImmCons = db->nDeferredImmCons);
          }  
        }  
        break;
      }
      case 45:
      {
        ((void ) 0);
        (u.av.iDb = pOp->p1);
        (u.av.iCookie = pOp->p3);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        sqlite3BtreeGetMeta(db->aDb[u.av.iDb].pBt, u.av.iCookie, ((u32 *) (&u.av.iMeta)));
        (pOut->u.i = u.av.iMeta);
        break;
      }
      case 46:
      {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.aw.pDb = (&db->aDb[pOp->p1]));
        ((void ) 0);
        ((void ) 0);
        (pIn3 = (&aMem[pOp->p3]));
        sqlite3VdbeMemIntegerify(pIn3);
        (rc = sqlite3BtreeUpdateMeta(u.aw.pDb->pBt, pOp->p2, ((int ) pIn3->u.i)));
        if ((pOp->p2 == 1)) {
          (u.aw.pDb->pSchema->schema_cookie = ((int ) pIn3->u.i));
          (db->flags |= 0x00000002);
        } 
        else if ((pOp->p2 == 2)) {
          (u.aw.pDb->pSchema->file_format = ((u8 ) pIn3->u.i));
        } 
        if ((pOp->p1 == 1)) {
          sqlite3ExpirePreparedStatements(db);
          (p->expired = 0);
        }  
        break;
      }
      case 47:
      {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.ax.pBt = db->aDb[pOp->p1].pBt);
        if (u.ax.pBt) {
          sqlite3BtreeGetMeta(u.ax.pBt, 1, ((u32 *) (&u.ax.iMeta)));
          (u.ax.iGen = db->aDb[pOp->p1].pSchema->iGeneration);
        }  
        else {
          (u.ax.iGen = (u.ax.iMeta = 0));
        }
        if (((u.ax.iMeta != pOp->p2) || (u.ax.iGen != pOp->p3))) {
          sqlite3DbFree(db, p->zErrMsg);
          (p->zErrMsg = sqlite3DbStrDup(db, "database schema has changed"));
          if ((db->aDb[pOp->p1].pSchema->schema_cookie != u.ax.iMeta)) {
            sqlite3ResetOneSchema(db, pOp->p1);
          }  
          (p->expired = 1);
          (rc = 17);
        }  
        break;
      }
      case 48:
      case 49:
      {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if (p->expired) {
          (rc = 4);
          break;
        }  
        (u.ay.nField = 0);
        (u.ay.pKeyInfo = 0);
        (u.ay.p2 = pOp->p2);
        (u.ay.iDb = pOp->p3);
        ((void ) 0);
        ((void ) 0);
        (u.ay.pDb = (&db->aDb[u.ay.iDb]));
        (u.ay.pX = u.ay.pDb->pBt);
        ((void ) 0);
        if ((pOp->opcode == 49)) {
          (u.ay.wrFlag = 1);
          ((void ) 0);
          if ((u.ay.pDb->pSchema->file_format < p->minWriteFileFormat)) {
            (p->minWriteFileFormat = u.ay.pDb->pSchema->file_format);
          }  
        }  
        else {
          (u.ay.wrFlag = 0);
        }
        if ((pOp->p5 & 0x02)) {
          ((void ) 0);
          ((void ) 0);
          (pIn2 = (&aMem[u.ay.p2]));
          ((void ) 0);
          ((void ) 0);
          sqlite3VdbeMemIntegerify(pIn2);
          (u.ay.p2 = ((int ) pIn2->u.i));
          if (((id2i_sqlite_coverage_test ) )) {
            if (0) {
              (rc = sqlite3CorruptError(69234));
              goto _1269_abort_due_to_error;
            }  
          }  
          if ((((! id2i_sqlite_coverage_test) ) )) {
            if ((u.ay.p2 < 2)) {
              (rc = sqlite3CorruptError(69234));
              goto _1269_abort_due_to_error;
            }  
          }  
        }  
        if ((pOp->p4type == (- 6))) {
          (u.ay.pKeyInfo = pOp->p4.pKeyInfo);
          (u.ay.pKeyInfo->enc = p->db->aDb[0].pSchema->enc);
          (u.ay.nField = (u.ay.pKeyInfo->nField + 1));
        } 
        else if ((pOp->p4type == (- 14))) {
          (u.ay.nField = pOp->p4.i);
        } 
        ((void ) 0);
        (u.ay.pCur = allocateCursor(p, pOp->p1, u.ay.nField, u.ay.iDb, 1));
        if ((u.ay.pCur == 0)) {
          goto _1269_no_mem;
        }  
        (u.ay.pCur->nullRow = 1);
        (u.ay.pCur->isOrdered = 1);
        (rc = sqlite3BtreeCursor(u.ay.pX, u.ay.p2, u.ay.wrFlag, u.ay.pKeyInfo, u.ay.pCur->pCursor));
        (u.ay.pCur->pKeyInfo = u.ay.pKeyInfo);
        ((void ) 0);
        sqlite3BtreeCursorHints(u.ay.pCur->pCursor, (pOp->p5 & 0x01));
        ((void ) 0);
        (u.ay.pCur->isTable = (pOp->p4type != (- 6)));
        (u.ay.pCur->isIndex = (! u.ay.pCur->isTable));
        break;
      }
      case 50:
      case 51:
      {
        static const int vfsFlags =  (0x00000002 | 0x00000004 | 0x00000010 | 0x00000008 | 0x00000400);
        ((void ) 0);
        (u.az.pCx = allocateCursor(p, pOp->p1, pOp->p2, (- 1), 1));
        if ((u.az.pCx == 0)) {
          goto _1269_no_mem;
        }  
        (u.az.pCx->nullRow = 1);
        (rc = sqlite3BtreeOpen(db->pVfs, 0, db, (&u.az.pCx->pBt), (1 | 4 | pOp->p5), vfsFlags));
        if ((rc == 0)) {
          (rc = sqlite3BtreeBeginTrans(u.az.pCx->pBt, 1));
        }  
        if ((rc == 0)) {
          if (pOp->p4.pKeyInfo) {
            int pgno;
            ((void ) 0);
            (rc = sqlite3BtreeCreateTable(u.az.pCx->pBt, (&pgno), (2 | pOp->p5)));
            if ((rc == 0)) {
              ((void ) 0);
              (rc = sqlite3BtreeCursor(u.az.pCx->pBt, pgno, 1, ((KeyInfo *) pOp->p4.z), u.az.pCx->pCursor));
              (u.az.pCx->pKeyInfo = pOp->p4.pKeyInfo);
              (u.az.pCx->pKeyInfo->enc = p->db->aDb[0].pSchema->enc);
            }  
            (u.az.pCx->isTable = 0);
          }  
          else {
            (rc = sqlite3BtreeCursor(u.az.pCx->pBt, 1, 1, 0, u.az.pCx->pCursor));
            (u.az.pCx->isTable = 1);
          }
        }  
        (u.az.pCx->isOrdered = (pOp->p5 != 8));
        (u.az.pCx->isIndex = (! u.az.pCx->isTable));
        break;
      }
      case 52:
      {
        (u.ba.pCx = allocateCursor(p, pOp->p1, pOp->p2, (- 1), 1));
        if ((u.ba.pCx == 0)) {
          goto _1269_no_mem;
        }  
        (u.ba.pCx->pKeyInfo = pOp->p4.pKeyInfo);
        (u.ba.pCx->pKeyInfo->enc = p->db->aDb[0].pSchema->enc);
        (u.ba.pCx->isSorter = 1);
        (rc = sqlite3VdbeSorterInit(db, u.ba.pCx));
        break;
      }
      case 53:
      {
        ((void ) 0);
        (u.bb.pCx = allocateCursor(p, pOp->p1, pOp->p3, (- 1), 0));
        if ((u.bb.pCx == 0)) {
          goto _1269_no_mem;
        }  
        (u.bb.pCx->nullRow = 1);
        (u.bb.pCx->pseudoTableReg = pOp->p2);
        (u.bb.pCx->isTable = 1);
        (u.bb.pCx->isIndex = 0);
        (u.bb.pCx->multiPseudo = pOp->p5);
        break;
      }
      case 54:
      {
        ((void ) 0);
        sqlite3VdbeFreeCursor(p, p->apCsr[pOp->p1]);
        (p->apCsr[pOp->p1] = 0);
        break;
      }
      case 55:
      case 56:
      case 57:
      case 58:
      {
        ((void ) 0);
        ((void ) 0);
        (u.bc.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            (u.bc.oc = pOp->opcode);
            (u.bc.pC->nullRow = 0);
            if (u.bc.pC->isTable) {
              (pIn3 = (&aMem[pOp->p3]));
              applyNumericAffinity(pIn3);
              (u.bc.iKey = sqlite3VdbeIntValue(pIn3));
              (u.bc.pC->rowidIsValid = 0);
              if (((pIn3->flags & 0x0004) == 0)) {
                if (((pIn3->flags & 0x0008) == 0)) {
                  (pc = (pOp->p2 - 1));
                  break;
                }  
                ((void ) 0);
                if (((u.bc.iKey == (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32)))) && ((pIn3->r < ((double ) u.bc.iKey)) || (pIn3->r > 0)))) {
                  (u.bc.res = 1);
                  if ((pIn3->r < 0)) {
                    if ((u.bc.oc >= 57)) {
                      ((void ) 0);
                      (rc = sqlite3BtreeFirst(u.bc.pC->pCursor, (&u.bc.res)));
                      if ((rc != 0)) {
                        goto _1269_abort_due_to_error;
                      }  
                    }  
                  }  
                  else {
                    if ((u.bc.oc <= 56)) {
                      ((void ) 0);
                      (rc = sqlite3BtreeLast(u.bc.pC->pCursor, (&u.bc.res)));
                      if ((rc != 0)) {
                        goto _1269_abort_due_to_error;
                      }  
                    }  
                  }
                  if (u.bc.res) {
                    (pc = (pOp->p2 - 1));
                  }  
                  break;
                } 
                else if (((u.bc.oc == 55) || (u.bc.oc == 57))) {
                  if ((pIn3->r > ((double ) u.bc.iKey))) {
                    u.bc.iKey++;
                  }  
                } 
                else {
                  ((void ) 0);
                  if ((pIn3->r < ((double ) u.bc.iKey))) {
                    u.bc.iKey--;
                  }  
                }
              }  
              (rc = sqlite3BtreeMovetoUnpacked(u.bc.pC->pCursor, 0, ((u64 ) u.bc.iKey), 0, (&u.bc.res)));
              if ((rc != 0)) {
                goto _1269_abort_due_to_error;
              }  
              if ((u.bc.res == 0)) {
                (u.bc.pC->rowidIsValid = 1);
                (u.bc.pC->lastRowid = u.bc.iKey);
              }  
            }  
            else {
              (u.bc.nField = pOp->p4.i);
              ((void ) 0);
              ((void ) 0);
              (u.bc.r.pKeyInfo = u.bc.pC->pKeyInfo);
              (u.bc.r.nField = ((u16 ) u.bc.nField));
              (u.bc.r.flags = ((u8 ) (0x01 * (1 & (u.bc.oc - 55)))));
              ((void ) 0);
              ((void ) 0);
              ((void ) 0);
              ((void ) 0);
              (u.bc.r.aMem = (&aMem[pOp->p3]));
              ((u.bc.r.aMem->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(u.bc.r.aMem) : 0);
              (rc = sqlite3BtreeMovetoUnpacked(u.bc.pC->pCursor, (&u.bc.r), 0, 0, (&u.bc.res)));
              if ((rc != 0)) {
                goto _1269_abort_due_to_error;
              }  
              (u.bc.pC->rowidIsValid = 0);
            }
            (u.bc.pC->deferredMoveto = 0);
            (u.bc.pC->cacheStatus = 0);
            if ((u.bc.oc >= 57)) {
              ((void ) 0);
              if (((u.bc.res < 0) || ((u.bc.res == 0) && (u.bc.oc == 58)))) {
                (rc = sqlite3BtreeNext(u.bc.pC->pCursor, (&u.bc.res)));
                if ((rc != 0)) {
                  goto _1269_abort_due_to_error;
                }  
                (u.bc.pC->rowidIsValid = 0);
              }  
              else {
                (u.bc.res = 0);
              }
            }  
            else {
              ((void ) 0);
              if (((u.bc.res > 0) || ((u.bc.res == 0) && (u.bc.oc == 55)))) {
                (rc = sqlite3BtreePrevious(u.bc.pC->pCursor, (&u.bc.res)));
                if ((rc != 0)) {
                  goto _1269_abort_due_to_error;
                }  
                (u.bc.pC->rowidIsValid = 0);
              }  
              else {
                (u.bc.res = sqlite3BtreeEof(u.bc.pC->pCursor));
              }
            }
            ((void ) 0);
            if (u.bc.res) {
              (pc = (pOp->p2 - 1));
            }  
          }  
          else {
            (pc = (pOp->p2 - 1));
          }
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bc.pC->pCursor != 0)) {
            (u.bc.oc = pOp->opcode);
            (u.bc.pC->nullRow = 0);
            if (u.bc.pC->isTable) {
              (pIn3 = (&aMem[pOp->p3]));
              applyNumericAffinity(pIn3);
              (u.bc.iKey = sqlite3VdbeIntValue(pIn3));
              (u.bc.pC->rowidIsValid = 0);
              if (((pIn3->flags & 0x0004) == 0)) {
                if (((pIn3->flags & 0x0008) == 0)) {
                  (pc = (pOp->p2 - 1));
                  break;
                }  
                ((void ) 0);
                if (((u.bc.iKey == (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32)))) && ((pIn3->r < ((double ) u.bc.iKey)) || (pIn3->r > 0)))) {
                  (u.bc.res = 1);
                  if ((pIn3->r < 0)) {
                    if ((u.bc.oc >= 57)) {
                      ((void ) 0);
                      (rc = sqlite3BtreeFirst(u.bc.pC->pCursor, (&u.bc.res)));
                      if ((rc != 0)) {
                        goto _1269_abort_due_to_error;
                      }  
                    }  
                  }  
                  else {
                    if ((u.bc.oc <= 56)) {
                      ((void ) 0);
                      (rc = sqlite3BtreeLast(u.bc.pC->pCursor, (&u.bc.res)));
                      if ((rc != 0)) {
                        goto _1269_abort_due_to_error;
                      }  
                    }  
                  }
                  if (u.bc.res) {
                    (pc = (pOp->p2 - 1));
                  }  
                  break;
                } 
                else if (((u.bc.oc == 55) || (u.bc.oc == 57))) {
                  if ((pIn3->r > ((double ) u.bc.iKey))) {
                    u.bc.iKey++;
                  }  
                } 
                else {
                  ((void ) 0);
                  if ((pIn3->r < ((double ) u.bc.iKey))) {
                    u.bc.iKey--;
                  }  
                }
              }  
              (rc = sqlite3BtreeMovetoUnpacked(u.bc.pC->pCursor, 0, ((u64 ) u.bc.iKey), 0, (&u.bc.res)));
              if ((rc != 0)) {
                goto _1269_abort_due_to_error;
              }  
              if ((u.bc.res == 0)) {
                (u.bc.pC->rowidIsValid = 1);
                (u.bc.pC->lastRowid = u.bc.iKey);
              }  
            }  
            else {
              (u.bc.nField = pOp->p4.i);
              ((void ) 0);
              ((void ) 0);
              (u.bc.r.pKeyInfo = u.bc.pC->pKeyInfo);
              (u.bc.r.nField = ((u16 ) u.bc.nField));
              (u.bc.r.flags = ((u8 ) (0x01 * (1 & (u.bc.oc - 55)))));
              ((void ) 0);
              ((void ) 0);
              ((void ) 0);
              ((void ) 0);
              (u.bc.r.aMem = (&aMem[pOp->p3]));
              ((u.bc.r.aMem->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(u.bc.r.aMem) : 0);
              (rc = sqlite3BtreeMovetoUnpacked(u.bc.pC->pCursor, (&u.bc.r), 0, 0, (&u.bc.res)));
              if ((rc != 0)) {
                goto _1269_abort_due_to_error;
              }  
              (u.bc.pC->rowidIsValid = 0);
            }
            (u.bc.pC->deferredMoveto = 0);
            (u.bc.pC->cacheStatus = 0);
            if ((u.bc.oc >= 57)) {
              ((void ) 0);
              if (((u.bc.res < 0) || ((u.bc.res == 0) && (u.bc.oc == 58)))) {
                (rc = sqlite3BtreeNext(u.bc.pC->pCursor, (&u.bc.res)));
                if ((rc != 0)) {
                  goto _1269_abort_due_to_error;
                }  
                (u.bc.pC->rowidIsValid = 0);
              }  
              else {
                (u.bc.res = 0);
              }
            }  
            else {
              ((void ) 0);
              if (((u.bc.res > 0) || ((u.bc.res == 0) && (u.bc.oc == 55)))) {
                (rc = sqlite3BtreePrevious(u.bc.pC->pCursor, (&u.bc.res)));
                if ((rc != 0)) {
                  goto _1269_abort_due_to_error;
                }  
                (u.bc.pC->rowidIsValid = 0);
              }  
              else {
                (u.bc.res = sqlite3BtreeEof(u.bc.pC->pCursor));
              }
            }
            ((void ) 0);
            if (u.bc.res) {
              (pc = (pOp->p2 - 1));
            }  
          }  
          else {
            (pc = (pOp->p2 - 1));
          }
        }  
        break;
      }
      case 59:
      {
        ((void ) 0);
        (u.bd.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            ((void ) 0);
            (u.bd.pC->nullRow = 0);
            (pIn2 = (&aMem[pOp->p2]));
            (u.bd.pC->movetoTarget = sqlite3VdbeIntValue(pIn2));
            (u.bd.pC->rowidIsValid = 0);
            (u.bd.pC->deferredMoveto = 1);
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bd.pC->pCursor != 0)) {
            ((void ) 0);
            (u.bd.pC->nullRow = 0);
            (pIn2 = (&aMem[pOp->p2]));
            (u.bd.pC->movetoTarget = sqlite3VdbeIntValue(pIn2));
            (u.bd.pC->rowidIsValid = 0);
            (u.bd.pC->deferredMoveto = 1);
          }  
        }  
        break;
      }
      case 60:
      case 61:
      {
        (u.be.alreadyExists = 0);
        ((void ) 0);
        ((void ) 0);
        (u.be.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (pIn3 = (&aMem[pOp->p3]));
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            ((void ) 0);
            if ((pOp->p4.i > 0)) {
              (u.be.r.pKeyInfo = u.be.pC->pKeyInfo);
              (u.be.r.nField = ((u16 ) pOp->p4.i));
              (u.be.r.aMem = pIn3);
              (u.be.r.flags = 0x02);
              (u.be.pIdxKey = (&u.be.r));
            }  
            else {
              (u.be.pIdxKey = sqlite3VdbeAllocUnpackedRecord(u.be.pC->pKeyInfo, u.be.aTempRec, sizeof(u.be.aTempRec), (&u.be.pFree)));
              if ((u.be.pIdxKey == 0)) {
                goto _1269_no_mem;
              }  
              ((void ) 0);
              ((void ) 0);
              sqlite3VdbeRecordUnpack(u.be.pC->pKeyInfo, pIn3->n, pIn3->z, u.be.pIdxKey);
              (u.be.pIdxKey->flags |= 0x02);
            }
            (rc = sqlite3BtreeMovetoUnpacked(u.be.pC->pCursor, u.be.pIdxKey, 0, 0, (&u.be.res)));
            if ((pOp->p4.i == 0)) {
              sqlite3DbFree(db, u.be.pFree);
            }  
            if ((rc != 0)) {
              break;
            }  
            (u.be.alreadyExists = (u.be.res == 0));
            (u.be.pC->deferredMoveto = 0);
            (u.be.pC->cacheStatus = 0);
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.be.pC->pCursor != 0)) {
            ((void ) 0);
            if ((pOp->p4.i > 0)) {
              (u.be.r.pKeyInfo = u.be.pC->pKeyInfo);
              (u.be.r.nField = ((u16 ) pOp->p4.i));
              (u.be.r.aMem = pIn3);
              (u.be.r.flags = 0x02);
              (u.be.pIdxKey = (&u.be.r));
            }  
            else {
              (u.be.pIdxKey = sqlite3VdbeAllocUnpackedRecord(u.be.pC->pKeyInfo, u.be.aTempRec, sizeof(u.be.aTempRec), (&u.be.pFree)));
              if ((u.be.pIdxKey == 0)) {
                goto _1269_no_mem;
              }  
              ((void ) 0);
              ((void ) 0);
              sqlite3VdbeRecordUnpack(u.be.pC->pKeyInfo, pIn3->n, pIn3->z, u.be.pIdxKey);
              (u.be.pIdxKey->flags |= 0x02);
            }
            (rc = sqlite3BtreeMovetoUnpacked(u.be.pC->pCursor, u.be.pIdxKey, 0, 0, (&u.be.res)));
            if ((pOp->p4.i == 0)) {
              sqlite3DbFree(db, u.be.pFree);
            }  
            if ((rc != 0)) {
              break;
            }  
            (u.be.alreadyExists = (u.be.res == 0));
            (u.be.pC->deferredMoveto = 0);
            (u.be.pC->cacheStatus = 0);
          }  
        }  
        if ((pOp->opcode == 61)) {
          if (u.be.alreadyExists) {
            (pc = (pOp->p2 - 1));
          }  
        }  
        else {
          if ((! u.be.alreadyExists)) {
            (pc = (pOp->p2 - 1));
          }  
        }
        break;
      }
      case 62:
      {
        (pIn3 = (&aMem[pOp->p3]));
        (u.bf.aMx = (&aMem[pOp->p4.i]));
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.bf.pCx = p->apCsr[pOp->p1]);
        ((void ) 0);
        (u.bf.pCx->seekResult = 0);
        (u.bf.pCx->cacheStatus = 0);
        (u.bf.pCrsr = u.bf.pCx->pCursor);
        (u.bf.nField = u.bf.pCx->pKeyInfo->nField);
        for ((u.bf.ii = 0); (u.bf.ii < u.bf.nField); u.bf.ii++) {
          if ((u.bf.aMx[u.bf.ii].flags & 0x0001)) {
            (pc = (pOp->p2 - 1));
            (u.bf.pCrsr = 0);
            break;
          }  
        }
        ((void ) 0);
        if ((u.bf.pCrsr != 0)) {
          (u.bf.r.pKeyInfo = u.bf.pCx->pKeyInfo);
          (u.bf.r.nField = (u.bf.nField + 1));
          (u.bf.r.flags = 0x04);
          (u.bf.r.aMem = u.bf.aMx);
          sqlite3VdbeMemIntegerify(pIn3);
          (u.bf.R = pIn3->u.i);
          (rc = sqlite3BtreeMovetoUnpacked(u.bf.pCrsr, (&u.bf.r), 0, 0, (&u.bf.pCx->seekResult)));
          if (((u.bf.r.flags & 0x04) || (u.bf.r.rowid == u.bf.R))) {
            (pc = (pOp->p2 - 1));
          }  
          else {
            (pIn3->u.i = u.bf.r.rowid);
          }
        }  
        break;
      }
      case 63:
      {
        (pIn3 = (&aMem[pOp->p3]));
        ((void ) 0);
        ((void ) 0);
        (u.bg.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.bg.pCrsr = u.bg.pC->pCursor);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            (u.bg.res = 0);
            (u.bg.iKey = pIn3->u.i);
            (rc = sqlite3BtreeMovetoUnpacked(u.bg.pCrsr, 0, u.bg.iKey, 0, (&u.bg.res)));
            (u.bg.pC->lastRowid = pIn3->u.i);
            (u.bg.pC->rowidIsValid = ((u.bg.res == 0) ? 1 : 0));
            (u.bg.pC->nullRow = 0);
            (u.bg.pC->cacheStatus = 0);
            (u.bg.pC->deferredMoveto = 0);
            if ((u.bg.res != 0)) {
              (pc = (pOp->p2 - 1));
              ((void ) 0);
            }  
            (u.bg.pC->seekResult = u.bg.res);
          }  
          else {
            (pc = (pOp->p2 - 1));
            ((void ) 0);
            (u.bg.pC->seekResult = 0);
          }
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bg.pCrsr != 0)) {
            (u.bg.res = 0);
            (u.bg.iKey = pIn3->u.i);
            (rc = sqlite3BtreeMovetoUnpacked(u.bg.pCrsr, 0, u.bg.iKey, 0, (&u.bg.res)));
            (u.bg.pC->lastRowid = pIn3->u.i);
            (u.bg.pC->rowidIsValid = ((u.bg.res == 0) ? 1 : 0));
            (u.bg.pC->nullRow = 0);
            (u.bg.pC->cacheStatus = 0);
            (u.bg.pC->deferredMoveto = 0);
            if ((u.bg.res != 0)) {
              (pc = (pOp->p2 - 1));
              ((void ) 0);
            }  
            (u.bg.pC->seekResult = u.bg.res);
          }  
          else {
            (pc = (pOp->p2 - 1));
            ((void ) 0);
            (u.bg.pC->seekResult = 0);
          }
        }  
        break;
      }
      case 64:
      {
        ((void ) 0);
        ((void ) 0);
        (pOut->u.i = p->apCsr[pOp->p1]->seqCount++);
        break;
      }
      case 65:
      {
        (u.bh.v = 0);
        (u.bh.res = 0);
        ((void ) 0);
        (u.bh.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if (0) {
            
          }  
          else {
            ((void ) 0);
            if ((! u.bh.pC->useRandomRowid)) {
              (u.bh.v = sqlite3BtreeGetCachedRowid(u.bh.pC->pCursor));
              if ((u.bh.v == 0)) {
                (rc = sqlite3BtreeLast(u.bh.pC->pCursor, (&u.bh.res)));
                if ((rc != 0)) {
                  goto _1269_abort_due_to_error;
                }  
                if (u.bh.res) {
                  (u.bh.v = 1);
                }  
                else {
                  ((void ) 0);
                  (rc = sqlite3BtreeKeySize(u.bh.pC->pCursor, (&u.bh.v)));
                  ((void ) 0);
                  if ((u.bh.v >= ((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff))))) {
                    (u.bh.pC->useRandomRowid = 1);
                  }  
                  else {
                    u.bh.v++;
                  }
                }
              }  
              if (pOp->p3) {
                ((void ) 0);
                if (p->pFrame) {
                  for ((u.bh.pFrame = p->pFrame); u.bh.pFrame->pParent; (u.bh.pFrame = u.bh.pFrame->pParent)) {
                    
                  }
                  ((void ) 0);
                  (u.bh.pMem = (&u.bh.pFrame->aMem[pOp->p3]));
                }  
                else {
                  ((void ) 0);
                  (u.bh.pMem = (&aMem[pOp->p3]));
                }
                ((void ) 0);
                sqlite3VdbeMemIntegerify(u.bh.pMem);
                ((void ) 0);
                if (((u.bh.pMem->u.i == ((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff)))) || u.bh.pC->useRandomRowid)) {
                  (rc = 13);
                  goto _1269_abort_due_to_error;
                }  
                if ((u.bh.v < (u.bh.pMem->u.i + 1))) {
                  (u.bh.v = (u.bh.pMem->u.i + 1));
                }  
                (u.bh.pMem->u.i = u.bh.v);
              }  
              sqlite3BtreeSetCachedRowid(u.bh.pC->pCursor, ((u.bh.v < ((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff)))) ? (u.bh.v + 1) : 0));
            }  
            if (u.bh.pC->useRandomRowid) {
              ((void ) 0);
              (u.bh.v = lastRowid);
              (u.bh.v &= (((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff))) >> 1));
              u.bh.v++;
              (u.bh.cnt = 0);
              while ((((rc = sqlite3BtreeMovetoUnpacked(u.bh.pC->pCursor, 0, ((u64 ) u.bh.v), 0, (&u.bh.res))) == 0) && (u.bh.res == 0) && (++u.bh.cnt < 100))) {
                sqlite3_randomness(sizeof(u.bh.v), (&u.bh.v));
                if ((u.bh.cnt < 5)) {
                  (u.bh.v &= 0xffffff);
                }  
                else {
                  (u.bh.v &= (((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff))) >> 1));
                }
                u.bh.v++;
              }
              if (((rc == 0) && (u.bh.res == 0))) {
                (rc = 13);
                goto _1269_abort_due_to_error;
              }  
              ((void ) 0);
            }  
            (u.bh.pC->rowidIsValid = 0);
            (u.bh.pC->deferredMoveto = 0);
            (u.bh.pC->cacheStatus = 0);
          }
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bh.pC->pCursor == 0)) {
            
          }  
          else {
            ((void ) 0);
            if ((! u.bh.pC->useRandomRowid)) {
              (u.bh.v = sqlite3BtreeGetCachedRowid(u.bh.pC->pCursor));
              if ((u.bh.v == 0)) {
                (rc = sqlite3BtreeLast(u.bh.pC->pCursor, (&u.bh.res)));
                if ((rc != 0)) {
                  goto _1269_abort_due_to_error;
                }  
                if (u.bh.res) {
                  (u.bh.v = 1);
                }  
                else {
                  ((void ) 0);
                  (rc = sqlite3BtreeKeySize(u.bh.pC->pCursor, (&u.bh.v)));
                  ((void ) 0);
                  if ((u.bh.v >= ((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff))))) {
                    (u.bh.pC->useRandomRowid = 1);
                  }  
                  else {
                    u.bh.v++;
                  }
                }
              }  
              if (pOp->p3) {
                ((void ) 0);
                if (p->pFrame) {
                  for ((u.bh.pFrame = p->pFrame); u.bh.pFrame->pParent; (u.bh.pFrame = u.bh.pFrame->pParent)) {
                    
                  }
                  ((void ) 0);
                  (u.bh.pMem = (&u.bh.pFrame->aMem[pOp->p3]));
                }  
                else {
                  ((void ) 0);
                  (u.bh.pMem = (&aMem[pOp->p3]));
                }
                ((void ) 0);
                sqlite3VdbeMemIntegerify(u.bh.pMem);
                ((void ) 0);
                if (((u.bh.pMem->u.i == ((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff)))) || u.bh.pC->useRandomRowid)) {
                  (rc = 13);
                  goto _1269_abort_due_to_error;
                }  
                if ((u.bh.v < (u.bh.pMem->u.i + 1))) {
                  (u.bh.v = (u.bh.pMem->u.i + 1));
                }  
                (u.bh.pMem->u.i = u.bh.v);
              }  
              sqlite3BtreeSetCachedRowid(u.bh.pC->pCursor, ((u.bh.v < ((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff)))) ? (u.bh.v + 1) : 0));
            }  
            if (u.bh.pC->useRandomRowid) {
              ((void ) 0);
              (u.bh.v = lastRowid);
              (u.bh.v &= (((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff))) >> 1));
              u.bh.v++;
              (u.bh.cnt = 0);
              while ((((rc = sqlite3BtreeMovetoUnpacked(u.bh.pC->pCursor, 0, ((u64 ) u.bh.v), 0, (&u.bh.res))) == 0) && (u.bh.res == 0) && (++u.bh.cnt < 100))) {
                sqlite3_randomness(sizeof(u.bh.v), (&u.bh.v));
                if ((u.bh.cnt < 5)) {
                  (u.bh.v &= 0xffffff);
                }  
                else {
                  (u.bh.v &= (((i64 ) ((((u64 ) 0x7fffffff) << 32) | ((u64 ) 0xffffffff))) >> 1));
                }
                u.bh.v++;
              }
              if (((rc == 0) && (u.bh.res == 0))) {
                (rc = 13);
                goto _1269_abort_due_to_error;
              }  
              ((void ) 0);
            }  
            (u.bh.pC->rowidIsValid = 0);
            (u.bh.pC->deferredMoveto = 0);
            (u.bh.pC->cacheStatus = 0);
          }
        }  
        (pOut->u.i = u.bh.v);
        break;
      }
      case 66:
      case 67:
      {
        (u.bi.pData = (&aMem[pOp->p2]));
        ((void ) 0);
        ((void ) 0);
        (u.bi.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if ((pOp->opcode == 66)) {
          (u.bi.pKey = (&aMem[pOp->p3]));
          ((void ) 0);
          ((void ) 0);
          (u.bi.iKey = u.bi.pKey->u.i);
        }  
        else {
          ((void ) 0);
          (u.bi.iKey = pOp->p3);
        }
        if ((pOp->p5 & 0x01)) {
          p->nChange++;
        }  
        if ((pOp->p5 & 0x02)) {
          (db->lastRowid = (lastRowid = u.bi.iKey));
        }  
        if ((u.bi.pData->flags & 0x0001)) {
          (u.bi.pData->z = 0);
          (u.bi.pData->n = 0);
        }  
        else {
          ((void ) 0);
        }
        (u.bi.seekResult = ((pOp->p5 & 0x10) ? u.bi.pC->seekResult : 0));
        if ((u.bi.pData->flags & 0x4000)) {
          (u.bi.nZero = u.bi.pData->u.nZero);
        }  
        else {
          (u.bi.nZero = 0);
        }
        sqlite3BtreeSetCachedRowid(u.bi.pC->pCursor, 0);
        (rc = sqlite3BtreeInsert(u.bi.pC->pCursor, 0, u.bi.iKey, u.bi.pData->z, u.bi.pData->n, u.bi.nZero, (pOp->p5 & 0x08), u.bi.seekResult));
        (u.bi.pC->rowidIsValid = 0);
        (u.bi.pC->deferredMoveto = 0);
        (u.bi.pC->cacheStatus = 0);
        if (((rc == 0) && db->xUpdateCallback && pOp->p4.z)) {
          (u.bi.zDb = db->aDb[u.bi.pC->iDb].zName);
          (u.bi.zTbl = pOp->p4.z);
          (u.bi.op = ((pOp->p5 & 0x04) ? 23 : 18));
          ((void ) 0);
          db->xUpdateCallback(db->pUpdateArg, u.bi.op, u.bi.zDb, u.bi.zTbl, u.bi.iKey);
          ((void ) 0);
        }  
        break;
      }
      case 70:
      {
        (u.bj.iKey = 0);
        ((void ) 0);
        (u.bj.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        if ((db->xUpdateCallback && pOp->p4.z)) {
          ((void ) 0);
          ((void ) 0);
          (u.bj.iKey = u.bj.pC->lastRowid);
        }  
        ((void ) 0);
        (rc = sqlite3VdbeCursorMoveto(u.bj.pC));
        if (((id2i_sqlite_coverage_test ) )) {
          if (0) {
            goto _1269_abort_due_to_error;
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((rc != 0)) {
            goto _1269_abort_due_to_error;
          }  
        }  
        sqlite3BtreeSetCachedRowid(u.bj.pC->pCursor, 0);
        (rc = sqlite3BtreeDelete(u.bj.pC->pCursor));
        (u.bj.pC->cacheStatus = 0);
        if (((rc == 0) && db->xUpdateCallback && pOp->p4.z)) {
          const char *zDb =  db->aDb[u.bj.pC->iDb].zName;
          const char *zTbl =  pOp->p4.z;
          db->xUpdateCallback(db->pUpdateArg, 9, zDb, zTbl, u.bj.iKey);
          ((void ) 0);
        }  
        if ((pOp->p2 & 0x01)) {
          p->nChange++;
        }  
        break;
      }
      case 71:
      {
        sqlite3VdbeSetChanges(db, p->nChange);
        (p->nChange = 0);
        break;
      }
      case 72:
      {
        (u.bk.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (pIn3 = (&aMem[pOp->p3]));
        (rc = sqlite3VdbeSorterCompare(u.bk.pC, pIn3, (&u.bk.res)));
        if (u.bk.res) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 81:
      {
        (pOut = (&aMem[pOp->p2]));
        (u.bl.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (rc = sqlite3VdbeSorterRowkey(u.bl.pC, pOut));
        break;
      }
      case 92:
      case 95:
      {
        (pOut = (&aMem[pOp->p2]));
        ((void ) 0);
        (u.bm.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.bm.pCrsr = u.bm.pC->pCursor);
        ((void ) 0);
        ((void ) 0);
        (rc = sqlite3VdbeCursorMoveto(u.bm.pC));
        if (((id2i_sqlite_coverage_test ) )) {
          if (0) {
            goto _1269_abort_due_to_error;
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((rc != 0)) {
            goto _1269_abort_due_to_error;
          }  
        }  
        if (u.bm.pC->isIndex) {
          ((void ) 0);
          sqlite3BtreeKeySize(u.bm.pCrsr, (&u.bm.n64));
          ((void ) 0);
          if ((u.bm.n64 > db->aLimit[0])) {
            goto _1269_too_big;
          }  
          (u.bm.n = ((u32 ) u.bm.n64));
        }  
        else {
          sqlite3BtreeDataSize(u.bm.pCrsr, (&u.bm.n));
          ((void ) 0);
          if ((u.bm.n > ((u32 ) db->aLimit[0]))) {
            goto _1269_too_big;
          }  
        }
        if (sqlite3VdbeMemGrow(pOut, u.bm.n, 0)) {
          goto _1269_no_mem;
        }  
        (pOut->n = u.bm.n);
        (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0010));
        if (u.bm.pC->isIndex) {
          (rc = sqlite3BtreeKey(u.bm.pCrsr, 0, u.bm.n, pOut->z));
        }  
        else {
          (rc = sqlite3BtreeData(u.bm.pCrsr, 0, u.bm.n, pOut->z));
        }
        (pOut->enc = 1);
        break;
      }
      case 96:
      {
        ((void ) 0);
        (u.bn.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        if (u.bn.pC->nullRow) {
          (pOut->flags = 0x0001);
          break;
        } 
        else if (u.bn.pC->deferredMoveto) {
          (u.bn.v = u.bn.pC->movetoTarget);
        }
        
        else if (u.bn.pC->pVtabCursor) {
          (u.bn.pVtab = u.bn.pC->pVtabCursor->pVtab);
          (u.bn.pModule = u.bn.pVtab->pModule);
          ((void ) 0);
          (rc = u.bn.pModule->xRowid(u.bn.pC->pVtabCursor, (&u.bn.v)));
          sqlite3VtabImportErrmsg(p, u.bn.pVtab);
        } 
        else {
          ((void ) 0);
          (rc = sqlite3VdbeCursorMoveto(u.bn.pC));
          if (rc) {
            goto _1269_abort_due_to_error;
          }  
          if (u.bn.pC->rowidIsValid) {
            (u.bn.v = u.bn.pC->lastRowid);
          }  
          else {
            (rc = sqlite3BtreeKeySize(u.bn.pC->pCursor, (&u.bn.v)));
            ((void ) 0);
          }
        }
        (pOut->u.i = u.bn.v);
        break;
      }
      case 97:
      {
        ((void ) 0);
        (u.bo.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (u.bo.pC->nullRow = 1);
        (u.bo.pC->rowidIsValid = 0);
        ((void ) 0);
        if (u.bo.pC->pCursor) {
          sqlite3BtreeClearCursor(u.bo.pC->pCursor);
        }  
        break;
      }
      case 98:
      {
        ((void ) 0);
        (u.bp.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (u.bp.pCrsr = u.bp.pC->pCursor);
        (u.bp.res = 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            (rc = sqlite3BtreeLast(u.bp.pCrsr, (&u.bp.res)));
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bp.pCrsr != 0)) {
            (rc = sqlite3BtreeLast(u.bp.pCrsr, (&u.bp.res)));
          }  
        }  
        (u.bp.pC->nullRow = ((u8 ) u.bp.res));
        (u.bp.pC->deferredMoveto = 0);
        (u.bp.pC->rowidIsValid = 0);
        (u.bp.pC->cacheStatus = 0);
        if (((pOp->p2 > 0) && u.bp.res)) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 99:
      case 100:
      {
        p->aCounter[2]++;
      }
      case 101:
      {
        ((void ) 0);
        (u.bq.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        (u.bq.res = 1);
        if ((u.bq.pC->pSorter != 0)) {
          (rc = sqlite3VdbeSorterRewind(db, u.bq.pC, (&u.bq.res)));
        }  
        else {
          (u.bq.pCrsr = u.bq.pC->pCursor);
          ((void ) 0);
          (rc = sqlite3BtreeFirst(u.bq.pCrsr, (&u.bq.res)));
          (u.bq.pC->atFirst = ((u.bq.res == 0) ? 1 : 0));
          (u.bq.pC->deferredMoveto = 0);
          (u.bq.pC->cacheStatus = 0);
          (u.bq.pC->rowidIsValid = 0);
        }
        (u.bq.pC->nullRow = ((u8 ) u.bq.res));
        ((void ) 0);
        if (u.bq.res) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 5:
      case 6:
      case 7:
      {
        ((void ) 0);
        ((void ) 0);
        (u.br.pC = p->apCsr[pOp->p1]);
        if ((u.br.pC == 0)) {
          break;
        }  
        ((void ) 0);
        if ((u.br.pC->pSorter != 0)) {
          ((void ) 0);
          (rc = sqlite3VdbeSorterNext(db, u.br.pC, (&u.br.res)));
        }  
        else {
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (rc = pOp->p4.xAdvance(u.br.pC->pCursor, (&u.br.res)));
        }
        (u.br.pC->nullRow = ((u8 ) u.br.res));
        (u.br.pC->cacheStatus = 0);
        if ((u.br.res == 0)) {
          (pc = (pOp->p2 - 1));
          p->aCounter[pOp->p5]++;
        }  
        (u.br.pC->rowidIsValid = 0);
        goto _1269_check_for_interrupt;
      }
      case 102:
      case 103:
      {
        ((void ) 0);
        (u.bs.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        (pIn2 = (&aMem[pOp->p2]));
        ((void ) 0);
        (u.bs.pCrsr = u.bs.pC->pCursor);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            ((void ) 0);
            (rc = ((pIn2->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn2) : 0));
            if ((rc == 0)) {
              if ((u.bs.pC->pSorter != 0)) {
                (rc = sqlite3VdbeSorterWrite(db, u.bs.pC, pIn2));
              }  
              else {
                (u.bs.nKey = pIn2->n);
                (u.bs.zKey = pIn2->z);
                (rc = sqlite3BtreeInsert(u.bs.pCrsr, u.bs.zKey, u.bs.nKey, "", 0, 0, pOp->p3, ((pOp->p5 & 0x10) ? u.bs.pC->seekResult : 0)));
                ((void ) 0);
                (u.bs.pC->cacheStatus = 0);
              }
            }  
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bs.pCrsr != 0)) {
            ((void ) 0);
            (rc = ((pIn2->flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn2) : 0));
            if ((rc == 0)) {
              if ((u.bs.pC->pSorter != 0)) {
                (rc = sqlite3VdbeSorterWrite(db, u.bs.pC, pIn2));
              }  
              else {
                (u.bs.nKey = pIn2->n);
                (u.bs.zKey = pIn2->z);
                (rc = sqlite3BtreeInsert(u.bs.pCrsr, u.bs.zKey, u.bs.nKey, "", 0, 0, pOp->p3, ((pOp->p5 & 0x10) ? u.bs.pC->seekResult : 0)));
                ((void ) 0);
                (u.bs.pC->cacheStatus = 0);
              }
            }  
          }  
        }  
        break;
      }
      case 104:
      {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.bt.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (u.bt.pCrsr = u.bt.pC->pCursor);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            (u.bt.r.pKeyInfo = u.bt.pC->pKeyInfo);
            (u.bt.r.nField = ((u16 ) pOp->p3));
            (u.bt.r.flags = 0);
            (u.bt.r.aMem = (&aMem[pOp->p2]));
            (rc = sqlite3BtreeMovetoUnpacked(u.bt.pCrsr, (&u.bt.r), 0, 0, (&u.bt.res)));
            if (((rc == 0) && (u.bt.res == 0))) {
              (rc = sqlite3BtreeDelete(u.bt.pCrsr));
            }  
            ((void ) 0);
            (u.bt.pC->cacheStatus = 0);
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bt.pCrsr != 0)) {
            (u.bt.r.pKeyInfo = u.bt.pC->pKeyInfo);
            (u.bt.r.nField = ((u16 ) pOp->p3));
            (u.bt.r.flags = 0);
            (u.bt.r.aMem = (&aMem[pOp->p2]));
            (rc = sqlite3BtreeMovetoUnpacked(u.bt.pCrsr, (&u.bt.r), 0, 0, (&u.bt.res)));
            if (((rc == 0) && (u.bt.res == 0))) {
              (rc = sqlite3BtreeDelete(u.bt.pCrsr));
            }  
            ((void ) 0);
            (u.bt.pC->cacheStatus = 0);
          }  
        }  
        break;
      }
      case 105:
      {
        ((void ) 0);
        (u.bu.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        (u.bu.pCrsr = u.bu.pC->pCursor);
        (pOut->flags = 0x0001);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            (rc = sqlite3VdbeCursorMoveto(u.bu.pC));
            if (0) {
              goto _1269_abort_due_to_error;
            }  
            ((void ) 0);
            ((void ) 0);
            if ((! u.bu.pC->nullRow)) {
              (rc = sqlite3VdbeIdxRowid(db, u.bu.pCrsr, (&u.bu.rowid)));
              if ((rc != 0)) {
                goto _1269_abort_due_to_error;
              }  
              (pOut->u.i = u.bu.rowid);
              (pOut->flags = 0x0004);
            }  
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bu.pCrsr != 0)) {
            (rc = sqlite3VdbeCursorMoveto(u.bu.pC));
            if (rc) {
              goto _1269_abort_due_to_error;
            }  
            ((void ) 0);
            ((void ) 0);
            if ((! u.bu.pC->nullRow)) {
              (rc = sqlite3VdbeIdxRowid(db, u.bu.pCrsr, (&u.bu.rowid)));
              if ((rc != 0)) {
                goto _1269_abort_due_to_error;
              }  
              (pOut->u.i = u.bu.rowid);
              (pOut->flags = 0x0004);
            }  
          }  
        }  
        break;
      }
      case 106:
      case 107:
      {
        ((void ) 0);
        (u.bv.pC = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            ((void ) 0);
            ((void ) 0);
            ((void ) 0);
            (u.bv.r.pKeyInfo = u.bv.pC->pKeyInfo);
            (u.bv.r.nField = ((u16 ) pOp->p4.i));
            if (pOp->p5) {
              (u.bv.r.flags = (0x01 | 0x02));
            }  
            else {
              (u.bv.r.flags = 0x02);
            }
            (u.bv.r.aMem = (&aMem[pOp->p3]));
            (rc = sqlite3VdbeIdxKeyCompare(u.bv.pC, (&u.bv.r), (&u.bv.res)));
            if ((pOp->opcode == 106)) {
              (u.bv.res = (- u.bv.res));
            }  
            else {
              ((void ) 0);
              u.bv.res++;
            }
            if ((u.bv.res > 0)) {
              (pc = (pOp->p2 - 1));
            }  
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if ((u.bv.pC->pCursor != 0)) {
            ((void ) 0);
            ((void ) 0);
            ((void ) 0);
            (u.bv.r.pKeyInfo = u.bv.pC->pKeyInfo);
            (u.bv.r.nField = ((u16 ) pOp->p4.i));
            if (pOp->p5) {
              (u.bv.r.flags = (0x01 | 0x02));
            }  
            else {
              (u.bv.r.flags = 0x02);
            }
            (u.bv.r.aMem = (&aMem[pOp->p3]));
            (rc = sqlite3VdbeIdxKeyCompare(u.bv.pC, (&u.bv.r), (&u.bv.res)));
            if ((pOp->opcode == 106)) {
              (u.bv.res = (- u.bv.res));
            }  
            else {
              ((void ) 0);
              u.bv.res++;
            }
            if ((u.bv.res > 0)) {
              (pc = (pOp->p2 - 1));
            }  
          }  
        }  
        break;
      }
      case 108:
      {
        ((void ) 0);
        (u.bw.iCnt = 0);
        for ((u.bw.pVdbe = db->pVdbe); u.bw.pVdbe; (u.bw.pVdbe = u.bw.pVdbe->pNext)) {
          if (((u.bw.pVdbe->magic == 0xbdf20da3) && u.bw.pVdbe->bIsReader && (u.bw.pVdbe->inVtabMethod < 2) && (u.bw.pVdbe->pc >= 0))) {
            u.bw.iCnt++;
          }  
        }
        (pOut->flags = 0x0001);
        if ((u.bw.iCnt > 1)) {
          (rc = 6);
          (p->errorAction = 2);
        }  
        else {
          (u.bw.iDb = pOp->p3);
          ((void ) 0);
          ((void ) 0);
          (rc = sqlite3BtreeDropTable(db->aDb[u.bw.iDb].pBt, pOp->p1, (&u.bw.iMoved)));
          (pOut->flags = 0x0004);
          (pOut->u.i = u.bw.iMoved);
          if ((((! id2i_sqlite_omit_autovacuum) ) )) {
            if (((rc == 0) && (u.bw.iMoved != 0))) {
              sqlite3RootPageMoved(db, u.bw.iDb, u.bw.iMoved, pOp->p1);
              ((void ) 0);
              (resetSchemaOnFault = (u.bw.iDb + 1));
            }  
          }  
        }
        break;
      }
      case 109:
      {
        (u.bx.nChange = 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (rc = sqlite3BtreeClearTable(db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? (&u.bx.nChange) : 0)));
        if (pOp->p3) {
          (p->nChange += u.bx.nChange);
          if ((pOp->p3 > 0)) {
            ((void ) 0);
            (aMem[pOp->p3].u.i += u.bx.nChange);
          }  
        }  
        break;
      }
      case 110:
      case 111:
      {
        (u.by.pgno = 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.by.pDb = (&db->aDb[pOp->p1]));
        ((void ) 0);
        if ((pOp->opcode == 111)) {
          (u.by.flags = 1);
        }  
        else {
          (u.by.flags = 2);
        }
        (rc = sqlite3BtreeCreateTable(u.by.pDb->pBt, (&u.by.pgno), u.by.flags));
        (pOut->u.i = u.by.pgno);
        break;
      }
      case 112:
      {
        (u.bz.iDb = pOp->p1);
        ((void ) 0);
        ((void ) 0);
        {
          (u.bz.zMaster = (((! 0) && (u.bz.iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"));
          (u.bz.initData.db = db);
          (u.bz.initData.iDb = pOp->p1);
          (u.bz.initData.pzErrMsg = (&p->zErrMsg));
          (u.bz.zSql = sqlite3MPrintf(db, "SELECT name, rootpage, sql FROM '%q'.%s WHERE %s ORDER BY rowid", db->aDb[u.bz.iDb].zName, u.bz.zMaster, pOp->p4.z));
          if ((u.bz.zSql == 0)) {
            (rc = 7);
          }  
          else {
            ((void ) 0);
            (db->init.busy = 1);
            (u.bz.initData.rc = 0);
            ((void ) 0);
            (rc = sqlite3_exec(db, u.bz.zSql, sqlite3InitCallback, (&u.bz.initData), 0));
            if ((rc == 0)) {
              (rc = u.bz.initData.rc);
            }  
            sqlite3DbFree(db, u.bz.zSql);
            (db->init.busy = 0);
          }
        }
        if (rc) {
          sqlite3ResetAllSchemasOfConnection(db);
        }  
        if ((rc == 7)) {
          goto _1269_no_mem;
        }  
        break;
      }
      case 113:
      if ((((! id2i_sqlite_omit_analyze) ) )) {
        ((void ) 0);
        (rc = sqlite3AnalysisLoad(db, pOp->p1));
        break;
      }  
      if (((id2i_sqlite_omit_analyze ) )) {
        if ((pOp->opcode == 113)) {
          goto id2i_label_1;
        }  
      }  
      case 114:
      {
        sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z);
        break;
      }
      case 115:
      {
        sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z);
        break;
      }
      case 116:
      {
        sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z);
        break;
      }
      case 117:
      {
        ((void ) 0);
        (u.ca.nRoot = pOp->p2);
        ((void ) 0);
        (u.ca.aRoot = sqlite3DbMallocRaw(db, (sizeof(int ) * (u.ca.nRoot + 1))));
        if ((u.ca.aRoot == 0)) {
          goto _1269_no_mem;
        }  
        ((void ) 0);
        (u.ca.pnErr = (&aMem[pOp->p3]));
        ((void ) 0);
        ((void ) 0);
        (pIn1 = (&aMem[pOp->p1]));
        for ((u.ca.j = 0); (u.ca.j < u.ca.nRoot); u.ca.j++) {
          (u.ca.aRoot[u.ca.j] = ((int ) sqlite3VdbeIntValue((&pIn1[u.ca.j]))));
        }
        (u.ca.aRoot[u.ca.j] = 0);
        ((void ) 0);
        ((void ) 0);
        (u.ca.z = sqlite3BtreeIntegrityCheck(db->aDb[pOp->p5].pBt, u.ca.aRoot, u.ca.nRoot, ((int ) u.ca.pnErr->u.i), (&u.ca.nErr)));
        sqlite3DbFree(db, u.ca.aRoot);
        (u.ca.pnErr->u.i -= u.ca.nErr);
        sqlite3VdbeMemSetNull(pIn1);
        if ((u.ca.nErr == 0)) {
          ((void ) 0);
        } 
        else if ((u.ca.z == 0)) {
          goto _1269_no_mem;
        } 
        else {
          sqlite3VdbeMemSetStr(pIn1, u.ca.z, (- 1), 1, sqlite3_free);
        }
        sqlite3VdbeChangeEncoding(pIn1, encoding);
        break;
      }
      case 118:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pIn2 = (&aMem[pOp->p2]));
        ((void ) 0);
        if (((pIn1->flags & 0x0020) == 0)) {
          sqlite3VdbeMemSetRowSet(pIn1);
          if (((pIn1->flags & 0x0020) == 0)) {
            goto _1269_no_mem;
          }  
        }  
        sqlite3RowSetInsert(pIn1->u.pRowSet, pIn2->u.i);
        break;
      }
      case 119:
      {
        (pIn1 = (&aMem[pOp->p1]));
        if ((((pIn1->flags & 0x0020) == 0) || (sqlite3RowSetNext(pIn1->u.pRowSet, (&u.cb.val)) == 0))) {
          sqlite3VdbeMemSetNull(pIn1);
          (pc = (pOp->p2 - 1));
        }  
        else {
          sqlite3VdbeMemSetInt64((&aMem[pOp->p3]), u.cb.val);
        }
        goto _1269_check_for_interrupt;
      }
      case 120:
      {
        (pIn1 = (&aMem[pOp->p1]));
        (pIn3 = (&aMem[pOp->p3]));
        (u.cc.iSet = pOp->p4.i);
        ((void ) 0);
        if (((pIn1->flags & 0x0020) == 0)) {
          sqlite3VdbeMemSetRowSet(pIn1);
          if (((pIn1->flags & 0x0020) == 0)) {
            goto _1269_no_mem;
          }  
        }  
        ((void ) 0);
        ((void ) 0);
        if (u.cc.iSet) {
          (u.cc.exists = sqlite3RowSetTest(pIn1->u.pRowSet, ((u8 ) ((u.cc.iSet >= 0) ? (u.cc.iSet & 0xf) : 0xff)), pIn3->u.i));
          if (u.cc.exists) {
            (pc = (pOp->p2 - 1));
            break;
          }  
        }  
        if ((u.cc.iSet >= 0)) {
          sqlite3RowSetInsert(pIn1->u.pRowSet, pIn3->u.i);
        }  
        break;
      }
      case 121:
      {
        (u.cd.pProgram = pOp->p4.pProgram);
        (u.cd.pRt = (&aMem[pOp->p3]));
        ((void ) 0);
        if (pOp->p5) {
          (u.cd.t = u.cd.pProgram->token);
          for ((u.cd.pFrame = p->pFrame); (u.cd.pFrame && (u.cd.pFrame->token != u.cd.t)); (u.cd.pFrame = u.cd.pFrame->pParent)) {
            
          }
          if (u.cd.pFrame) {
            break;
          }  
        }  
        if ((p->nFrame >= db->aLimit[10])) {
          (rc = 1);
          sqlite3SetString((&p->zErrMsg), db, "too many levels of trigger recursion");
          break;
        }  
        if (((u.cd.pRt->flags & 0x0040) == 0)) {
          (u.cd.nMem = (u.cd.pProgram->nMem + u.cd.pProgram->nCsr));
          (u.cd.nByte = (((sizeof(VdbeFrame ) + 7) & (~ 7)) + (u.cd.nMem * sizeof(Mem )) + (u.cd.pProgram->nCsr * sizeof(VdbeCursor *)) + (u.cd.pProgram->nOnce * sizeof(u8 ))));
          (u.cd.pFrame = sqlite3DbMallocZero(db, u.cd.nByte));
          if ((! u.cd.pFrame)) {
            goto _1269_no_mem;
          }  
          sqlite3VdbeMemRelease(u.cd.pRt);
          (u.cd.pRt->flags = 0x0040);
          (u.cd.pRt->u.pFrame = u.cd.pFrame);
          (u.cd.pFrame->v = p);
          (u.cd.pFrame->nChildMem = u.cd.nMem);
          (u.cd.pFrame->nChildCsr = u.cd.pProgram->nCsr);
          (u.cd.pFrame->pc = pc);
          (u.cd.pFrame->aMem = p->aMem);
          (u.cd.pFrame->nMem = p->nMem);
          (u.cd.pFrame->apCsr = p->apCsr);
          (u.cd.pFrame->nCursor = p->nCursor);
          (u.cd.pFrame->aOp = p->aOp);
          (u.cd.pFrame->nOp = p->nOp);
          (u.cd.pFrame->token = u.cd.pProgram->token);
          (u.cd.pFrame->aOnceFlag = p->aOnceFlag);
          (u.cd.pFrame->nOnceFlag = p->nOnceFlag);
          (u.cd.pEnd = (&((Mem *) (&((u8 *) u.cd.pFrame)[((sizeof(VdbeFrame ) + 7) & (~ 7))]))[u.cd.pFrame->nChildMem]));
          for ((u.cd.pMem = ((Mem *) (&((u8 *) u.cd.pFrame)[((sizeof(VdbeFrame ) + 7) & (~ 7))]))); (u.cd.pMem != u.cd.pEnd); u.cd.pMem++) {
            (u.cd.pMem->flags = 0x0080);
            (u.cd.pMem->db = db);
          }
        }  
        else {
          (u.cd.pFrame = u.cd.pRt->u.pFrame);
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
        }
        p->nFrame++;
        (u.cd.pFrame->pParent = p->pFrame);
        (u.cd.pFrame->lastRowid = lastRowid);
        (u.cd.pFrame->nChange = p->nChange);
        (p->nChange = 0);
        (p->pFrame = u.cd.pFrame);
        (p->aMem = (aMem = (&((Mem *) (&((u8 *) u.cd.pFrame)[((sizeof(VdbeFrame ) + 7) & (~ 7))]))[(- 1)])));
        (p->nMem = u.cd.pFrame->nChildMem);
        (p->nCursor = ((u16 ) u.cd.pFrame->nChildCsr));
        (p->apCsr = ((VdbeCursor **) (&aMem[(p->nMem + 1)])));
        (p->aOp = (aOp = u.cd.pProgram->aOp));
        (p->nOp = u.cd.pProgram->nOp);
        (p->aOnceFlag = ((u8 *) (&p->apCsr[p->nCursor])));
        (p->nOnceFlag = u.cd.pProgram->nOnce);
        (pc = (- 1));
        memset(p->aOnceFlag, 0, p->nOnceFlag);
        break;
      }
      case 122:
      {
        (u.ce.pFrame = p->pFrame);
        (u.ce.pIn = (&u.ce.pFrame->aMem[(pOp->p1 + u.ce.pFrame->aOp[u.ce.pFrame->pc].p1)]));
        sqlite3VdbeMemShallowCopy(pOut, u.ce.pIn, 0x1000);
        break;
      }
      case 123:
      if ((((! id2i_sqlite_omit_foreign_key) ) )) {
        if ((db->flags & 0x01000000)) {
          (db->nDeferredImmCons += pOp->p2);
        } 
        else if (pOp->p1) {
          (db->nDeferredCons += pOp->p2);
        } 
        else {
          (p->nFkConstraint += pOp->p2);
        }
        break;
      }  
      if (((id2i_sqlite_omit_foreign_key ) )) {
        if ((pOp->opcode == 123)) {
          goto id2i_label_1;
        }  
      }  
      case 124:
      if ((((! id2i_sqlite_omit_foreign_key) ) )) {
        if (pOp->p1) {
          if (((db->nDeferredCons == 0) && (db->nDeferredImmCons == 0))) {
            (pc = (pOp->p2 - 1));
          }  
        }  
        else {
          if (((p->nFkConstraint == 0) && (db->nDeferredImmCons == 0))) {
            (pc = (pOp->p2 - 1));
          }  
        }
        break;
      }  
      if (((id2i_sqlite_omit_foreign_key ) )) {
        if ((pOp->opcode == 124)) {
          goto id2i_label_1;
        }  
      }  
      case 125:
      {
        if (p->pFrame) {
          for ((u.cf.pFrame = p->pFrame); u.cf.pFrame->pParent; (u.cf.pFrame = u.cf.pFrame->pParent)) {
            
          }
          (u.cf.pIn1 = (&u.cf.pFrame->aMem[pOp->p1]));
        }  
        else {
          (u.cf.pIn1 = (&aMem[pOp->p1]));
        }
        ((void ) 0);
        sqlite3VdbeMemIntegerify(u.cf.pIn1);
        (pIn2 = (&aMem[pOp->p2]));
        sqlite3VdbeMemIntegerify(pIn2);
        if ((u.cf.pIn1->u.i < pIn2->u.i)) {
          (u.cf.pIn1->u.i = pIn2->u.i);
        }  
        break;
      }
      case 126:
      {
        (pIn1 = (&aMem[pOp->p1]));
        ((void ) 0);
        if ((pIn1->u.i > 0)) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 127:
      {
        (pIn1 = (&aMem[pOp->p1]));
        ((void ) 0);
        if ((pIn1->u.i < 0)) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 128:
      {
        (pIn1 = (&aMem[pOp->p1]));
        ((void ) 0);
        (pIn1->u.i += pOp->p3);
        if ((pIn1->u.i == 0)) {
          (pc = (pOp->p2 - 1));
        }  
        break;
      }
      case 8:
      {
        (u.cg.n = pOp->p5);
        ((void ) 0);
        (u.cg.pRec = (&aMem[pOp->p2]));
        (u.cg.apVal = p->apArg);
        ((void ) 0);
        for ((u.cg.i = 0); (u.cg.i < u.cg.n); u.cg.i++, u.cg.pRec++) {
          ((void ) 0);
          (u.cg.apVal[u.cg.i] = u.cg.pRec);
          sqlite3VdbeMemStoreType(u.cg.pRec);
        }
        (u.cg.ctx.pFunc = pOp->p4.pFunc);
        ((void ) 0);
        (u.cg.ctx.pMem = (u.cg.pMem = (&aMem[pOp->p3])));
        u.cg.pMem->n++;
        (u.cg.ctx.s.flags = 0x0001);
        (u.cg.ctx.s.z = 0);
        (u.cg.ctx.s.zMalloc = 0);
        (u.cg.ctx.s.xDel = 0);
        (u.cg.ctx.s.db = db);
        (u.cg.ctx.isError = 0);
        (u.cg.ctx.pColl = 0);
        (u.cg.ctx.skipFlag = 0);
        if ((u.cg.ctx.pFunc->funcFlags & 0x020)) {
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (u.cg.ctx.pColl = pOp[(- 1)].p4.pColl);
        }  
        u.cg.ctx.pFunc->xStep((&u.cg.ctx), u.cg.n, u.cg.apVal);
        if (u.cg.ctx.isError) {
          sqlite3SetString((&p->zErrMsg), db, "%s", sqlite3_value_text((&u.cg.ctx.s)));
          (rc = u.cg.ctx.isError);
        }  
        if (u.cg.ctx.skipFlag) {
          ((void ) 0);
          (u.cg.i = pOp[(- 1)].p1);
          if (u.cg.i) {
            sqlite3VdbeMemSetInt64((&aMem[u.cg.i]), 1);
          }  
        }  
        sqlite3VdbeMemRelease((&u.cg.ctx.s));
        break;
      }
      case 129:
      {
        ((void ) 0);
        (u.ch.pMem = (&aMem[pOp->p1]));
        ((void ) 0);
        (rc = sqlite3VdbeMemFinalize(u.ch.pMem, pOp->p4.pFunc));
        if (rc) {
          sqlite3SetString((&p->zErrMsg), db, "%s", sqlite3_value_text(u.ch.pMem));
        }  
        sqlite3VdbeChangeEncoding(u.ch.pMem, encoding);
        if (sqlite3VdbeMemTooBig(u.ch.pMem)) {
          goto _1269_too_big;
        }  
        break;
      }
      case 9:
      {
        ((void ) 0);
        (u.ci.aRes[0] = 0);
        (u.ci.aRes[1] = (u.ci.aRes[2] = (- 1)));
        ((void ) 0);
        (rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, (&u.ci.aRes[1]), (&u.ci.aRes[2])));
        if ((rc == 5)) {
          (rc = 0);
          (u.ci.aRes[0] = 1);
        }  
        for ((u.ci.i = 0), (u.ci.pMem = (&aMem[pOp->p3])); (u.ci.i < 3); u.ci.i++, u.ci.pMem++) {
          sqlite3VdbeMemSetInt64(u.ci.pMem, ((i64 ) u.ci.aRes[u.ci.i]));
        }
        break;
      }
      case 10:
      {
        (u.cj.eNew = pOp->p3);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.cj.pBt = db->aDb[pOp->p1].pBt);
        (u.cj.pPager = sqlite3BtreePager(u.cj.pBt));
        (u.cj.eOld = sqlite3PagerGetJournalMode(u.cj.pPager));
        if ((u.cj.eNew == (- 1))) {
          (u.cj.eNew = u.cj.eOld);
        }  
        if ((! sqlite3PagerOkToChangeJournalMode(u.cj.pPager))) {
          (u.cj.eNew = u.cj.eOld);
        }  
        (u.cj.zFilename = sqlite3PagerFilename(u.cj.pPager, 1));
        if (((u.cj.eNew == 5) && ((sqlite3Strlen30(u.cj.zFilename) == 0) || (! sqlite3PagerWalSupported(u.cj.pPager))))) {
          (u.cj.eNew = u.cj.eOld);
        }  
        if (((u.cj.eNew != u.cj.eOld) && ((u.cj.eOld == 5) || (u.cj.eNew == 5)))) {
          if (((! db->autoCommit) || (db->nVdbeRead > 1))) {
            (rc = 1);
            sqlite3SetString((&p->zErrMsg), db, "cannot change %s wal mode from within a transaction", ((u.cj.eNew == 5) ? "into" : "out of"));
            break;
          }  
          else {
            if ((u.cj.eOld == 5)) {
              (rc = sqlite3PagerCloseWal(u.cj.pPager));
              if ((rc == 0)) {
                sqlite3PagerSetJournalMode(u.cj.pPager, u.cj.eNew);
              }  
            } 
            else if ((u.cj.eOld == 4)) {
              sqlite3PagerSetJournalMode(u.cj.pPager, 2);
            } 
            ((void ) 0);
            if ((rc == 0)) {
              (rc = sqlite3BtreeSetVersion(u.cj.pBt, ((u.cj.eNew == 5) ? 2 : 1)));
            }  
          }
        }  
        if (rc) {
          (u.cj.eNew = u.cj.eOld);
        }  
        (u.cj.eNew = sqlite3PagerSetJournalMode(u.cj.pPager, u.cj.eNew));
        (pOut = (&aMem[pOp->p2]));
        (pOut->flags = (0x0002 | 0x0800 | 0x0200));
        (pOut->z = ((char *) sqlite3JournalModename(u.cj.eNew)));
        (pOut->n = sqlite3Strlen30(pOut->z));
        (pOut->enc = 1);
        sqlite3VdbeChangeEncoding(pOut, encoding);
        break;
      }
      case 11:
      {
        ((void ) 0);
        (rc = sqlite3RunVacuum((&p->zErrMsg), db));
        break;
      }
      case 131:
      if ((((! id2i_sqlite_omit_autovacuum) ) )) {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (u.ck.pBt = db->aDb[pOp->p1].pBt);
        (rc = sqlite3BtreeIncrVacuum(u.ck.pBt));
        if ((rc == 101)) {
          (pc = (pOp->p2 - 1));
          (rc = 0);
        }  
        break;
      }  
      if (((id2i_sqlite_omit_autovacuum ) )) {
        if ((pOp->opcode == 131)) {
          goto id2i_label_1;
        }  
      }  
      case 132:
      {
        if ((! pOp->p1)) {
          sqlite3ExpirePreparedStatements(db);
        }  
        else {
          (p->expired = 1);
        }
        break;
      }
      case 133:
      {
        u8 isWriteLock =  ((u8 ) pOp->p3);
        if ((isWriteLock || (0 == (db->flags & 0x0004000)))) {
          int p1 =  pOp->p1;
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock));
          if (((rc & 0xFF) == 6)) {
            const char *z =  pOp->p4.z;
            sqlite3SetString((&p->zErrMsg), db, "database table is locked: %s", z);
          }  
        }  
        break;
      }
      case 134:
      {
        (u.cl.pVTab = pOp->p4.pVtab);
        (rc = sqlite3VtabBegin(db, u.cl.pVTab));
        if (u.cl.pVTab) {
          sqlite3VtabImportErrmsg(p, u.cl.pVTab->pVtab);
        }  
        break;
      }
      case 135:
      {
        (rc = sqlite3VtabCallCreate(db, pOp->p1, pOp->p4.z, (&p->zErrMsg)));
        break;
      }
      case 136:
      {
        (p->inVtabMethod = 2);
        (rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z));
        (p->inVtabMethod = 0);
        break;
      }
      case 137:
      {
        ((void ) 0);
        (u.cm.pCur = 0);
        (u.cm.pVtabCursor = 0);
        (u.cm.pVtab = pOp->p4.pVtab->pVtab);
        (u.cm.pModule = ((sqlite3_module *) u.cm.pVtab->pModule));
        ((void ) 0);
        (rc = u.cm.pModule->xOpen(u.cm.pVtab, (&u.cm.pVtabCursor)));
        sqlite3VtabImportErrmsg(p, u.cm.pVtab);
        if ((0 == rc)) {
          (u.cm.pVtabCursor->pVtab = u.cm.pVtab);
          (u.cm.pCur = allocateCursor(p, pOp->p1, 0, (- 1), 0));
          if (u.cm.pCur) {
            (u.cm.pCur->pVtabCursor = u.cm.pVtabCursor);
            (u.cm.pCur->pModule = u.cm.pVtabCursor->pVtab->pModule);
          }  
          else {
            (db->mallocFailed = 1);
            u.cm.pModule->xClose(u.cm.pVtabCursor);
          }
        }  
        break;
      }
      case 12:
      {
        (u.cn.pQuery = (&aMem[pOp->p3]));
        (u.cn.pArgc = (&u.cn.pQuery[1]));
        (u.cn.pCur = p->apCsr[pOp->p1]);
        ((void ) 0);
        ((void ) 0);
        (u.cn.pVtabCursor = u.cn.pCur->pVtabCursor);
        (u.cn.pVtab = u.cn.pVtabCursor->pVtab);
        (u.cn.pModule = u.cn.pVtab->pModule);
        ((void ) 0);
        (u.cn.nArg = ((int ) u.cn.pArgc->u.i));
        (u.cn.iQuery = ((int ) u.cn.pQuery->u.i));
        {
          (u.cn.res = 0);
          (u.cn.apArg = p->apArg);
          for ((u.cn.i = 0); (u.cn.i < u.cn.nArg); u.cn.i++) {
            (u.cn.apArg[u.cn.i] = (&u.cn.pArgc[(u.cn.i + 1)]));
            sqlite3VdbeMemStoreType(u.cn.apArg[u.cn.i]);
          }
          (p->inVtabMethod = 1);
          (rc = u.cn.pModule->xFilter(u.cn.pVtabCursor, u.cn.iQuery, pOp->p4.z, u.cn.nArg, u.cn.apArg));
          (p->inVtabMethod = 0);
          sqlite3VtabImportErrmsg(p, u.cn.pVtab);
          if ((rc == 0)) {
            (u.cn.res = u.cn.pModule->xEof(u.cn.pVtabCursor));
          }  
          if (u.cn.res) {
            (pc = (pOp->p2 - 1));
          }  
        }
        (u.cn.pCur->nullRow = 0);
        break;
      }
      case 138:
      {
        VdbeCursor *pCur =  p->apCsr[pOp->p1];
        ((void ) 0);
        ((void ) 0);
        (u.co.pDest = (&aMem[pOp->p3]));
        if (pCur->nullRow) {
          sqlite3VdbeMemSetNull(u.co.pDest);
          break;
        }  
        (u.co.pVtab = pCur->pVtabCursor->pVtab);
        (u.co.pModule = u.co.pVtab->pModule);
        ((void ) 0);
        memset((&u.co.sContext), 0, sizeof(u.co.sContext));
        sqlite3VdbeMemMove((&u.co.sContext.s), u.co.pDest);
        ((&u.co.sContext.s)->flags = (((&u.co.sContext.s)->flags & (~ (0x01ff | 0x4000))) | 0x0001));
        (rc = u.co.pModule->xColumn(pCur->pVtabCursor, (&u.co.sContext), pOp->p2));
        sqlite3VtabImportErrmsg(p, u.co.pVtab);
        if (u.co.sContext.isError) {
          (rc = u.co.sContext.isError);
        }  
        sqlite3VdbeChangeEncoding((&u.co.sContext.s), encoding);
        sqlite3VdbeMemMove(u.co.pDest, (&u.co.sContext.s));
        if (sqlite3VdbeMemTooBig(u.co.pDest)) {
          goto _1269_too_big;
        }  
        break;
      }
      case 139:
      {
        (u.cp.res = 0);
        (u.cp.pCur = p->apCsr[pOp->p1]);
        ((void ) 0);
        if (u.cp.pCur->nullRow) {
          break;
        }  
        (u.cp.pVtab = u.cp.pCur->pVtabCursor->pVtab);
        (u.cp.pModule = u.cp.pVtab->pModule);
        ((void ) 0);
        (p->inVtabMethod = 1);
        (rc = u.cp.pModule->xNext(u.cp.pCur->pVtabCursor));
        (p->inVtabMethod = 0);
        sqlite3VtabImportErrmsg(p, u.cp.pVtab);
        if ((rc == 0)) {
          (u.cp.res = u.cp.pModule->xEof(u.cp.pCur->pVtabCursor));
        }  
        if ((! u.cp.res)) {
          (pc = (pOp->p2 - 1));
        }  
        goto _1269_check_for_interrupt;
      }
      case 140:
      {
        (u.cq.pVtab = pOp->p4.pVtab->pVtab);
        (u.cq.pName = (&aMem[pOp->p1]));
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((u.cq.pName->enc == 1)) {
            sqlite3Coverage(72107);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((u.cq.pName->enc == 3)) {
            sqlite3Coverage(72108);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((u.cq.pName->enc == 2)) {
            sqlite3Coverage(72109);
          }  
        }  
        (rc = sqlite3VdbeChangeEncoding(u.cq.pName, 1));
        if ((rc == 0)) {
          (rc = u.cq.pVtab->pModule->xRename(u.cq.pVtab, u.cq.pName->z));
          sqlite3VtabImportErrmsg(p, u.cq.pVtab);
          (p->expired = 0);
        }  
        break;
      }
      case 13:
      {
        ((void ) 0);
        ((void ) 0);
        (u.cr.pVtab = pOp->p4.pVtab->pVtab);
        (u.cr.pModule = ((sqlite3_module *) u.cr.pVtab->pModule));
        (u.cr.nArg = pOp->p2);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if (1) {
            u8 vtabOnConflict =  db->vtabOnConflict;
            (u.cr.apArg = p->apArg);
            (u.cr.pX = (&aMem[pOp->p3]));
            for ((u.cr.i = 0); (u.cr.i < u.cr.nArg); u.cr.i++) {
              ((void ) 0);
              sqlite3VdbeMemStoreType(u.cr.pX);
              (u.cr.apArg[u.cr.i] = u.cr.pX);
              u.cr.pX++;
            }
            (db->vtabOnConflict = pOp->p5);
            (rc = u.cr.pModule->xUpdate(u.cr.pVtab, u.cr.nArg, u.cr.apArg, (&u.cr.rowid)));
            (db->vtabOnConflict = vtabOnConflict);
            sqlite3VtabImportErrmsg(p, u.cr.pVtab);
            if (((rc == 0) && pOp->p1)) {
              ((void ) 0);
              (db->lastRowid = (lastRowid = u.cr.rowid));
            }  
            if ((((rc & 0xff) == 19) && pOp->p4.pVtab->bConstraint)) {
              if ((pOp->p5 == 4)) {
                (rc = 0);
              }  
              else {
                (p->errorAction = ((pOp->p5 == 5) ? 2 : pOp->p5));
              }
            }  
            else {
              p->nChange++;
            }
          }  
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if (u.cr.pModule->xUpdate) {
            u8 vtabOnConflict =  db->vtabOnConflict;
            (u.cr.apArg = p->apArg);
            (u.cr.pX = (&aMem[pOp->p3]));
            for ((u.cr.i = 0); (u.cr.i < u.cr.nArg); u.cr.i++) {
              ((void ) 0);
              sqlite3VdbeMemStoreType(u.cr.pX);
              (u.cr.apArg[u.cr.i] = u.cr.pX);
              u.cr.pX++;
            }
            (db->vtabOnConflict = pOp->p5);
            (rc = u.cr.pModule->xUpdate(u.cr.pVtab, u.cr.nArg, u.cr.apArg, (&u.cr.rowid)));
            (db->vtabOnConflict = vtabOnConflict);
            sqlite3VtabImportErrmsg(p, u.cr.pVtab);
            if (((rc == 0) && pOp->p1)) {
              ((void ) 0);
              (db->lastRowid = (lastRowid = u.cr.rowid));
            }  
            if ((((rc & 0xff) == 19) && pOp->p4.pVtab->bConstraint)) {
              if ((pOp->p5 == 4)) {
                (rc = 0);
              }  
              else {
                (p->errorAction = ((pOp->p5 == 5) ? 2 : pOp->p5));
              }
            }  
            else {
              p->nChange++;
            }
          }  
        }  
        break;
      }
      case 146:
      if ((((! id2i_sqlite_omit_pager_pragmas) ) )) {
        (pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt));
        break;
      }  
      if (((id2i_sqlite_omit_pager_pragmas ) )) {
        if ((pOp->opcode == 146)) {
          goto id2i_label_1;
        }  
      }  
      case 147:
      if ((((! id2i_sqlite_omit_pager_pragmas) ) )) {
        unsigned int newMax;
        Btree *pBt;
        (pBt = db->aDb[pOp->p1].pBt);
        (newMax = 0);
        if (pOp->p3) {
          (newMax = sqlite3BtreeLastPage(pBt));
          if ((newMax < ((unsigned ) pOp->p3))) {
            (newMax = ((unsigned ) pOp->p3));
          }  
        }  
        (pOut->u.i = sqlite3BtreeMaxPageCount(pBt, newMax));
        break;
      }  
      if (((id2i_sqlite_omit_pager_pragmas ) )) {
        if ((pOp->opcode == 147)) {
          goto id2i_label_1;
        }  
      }  
      case 148:
      {
        if ((db->xTrace && (! p->doingRerun) && ((u.cs.zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql)) != 0))) {
          (u.cs.z = sqlite3VdbeExpandSql(p, u.cs.zTrace));
          db->xTrace(db->pTraceArg, u.cs.z);
          sqlite3DbFree(db, u.cs.z);
        }  
        break;
      }
      id2i_label_1:
      default:
      {
        ((void ) 0);
        break;
      }
    }
    {
      u64 elapsed =  ((((! id2i_i386) && (! id2i___i386__) && (! id2i__m_ix86)) ) ? (_1318_sqlite3Hwtime() - start) : (_1317_sqlite3Hwtime() - start));
      (pOp->_1269_cycles += elapsed);
      pOp->_1269_cnt++;
    }
  }
  _1269_vdbe_error_halt:
  ((void ) 0);
  (p->rc = rc);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      if ((_1283_sqlite3Config.xLog != 0)) {
        sqlite3Coverage(72329);
      }  
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      if ((_1284_sqlite3Config.xLog != 0)) {
        sqlite3Coverage(72329);
      }  
    }  
  }  
  sqlite3_log(rc, "statement aborts at %d: [%s] %s", pc, p->zSql, p->zErrMsg);
  sqlite3VdbeHalt(p);
  if ((rc == (10 | (12 << 8)))) {
    (db->mallocFailed = 1);
  }  
  (rc = 1);
  if ((resetSchemaOnFault > 0)) {
    sqlite3ResetOneSchema(db, (resetSchemaOnFault - 1));
  }  
  _1269_vdbe_return:
  (db->lastRowid = lastRowid);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((nVmStep > 0)) {
      sqlite3Coverage(72344);
    }  
  }  
  (p->aCounter[4] += ((int ) nVmStep));
  return rc;
  _1269_too_big:
  sqlite3SetString((&p->zErrMsg), db, "string or blob too big");
  (rc = 18);
  goto _1269_vdbe_error_halt;
  _1269_no_mem:
  (db->mallocFailed = 1);
  sqlite3SetString((&p->zErrMsg), db, "out of memory");
  (rc = 7);
  goto _1269_vdbe_error_halt;
  _1269_abort_due_to_error:
  ((void ) 0);
  if (db->mallocFailed) {
    (rc = 7);
  }  
  if ((rc != (10 | (12 << 8)))) {
    sqlite3SetString((&p->zErrMsg), db, "%s", sqlite3ErrStr(rc));
  }  
  goto _1269_vdbe_error_halt;
  _1269_abort_due_to_interrupt:
  ((void ) 0);
  (rc = 9);
  (p->rc = rc);
  sqlite3SetString((&p->zErrMsg), db, "%s", sqlite3ErrStr(rc));
  goto _1269_vdbe_error_halt;
}
typedef struct  Incrblob   Incrblob;
struct  Incrblob {
  int flags ;
  int nByte ;
  int iOffset ;
  int iCol ;
  BtCursor *pCsr ;
  sqlite3_stmt *pStmt ;
  sqlite3 *db ;
}  ;
static  int blobSeekToRow(Incrblob *p , sqlite3_int64 iRow , char **pzErr )  {
  int rc;
  char *zErr =  0;
  Vdbe *v =  ((Vdbe *) p->pStmt);
  ((void ) 0);
  (v->aVar[0].u.i = iRow);
  (rc = sqlite3_step(p->pStmt));
  if ((rc == 100)) {
    u32 type =  v->apCsr[0]->aType[p->iCol];
    if ((type < 12)) {
      (zErr = sqlite3MPrintf(p->db, "cannot open value of type %s", ((type == 0) ? "null" : ((type == 7) ? "real" : "integer"))));
      (rc = 1);
      sqlite3_finalize(p->pStmt);
      (p->pStmt = 0);
    }  
    else {
      (p->iOffset = v->apCsr[0]->aOffset[p->iCol]);
      (p->nByte = sqlite3VdbeSerialTypeLen(type));
      (p->pCsr = v->apCsr[0]->pCursor);
      sqlite3BtreeCacheOverflow(p->pCsr);
    }
  }  
  if ((rc == 100)) {
    (rc = 0);
  } 
  else if (p->pStmt) {
    (rc = sqlite3_finalize(p->pStmt));
    (p->pStmt = 0);
    if ((rc == 0)) {
      (zErr = sqlite3MPrintf(p->db, "no such rowid: %lld", iRow));
      (rc = 1);
    }  
    else {
      (zErr = sqlite3MPrintf(p->db, "%s", sqlite3_errmsg(p->db)));
    }
  } 
  ((void ) 0);
  ((void ) 0);
  ((*pzErr) = zErr);
  return rc;
}
int sqlite3_blob_open(sqlite3 *db , const  char *zDb , const  char *zTable , const  char *zColumn , sqlite_int64 iRow , int flags , sqlite3_blob **ppBlob )  {
  int nAttempt =  0;
  int iCol;
  static const VdbeOpList openBlob[] =  { { 4,  0,  0,  0},  { 47,  0,  0,  0},  { 133,  0,  0,  0},  { 48,  0,  0,  0},  { 49,  0,  0,  0},  { 26,  1,  1,  1},  { 63,  0,  10,  1},  { 41,  0,  0,  1},  { 30,  1,  0,  0},  { 14,  0,  5,  0},  { 54,  0,  0,  0},  { 20,  0,  0,  0}};
  int rc =  0;
  char *zErr =  0;
  Table *pTab;
  Parse *pParse =  0;
  Incrblob *pBlob =  0;
  (flags = (! (! flags)));
  ((*ppBlob) = 0);
  (pBlob = ((Incrblob *) sqlite3DbMallocZero(db, sizeof(Incrblob ))));
  if ((! pBlob)) {
    goto blob_open_out;
  }  
  (pParse = sqlite3DbMallocRaw(db, sizeof((*pParse))));
  if ((! pParse)) {
    goto blob_open_out;
  }  
  do {
    memset(pParse, 0, sizeof(Parse ));
    (pParse->db = db);
    sqlite3DbFree(db, zErr);
    (zErr = 0);
    sqlite3BtreeEnterAll(db);
    (pTab = sqlite3LocateTable(pParse, 0, zTable, zDb));
    if ((pTab && ((pTab->tabFlags & 0x10) != 0))) {
      (pTab = 0);
      sqlite3ErrorMsg(pParse, "cannot open virtual table: %s", zTable);
    }  
    if ((((! id2i_sqlite_omit_view) ) )) {
      if ((pTab && pTab->pSelect)) {
        (pTab = 0);
        sqlite3ErrorMsg(pParse, "cannot open view: %s", zTable);
      }  
    }  
    if ((! pTab)) {
      if (pParse->zErrMsg) {
        sqlite3DbFree(db, zErr);
        (zErr = pParse->zErrMsg);
        (pParse->zErrMsg = 0);
      }  
      (rc = 1);
      goto blob_open_out;
    }  
    for ((iCol = 0); (iCol < pTab->nCol); iCol++) {
      if ((sqlite3_stricmp(pTab->aCol[iCol].zName, zColumn) == 0)) {
        break;
      }  
    }
    if ((iCol == pTab->nCol)) {
      sqlite3DbFree(db, zErr);
      (zErr = sqlite3MPrintf(db, "no such column: \"%s\"", zColumn));
      (rc = 1);
      goto blob_open_out;
    }  
    if (flags) {
      const char *zFault =  0;
      Index *pIdx;
      if ((((! id2i_sqlite_omit_foreign_key) ) )) {
        if ((db->flags & 0x00080000)) {
          FKey *pFKey;
          for ((pFKey = pTab->pFKey); pFKey; (pFKey = pFKey->pNextFrom)) {
            int j;
            for ((j = 0); (j < pFKey->nCol); j++) {
              if ((pFKey->aCol[j].iFrom == iCol)) {
                (zFault = "foreign key");
              }  
            }
          }
        }  
      }  
      for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
        int j;
        for ((j = 0); (j < pIdx->nColumn); j++) {
          if ((pIdx->aiColumn[j] == iCol)) {
            (zFault = "indexed");
          }  
        }
      }
      if (zFault) {
        sqlite3DbFree(db, zErr);
        (zErr = sqlite3MPrintf(db, "cannot open %s column for writing", zFault));
        (rc = 1);
        goto blob_open_out;
      }  
    }  
    (pBlob->pStmt = ((sqlite3_stmt *) sqlite3VdbeCreate(db)));
    ((void ) 0);
    if (pBlob->pStmt) {
      Vdbe *v =  ((Vdbe *) pBlob->pStmt);
      int iDb =  sqlite3SchemaToIndex(db, pTab->pSchema);
      sqlite3VdbeAddOpList(v, (sizeof(openBlob) / sizeof(VdbeOpList )), openBlob);
      sqlite3VdbeChangeP1(v, 0, iDb);
      sqlite3VdbeChangeP2(v, 0, flags);
      sqlite3VdbeChangeP1(v, 1, iDb);
      sqlite3VdbeChangeP2(v, 1, pTab->pSchema->schema_cookie);
      sqlite3VdbeChangeP3(v, 1, pTab->pSchema->iGeneration);
      sqlite3VdbeUsesBtree(v, iDb);
      sqlite3VdbeChangeP1(v, 2, iDb);
      sqlite3VdbeChangeP2(v, 2, pTab->tnum);
      sqlite3VdbeChangeP3(v, 2, flags);
      sqlite3VdbeChangeP4(v, 2, pTab->zName, 0);
      sqlite3VdbeChangeToNoop(v, (4 - flags));
      sqlite3VdbeChangeP2(v, (3 + flags), pTab->tnum);
      sqlite3VdbeChangeP3(v, (3 + flags), iDb);
      sqlite3VdbeChangeP4(v, (3 + flags), ((void *) ((long  int ) (pTab->nCol + 1))), (- 14));
      sqlite3VdbeChangeP2(v, 7, pTab->nCol);
      if ((! db->mallocFailed)) {
        (pParse->nVar = 1);
        (pParse->nMem = 1);
        (pParse->nTab = 1);
        sqlite3VdbeMakeReady(v, pParse);
      }  
    }  
    (pBlob->flags = flags);
    (pBlob->iCol = iCol);
    (pBlob->db = db);
    if (db->mallocFailed) {
      goto blob_open_out;
    }  
    sqlite3_bind_int64(pBlob->pStmt, 1, iRow);
    (rc = blobSeekToRow(pBlob, iRow, (&zErr)));
  } while (((++nAttempt < 50) && (rc == 17)));
  blob_open_out:
  if (((rc == 0) && (db->mallocFailed == 0))) {
    ((*ppBlob) = ((sqlite3_blob *) pBlob));
  }  
  else {
    if ((pBlob && pBlob->pStmt)) {
      sqlite3VdbeFinalize(((Vdbe *) pBlob->pStmt));
    }  
    sqlite3DbFree(db, pBlob);
  }
  sqlite3Error(db, rc, (zErr ? "%s" : 0), zErr);
  sqlite3DbFree(db, zErr);
  sqlite3DbFree(db, pParse);
  (rc = sqlite3ApiExit(db, rc));
  return rc;
}
int sqlite3_blob_close(sqlite3_blob *pBlob )  {
  Incrblob *p =  ((Incrblob *) pBlob);
  int rc;
  sqlite3 *db;
  if (p) {
    (db = p->db);
    (rc = sqlite3_finalize(p->pStmt));
    sqlite3DbFree(db, p);
  }  
  else {
    (rc = 0);
  }
  return rc;
}
static  int blobReadWrite(sqlite3_blob *pBlob , void *z , int n , int iOffset , int ( *xCall)(BtCursor * , u32 , u32 , void * ) )  {
  int rc;
  Incrblob *p =  ((Incrblob *) pBlob);
  Vdbe *v;
  sqlite3 *db;
  if ((p == 0)) {
    return sqlite3MisuseError(72755);
  }  
  (db = p->db);
  (v = ((Vdbe *) p->pStmt));
  if (((n < 0) || (iOffset < 0) || ((iOffset + n) > p->nByte))) {
    (rc = 1);
    sqlite3Error(db, 1, 0);
  } 
  else if ((v == 0)) {
    (rc = 4);
  } 
  else {
    ((void ) 0);
    (rc = xCall(p->pCsr, (iOffset + p->iOffset), n, z));
    if ((rc == 4)) {
      sqlite3VdbeFinalize(v);
      (p->pStmt = 0);
    }  
    else {
      (db->errCode = rc);
      (v->rc = rc);
    }
  }
  (rc = sqlite3ApiExit(db, rc));
  return rc;
}
int sqlite3_blob_read(sqlite3_blob *pBlob , void *z , int n , int iOffset )  {
  return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreeData);
}
int sqlite3_blob_write(sqlite3_blob *pBlob , const  void *z , int n , int iOffset )  {
  return blobReadWrite(pBlob, ((void *) z), n, iOffset, sqlite3BtreePutData);
}
int sqlite3_blob_bytes(sqlite3_blob *pBlob )  {
  Incrblob *p =  ((Incrblob *) pBlob);
  return ((p && p->pStmt) ? p->nByte : 0);
}
int sqlite3_blob_reopen(sqlite3_blob *pBlob , sqlite3_int64 iRow )  {
  int rc;
  Incrblob *p =  ((Incrblob *) pBlob);
  sqlite3 *db;
  if ((p == 0)) {
    return sqlite3MisuseError(72830);
  }  
  (db = p->db);
  if ((p->pStmt == 0)) {
    (rc = 4);
  }  
  else {
    char *zErr;
    (rc = blobSeekToRow(p, iRow, (&zErr)));
    if ((rc != 0)) {
      sqlite3Error(db, rc, (zErr ? "%s" : 0), zErr);
      sqlite3DbFree(db, zErr);
    }  
    ((void ) 0);
  }
  (rc = sqlite3ApiExit(db, rc));
  ((void ) 0);
  return rc;
}
typedef struct  VdbeSorterIter   VdbeSorterIter;
typedef struct  SorterRecord   SorterRecord;
typedef struct  FileWriter   FileWriter;
struct  VdbeSorter {
  i64 iWriteOff ;
  i64 iReadOff ;
  int nInMemory ;
  int nTree ;
  int nPMA ;
  int mnPmaSize ;
  int mxPmaSize ;
  VdbeSorterIter *aIter ;
  int *aTree ;
  sqlite3_file *pTemp1 ;
  SorterRecord *pRecord ;
  UnpackedRecord *pUnpacked ;
}  ;
struct  VdbeSorterIter {
  i64 iReadOff ;
  i64 iEof ;
  int nAlloc ;
  int nKey ;
  sqlite3_file *pFile ;
  u8 *aAlloc ;
  u8 *aKey ;
  u8 *aBuffer ;
  int nBuffer ;
}  ;
struct  FileWriter {
  int eFWErr ;
  u8 *aBuffer ;
  int nBuffer ;
  int iBufStart ;
  int iBufEnd ;
  i64 iWriteOff ;
  sqlite3_file *pFile ;
}  ;
struct  SorterRecord {
  void *pVal ;
  int nVal ;
  SorterRecord *pNext ;
}  ;
static  void vdbeSorterIterZero(sqlite3 *db , VdbeSorterIter *pIter )  {
  sqlite3DbFree(db, pIter->aAlloc);
  sqlite3DbFree(db, pIter->aBuffer);
  memset(pIter, 0, sizeof(VdbeSorterIter ));
}
static  int vdbeSorterIterRead(sqlite3 *db , VdbeSorterIter *p , int nByte , u8 **ppOut )  {
  int iBuf;
  int nAvail;
  ((void ) 0);
  (iBuf = (p->iReadOff % p->nBuffer));
  if ((iBuf == 0)) {
    int nRead;
    int rc;
    if (((p->iEof - p->iReadOff) > ((i64 ) p->nBuffer))) {
      (nRead = p->nBuffer);
    }  
    else {
      (nRead = ((int ) (p->iEof - p->iReadOff)));
    }
    ((void ) 0);
    (rc = sqlite3OsRead(p->pFile, p->aBuffer, nRead, p->iReadOff));
    ((void ) 0);
    if ((rc != 0)) {
      return rc;
    }  
  }  
  (nAvail = (p->nBuffer - iBuf));
  if ((nByte <= nAvail)) {
    ((*ppOut) = (&p->aBuffer[iBuf]));
    (p->iReadOff += nByte);
  }  
  else {
    int nRem;
    if ((p->nAlloc < nByte)) {
      int nNew =  (p->nAlloc * 2);
      while ((nByte > nNew)) {
        (nNew = (nNew * 2));
      }
      (p->aAlloc = sqlite3DbReallocOrFree(db, p->aAlloc, nNew));
      if ((! p->aAlloc)) {
        return 7;
      }  
      (p->nAlloc = nNew);
    }  
    memcpy(p->aAlloc, (&p->aBuffer[iBuf]), nAvail);
    (p->iReadOff += nAvail);
    (nRem = (nByte - nAvail));
    while ((nRem > 0)) {
      int rc;
      int nCopy;
      u8 *aNext;
      (nCopy = nRem);
      if ((nRem > p->nBuffer)) {
        (nCopy = p->nBuffer);
      }  
      (rc = vdbeSorterIterRead(db, p, nCopy, (&aNext)));
      if ((rc != 0)) {
        return rc;
      }  
      ((void ) 0);
      memcpy((&p->aAlloc[(nByte - nRem)]), aNext, nCopy);
      (nRem -= nCopy);
    }
    ((*ppOut) = p->aAlloc);
  }
  return 0;
}
static  int vdbeSorterIterVarint(sqlite3 *db , VdbeSorterIter *p , u64 *pnOut )  {
  int iBuf;
  (iBuf = (p->iReadOff % p->nBuffer));
  if ((iBuf && ((p->nBuffer - iBuf) >= 9))) {
    (p->iReadOff += sqlite3GetVarint((&p->aBuffer[iBuf]), pnOut));
  }  
  else {
    u8 aVarint[16], *a;
    int i =  0, rc;
    do {
      (rc = vdbeSorterIterRead(db, p, 1, (&a)));
      if (rc) {
        return rc;
      }  
      (aVarint[(i++ & 0xf)] = a[0]);
    } while (((a[0] & 0x80) != 0));
    sqlite3GetVarint(aVarint, pnOut);
  }
  return 0;
}
static  int vdbeSorterIterNext(sqlite3 *db , VdbeSorterIter *pIter )  {
  int rc;
  u64 nRec =  0;
  if ((pIter->iReadOff >= pIter->iEof)) {
    vdbeSorterIterZero(db, pIter);
    return 0;
  }  
  (rc = vdbeSorterIterVarint(db, pIter, (&nRec)));
  if ((rc == 0)) {
    (pIter->nKey = ((int ) nRec));
    (rc = vdbeSorterIterRead(db, pIter, ((int ) nRec), (&pIter->aKey)));
  }  
  return rc;
}
static  int vdbeSorterIterInit(sqlite3 *db , const  VdbeSorter *pSorter , i64 iStart , VdbeSorterIter *pIter , i64 *pnByte )  {
  int rc =  0;
  int nBuf;
  (nBuf = sqlite3BtreeGetPageSize(db->aDb[0].pBt));
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (pIter->pFile = pSorter->pTemp1);
  (pIter->iReadOff = iStart);
  (pIter->nAlloc = 128);
  (pIter->aAlloc = ((u8 *) sqlite3DbMallocRaw(db, pIter->nAlloc)));
  (pIter->nBuffer = nBuf);
  (pIter->aBuffer = ((u8 *) sqlite3DbMallocRaw(db, nBuf)));
  if ((! pIter->aBuffer)) {
    (rc = 7);
  }  
  else {
    int iBuf;
    (iBuf = (iStart % nBuf));
    if (iBuf) {
      int nRead =  (nBuf - iBuf);
      if (((iStart + nRead) > pSorter->iWriteOff)) {
        (nRead = ((int ) (pSorter->iWriteOff - iStart)));
      }  
      (rc = sqlite3OsRead(pSorter->pTemp1, (&pIter->aBuffer[iBuf]), nRead, iStart));
      ((void ) 0);
    }  
    if ((rc == 0)) {
      u64 nByte;
      (pIter->iEof = pSorter->iWriteOff);
      (rc = vdbeSorterIterVarint(db, pIter, (&nByte)));
      (pIter->iEof = (pIter->iReadOff + nByte));
      ((*pnByte) += nByte);
    }  
  }
  if ((rc == 0)) {
    (rc = vdbeSorterIterNext(db, pIter));
  }  
  return rc;
}
static  void vdbeSorterCompare(const  VdbeCursor *pCsr , int bOmitRowid , const  void *pKey1 , int nKey1 , const  void *pKey2 , int nKey2 , int *pRes )  {
  KeyInfo *pKeyInfo =  pCsr->pKeyInfo;
  VdbeSorter *pSorter =  pCsr->pSorter;
  UnpackedRecord *r2 =  pSorter->pUnpacked;
  int i;
  if (pKey2) {
    sqlite3VdbeRecordUnpack(pKeyInfo, nKey2, pKey2, r2);
  }  
  if (bOmitRowid) {
    (r2->nField = pKeyInfo->nField);
    ((void ) 0);
    for ((i = 0); (i < r2->nField); i++) {
      if ((r2->aMem[i].flags & 0x0001)) {
        ((*pRes) = (- 1));
        return;
      }  
    }
    (r2->flags |= 0x02);
  }  
  ((*pRes) = sqlite3VdbeRecordCompare(nKey1, pKey1, r2));
}
static  int vdbeSorterDoCompare(const  VdbeCursor *pCsr , int iOut )  {
  VdbeSorter *pSorter =  pCsr->pSorter;
  int i1;
  int i2;
  int iRes;
  VdbeSorterIter *p1;
  VdbeSorterIter *p2;
  ((void ) 0);
  if ((iOut >= (pSorter->nTree / 2))) {
    (i1 = ((iOut - (pSorter->nTree / 2)) * 2));
    (i2 = (i1 + 1));
  }  
  else {
    (i1 = pSorter->aTree[(iOut * 2)]);
    (i2 = pSorter->aTree[((iOut * 2) + 1)]);
  }
  (p1 = (&pSorter->aIter[i1]));
  (p2 = (&pSorter->aIter[i2]));
  if ((p1->pFile == 0)) {
    (iRes = i2);
  } 
  else if ((p2->pFile == 0)) {
    (iRes = i1);
  } 
  else {
    int res;
    ((void ) 0);
    vdbeSorterCompare(pCsr, 0, p1->aKey, p1->nKey, p2->aKey, p2->nKey, (&res));
    if ((res <= 0)) {
      (iRes = i1);
    }  
    else {
      (iRes = i2);
    }
  }
  (pSorter->aTree[iOut] = iRes);
  return 0;
}
static  int sqlite3VdbeSorterInit(sqlite3 *db , VdbeCursor *pCsr )  {
  int pgsz;
  int mxCache;
  VdbeSorter *pSorter;
  char *d;
  ((void ) 0);
  (pCsr->pSorter = (pSorter = sqlite3DbMallocZero(db, sizeof(VdbeSorter ))));
  if ((pSorter == 0)) {
    return 7;
  }  
  (pSorter->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pCsr->pKeyInfo, 0, 0, (&d)));
  if ((pSorter->pUnpacked == 0)) {
    return 7;
  }  
  ((void ) 0);
  if ((! sqlite3TempInMemory(db))) {
    (pgsz = sqlite3BtreeGetPageSize(db->aDb[0].pBt));
    (pSorter->mnPmaSize = (10 * pgsz));
    (mxCache = db->aDb[0].pSchema->cache_size);
    if ((mxCache < 10)) {
      (mxCache = 10);
    }  
    (pSorter->mxPmaSize = (mxCache * pgsz));
  }  
  return 0;
}
static  void vdbeSorterRecordFree(sqlite3 *db , SorterRecord *pRecord )  {
  SorterRecord *p;
  SorterRecord *pNext;
  for ((p = pRecord); p; (p = pNext)) {
    (pNext = p->pNext);
    sqlite3DbFree(db, p);
  }
}
static  void sqlite3VdbeSorterClose(sqlite3 *db , VdbeCursor *pCsr )  {
  VdbeSorter *pSorter =  pCsr->pSorter;
  if (pSorter) {
    if (pSorter->aIter) {
      int i;
      for ((i = 0); (i < pSorter->nTree); i++) {
        vdbeSorterIterZero(db, (&pSorter->aIter[i]));
      }
      sqlite3DbFree(db, pSorter->aIter);
    }  
    if (pSorter->pTemp1) {
      sqlite3OsCloseFree(pSorter->pTemp1);
    }  
    vdbeSorterRecordFree(db, pSorter->pRecord);
    sqlite3DbFree(db, pSorter->pUnpacked);
    sqlite3DbFree(db, pSorter);
    (pCsr->pSorter = 0);
  }  
}
static  int vdbeSorterOpenTempFile(sqlite3 *db , sqlite3_file **ppFile )  {
  int dummy;
  return sqlite3OsOpenMalloc(db->pVfs, 0, ppFile, (0x00001000 | 0x00000002 | 0x00000004 | 0x00000010 | 0x00000008), (&dummy));
}
static  void vdbeSorterMerge(const  VdbeCursor *pCsr , SorterRecord *p1 , SorterRecord *p2 , SorterRecord **ppOut )  {
  SorterRecord *pFinal =  0;
  SorterRecord **pp =  (&pFinal);
  void *pVal2 =  (p2 ? p2->pVal : 0);
  while ((p1 && p2)) {
    int res;
    vdbeSorterCompare(pCsr, 0, p1->pVal, p1->nVal, pVal2, p2->nVal, (&res));
    if ((res <= 0)) {
      ((*pp) = p1);
      (pp = (&p1->pNext));
      (p1 = p1->pNext);
      (pVal2 = 0);
    }  
    else {
      ((*pp) = p2);
      (pp = (&p2->pNext));
      (p2 = p2->pNext);
      if ((p2 == 0)) {
        break;
      }  
      (pVal2 = p2->pVal);
    }
  }
  ((*pp) = (p1 ? p1 : p2));
  ((*ppOut) = pFinal);
}
static  int vdbeSorterSort(const  VdbeCursor *pCsr )  {
  int i;
  SorterRecord **aSlot;
  SorterRecord *p;
  VdbeSorter *pSorter =  pCsr->pSorter;
  (aSlot = ((SorterRecord **) sqlite3MallocZero((64 * sizeof(SorterRecord *)))));
  if ((! aSlot)) {
    return 7;
  }  
  (p = pSorter->pRecord);
  while (p) {
    SorterRecord *pNext =  p->pNext;
    (p->pNext = 0);
    for ((i = 0); aSlot[i]; i++) {
      vdbeSorterMerge(pCsr, p, aSlot[i], (&p));
      (aSlot[i] = 0);
    }
    (aSlot[i] = p);
    (p = pNext);
  }
  (p = 0);
  for ((i = 0); (i < 64); i++) {
    vdbeSorterMerge(pCsr, p, aSlot[i], (&p));
  }
  (pSorter->pRecord = p);
  sqlite3_free(aSlot);
  return 0;
}
static  void fileWriterInit(sqlite3 *db , sqlite3_file *pFile , FileWriter *p , i64 iStart )  {
  int nBuf =  sqlite3BtreeGetPageSize(db->aDb[0].pBt);
  memset(p, 0, sizeof(FileWriter ));
  (p->aBuffer = ((u8 *) sqlite3DbMallocRaw(db, nBuf)));
  if ((! p->aBuffer)) {
    (p->eFWErr = 7);
  }  
  else {
    (p->iBufEnd = (p->iBufStart = (iStart % nBuf)));
    (p->iWriteOff = (iStart - p->iBufStart));
    (p->nBuffer = nBuf);
    (p->pFile = pFile);
  }
}
static  void fileWriterWrite(FileWriter *p , u8 *pData , int nData )  {
  int nRem =  nData;
  while (((nRem > 0) && (p->eFWErr == 0))) {
    int nCopy =  nRem;
    if ((nCopy > (p->nBuffer - p->iBufEnd))) {
      (nCopy = (p->nBuffer - p->iBufEnd));
    }  
    memcpy((&p->aBuffer[p->iBufEnd]), (&pData[(nData - nRem)]), nCopy);
    (p->iBufEnd += nCopy);
    if ((p->iBufEnd == p->nBuffer)) {
      (p->eFWErr = sqlite3OsWrite(p->pFile, (&p->aBuffer[p->iBufStart]), (p->iBufEnd - p->iBufStart), (p->iWriteOff + p->iBufStart)));
      (p->iBufStart = (p->iBufEnd = 0));
      (p->iWriteOff += p->nBuffer);
    }  
    ((void ) 0);
    (nRem -= nCopy);
  }
}
static  int fileWriterFinish(sqlite3 *db , FileWriter *p , i64 *piEof )  {
  int rc;
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((p->eFWErr == 0) && p->aBuffer && (p->iBufEnd > p->iBufStart))) {
      (p->eFWErr = sqlite3OsWrite(p->pFile, (&p->aBuffer[p->iBufStart]), (p->iBufEnd - p->iBufStart), (p->iWriteOff + p->iBufStart)));
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((p->eFWErr == 0) && 1 && (p->iBufEnd > p->iBufStart))) {
      (p->eFWErr = sqlite3OsWrite(p->pFile, (&p->aBuffer[p->iBufStart]), (p->iBufEnd - p->iBufStart), (p->iWriteOff + p->iBufStart)));
    }  
  }  
  ((*piEof) = (p->iWriteOff + p->iBufEnd));
  sqlite3DbFree(db, p->aBuffer);
  (rc = p->eFWErr);
  memset(p, 0, sizeof(FileWriter ));
  return rc;
}
static  void fileWriterWriteVarint(FileWriter *p , u64 iVal )  {
  int nByte;
  u8 aByte[10];
  (nByte = sqlite3PutVarint(aByte, iVal));
  fileWriterWrite(p, aByte, nByte);
}
static  int vdbeSorterListToPMA(sqlite3 *db , const  VdbeCursor *pCsr )  {
  int rc =  0;
  VdbeSorter *pSorter =  pCsr->pSorter;
  FileWriter writer;
  memset((&writer), 0, sizeof(FileWriter ));
  if ((pSorter->nInMemory == 0)) {
    ((void ) 0);
    return rc;
  }  
  (rc = vdbeSorterSort(pCsr));
  if (((rc == 0) && (pSorter->pTemp1 == 0))) {
    (rc = vdbeSorterOpenTempFile(db, (&pSorter->pTemp1)));
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
  }  
  if ((rc == 0)) {
    SorterRecord *p;
    SorterRecord *pNext =  0;
    fileWriterInit(db, pSorter->pTemp1, (&writer), pSorter->iWriteOff);
    pSorter->nPMA++;
    fileWriterWriteVarint((&writer), pSorter->nInMemory);
    for ((p = pSorter->pRecord); p; (p = pNext)) {
      (pNext = p->pNext);
      fileWriterWriteVarint((&writer), p->nVal);
      fileWriterWrite((&writer), p->pVal, p->nVal);
      sqlite3DbFree(db, p);
    }
    (pSorter->pRecord = p);
    (rc = fileWriterFinish(db, (&writer), (&pSorter->iWriteOff)));
  }  
  return rc;
}
static  int sqlite3VdbeSorterWrite(sqlite3 *db , const  VdbeCursor *pCsr , Mem *pVal )  {
  VdbeSorter *pSorter =  pCsr->pSorter;
  int rc =  0;
  SorterRecord *pNew;
  ((void ) 0);
  (pSorter->nInMemory += (sqlite3VarintLen(pVal->n) + pVal->n));
  (pNew = ((SorterRecord *) sqlite3DbMallocRaw(db, (pVal->n + sizeof(SorterRecord )))));
  if ((pNew == 0)) {
    (rc = 7);
  }  
  else {
    (pNew->pVal = ((void *) (&pNew[1])));
    memcpy(pNew->pVal, pVal->z, pVal->n);
    (pNew->nVal = pVal->n);
    (pNew->pNext = pSorter->pRecord);
    (pSorter->pRecord = pNew);
  }
  if (((rc == 0) && (pSorter->mxPmaSize > 0) && ((pSorter->nInMemory > pSorter->mxPmaSize) || ((pSorter->nInMemory > pSorter->mnPmaSize) && sqlite3HeapNearlyFull())))) {
    (rc = vdbeSorterListToPMA(db, pCsr));
    (pSorter->nInMemory = 0);
    ((void ) 0);
  }  
  return rc;
}
static  int vdbeSorterInitMerge(sqlite3 *db , const  VdbeCursor *pCsr , i64 *pnByte )  {
  VdbeSorter *pSorter =  pCsr->pSorter;
  int rc =  0;
  int i;
  i64 nByte =  0;
  for ((i = 0); (i < 16); i++) {
    VdbeSorterIter *pIter =  (&pSorter->aIter[i]);
    (rc = vdbeSorterIterInit(db, pSorter, pSorter->iReadOff, pIter, (&nByte)));
    (pSorter->iReadOff = pIter->iEof);
    ((void ) 0);
    if (((rc != 0) || (pSorter->iReadOff >= pSorter->iWriteOff))) {
      break;
    }  
  }
  for ((i = (pSorter->nTree - 1)); ((rc == 0) && (i > 0)); i--) {
    (rc = vdbeSorterDoCompare(pCsr, i));
  }
  ((*pnByte) = nByte);
  return rc;
}
static  int sqlite3VdbeSorterRewind(sqlite3 *db , const  VdbeCursor *pCsr , int *pbEof )  {
  VdbeSorter *pSorter =  pCsr->pSorter;
  int rc;
  sqlite3_file *pTemp2 =  0;
  i64 iWrite2 =  0;
  int nIter;
  int nByte;
  int N =  2;
  ((void ) 0);
  if ((pSorter->nPMA == 0)) {
    ((*pbEof) = (! pSorter->pRecord));
    ((void ) 0);
    return vdbeSorterSort(pCsr);
  }  
  (rc = vdbeSorterListToPMA(db, pCsr));
  if ((rc != 0)) {
    return rc;
  }  
  (nIter = pSorter->nPMA);
  if ((nIter > 16)) {
    (nIter = 16);
  }  
  ((void ) 0);
  while ((N < nIter)) {
    (N += N);
  }
  (nByte = (N * (sizeof(int ) + sizeof(VdbeSorterIter ))));
  (pSorter->aIter = ((VdbeSorterIter *) sqlite3DbMallocZero(db, nByte)));
  if ((! pSorter->aIter)) {
    return 7;
  }  
  (pSorter->aTree = ((int *) (&pSorter->aIter[N])));
  (pSorter->nTree = N);
  do {
    int iNew;
    for ((iNew = 0); ((rc == 0) && ((iNew * 16) < pSorter->nPMA)); iNew++) {
      int rc2;
      FileWriter writer;
      i64 nWrite;
      memset((&writer), 0, sizeof(FileWriter ));
      (rc = vdbeSorterInitMerge(db, pCsr, (&nWrite)));
      ((void ) 0);
      if (((rc != 0) || (pSorter->nPMA <= 16))) {
        break;
      }  
      if ((pTemp2 == 0)) {
        ((void ) 0);
        (rc = vdbeSorterOpenTempFile(db, (&pTemp2)));
      }  
      if ((rc == 0)) {
        int bEof =  0;
        fileWriterInit(db, pTemp2, (&writer), iWrite2);
        fileWriterWriteVarint((&writer), nWrite);
        while (((rc == 0) && (bEof == 0))) {
          VdbeSorterIter *pIter =  (&pSorter->aIter[pSorter->aTree[1]]);
          ((void ) 0);
          fileWriterWriteVarint((&writer), pIter->nKey);
          fileWriterWrite((&writer), pIter->aKey, pIter->nKey);
          (rc = sqlite3VdbeSorterNext(db, pCsr, (&bEof)));
        }
        (rc2 = fileWriterFinish(db, (&writer), (&iWrite2)));
        if ((rc == 0)) {
          (rc = rc2);
        }  
      }  
    }
    if ((pSorter->nPMA <= 16)) {
      break;
    }  
    else {
      sqlite3_file *pTmp =  pSorter->pTemp1;
      (pSorter->nPMA = iNew);
      (pSorter->pTemp1 = pTemp2);
      (pTemp2 = pTmp);
      (pSorter->iWriteOff = iWrite2);
      (pSorter->iReadOff = 0);
      (iWrite2 = 0);
    }
  } while ((rc == 0));
  if (pTemp2) {
    sqlite3OsCloseFree(pTemp2);
  }  
  ((*pbEof) = (pSorter->aIter[pSorter->aTree[1]].pFile == 0));
  return rc;
}
static  int sqlite3VdbeSorterNext(sqlite3 *db , const  VdbeCursor *pCsr , int *pbEof )  {
  VdbeSorter *pSorter =  pCsr->pSorter;
  int rc;
  if (pSorter->aTree) {
    int iPrev =  pSorter->aTree[1];
    int i;
    (rc = vdbeSorterIterNext(db, (&pSorter->aIter[iPrev])));
    for ((i = ((pSorter->nTree + iPrev) / 2)); ((rc == 0) && (i > 0)); (i = (i / 2))) {
      (rc = vdbeSorterDoCompare(pCsr, i));
    }
    ((*pbEof) = (pSorter->aIter[pSorter->aTree[1]].pFile == 0));
  }  
  else {
    SorterRecord *pFree =  pSorter->pRecord;
    (pSorter->pRecord = pFree->pNext);
    (pFree->pNext = 0);
    vdbeSorterRecordFree(db, pFree);
    ((*pbEof) = (! pSorter->pRecord));
    (rc = 0);
  }
  return rc;
}
static  void *vdbeSorterRowkey(const  VdbeSorter *pSorter , int *pnKey )  {
  void *pKey;
  if (pSorter->aTree) {
    VdbeSorterIter *pIter;
    (pIter = (&pSorter->aIter[pSorter->aTree[1]]));
    ((*pnKey) = pIter->nKey);
    (pKey = pIter->aKey);
  }  
  else {
    ((*pnKey) = pSorter->pRecord->nVal);
    (pKey = pSorter->pRecord->pVal);
  }
  return pKey;
}
static  int sqlite3VdbeSorterRowkey(const  VdbeCursor *pCsr , Mem *pOut )  {
  VdbeSorter *pSorter =  pCsr->pSorter;
  void *pKey;
  int nKey;
  (pKey = vdbeSorterRowkey(pSorter, (&nKey)));
  if (sqlite3VdbeMemGrow(pOut, nKey, 0)) {
    return 7;
  }  
  (pOut->n = nKey);
  (pOut->flags = ((pOut->flags & (~ (0x01ff | 0x4000))) | 0x0010));
  memcpy(pOut->z, pKey, nKey);
  return 0;
}
static  int sqlite3VdbeSorterCompare(const  VdbeCursor *pCsr , Mem *pVal , int *pRes )  {
  VdbeSorter *pSorter =  pCsr->pSorter;
  void *pKey;
  int nKey;
  (pKey = vdbeSorterRowkey(pSorter, (&nKey)));
  vdbeSorterCompare(pCsr, 1, pVal->z, pVal->n, pKey, nKey, pRes);
  return 0;
}
typedef struct  MemJournal   MemJournal;
typedef struct  FilePoint   FilePoint;
typedef struct  FileChunk   FileChunk;
struct  FileChunk {
  FileChunk *pNext ;
  u8 zChunk[((int ) (1024 - sizeof(FileChunk *)))] ;
}  ;
struct  FilePoint {
  sqlite3_int64 iOffset ;
  FileChunk *pChunk ;
}  ;
struct  MemJournal {
  sqlite3_io_methods *pMethod ;
  FileChunk *pFirst ;
  FilePoint endpoint ;
  FilePoint readpoint ;
}  ;
static  int memjrnlRead(sqlite3_file *pJfd , void *zBuf , int iAmt , sqlite_int64 iOfst )  {
  MemJournal *p =  ((MemJournal *) pJfd);
  u8 *zOut =  zBuf;
  int nRead =  iAmt;
  int iChunkOffset;
  FileChunk *pChunk;
  ((void ) 0);
  if (((p->readpoint.iOffset != iOfst) || (iOfst == 0))) {
    sqlite3_int64 iOff =  0;
    if (((id2i_sqlite_coverage_test ) )) {
      for ((pChunk = p->pFirst); (1 && ((iOff + ((int ) (1024 - sizeof(FileChunk *)))) <= iOfst)); (pChunk = pChunk->pNext)) {
        (iOff += ((int ) (1024 - sizeof(FileChunk *))));
      }
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      for ((pChunk = p->pFirst); (pChunk && ((iOff + ((int ) (1024 - sizeof(FileChunk *)))) <= iOfst)); (pChunk = pChunk->pNext)) {
        (iOff += ((int ) (1024 - sizeof(FileChunk *))));
      }
    }  
  }  
  else {
    (pChunk = p->readpoint.pChunk);
  }
  (iChunkOffset = ((int ) (iOfst % ((int ) (1024 - sizeof(FileChunk *))))));
  do {
    int iSpace =  (((int ) (1024 - sizeof(FileChunk *))) - iChunkOffset);
    int nCopy =  ((nRead < (((int ) (1024 - sizeof(FileChunk *))) - iChunkOffset)) ? nRead : (((int ) (1024 - sizeof(FileChunk *))) - iChunkOffset));
    memcpy(zOut, (&pChunk->zChunk[iChunkOffset]), nCopy);
    (zOut += nCopy);
    (nRead -= iSpace);
    (iChunkOffset = 0);
  } while (((nRead >= 0) && ((pChunk = pChunk->pNext) != 0) && (nRead > 0)));
  (p->readpoint.iOffset = (iOfst + iAmt));
  (p->readpoint.pChunk = pChunk);
  return 0;
}
static  int memjrnlWrite(sqlite3_file *pJfd , const  void *zBuf , int iAmt , sqlite_int64 iOfst )  {
  MemJournal *p =  ((MemJournal *) pJfd);
  int nWrite =  iAmt;
  u8 *zWrite =  ((u8 *) zBuf);
  ((void ) 0);
  ((void ) iOfst);
  while ((nWrite > 0)) {
    FileChunk *pChunk =  p->endpoint.pChunk;
    int iChunkOffset =  ((int ) (p->endpoint.iOffset % ((int ) (1024 - sizeof(FileChunk *)))));
    int iSpace =  ((nWrite < (((int ) (1024 - sizeof(FileChunk *))) - iChunkOffset)) ? nWrite : (((int ) (1024 - sizeof(FileChunk *))) - iChunkOffset));
    if ((iChunkOffset == 0)) {
      FileChunk *pNew =  sqlite3_malloc(sizeof(FileChunk ));
      if ((! pNew)) {
        return (10 | (12 << 8));
      }  
      (pNew->pNext = 0);
      if (pChunk) {
        ((void ) 0);
        (pChunk->pNext = pNew);
      }  
      else {
        ((void ) 0);
        (p->pFirst = pNew);
      }
      (p->endpoint.pChunk = pNew);
    }  
    memcpy((&p->endpoint.pChunk->zChunk[iChunkOffset]), zWrite, iSpace);
    (zWrite += iSpace);
    (nWrite -= iSpace);
    (p->endpoint.iOffset += iSpace);
  }
  return 0;
}
static  int memjrnlTruncate(sqlite3_file *pJfd , sqlite_int64 size )  {
  MemJournal *p =  ((MemJournal *) pJfd);
  FileChunk *pChunk;
  ((void ) 0);
  ((void ) size);
  (pChunk = p->pFirst);
  while (pChunk) {
    FileChunk *pTmp =  pChunk;
    (pChunk = pChunk->pNext);
    sqlite3_free(pTmp);
  }
  sqlite3MemJournalOpen(pJfd);
  return 0;
}
static  int memjrnlClose(sqlite3_file *pJfd )  {
  memjrnlTruncate(pJfd, 0);
  return 0;
}
static  int memjrnlSync(sqlite3_file *NotUsed , int NotUsed2 )  {
  ((void ) NotUsed), ((void ) NotUsed2);
  return 0;
}
static  int memjrnlFileSize(sqlite3_file *pJfd , sqlite_int64 *pSize )  {
  MemJournal *p =  ((MemJournal *) pJfd);
  ((*pSize) = ((sqlite_int64 ) p->endpoint.iOffset));
  return 0;
}
static const struct  sqlite3_io_methods   MemJournalMethods =  { 1,  memjrnlClose,  memjrnlRead,  memjrnlWrite,  memjrnlTruncate,  memjrnlSync,  memjrnlFileSize,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0};
static  void sqlite3MemJournalOpen(sqlite3_file *pJfd )  {
  MemJournal *p =  ((MemJournal *) pJfd);
  ((void ) 0);
  memset(p, 0, sqlite3MemJournalSize());
  (p->pMethod = ((sqlite3_io_methods *) (&MemJournalMethods)));
}
static  int sqlite3IsMemJournal(sqlite3_file *pJfd )  {
  return (pJfd->pMethods == (&MemJournalMethods));
}
static  int sqlite3MemJournalSize(void )  {
  return sizeof(MemJournal );
}
static  int sqlite3WalkExpr(Walker *pWalker , Expr *pExpr )  {
  int rc;
  if ((pExpr == 0)) {
    return 0;
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((pExpr->flags & 0x004000) != 0)) {
      sqlite3Coverage(74453);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((pExpr->flags & 0x002000) != 0)) {
      sqlite3Coverage(74454);
    }  
  }  
  (rc = pWalker->xExprCallback(pWalker, pExpr));
  if (((rc == 0) && (! ((pExpr->flags & 0x004000) != 0)))) {
    if (sqlite3WalkExpr(pWalker, pExpr->pLeft)) {
      return 2;
    }  
    if (sqlite3WalkExpr(pWalker, pExpr->pRight)) {
      return 2;
    }  
    if (((pExpr->flags & 0x000800) != 0)) {
      if (sqlite3WalkSelect(pWalker, pExpr->x.pSelect)) {
        return 2;
      }  
    }  
    else {
      if (sqlite3WalkExprList(pWalker, pExpr->x.pList)) {
        return 2;
      }  
    }
  }  
  return (rc & 2);
}
static  int sqlite3WalkExprList(Walker *pWalker , ExprList *p )  {
  int i;
  struct  ExprList_item   *pItem;
  if (p) {
    for ((i = p->nExpr), (pItem = p->a); (i > 0); i--, pItem++) {
      if (sqlite3WalkExpr(pWalker, pItem->pExpr)) {
        return 2;
      }  
    }
  }  
  return 0;
}
static  int sqlite3WalkSelectExpr(Walker *pWalker , Select *p )  {
  if (sqlite3WalkExprList(pWalker, p->pEList)) {
    return 2;
  }  
  if (sqlite3WalkExpr(pWalker, p->pWhere)) {
    return 2;
  }  
  if (sqlite3WalkExprList(pWalker, p->pGroupBy)) {
    return 2;
  }  
  if (sqlite3WalkExpr(pWalker, p->pHaving)) {
    return 2;
  }  
  if (sqlite3WalkExprList(pWalker, p->pOrderBy)) {
    return 2;
  }  
  if (sqlite3WalkExpr(pWalker, p->pLimit)) {
    return 2;
  }  
  if (sqlite3WalkExpr(pWalker, p->pOffset)) {
    return 2;
  }  
  return 0;
}
static  int sqlite3WalkSelectFrom(Walker *pWalker , Select *p )  {
  SrcList *pSrc;
  int i;
  struct  SrcList_item   *pItem;
  (pSrc = p->pSrc);
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      for ((i = pSrc->nSrc), (pItem = pSrc->a); (i > 0); i--, pItem++) {
        if (sqlite3WalkSelect(pWalker, pItem->pSelect)) {
          return 2;
        }  
      }
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pSrc) {
      for ((i = pSrc->nSrc), (pItem = pSrc->a); (i > 0); i--, pItem++) {
        if (sqlite3WalkSelect(pWalker, pItem->pSelect)) {
          return 2;
        }  
      }
    }  
  }  
  return 0;
}
static  int sqlite3WalkSelect(Walker *pWalker , Select *p )  {
  int rc;
  if (((p == 0) || (pWalker->xSelectCallback == 0))) {
    return 0;
  }  
  (rc = 0);
  pWalker->walkerDepth++;
  while (p) {
    if ((! pWalker->bSelectDepthFirst)) {
      (rc = pWalker->xSelectCallback(pWalker, p));
      if (rc) {
        break;
      }  
    }  
    if ((sqlite3WalkSelectExpr(pWalker, p) || sqlite3WalkSelectFrom(pWalker, p))) {
      pWalker->walkerDepth--;
      return 2;
    }  
    if (pWalker->bSelectDepthFirst) {
      (rc = pWalker->xSelectCallback(pWalker, p));
      if (((id2i_sqlite_coverage_test ) )) {
        if (0) {
          break;
        }  
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if (rc) {
          break;
        }  
      }  
    }  
    (p = p->pPrior);
  }
  pWalker->walkerDepth--;
  return (rc & 2);
}
static  int incrAggDepth(Walker *pWalker , Expr *pExpr )  {
  if ((pExpr->op == 153)) {
    (pExpr->op2 += pWalker->u.i);
  }  
  return 0;
}
static  void incrAggFunctionDepth(Expr *pExpr , int N )  {
  if ((N > 0)) {
    Walker w;
    memset((&w), 0, sizeof(w));
    (w.xExprCallback = incrAggDepth);
    (w.u.i = N);
    sqlite3WalkExpr((&w), pExpr);
  }  
}
static  void resolveAlias(Parse *pParse , ExprList *pEList , int iCol , Expr *pExpr , const  char *zType , int nSubquery )  {
  Expr *pOrig;
  Expr *pDup;
  sqlite3 *db;
  ((void ) 0);
  (pOrig = pEList->a[iCol].pExpr);
  ((void ) 0);
  ((void ) 0);
  (db = pParse->db);
  (pDup = sqlite3ExprDup(db, pOrig, 0));
  if ((pDup == 0)) {
    return;
  }  
  if (((pOrig->op != 152) && (zType[0] != 'G'))) {
    incrAggFunctionDepth(pDup, nSubquery);
    (pDup = sqlite3PExpr(pParse, 24, pDup, 0, 0));
    if ((pDup == 0)) {
      return;
    }  
    (pDup->flags |= 0x001000);
    if ((pEList->a[iCol].iAlias == 0)) {
      (pEList->a[iCol].iAlias = ((u16 ) ++pParse->nAlias));
    }  
    (pDup->iTable = pEList->a[iCol].iAlias);
  }  
  if ((pExpr->op == 92)) {
    (pDup = sqlite3ExprAddCollateString(pParse, pDup, pExpr->u.zToken));
  }  
  (pExpr->flags |= 0x008000);
  sqlite3ExprDelete(db, pExpr);
  memcpy(pExpr, pDup, sizeof((*pExpr)));
  if (((! ((pExpr->flags & 0x000400) != 0)) && (pExpr->u.zToken != 0))) {
    ((void ) 0);
    (pExpr->u.zToken = sqlite3DbStrDup(db, pExpr->u.zToken));
    (pExpr->flags |= 0x010000);
  }  
  sqlite3DbFree(db, pDup);
}
static  int nameInUsingClause(IdList *pUsing , const  char *zCol )  {
  if (pUsing) {
    int k;
    for ((k = 0); (k < pUsing->nId); k++) {
      if ((sqlite3_stricmp(pUsing->a[k].zName, zCol) == 0)) {
        return 1;
      }  
    }
  }  
  return 0;
}
static  int sqlite3MatchSpanName(const  char *zSpan , const  char *zCol , const  char *zTab , const  char *zDb )  {
  int n;
  if (((id2i_sqlite_coverage_test ) )) {
    for ((n = 0); (1 && (zSpan[n] != '.')); n++) {
      
    }
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    for ((n = 0); (zSpan[n] && (zSpan[n] != '.')); n++) {
      
    }
  }  
  if ((zDb && ((sqlite3_strnicmp(zSpan, zDb, n) != 0) || (zDb[n] != 0)))) {
    return 0;
  }  
  (zSpan += (n + 1));
  if (((id2i_sqlite_coverage_test ) )) {
    for ((n = 0); (1 && (zSpan[n] != '.')); n++) {
      
    }
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    for ((n = 0); (zSpan[n] && (zSpan[n] != '.')); n++) {
      
    }
  }  
  if ((zTab && ((sqlite3_strnicmp(zSpan, zTab, n) != 0) || (zTab[n] != 0)))) {
    return 0;
  }  
  (zSpan += (n + 1));
  if ((zCol && (sqlite3_stricmp(zSpan, zCol) != 0))) {
    return 0;
  }  
  return 1;
}
static  int lookupName(Parse *pParse , const  char *zDb , const  char *zTab , const  char *zCol , NameContext *pNC , Expr *pExpr )  {
  int i, j;
  int cnt =  0;
  int cntTab =  0;
  int nSubquery =  0;
  sqlite3 *db =  pParse->db;
  struct  SrcList_item   *pItem;
  struct  SrcList_item   *pMatch =  0;
  NameContext *pTopNC =  pNC;
  Schema *pSchema =  0;
  int isTrigger =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (pExpr->iTable = (- 1));
  (pExpr->pTab = 0);
  if (zDb) {
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pNC->ncFlags & 0x10)) {
        sqlite3Coverage(74811);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pNC->ncFlags & 0x04)) {
        sqlite3Coverage(74812);
      }  
    }  
    if (((pNC->ncFlags & (0x10 | 0x04)) != 0)) {
      (zDb = 0);
    }  
    else {
      for ((i = 0); (i < db->nDb); i++) {
        ((void ) 0);
        if ((sqlite3_stricmp(db->aDb[i].zName, zDb) == 0)) {
          (pSchema = db->aDb[i].pSchema);
          break;
        }  
      }
    }
  }  
  while ((pNC && (cnt == 0))) {
    ExprList *pEList;
    SrcList *pSrcList =  pNC->pSrcList;
    if (pSrcList) {
      for ((i = 0), (pItem = pSrcList->a); (i < pSrcList->nSrc); i++, pItem++) {
        Table *pTab;
        Column *pCol;
        (pTab = pItem->pTab);
        ((void ) 0);
        ((void ) 0);
        if ((pItem->pSelect && ((pItem->pSelect->selFlags & 0x0200) != 0))) {
          int hit =  0;
          (pEList = pItem->pSelect->pEList);
          for ((j = 0); (j < pEList->nExpr); j++) {
            if (sqlite3MatchSpanName(pEList->a[j].zSpan, zCol, zTab, zDb)) {
              cnt++;
              (cntTab = 2);
              (pMatch = pItem);
              (pExpr->iColumn = j);
              (hit = 1);
            }  
          }
          if ((hit || (zTab == 0))) {
            continue;
          }  
        }  
        if ((zDb && (pTab->pSchema != pSchema))) {
          continue;
        }  
        if (zTab) {
          const char *zTabName =  (pItem->zAlias ? pItem->zAlias : pTab->zName);
          ((void ) 0);
          if ((sqlite3_stricmp(zTabName, zTab) != 0)) {
            continue;
          }  
        }  
        if ((0 == cntTab++)) {
          (pMatch = pItem);
        }  
        for ((j = 0), (pCol = pTab->aCol); (j < pTab->nCol); j++, pCol++) {
          if ((sqlite3_stricmp(pCol->zName, zCol) == 0)) {
            if ((cnt == 1)) {
              if ((pItem->jointype & 0x0004)) {
                continue;
              }  
              if (nameInUsingClause(pItem->pUsing, zCol)) {
                continue;
              }  
            }  
            cnt++;
            (pMatch = pItem);
            (pExpr->iColumn = ((j == pTab->iPKey) ? (- 1) : ((i16 ) j)));
            break;
          }  
        }
      }
      if (pMatch) {
        (pExpr->iTable = pMatch->iCursor);
        (pExpr->pTab = pMatch->pTab);
        (pSchema = pExpr->pTab->pSchema);
      }  
    }  
    if (((zDb == 0) && (zTab != 0) && (cnt == 0) && (pParse->pTriggerTab != 0))) {
      int op =  pParse->eTriggerOp;
      Table *pTab =  0;
      ((void ) 0);
      if (((op != 106) && (sqlite3_stricmp("new", zTab) == 0))) {
        (pExpr->iTable = 1);
        (pTab = pParse->pTriggerTab);
      } 
      else if (((op != 105) && (sqlite3_stricmp("old", zTab) == 0))) {
        (pExpr->iTable = 0);
        (pTab = pParse->pTriggerTab);
      } 
      if (pTab) {
        int iCol;
        (pSchema = pTab->pSchema);
        cntTab++;
        for ((iCol = 0); (iCol < pTab->nCol); iCol++) {
          Column *pCol =  (&pTab->aCol[iCol]);
          if ((sqlite3_stricmp(pCol->zName, zCol) == 0)) {
            if ((iCol == pTab->iPKey)) {
              (iCol = (- 1));
            }  
            break;
          }  
        }
        if (((iCol >= pTab->nCol) && sqlite3IsRowid(zCol))) {
          (iCol = (- 1));
        }  
        if ((iCol < pTab->nCol)) {
          cnt++;
          if ((iCol < 0)) {
            (pExpr->affinity = 'd');
          } 
          else if ((pExpr->iTable == 0)) {
            if (((id2i_sqlite_coverage_test ) )) {
              if ((iCol == 31)) {
                sqlite3Coverage(74931);
              }  
            }  
            if (((id2i_sqlite_coverage_test ) )) {
              if ((iCol == 32)) {
                sqlite3Coverage(74932);
              }  
            }  
            (pParse->oldmask |= ((iCol >= 32) ? 0xffffffff : (((u32 ) 1) << iCol)));
          } 
          else {
            if (((id2i_sqlite_coverage_test ) )) {
              if ((iCol == 31)) {
                sqlite3Coverage(74935);
              }  
            }  
            if (((id2i_sqlite_coverage_test ) )) {
              if ((iCol == 32)) {
                sqlite3Coverage(74936);
              }  
            }  
            (pParse->newmask |= ((iCol >= 32) ? 0xffffffff : (((u32 ) 1) << iCol)));
          }
          (pExpr->iColumn = ((i16 ) iCol));
          (pExpr->pTab = pTab);
          (isTrigger = 1);
        }  
      }  
    }  
    if (((cnt == 0) && (cntTab == 1) && sqlite3IsRowid(zCol))) {
      (cnt = 1);
      (pExpr->iColumn = (- 1));
      (pExpr->affinity = 'd');
    }  
    if ((((pEList = pNC->pEList) != 0) && (zTab == 0) && (cnt == 0))) {
      for ((j = 0); (j < pEList->nExpr); j++) {
        char *zAs =  pEList->a[j].zName;
        if (((zAs != 0) && (sqlite3_stricmp(zAs, zCol) == 0))) {
          Expr *pOrig;
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (pOrig = pEList->a[j].pExpr);
          if ((((pNC->ncFlags & 0x01) == 0) && ((pOrig->flags & 0x000002) != 0))) {
            sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs);
            return 2;
          }  
          resolveAlias(pParse, pEList, j, pExpr, "", nSubquery);
          (cnt = 1);
          (pMatch = 0);
          ((void ) 0);
          goto lookupname_end;
        }  
      }
    }  
    if ((cnt == 0)) {
      (pNC = pNC->pNext);
      nSubquery++;
    }  
  }
  if (((cnt == 0) && (zTab == 0) && ((pExpr->flags & 0x000040) != 0))) {
    (pExpr->op = 94);
    (pExpr->pTab = 0);
    return 1;
  }  
  if ((cnt != 1)) {
    const char *zErr;
    (zErr = ((cnt == 0) ? "no such column" : "ambiguous column name"));
    if (zDb) {
      sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);
    } 
    else if (zTab) {
      sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol);
    } 
    else {
      sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol);
    }
    (pParse->checkSchema = 1);
    pTopNC->nErr++;
  }  
  if (((pExpr->iColumn >= 0) && (pMatch != 0))) {
    int n =  pExpr->iColumn;
    if (((id2i_sqlite_coverage_test ) )) {
      if ((n == (((int ) (sizeof(Bitmask ) * 8)) - 1))) {
        sqlite3Coverage(75050);
      }  
    }  
    if ((n >= ((int ) (sizeof(Bitmask ) * 8)))) {
      (n = (((int ) (sizeof(Bitmask ) * 8)) - 1));
    }  
    ((void ) 0);
    (pMatch->colUsed |= (((Bitmask ) 1) << n));
  }  
  sqlite3ExprDelete(db, pExpr->pLeft);
  (pExpr->pLeft = 0);
  sqlite3ExprDelete(db, pExpr->pRight);
  (pExpr->pRight = 0);
  (pExpr->op = (isTrigger ? 60 : 152));
  lookupname_end:
  if ((cnt == 1)) {
    ((void ) 0);
    if ((pExpr->op != 24)) {
      sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);
    }  
    for (; ; ) {
      ((void ) 0);
      pTopNC->nRef++;
      if ((pTopNC == pNC)) {
        break;
      }  
      (pTopNC = pTopNC->pNext);
    }
    return 1;
  }  
  else {
    return 2;
  }
}
static  Expr *sqlite3CreateColumnExpr(sqlite3 *db , SrcList *pSrc , int iSrc , int iCol )  {
  Expr *p =  sqlite3ExprAlloc(db, 152, 0, 0);
  if (p) {
    struct  SrcList_item   *pItem =  (&pSrc->a[iSrc]);
    (p->pTab = pItem->pTab);
    (p->iTable = pItem->iCursor);
    if ((p->pTab->iPKey == iCol)) {
      (p->iColumn = (- 1));
    }  
    else {
      (p->iColumn = ((ynVar ) iCol));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((iCol == ((int ) (sizeof(Bitmask ) * 8)))) {
          sqlite3Coverage(75099);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((iCol == (((int ) (sizeof(Bitmask ) * 8)) - 1))) {
          sqlite3Coverage(75100);
        }  
      }  
      (pItem->colUsed |= (((Bitmask ) 1) << ((iCol >= ((int ) (sizeof(Bitmask ) * 8))) ? (((int ) (sizeof(Bitmask ) * 8)) - 1) : iCol)));
    }
    (p->flags |= 0x000004);
  }  
  return p;
}
static  void notValidPartIdxWhere(Parse *pParse , NameContext *pNC , const  char *zMsg )  {
  if (((pNC->ncFlags & 0x10) != 0)) {
    sqlite3ErrorMsg(pParse, "%s prohibited in partial index WHERE clauses", zMsg);
  }  
}
static  void notValidCheckConstraint(Parse *pParse , NameContext *pNC , const  char *zMsg )  {
  if (((pNC->ncFlags & 0x04) != 0)) {
    sqlite3ErrorMsg(pParse, "%s prohibited in CHECK constraints", zMsg);
  }  
}
static  int exprProbability(Expr *p )  {
  double r =  (- 1.0);
  if ((p->op != 130)) {
    return (- 1);
  }  
  sqlite3AtoF(p->u.zToken, (&r), sqlite3Strlen30(p->u.zToken), 1);
  ((void ) 0);
  if ((r > 1.0)) {
    return (- 1);
  }  
  return ((int ) (r * 1000.0));
}
static  int resolveExprStep(Walker *pWalker , Expr *pExpr )  {
  NameContext *pNC;
  Parse *pParse;
  (pNC = pWalker->u.pNC);
  ((void ) 0);
  (pParse = pNC->pParse);
  ((void ) 0);
  if (((pExpr->flags & 0x000004) != 0)) {
    return 1;
  }  
  (pExpr->flags |= 0x000004);
  switch (pExpr->op) {
    case 26:
    {
      return lookupName(pParse, 0, 0, pExpr->u.zToken, pNC, pExpr);
    }
    case 118:
    {
      const char *zColumn;
      const char *zTable;
      const char *zDb;
      Expr *pRight;
      (pRight = pExpr->pRight);
      if ((pRight->op == 26)) {
        (zDb = 0);
        (zTable = pExpr->pLeft->u.zToken);
        (zColumn = pRight->u.zToken);
      }  
      else {
        ((void ) 0);
        (zDb = pExpr->pLeft->u.zToken);
        (zTable = pRight->pLeft->u.zToken);
        (zColumn = pRight->pRight->u.zToken);
      }
      return lookupName(pParse, zDb, zTable, zColumn, pNC, pExpr);
    }
    case 155:
    case 151:
    {
      ExprList *pList =  pExpr->x.pList;
      int n =  (pList ? pList->nExpr : 0);
      int no_such_func =  0;
      int wrong_num_args =  0;
      int is_agg =  0;
      int auth;
      int nId;
      const char *zId;
      FuncDef *pDef;
      u8 enc =  pParse->db->aDb[0].pSchema->enc;
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pExpr->op == 155)) {
          sqlite3Coverage(75251);
        }  
      }  
      ((void ) 0);
      notValidPartIdxWhere(pParse, pNC, "functions");
      (zId = pExpr->u.zToken);
      (nId = sqlite3Strlen30(zId));
      (pDef = sqlite3FindFunction(pParse->db, zId, nId, n, enc, 0));
      if ((pDef == 0)) {
        (pDef = sqlite3FindFunction(pParse->db, zId, nId, (- 2), enc, 0));
        if ((pDef == 0)) {
          (no_such_func = 1);
        }  
        else {
          (wrong_num_args = 1);
        }
      }  
      else {
        (is_agg = (pDef->xFunc == 0));
        if ((pDef->funcFlags & 0x400)) {
          (pExpr->flags |= (0x040000 | 0x001000));
          if ((n == 2)) {
            (pExpr->iTable = exprProbability(pList->a[1].pExpr));
            if ((pExpr->iTable < 0)) {
              sqlite3ErrorMsg(pParse, "second argument to likelihood() must be a " "constant between 0.0 and 1.0");
              pNC->nErr++;
            }  
          }  
          else {
            (pExpr->iTable = 62);
          }
        }  
      }
      if (pDef) {
        (auth = sqlite3AuthCheck(pParse, 31, 0, pDef->zName, 0));
        if ((auth != 0)) {
          if ((auth == 1)) {
            sqlite3ErrorMsg(pParse, "not authorized to use function: %s", pDef->zName);
            pNC->nErr++;
          }  
          (pExpr->op = 98);
          return 1;
        }  
      }  
      if ((is_agg && ((pNC->ncFlags & 0x01) == 0))) {
        sqlite3ErrorMsg(pParse, "misuse of aggregate function %.*s()", nId, zId);
        pNC->nErr++;
        (is_agg = 0);
      } 
      else if ((no_such_func && (pParse->db->init.busy == 0))) {
        sqlite3ErrorMsg(pParse, "no such function: %.*s", nId, zId);
        pNC->nErr++;
      }
      
      else if (wrong_num_args) {
        sqlite3ErrorMsg(pParse, "wrong number of arguments to function %.*s()", nId, zId);
        pNC->nErr++;
      } 
      if (is_agg) {
        (pNC->ncFlags &= (~ 0x01));
      }  
      sqlite3WalkExprList(pWalker, pList);
      if (is_agg) {
        NameContext *pNC2 =  pNC;
        (pExpr->op = 153);
        (pExpr->op2 = 0);
        while ((pNC2 && (! sqlite3FunctionUsesThisSrc(pExpr, pNC2->pSrcList)))) {
          pExpr->op2++;
          (pNC2 = pNC2->pNext);
        }
        if (pNC2) {
          (pNC2->ncFlags |= 0x02);
        }  
        (pNC->ncFlags |= 0x01);
      }  
      return 1;
    }
    case 116:
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((pExpr->op == 116)) {
        break;
      }  
    }  
    case 20:
    if (((id2i_sqlite_coverage_test && (! id2i_sqlite_omit_subquery)) )) {
      if ((pExpr->op == 20)) {
        sqlite3Coverage(75330);
      }  
    }  
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((pExpr->op == 20)) {
        break;
      }  
    }  
    case 72:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pExpr->op == 72)) {
          sqlite3Coverage(75333);
        }  
      }  
      if (((pExpr->flags & 0x000800) != 0)) {
        int nRef =  pNC->nRef;
        notValidCheckConstraint(pParse, pNC, "subqueries");
        notValidPartIdxWhere(pParse, pNC, "subqueries");
        sqlite3WalkSelect(pWalker, pExpr->x.pSelect);
        ((void ) 0);
        if ((nRef != pNC->nRef)) {
          (pExpr->flags |= 0x000020);
        }  
      }  
      break;
    }
    case 133:
    {
      notValidCheckConstraint(pParse, pNC, "parameters");
      notValidPartIdxWhere(pParse, pNC, "parameters");
      break;
    }
  }
  return ((pParse->nErr || pParse->db->mallocFailed) ? 2 : 0);
}
static  int resolveAsName(Parse *pParse , ExprList *pEList , Expr *pE )  {
  int i;
  ((void ) pParse);
  if ((pE->op == 26)) {
    char *zCol =  pE->u.zToken;
    for ((i = 0); (i < pEList->nExpr); i++) {
      char *zAs =  pEList->a[i].zName;
      if (((zAs != 0) && (sqlite3_stricmp(zAs, zCol) == 0))) {
        return (i + 1);
      }  
    }
  }  
  return 0;
}
static  int resolveOrderByTermToExprList(Parse *pParse , Select *pSelect , Expr *pE )  {
  int i;
  ExprList *pEList;
  NameContext nc;
  sqlite3 *db;
  int rc;
  u8 savedSuppErr;
  ((void ) 0);
  (pEList = pSelect->pEList);
  memset((&nc), 0, sizeof(nc));
  (nc.pParse = pParse);
  (nc.pSrcList = pSelect->pSrc);
  (nc.pEList = pEList);
  (nc.ncFlags = 0x01);
  (nc.nErr = 0);
  (db = pParse->db);
  (savedSuppErr = db->suppressErr);
  (db->suppressErr = 1);
  (rc = sqlite3ResolveExprNames((&nc), pE));
  (db->suppressErr = savedSuppErr);
  if (rc) {
    return 0;
  }  
  for ((i = 0); (i < pEList->nExpr); i++) {
    if ((sqlite3ExprCompare(pEList->a[i].pExpr, pE, (- 1)) < 2)) {
      return (i + 1);
    }  
  }
  return 0;
}
static  void resolveOutOfRangeError(Parse *pParse , const  char *zType , int i , int mx )  {
  sqlite3ErrorMsg(pParse, "%r %s BY term out of range - should be " "between 1 and %d", i, zType, mx);
}
static  int resolveCompoundOrderBy(Parse *pParse , Select *pSelect )  {
  int i;
  ExprList *pOrderBy;
  ExprList *pEList;
  sqlite3 *db;
  int moreToDo =  1;
  (pOrderBy = pSelect->pOrderBy);
  if ((pOrderBy == 0)) {
    return 0;
  }  
  (db = pParse->db);
  if ((pOrderBy->nExpr > db->aLimit[2])) {
    sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");
    return 1;
  }  
  for ((i = 0); (i < pOrderBy->nExpr); i++) {
    (pOrderBy->a[i].done = 0);
  }
  (pSelect->pNext = 0);
  while (pSelect->pPrior) {
    (pSelect->pPrior->pNext = pSelect);
    (pSelect = pSelect->pPrior);
  }
  while ((pSelect && moreToDo)) {
    struct  ExprList_item   *pItem;
    (moreToDo = 0);
    (pEList = pSelect->pEList);
    ((void ) 0);
    for ((i = 0), (pItem = pOrderBy->a); (i < pOrderBy->nExpr); i++, pItem++) {
      int iCol =  (- 1);
      Expr *pE, *pDup;
      if (pItem->done) {
        continue;
      }  
      (pE = sqlite3ExprSkipCollate(pItem->pExpr));
      if (sqlite3ExprIsInteger(pE, (&iCol))) {
        if (((iCol <= 0) || (iCol > pEList->nExpr))) {
          resolveOutOfRangeError(pParse, "ORDER", (i + 1), pEList->nExpr);
          return 1;
        }  
      }  
      else {
        (iCol = resolveAsName(pParse, pEList, pE));
        if ((iCol == 0)) {
          (pDup = sqlite3ExprDup(db, pE, 0));
          if ((! db->mallocFailed)) {
            ((void ) 0);
            (iCol = resolveOrderByTermToExprList(pParse, pSelect, pDup));
          }  
          sqlite3ExprDelete(db, pDup);
        }  
      }
      if ((iCol > 0)) {
        Expr *pNew =  sqlite3Expr(db, 129, 0);
        if ((pNew == 0)) {
          return 1;
        }  
        (pNew->flags |= 0x000400);
        (pNew->u.iValue = iCol);
        if ((pItem->pExpr == pE)) {
          (pItem->pExpr = pNew);
        }  
        else {
          ((void ) 0);
          ((void ) 0);
          (pItem->pExpr->pLeft = pNew);
        }
        sqlite3ExprDelete(db, pE);
        (pItem->iOrderByCol = ((u16 ) iCol));
        (pItem->done = 1);
      }  
      else {
        (moreToDo = 1);
      }
    }
    (pSelect = pSelect->pNext);
  }
  for ((i = 0); (i < pOrderBy->nExpr); i++) {
    if ((pOrderBy->a[i].done == 0)) {
      sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any " "column in the result set", (i + 1));
      return 1;
    }  
  }
  return 0;
}
static  int sqlite3ResolveOrderGroupBy(Parse *pParse , Select *pSelect , ExprList *pOrderBy , const  char *zType )  {
  int i;
  sqlite3 *db =  pParse->db;
  ExprList *pEList;
  struct  ExprList_item   *pItem;
  if (((pOrderBy == 0) || pParse->db->mallocFailed)) {
    return 0;
  }  
  if ((pOrderBy->nExpr > db->aLimit[2])) {
    sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType);
    return 1;
  }  
  (pEList = pSelect->pEList);
  ((void ) 0);
  for ((i = 0), (pItem = pOrderBy->a); (i < pOrderBy->nExpr); i++, pItem++) {
    if (pItem->iOrderByCol) {
      if ((pItem->iOrderByCol > pEList->nExpr)) {
        resolveOutOfRangeError(pParse, zType, (i + 1), pEList->nExpr);
        return 1;
      }  
      resolveAlias(pParse, pEList, (pItem->iOrderByCol - 1), pItem->pExpr, zType, 0);
    }  
  }
  return 0;
}
static  int resolveOrderGroupBy(NameContext *pNC , Select *pSelect , ExprList *pOrderBy , const  char *zType )  {
  int i, j;
  int iCol;
  struct  ExprList_item   *pItem;
  Parse *pParse;
  int nResult;
  if ((pOrderBy == 0)) {
    return 0;
  }  
  (nResult = pSelect->pEList->nExpr);
  (pParse = pNC->pParse);
  for ((i = 0), (pItem = pOrderBy->a); (i < pOrderBy->nExpr); i++, pItem++) {
    Expr *pE =  pItem->pExpr;
    Expr *pE2 =  sqlite3ExprSkipCollate(pE);
    if ((zType[0] != 'G')) {
      (iCol = resolveAsName(pParse, pSelect->pEList, pE2));
      if ((iCol > 0)) {
        (pItem->iOrderByCol = ((u16 ) iCol));
        continue;
      }  
    }  
    if (sqlite3ExprIsInteger(pE2, (&iCol))) {
      if (((iCol < 1) || (iCol > 0xffff))) {
        resolveOutOfRangeError(pParse, zType, (i + 1), nResult);
        return 1;
      }  
      (pItem->iOrderByCol = ((u16 ) iCol));
      continue;
    }  
    (pItem->iOrderByCol = 0);
    if (sqlite3ResolveExprNames(pNC, pE)) {
      return 1;
    }  
    for ((j = 0); (j < pSelect->pEList->nExpr); j++) {
      if ((sqlite3ExprCompare(pE, pSelect->pEList->a[j].pExpr, (- 1)) == 0)) {
        (pItem->iOrderByCol = (j + 1));
      }  
    }
  }
  return sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType);
}
static  int resolveSelectStep(Walker *pWalker , Select *p )  {
  NameContext *pOuterNC;
  NameContext sNC;
  int isCompound;
  int nCompound;
  Parse *pParse;
  ExprList *pEList;
  int i;
  ExprList *pGroupBy;
  Select *pLeftmost;
  sqlite3 *db;
  ((void ) 0);
  if ((p->selFlags & 0x0002)) {
    return 1;
  }  
  (pOuterNC = pWalker->u.pNC);
  (pParse = pWalker->pParse);
  (db = pParse->db);
  if (((p->selFlags & 0x0010) == 0)) {
    sqlite3SelectPrep(pParse, p, pOuterNC);
    return ((pParse->nErr || db->mallocFailed) ? 2 : 1);
  }  
  (isCompound = (p->pPrior != 0));
  (nCompound = 0);
  (pLeftmost = p);
  while (p) {
    ((void ) 0);
    ((void ) 0);
    (p->selFlags |= 0x0002);
    memset((&sNC), 0, sizeof(sNC));
    (sNC.pParse = pParse);
    if ((sqlite3ResolveExprNames((&sNC), p->pLimit) || sqlite3ResolveExprNames((&sNC), p->pOffset))) {
      return 2;
    }  
    for ((i = 0); (i < p->pSrc->nSrc); i++) {
      struct  SrcList_item   *pItem =  (&p->pSrc->a[i]);
      if (pItem->pSelect) {
        NameContext *pNC;
        int nRef =  0;
        const char *zSavedContext =  pParse->zAuthContext;
        for ((pNC = pOuterNC); pNC; (pNC = pNC->pNext)) {
          (nRef += pNC->nRef);
        }
        if (pItem->zName) {
          (pParse->zAuthContext = pItem->zName);
        }  
        sqlite3ResolveSelectNames(pParse, pItem->pSelect, pOuterNC);
        (pParse->zAuthContext = zSavedContext);
        if ((pParse->nErr || db->mallocFailed)) {
          return 2;
        }  
        for ((pNC = pOuterNC); pNC; (pNC = pNC->pNext)) {
          (nRef -= pNC->nRef);
        }
        ((void ) 0);
        (pItem->isCorrelated = (nRef != 0));
      }  
    }
    (sNC.ncFlags = 0x01);
    (sNC.pSrcList = p->pSrc);
    (sNC.pNext = pOuterNC);
    (pEList = p->pEList);
    ((void ) 0);
    for ((i = 0); (i < pEList->nExpr); i++) {
      Expr *pX =  pEList->a[i].pExpr;
      if (sqlite3ResolveExprNames((&sNC), pX)) {
        return 2;
      }  
    }
    ((void ) 0);
    (pGroupBy = p->pGroupBy);
    if ((pGroupBy || ((sNC.ncFlags & 0x02) != 0))) {
      (p->selFlags |= 0x0004);
    }  
    else {
      (sNC.ncFlags &= (~ 0x01));
    }
    if ((p->pHaving && (! pGroupBy))) {
      sqlite3ErrorMsg(pParse, "a GROUP BY clause is required before HAVING");
      return 2;
    }  
    (sNC.pEList = p->pEList);
    if (sqlite3ResolveExprNames((&sNC), p->pHaving)) {
      return 2;
    }  
    if (sqlite3ResolveExprNames((&sNC), p->pWhere)) {
      return 2;
    }  
    (sNC.pNext = 0);
    (sNC.ncFlags |= 0x01);
    if (((! isCompound) && resolveOrderGroupBy((&sNC), p, p->pOrderBy, "ORDER"))) {
      return 2;
    }  
    if (db->mallocFailed) {
      return 2;
    }  
    if (pGroupBy) {
      struct  ExprList_item   *pItem;
      if ((resolveOrderGroupBy((&sNC), p, pGroupBy, "GROUP") || db->mallocFailed)) {
        return 2;
      }  
      for ((i = 0), (pItem = pGroupBy->a); (i < pGroupBy->nExpr); i++, pItem++) {
        if (((pItem->pExpr->flags & 0x000002) != 0)) {
          sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in " "the GROUP BY clause");
          return 2;
        }  
      }
    }  
    (p = p->pPrior);
    nCompound++;
  }
  if ((isCompound && resolveCompoundOrderBy(pParse, pLeftmost))) {
    return 2;
  }  
  return 1;
}
static  int sqlite3ResolveExprNames(NameContext *pNC , Expr *pExpr )  {
  u8 savedHasAgg;
  Walker w;
  if ((pExpr == 0)) {
    return 0;
  }  
  {
    Parse *pParse =  pNC->pParse;
    if (sqlite3ExprCheckHeight(pParse, (pExpr->nHeight + pNC->pParse->nHeight))) {
      return 1;
    }  
    (pParse->nHeight += pExpr->nHeight);
  }
  (savedHasAgg = (pNC->ncFlags & 0x02));
  (pNC->ncFlags &= (~ 0x02));
  memset((&w), 0, sizeof(w));
  (w.xExprCallback = resolveExprStep);
  (w.xSelectCallback = resolveSelectStep);
  (w.pParse = pNC->pParse);
  (w.u.pNC = pNC);
  sqlite3WalkExpr((&w), pExpr);
  (pNC->pParse->nHeight -= pExpr->nHeight);
  if (((pNC->nErr > 0) || (w.pParse->nErr > 0))) {
    (pExpr->flags |= 0x000008);
  }  
  if ((pNC->ncFlags & 0x02)) {
    (pExpr->flags |= 0x000002);
  } 
  else if (savedHasAgg) {
    (pNC->ncFlags |= 0x02);
  } 
  return ((pExpr->flags & 0x000008) != 0);
}
static  void sqlite3ResolveSelectNames(Parse *pParse , Select *p , NameContext *pOuterNC )  {
  Walker w;
  ((void ) 0);
  memset((&w), 0, sizeof(w));
  (w.xExprCallback = resolveExprStep);
  (w.xSelectCallback = resolveSelectStep);
  (w.pParse = pParse);
  (w.u.pNC = pOuterNC);
  sqlite3WalkSelect((&w), p);
}
static  void sqlite3ResolveSelfReference(Parse *pParse , Table *pTab , int type , Expr *pExpr , ExprList *pList )  {
  SrcList sSrc;
  NameContext sNC;
  int i;
  ((void ) 0);
  memset((&sNC), 0, sizeof(sNC));
  memset((&sSrc), 0, sizeof(sSrc));
  (sSrc.nSrc = 1);
  (sSrc.a[0].zName = pTab->zName);
  (sSrc.a[0].pTab = pTab);
  (sSrc.a[0].iCursor = (- 1));
  (sNC.pParse = pParse);
  (sNC.pSrcList = (&sSrc));
  (sNC.ncFlags = type);
  if (sqlite3ResolveExprNames((&sNC), pExpr)) {
    return;
  }  
  if (pList) {
    for ((i = 0); (i < pList->nExpr); i++) {
      if (sqlite3ResolveExprNames((&sNC), pList->a[i].pExpr)) {
        return;
      }  
    }
  }  
}
static  char sqlite3ExprAffinity(Expr *pExpr )  {
  int op;
  (pExpr = sqlite3ExprSkipCollate(pExpr));
  (op = pExpr->op);
  if ((op == 116)) {
    ((void ) 0);
    return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);
  }  
  if ((((! id2i_sqlite_omit_cast) ) )) {
    if ((op == 37)) {
      ((void ) 0);
      return sqlite3AffinityType(pExpr->u.zToken, 0);
    }  
  }  
  if ((((op == 154) || (op == 152) || (op == 132)) && (pExpr->pTab != 0))) {
    int j =  pExpr->iColumn;
    if ((j < 0)) {
      return 'd';
    }  
    ((void ) 0);
    return pExpr->pTab->aCol[j].affinity;
  }  
  return pExpr->affinity;
}
static  Expr *sqlite3ExprAddCollateToken(Parse *pParse , Expr *pExpr , Token *pCollName )  {
  if ((pCollName->n > 0)) {
    Expr *pNew =  sqlite3ExprAlloc(pParse->db, 92, pCollName, 1);
    if (pNew) {
      (pNew->pLeft = pExpr);
      (pNew->flags |= (0x000100 | 0x001000));
      (pExpr = pNew);
    }  
  }  
  return pExpr;
}
static  Expr *sqlite3ExprAddCollateString(Parse *pParse , Expr *pExpr , const  char *zC )  {
  Token s;
  ((void ) 0);
  (s.z = zC);
  (s.n = sqlite3Strlen30(s.z));
  return sqlite3ExprAddCollateToken(pParse, pExpr, (&s));
}
static  Expr *sqlite3ExprSkipCollate(Expr *pExpr )  {
  while ((pExpr && ((pExpr->flags & 0x001000) != 0))) {
    if (((pExpr->flags & 0x040000) != 0)) {
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      (pExpr = pExpr->x.pList->a[0].pExpr);
    }  
    else {
      ((void ) 0);
      (pExpr = pExpr->pLeft);
    }
  }
  return pExpr;
}
static  CollSeq *sqlite3ExprCollSeq(Parse *pParse , Expr *pExpr )  {
  sqlite3 *db =  pParse->db;
  CollSeq *pColl =  0;
  Expr *p =  pExpr;
  while (p) {
    int op =  p->op;
    if (((op == 37) || (op == 157))) {
      (p = p->pLeft);
      continue;
    }  
    if (((op == 92) || ((op == 132) && (p->op2 == 92)))) {
      (pColl = sqlite3GetCollSeq(pParse, db->aDb[0].pSchema->enc, 0, p->u.zToken));
      break;
    }  
    if (((p->pTab != 0) && ((op == 154) || (op == 152) || (op == 132) || (op == 60)))) {
      int j =  p->iColumn;
      if ((j >= 0)) {
        const char *zColl =  p->pTab->aCol[j].zColl;
        (pColl = sqlite3FindCollSeq(db, db->aDb[0].pSchema->enc, zColl, 0));
      }  
      break;
    }  
    if ((p->flags & 0x000100)) {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((1 && ((p->pLeft->flags & 0x000100) != 0))) {
          (p = p->pLeft);
        }  
        else {
          (p = p->pRight);
        }
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if ((p->pLeft && ((p->pLeft->flags & 0x000100) != 0))) {
          (p = p->pLeft);
        }  
        else {
          (p = p->pRight);
        }
      }  
    }  
    else {
      break;
    }
  }
  if (sqlite3CheckCollSeq(pParse, pColl)) {
    (pColl = 0);
  }  
  return pColl;
}
static  char sqlite3CompareAffinity(Expr *pExpr , char aff2 )  {
  char aff1 =  sqlite3ExprAffinity(pExpr);
  if ((aff1 && aff2)) {
    if (((aff1 >= 'c') || (aff2 >= 'c'))) {
      return 'c';
    }  
    else {
      return 'b';
    }
  } 
  else if (((! aff1) && (! aff2))) {
    return 'b';
  } 
  else {
    ((void ) 0);
    return (aff1 + aff2);
  }
}
static  char comparisonAffinity(Expr *pExpr )  {
  char aff;
  ((void ) 0);
  ((void ) 0);
  (aff = sqlite3ExprAffinity(pExpr->pLeft));
  if (pExpr->pRight) {
    (aff = sqlite3CompareAffinity(pExpr->pRight, aff));
  } 
  else if (((pExpr->flags & 0x000800) != 0)) {
    (aff = sqlite3CompareAffinity(pExpr->x.pSelect->pEList->a[0].pExpr, aff));
  }
  
  else if ((! aff)) {
    (aff = 'b');
  } 
  return aff;
}
static  int sqlite3IndexAffinityOk(Expr *pExpr , char idx_affinity )  {
  char aff =  comparisonAffinity(pExpr);
  switch (aff) {
    case 'b':
    return 1;
    case 'a':
    return (idx_affinity == 'a');
    id2i_label_1:
    default:
    return (idx_affinity >= 'c');
  }
}
static  u8 binaryCompareP5(Expr *pExpr1 , Expr *pExpr2 , int jumpIfNull )  {
  u8 aff =  ((char ) sqlite3ExprAffinity(pExpr2));
  (aff = (((u8 ) sqlite3CompareAffinity(pExpr1, aff)) | ((u8 ) jumpIfNull)));
  return aff;
}
static  CollSeq *sqlite3BinaryCompareCollSeq(Parse *pParse , Expr *pLeft , Expr *pRight )  {
  CollSeq *pColl;
  ((void ) 0);
  if ((pLeft->flags & 0x000100)) {
    (pColl = sqlite3ExprCollSeq(pParse, pLeft));
  } 
  else if ((pRight && ((pRight->flags & 0x000100) != 0))) {
    (pColl = sqlite3ExprCollSeq(pParse, pRight));
  } 
  else {
    (pColl = sqlite3ExprCollSeq(pParse, pLeft));
    if ((! pColl)) {
      (pColl = sqlite3ExprCollSeq(pParse, pRight));
    }  
  }
  return pColl;
}
static  int codeCompare(Parse *pParse , Expr *pLeft , Expr *pRight , int opcode , int in1 , int in2 , int dest , int jumpIfNull )  {
  int p5;
  int addr;
  CollSeq *p4;
  (p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight));
  (p5 = binaryCompareP5(pLeft, pRight, jumpIfNull));
  (addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1, ((void *) p4), (- 4)));
  sqlite3VdbeChangeP5(pParse->pVdbe, ((u8 ) p5));
  return addr;
}
static  int sqlite3ExprCheckHeight(Parse *pParse , int nHeight )  {
  int rc =  0;
  int mxHeight =  pParse->db->aLimit[3];
  if ((nHeight > mxHeight)) {
    sqlite3ErrorMsg(pParse, "Expression tree is too large (maximum depth %d)", mxHeight);
    (rc = 1);
  }  
  return rc;
}
static  void heightOfExpr(Expr *p , int *pnHeight )  {
  if (p) {
    if ((p->nHeight > (*pnHeight))) {
      ((*pnHeight) = p->nHeight);
    }  
  }  
}
static  void heightOfExprList(ExprList *p , int *pnHeight )  {
  if (p) {
    int i;
    for ((i = 0); (i < p->nExpr); i++) {
      heightOfExpr(p->a[i].pExpr, pnHeight);
    }
  }  
}
static  void heightOfSelect(Select *p , int *pnHeight )  {
  if (p) {
    heightOfExpr(p->pWhere, pnHeight);
    heightOfExpr(p->pHaving, pnHeight);
    heightOfExpr(p->pLimit, pnHeight);
    heightOfExpr(p->pOffset, pnHeight);
    heightOfExprList(p->pEList, pnHeight);
    heightOfExprList(p->pGroupBy, pnHeight);
    heightOfExprList(p->pOrderBy, pnHeight);
    heightOfSelect(p->pPrior, pnHeight);
  }  
}
static  void exprSetHeight(Expr *p )  {
  int nHeight =  0;
  heightOfExpr(p->pLeft, (&nHeight));
  heightOfExpr(p->pRight, (&nHeight));
  if (((p->flags & 0x000800) != 0)) {
    heightOfSelect(p->x.pSelect, (&nHeight));
  }  
  else {
    heightOfExprList(p->x.pList, (&nHeight));
  }
  (p->nHeight = (nHeight + 1));
}
static  void sqlite3ExprSetHeight(Parse *pParse , Expr *p )  {
  exprSetHeight(p);
  sqlite3ExprCheckHeight(pParse, p->nHeight);
}
static  int sqlite3SelectExprHeight(Select *p )  {
  int nHeight =  0;
  heightOfSelect(p, (&nHeight));
  return nHeight;
}
static  Expr *sqlite3ExprAlloc(sqlite3 *db , int op , const  Token *pToken , int dequote )  {
  Expr *pNew;
  int nExtra =  0;
  int iValue =  0;
  if (pToken) {
    if (((op != 129) || (pToken->z == 0) || (sqlite3GetInt32(pToken->z, (&iValue)) == 0))) {
      (nExtra = (pToken->n + 1));
      ((void ) 0);
    }  
  }  
  (pNew = sqlite3DbMallocZero(db, (sizeof(Expr ) + nExtra)));
  if (pNew) {
    (pNew->op = ((u8 ) op));
    (pNew->iAgg = (- 1));
    if (pToken) {
      if ((nExtra == 0)) {
        (pNew->flags |= 0x000400);
        (pNew->u.iValue = iValue);
      }  
      else {
        int c;
        (pNew->u.zToken = ((char *) (&pNew[1])));
        ((void ) 0);
        if (pToken->n) {
          memcpy(pNew->u.zToken, pToken->z, pToken->n);
        }  
        (pNew->u.zToken[pToken->n] = 0);
        if ((dequote && (nExtra >= 3) && (((c = pToken->z[0]) == '\'') || (c == '"') || (c == '[') || (c == '`')))) {
          sqlite3Dequote(pNew->u.zToken);
          if ((c == '"')) {
            (pNew->flags |= 0x000040);
          }  
        }  
      }
    }  
    (pNew->nHeight = 1);
  }  
  return pNew;
}
static  Expr *sqlite3Expr(sqlite3 *db , int op , const  char *zToken )  {
  Token x;
  (x.z = zToken);
  (x.n = (zToken ? sqlite3Strlen30(zToken) : 0));
  return sqlite3ExprAlloc(db, op, (&x), 0);
}
static  void sqlite3ExprAttachSubtrees(sqlite3 *db , Expr *pRoot , Expr *pLeft , Expr *pRight )  {
  if ((pRoot == 0)) {
    ((void ) 0);
    sqlite3ExprDelete(db, pLeft);
    sqlite3ExprDelete(db, pRight);
  }  
  else {
    if (pRight) {
      (pRoot->pRight = pRight);
      (pRoot->flags |= (0x000100 & pRight->flags));
    }  
    if (pLeft) {
      (pRoot->pLeft = pLeft);
      (pRoot->flags |= (0x000100 & pLeft->flags));
    }  
    exprSetHeight(pRoot);
  }
}
static  Expr *sqlite3PExpr(Parse *pParse , int op , Expr *pLeft , Expr *pRight , const  Token *pToken )  {
  Expr *p;
  if (((op == 69) && pLeft && pRight)) {
    (p = sqlite3ExprAnd(pParse->db, pLeft, pRight));
  }  
  else {
    (p = sqlite3ExprAlloc(pParse->db, op, pToken, 1));
    sqlite3ExprAttachSubtrees(pParse->db, p, pLeft, pRight);
  }
  if (p) {
    sqlite3ExprCheckHeight(pParse, p->nHeight);
  }  
  return p;
}
static  int exprAlwaysFalse(Expr *p )  {
  int v =  0;
  if (((p->flags & 0x000001) != 0)) {
    return 0;
  }  
  if ((! sqlite3ExprIsInteger(p, (&v)))) {
    return 0;
  }  
  return (v == 0);
}
static  Expr *sqlite3ExprAnd(sqlite3 *db , Expr *pLeft , Expr *pRight )  {
  if ((pLeft == 0)) {
    return pRight;
  } 
  else if ((pRight == 0)) {
    return pLeft;
  }
  
  else if ((exprAlwaysFalse(pLeft) || exprAlwaysFalse(pRight))) {
    sqlite3ExprDelete(db, pLeft);
    sqlite3ExprDelete(db, pRight);
    return sqlite3ExprAlloc(db, 129, (&sqlite3IntTokens[0]), 0);
  } 
  else {
    Expr *pNew =  sqlite3ExprAlloc(db, 69, 0, 0);
    sqlite3ExprAttachSubtrees(db, pNew, pLeft, pRight);
    return pNew;
  }
}
static  Expr *sqlite3ExprFunction(Parse *pParse , ExprList *pList , Token *pToken )  {
  Expr *pNew;
  sqlite3 *db =  pParse->db;
  ((void ) 0);
  (pNew = sqlite3ExprAlloc(db, 151, pToken, 1));
  if ((pNew == 0)) {
    sqlite3ExprListDelete(db, pList);
    return 0;
  }  
  (pNew->x.pList = pList);
  ((void ) 0);
  sqlite3ExprSetHeight(pParse, pNew);
  return pNew;
}
static  void sqlite3ExprAssignVarNumber(Parse *pParse , Expr *pExpr )  {
  sqlite3 *db =  pParse->db;
  const char *z;
  if ((pExpr == 0)) {
    return;
  }  
  ((void ) 0);
  (z = pExpr->u.zToken);
  ((void ) 0);
  ((void ) 0);
  if ((z[1] == 0)) {
    ((void ) 0);
    (pExpr->iColumn = ((ynVar ) ++pParse->nVar));
  }  
  else {
    ynVar x =  0;
    u32 n =  sqlite3Strlen30(z);
    if ((z[0] == '?')) {
      i64 i;
      int bOk =  (0 == sqlite3Atoi64((&z[1]), (&i), (n - 1), 1));
      (pExpr->iColumn = (x = ((ynVar ) i)));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 0)) {
          sqlite3Coverage(76643);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 1)) {
          sqlite3Coverage(76644);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == (db->aLimit[9] - 1))) {
          sqlite3Coverage(76645);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == db->aLimit[9])) {
          sqlite3Coverage(76646);
        }  
      }  
      if (((bOk == 0) || (i < 1) || (i > db->aLimit[9]))) {
        sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d", db->aLimit[9]);
        (x = 0);
      }  
      if ((i > pParse->nVar)) {
        (pParse->nVar = ((int ) i));
      }  
    }  
    else {
      ynVar i;
      for ((i = 0); (i < pParse->nzVar); i++) {
        if ((pParse->azVar[i] && (strcmp(pParse->azVar[i], z) == 0))) {
          (pExpr->iColumn = (x = (((ynVar ) i) + 1)));
          break;
        }  
      }
      if ((x == 0)) {
        (x = (pExpr->iColumn = ((ynVar ) ++pParse->nVar)));
      }  
    }
    if ((x > 0)) {
      if ((x > pParse->nzVar)) {
        char **a;
        (a = sqlite3DbRealloc(db, pParse->azVar, (x * sizeof(a[0]))));
        if ((a == 0)) {
          return;
        }  
        (pParse->azVar = a);
        memset((&a[pParse->nzVar]), 0, ((x - pParse->nzVar) * sizeof(a[0])));
        (pParse->nzVar = x);
      }  
      if (((z[0] != '?') || (pParse->azVar[(x - 1)] == 0))) {
        sqlite3DbFree(db, pParse->azVar[(x - 1)]);
        (pParse->azVar[(x - 1)] = sqlite3DbStrNDup(db, z, n));
      }  
    }  
  }
  if (((! pParse->nErr) && (pParse->nVar > db->aLimit[9]))) {
    sqlite3ErrorMsg(pParse, "too many SQL variables");
  }  
}
static  void sqlite3ExprDelete(sqlite3 *db , Expr *p )  {
  if ((p == 0)) {
    return;
  }  
  ((void ) 0);
  if ((! ((p->flags & 0x004000) != 0))) {
    ((void ) 0);
    sqlite3ExprDelete(db, p->pLeft);
    sqlite3ExprDelete(db, p->pRight);
    if (((p->flags & 0x010000) != 0)) {
      sqlite3DbFree(db, p->u.zToken);
    }  
    if (((p->flags & 0x000800) != 0)) {
      sqlite3SelectDelete(db, p->x.pSelect);
    }  
    else {
      sqlite3ExprListDelete(db, p->x.pList);
    }
  }  
  if ((! ((p->flags & 0x008000) != 0))) {
    sqlite3DbFree(db, p);
  }  
}
static  int exprStructSize(Expr *p )  {
  if (((p->flags & 0x004000) != 0)) {
    return __builtin_offsetof(Expr , pLeft);
  }  
  if (((p->flags & 0x002000) != 0)) {
    return __builtin_offsetof(Expr , iTable);
  }  
  return sizeof(Expr );
}
static  int dupedExprStructSize(Expr *p , int flags )  {
  int nSize;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((0 == (flags & 0x0001))) {
    (nSize = sizeof(Expr ));
  }  
  else {
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    if ((p->pLeft || p->x.pList)) {
      (nSize = (__builtin_offsetof(Expr , iTable) | 0x002000));
    }  
    else {
      ((void ) 0);
      (nSize = (__builtin_offsetof(Expr , pLeft) | 0x004000));
    }
  }
  return nSize;
}
static  int dupedExprNodeSize(Expr *p , int flags )  {
  int nByte =  (dupedExprStructSize(p, flags) & 0xfff);
  if (((! ((p->flags & 0x000400) != 0)) && p->u.zToken)) {
    (nByte += (sqlite3Strlen30(p->u.zToken) + 1));
  }  
  return ((nByte + 7) & (~ 7));
}
static  int dupedExprSize(Expr *p , int flags )  {
  int nByte =  0;
  if (p) {
    (nByte = dupedExprNodeSize(p, flags));
    if ((flags & 0x0001)) {
      (nByte += (dupedExprSize(p->pLeft, flags) + dupedExprSize(p->pRight, flags)));
    }  
  }  
  return nByte;
}
static  Expr *exprDup(sqlite3 *db , Expr *p , int flags , u8 **pzBuffer )  {
  Expr *pNew =  0;
  if (p) {
    const int isReduced =  (flags & 0x0001);
    u8 *zAlloc;
    u32 staticFlag =  0;
    ((void ) 0);
    if (pzBuffer) {
      (zAlloc = (*pzBuffer));
      (staticFlag = 0x008000);
    }  
    else {
      (zAlloc = sqlite3DbMallocRaw(db, dupedExprSize(p, flags)));
    }
    (pNew = ((Expr *) zAlloc));
    if (pNew) {
      const unsigned nStructSize =  dupedExprStructSize(p, flags);
      const int nNewSize =  (nStructSize & 0xfff);
      int nToken;
      if (((! ((p->flags & 0x000400) != 0)) && p->u.zToken)) {
        (nToken = (sqlite3Strlen30(p->u.zToken) + 1));
      }  
      else {
        (nToken = 0);
      }
      if (isReduced) {
        ((void ) 0);
        memcpy(zAlloc, p, nNewSize);
      }  
      else {
        int nSize =  exprStructSize(p);
        memcpy(zAlloc, p, nSize);
        memset((&zAlloc[nSize]), 0, (sizeof(Expr ) - nSize));
      }
      (pNew->flags &= (~ (0x002000 | 0x004000 | 0x008000 | 0x010000)));
      (pNew->flags |= (nStructSize & (0x002000 | 0x004000)));
      (pNew->flags |= staticFlag);
      if (nToken) {
        char *zToken =  (pNew->u.zToken = ((char *) (&zAlloc[nNewSize])));
        memcpy(zToken, p->u.zToken, nToken);
      }  
      if ((0 == ((p->flags | pNew->flags) & 0x004000))) {
        if (((p->flags & 0x000800) != 0)) {
          (pNew->x.pSelect = sqlite3SelectDup(db, p->x.pSelect, isReduced));
        }  
        else {
          (pNew->x.pList = sqlite3ExprListDup(db, p->x.pList, isReduced));
        }
      }  
      if (((pNew->flags & (0x002000 | 0x004000)) != 0)) {
        (zAlloc += dupedExprNodeSize(p, flags));
        if (((pNew->flags & 0x002000) != 0)) {
          (pNew->pLeft = exprDup(db, p->pLeft, 0x0001, (&zAlloc)));
          (pNew->pRight = exprDup(db, p->pRight, 0x0001, (&zAlloc)));
        }  
        if (pzBuffer) {
          ((*pzBuffer) = zAlloc);
        }  
      }  
      else {
        if ((! ((p->flags & 0x004000) != 0))) {
          (pNew->pLeft = sqlite3ExprDup(db, p->pLeft, 0));
          (pNew->pRight = sqlite3ExprDup(db, p->pRight, 0));
        }  
      }
    }  
  }  
  return pNew;
}
static  Expr *sqlite3ExprDup(sqlite3 *db , Expr *p , int flags )  {
  return exprDup(db, p, flags, 0);
}
static  ExprList *sqlite3ExprListDup(sqlite3 *db , ExprList *p , int flags )  {
  ExprList *pNew;
  struct  ExprList_item   *pItem, *pOldItem;
  int i;
  if ((p == 0)) {
    return 0;
  }  
  (pNew = sqlite3DbMallocRaw(db, sizeof((*pNew))));
  if ((pNew == 0)) {
    return 0;
  }  
  (pNew->iECursor = 0);
  (pNew->nExpr = (i = p->nExpr));
  if (((flags & 0x0001) == 0)) {
    for ((i = 1); (i < p->nExpr); (i += i)) {
      
    }
  }  
  (pNew->a = (pItem = sqlite3DbMallocRaw(db, (i * sizeof(p->a[0])))));
  if ((pItem == 0)) {
    sqlite3DbFree(db, pNew);
    return 0;
  }  
  (pOldItem = p->a);
  for ((i = 0); (i < p->nExpr); i++, pItem++, pOldItem++) {
    Expr *pOldExpr =  pOldItem->pExpr;
    (pItem->pExpr = sqlite3ExprDup(db, pOldExpr, flags));
    (pItem->zName = sqlite3DbStrDup(db, pOldItem->zName));
    (pItem->zSpan = sqlite3DbStrDup(db, pOldItem->zSpan));
    (pItem->sortOrder = pOldItem->sortOrder);
    (pItem->done = 0);
    (pItem->bSpanIsTab = pOldItem->bSpanIsTab);
    (pItem->iOrderByCol = pOldItem->iOrderByCol);
    (pItem->iAlias = pOldItem->iAlias);
  }
  return pNew;
}
static  SrcList *sqlite3SrcListDup(sqlite3 *db , SrcList *p , int flags )  {
  SrcList *pNew;
  int i;
  int nByte;
  if ((p == 0)) {
    return 0;
  }  
  (nByte = (sizeof((*p)) + ((p->nSrc > 0) ? (sizeof(p->a[0]) * (p->nSrc - 1)) : 0)));
  (pNew = sqlite3DbMallocRaw(db, nByte));
  if ((pNew == 0)) {
    return 0;
  }  
  (pNew->nSrc = (pNew->nAlloc = p->nSrc));
  for ((i = 0); (i < p->nSrc); i++) {
    struct  SrcList_item   *pNewItem =  (&pNew->a[i]);
    struct  SrcList_item   *pOldItem =  (&p->a[i]);
    Table *pTab;
    (pNewItem->pSchema = pOldItem->pSchema);
    (pNewItem->zDatabase = sqlite3DbStrDup(db, pOldItem->zDatabase));
    (pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName));
    (pNewItem->zAlias = sqlite3DbStrDup(db, pOldItem->zAlias));
    (pNewItem->jointype = pOldItem->jointype);
    (pNewItem->iCursor = pOldItem->iCursor);
    (pNewItem->addrFillSub = pOldItem->addrFillSub);
    (pNewItem->regReturn = pOldItem->regReturn);
    (pNewItem->isCorrelated = pOldItem->isCorrelated);
    (pNewItem->viaCoroutine = pOldItem->viaCoroutine);
    (pNewItem->zIndex = sqlite3DbStrDup(db, pOldItem->zIndex));
    (pNewItem->notIndexed = pOldItem->notIndexed);
    (pNewItem->pIndex = pOldItem->pIndex);
    (pTab = (pNewItem->pTab = pOldItem->pTab));
    if (pTab) {
      pTab->nRef++;
    }  
    (pNewItem->pSelect = sqlite3SelectDup(db, pOldItem->pSelect, flags));
    (pNewItem->pOn = sqlite3ExprDup(db, pOldItem->pOn, flags));
    (pNewItem->pUsing = sqlite3IdListDup(db, pOldItem->pUsing));
    (pNewItem->colUsed = pOldItem->colUsed);
  }
  return pNew;
}
static  IdList *sqlite3IdListDup(sqlite3 *db , IdList *p )  {
  IdList *pNew;
  int i;
  if ((p == 0)) {
    return 0;
  }  
  (pNew = sqlite3DbMallocRaw(db, sizeof((*pNew))));
  if ((pNew == 0)) {
    return 0;
  }  
  (pNew->nId = p->nId);
  (pNew->a = sqlite3DbMallocRaw(db, (p->nId * sizeof(p->a[0]))));
  if ((pNew->a == 0)) {
    sqlite3DbFree(db, pNew);
    return 0;
  }  
  for ((i = 0); (i < p->nId); i++) {
    struct  IdList_item   *pNewItem =  (&pNew->a[i]);
    struct  IdList_item   *pOldItem =  (&p->a[i]);
    (pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName));
    (pNewItem->idx = pOldItem->idx);
  }
  return pNew;
}
static  Select *sqlite3SelectDup(sqlite3 *db , Select *p , int flags )  {
  Select *pNew, *pPrior;
  if ((p == 0)) {
    return 0;
  }  
  (pNew = sqlite3DbMallocRaw(db, sizeof((*p))));
  if ((pNew == 0)) {
    return 0;
  }  
  (pNew->pEList = sqlite3ExprListDup(db, p->pEList, flags));
  (pNew->pSrc = sqlite3SrcListDup(db, p->pSrc, flags));
  (pNew->pWhere = sqlite3ExprDup(db, p->pWhere, flags));
  (pNew->pGroupBy = sqlite3ExprListDup(db, p->pGroupBy, flags));
  (pNew->pHaving = sqlite3ExprDup(db, p->pHaving, flags));
  (pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, flags));
  (pNew->op = p->op);
  (pNew->pPrior = (pPrior = sqlite3SelectDup(db, p->pPrior, flags)));
  if (pPrior) {
    (pPrior->pNext = pNew);
  }  
  (pNew->pNext = 0);
  (pNew->pLimit = sqlite3ExprDup(db, p->pLimit, flags));
  (pNew->pOffset = sqlite3ExprDup(db, p->pOffset, flags));
  (pNew->iLimit = 0);
  (pNew->iOffset = 0);
  (pNew->selFlags = (p->selFlags & (~ 0x0008)));
  (pNew->pRightmost = 0);
  (pNew->addrOpenEphm[0] = (- 1));
  (pNew->addrOpenEphm[1] = (- 1));
  (pNew->addrOpenEphm[2] = (- 1));
  return pNew;
}
static  ExprList *sqlite3ExprListAppend(Parse *pParse , ExprList *pList , Expr *pExpr )  {
  sqlite3 *db =  pParse->db;
  if ((pList == 0)) {
    (pList = sqlite3DbMallocZero(db, sizeof(ExprList )));
    if ((pList == 0)) {
      goto no_mem;
    }  
    (pList->a = sqlite3DbMallocRaw(db, sizeof(pList->a[0])));
    if ((pList->a == 0)) {
      goto no_mem;
    }  
  } 
  else if (((pList->nExpr & (pList->nExpr - 1)) == 0)) {
    struct  ExprList_item   *a;
    ((void ) 0);
    (a = sqlite3DbRealloc(db, pList->a, (pList->nExpr * 2 * sizeof(pList->a[0]))));
    if ((a == 0)) {
      goto no_mem;
    }  
    (pList->a = a);
  } 
  ((void ) 0);
  if (1) {
    struct  ExprList_item   *pItem =  (&pList->a[pList->nExpr++]);
    memset(pItem, 0, sizeof((*pItem)));
    (pItem->pExpr = pExpr);
  }  
  return pList;
  no_mem:
  sqlite3ExprDelete(db, pExpr);
  sqlite3ExprListDelete(db, pList);
  return 0;
}
static  void sqlite3ExprListSetName(Parse *pParse , ExprList *pList , Token *pName , int dequote )  {
  ((void ) 0);
  if (pList) {
    struct  ExprList_item   *pItem;
    ((void ) 0);
    (pItem = (&pList->a[(pList->nExpr - 1)]));
    ((void ) 0);
    (pItem->zName = sqlite3DbStrNDup(pParse->db, pName->z, pName->n));
    if ((dequote && pItem->zName)) {
      sqlite3Dequote(pItem->zName);
    }  
  }  
}
static  void sqlite3ExprListSetSpan(Parse *pParse , ExprList *pList , ExprSpan *pSpan )  {
  sqlite3 *db =  pParse->db;
  ((void ) 0);
  if (pList) {
    struct  ExprList_item   *pItem =  (&pList->a[(pList->nExpr - 1)]);
    ((void ) 0);
    ((void ) 0);
    sqlite3DbFree(db, pItem->zSpan);
    (pItem->zSpan = sqlite3DbStrNDup(db, ((char *) pSpan->zStart), ((int ) (pSpan->zEnd - pSpan->zStart))));
  }  
}
static  void sqlite3ExprListCheckLength(Parse *pParse , ExprList *pEList , const  char *zObject )  {
  int mx =  pParse->db->aLimit[2];
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pEList && (pEList->nExpr == mx))) {
      sqlite3Coverage(77165);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pEList && (pEList->nExpr == (mx + 1)))) {
      sqlite3Coverage(77166);
    }  
  }  
  if ((pEList && (pEList->nExpr > mx))) {
    sqlite3ErrorMsg(pParse, "too many columns in %s", zObject);
  }  
}
static  void sqlite3ExprListDelete(sqlite3 *db , ExprList *pList )  {
  int i;
  struct  ExprList_item   *pItem;
  if ((pList == 0)) {
    return;
  }  
  ((void ) 0);
  for ((pItem = pList->a), (i = 0); (i < pList->nExpr); i++, pItem++) {
    sqlite3ExprDelete(db, pItem->pExpr);
    sqlite3DbFree(db, pItem->zName);
    sqlite3DbFree(db, pItem->zSpan);
  }
  sqlite3DbFree(db, pList->a);
  sqlite3DbFree(db, pList);
}
static  int exprNodeIsConstant(Walker *pWalker , Expr *pExpr )  {
  if (((pWalker->u.i == 3) && ((pExpr->flags & 0x000001) != 0))) {
    (pWalker->u.i = 0);
    return 2;
  }  
  switch (pExpr->op) {
    case 151:
    if ((pWalker->u.i == 2)) {
      return 0;
    }  
    case 26:
    case 152:
    case 153:
    case 154:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pExpr->op == 26)) {
        sqlite3Coverage(77222);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pExpr->op == 152)) {
        sqlite3Coverage(77223);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pExpr->op == 153)) {
        sqlite3Coverage(77224);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pExpr->op == 154)) {
        sqlite3Coverage(77225);
      }  
    }  
    (pWalker->u.i = 0);
    return 2;
    id2i_label_1:
    default:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pExpr->op == 116)) {
        sqlite3Coverage(77229);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pExpr->op == 20)) {
        sqlite3Coverage(77230);
      }  
    }  
    return 0;
  }
}
static  int selectNodeIsConstant(Walker *pWalker , Select *NotUsed )  {
  ((void ) NotUsed);
  (pWalker->u.i = 0);
  return 2;
}
static  int exprIsConst(Expr *p , int initFlag )  {
  Walker w;
  memset((&w), 0, sizeof(w));
  (w.u.i = initFlag);
  (w.xExprCallback = exprNodeIsConstant);
  (w.xSelectCallback = selectNodeIsConstant);
  sqlite3WalkExpr((&w), p);
  return w.u.i;
}
static  int sqlite3ExprIsConstant(Expr *p )  {
  return exprIsConst(p, 1);
}
static  int sqlite3ExprIsConstantNotJoin(Expr *p )  {
  return exprIsConst(p, 3);
}
static  int sqlite3ExprIsConstantOrFunction(Expr *p )  {
  return exprIsConst(p, 2);
}
static  int sqlite3ExprIsInteger(Expr *p , int *pValue )  {
  int rc =  0;
  ((void ) 0);
  if ((p->flags & 0x000400)) {
    ((*pValue) = p->u.iValue);
    return 1;
  }  
  switch (p->op) {
    case 157:
    {
      (rc = sqlite3ExprIsInteger(p->pLeft, pValue));
      break;
    }
    case 156:
    {
      int v;
      if (sqlite3ExprIsInteger(p->pLeft, (&v))) {
        ((void ) 0);
        ((*pValue) = (- v));
        (rc = 1);
      }  
      break;
    }
    id2i_label_1:
    default:
    break;
  }
  return rc;
}
static  int sqlite3ExprCanBeNull(const  Expr *p )  {
  u8 op;
  while (((p->op == 157) || (p->op == 156))) {
    (p = p->pLeft);
  }
  (op = p->op);
  if ((op == 132)) {
    (op = p->op2);
  }  
  switch (op) {
    case 129:
    case 94:
    case 130:
    case 131:
    return 0;
    id2i_label_1:
    default:
    return 1;
  }
}
static  void sqlite3ExprCodeIsNullJump(Vdbe *v , const  Expr *pExpr , int iReg , int iDest )  {
  if (sqlite3ExprCanBeNull(pExpr)) {
    sqlite3VdbeAddOp2(v, 73, iReg, iDest);
  }  
}
static  int sqlite3ExprNeedsNoAffinityChange(const  Expr *p , char aff )  {
  u8 op;
  if ((aff == 'b')) {
    return 1;
  }  
  while (((p->op == 157) || (p->op == 156))) {
    (p = p->pLeft);
  }
  (op = p->op);
  if ((op == 132)) {
    (op = p->op2);
  }  
  switch (op) {
    case 129:
    {
      return ((aff == 'd') || (aff == 'c'));
    }
    case 130:
    {
      return ((aff == 'e') || (aff == 'c'));
    }
    case 94:
    {
      return (aff == 'a');
    }
    case 131:
    {
      return 1;
    }
    case 152:
    {
      ((void ) 0);
      return ((p->iColumn < 0) && ((aff == 'd') || (aff == 'c')));
    }
    id2i_label_1:
    default:
    {
      return 0;
    }
  }
}
static  int sqlite3IsRowid(const  char *z )  {
  if ((sqlite3_stricmp(z, "_ROWID_") == 0)) {
    return 1;
  }  
  if ((sqlite3_stricmp(z, "ROWID") == 0)) {
    return 1;
  }  
  if ((sqlite3_stricmp(z, "OID") == 0)) {
    return 1;
  }  
  return 0;
}
static  int isCandidateForInOpt(Select *p )  {
  SrcList *pSrc;
  ExprList *pEList;
  Table *pTab;
  if ((p == 0)) {
    return 0;
  }  
  if (p->pPrior) {
    return 0;
  }  
  if ((p->selFlags & (0x0001 | 0x0004))) {
    if (((id2i_sqlite_coverage_test ) )) {
      if (((p->selFlags & (0x0001 | 0x0004)) == 0x0001)) {
        sqlite3Coverage(77439);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if (((p->selFlags & (0x0001 | 0x0004)) == 0x0004)) {
        sqlite3Coverage(77440);
      }  
    }  
    return 0;
  }  
  ((void ) 0);
  if (p->pLimit) {
    return 0;
  }  
  ((void ) 0);
  if (p->pWhere) {
    return 0;
  }  
  (pSrc = p->pSrc);
  ((void ) 0);
  if ((pSrc->nSrc != 1)) {
    return 0;
  }  
  if (pSrc->a[0].pSelect) {
    return 0;
  }  
  (pTab = pSrc->a[0].pTab);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return 0;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pTab == 0)) {
      return 0;
    }  
  }  
  ((void ) 0);
  if (((pTab->tabFlags & 0x10) != 0)) {
    return 0;
  }  
  (pEList = p->pEList);
  if ((pEList->nExpr != 1)) {
    return 0;
  }  
  if ((pEList->a[0].pExpr->op != 152)) {
    return 0;
  }  
  return 1;
}
static  int sqlite3CodeOnce(Parse *pParse )  {
  Vdbe *v =  sqlite3GetVdbe(pParse);
  return sqlite3VdbeAddOp1(v, 38, pParse->nOnce++);
}
static  int sqlite3FindInIndex(Parse *pParse , Expr *pX , int *prNotFound )  {
  Select *p;
  int eType =  0;
  int iTab =  pParse->nTab++;
  int mustBeUnique =  (prNotFound == 0);
  Vdbe *v =  sqlite3GetVdbe(pParse);
  ((void ) 0);
  (p = (((pX->flags & 0x000800) != 0) ? pX->x.pSelect : 0));
  if (((id2i_sqlite_coverage_test ) )) {
    if ((1 && isCandidateForInOpt(p))) {
      sqlite3 *db =  pParse->db;
      Table *pTab;
      Expr *pExpr;
      int iCol;
      int iDb;
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      (pTab = p->pSrc->a[0].pTab);
      (pExpr = p->pEList->a[0].pExpr);
      (iCol = pExpr->iColumn);
      (iDb = sqlite3SchemaToIndex(db, pTab->pSchema));
      sqlite3CodeVerifySchema(pParse, iDb);
      sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
      ((void ) 0);
      if ((iCol < 0)) {
        int iAddr;
        (iAddr = sqlite3CodeOnce(pParse));
        sqlite3OpenTable(pParse, iTab, iDb, pTab, 48);
        (eType = 1);
        sqlite3VdbeJumpHere(v, iAddr);
      }  
      else {
        Index *pIdx;
        CollSeq *pReq =  sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pExpr);
        int affinity_ok =  sqlite3IndexAffinityOk(pX, pTab->aCol[iCol].affinity);
        for ((pIdx = pTab->pIndex); (pIdx && (eType == 0) && affinity_ok); (pIdx = pIdx->pNext)) {
          if (((pIdx->aiColumn[0] == iCol) && (sqlite3FindCollSeq(db, db->aDb[0].pSchema->enc, pIdx->azColl[0], 0) == pReq) && ((! mustBeUnique) || ((pIdx->nColumn == 1) && (pIdx->onError != 0))))) {
            int iAddr;
            char *pKey;
            (pKey = ((char *) sqlite3IndexKeyinfo(pParse, pIdx)));
            (iAddr = sqlite3CodeOnce(pParse));
            sqlite3VdbeAddOp4(v, 48, iTab, pIdx->tnum, iDb, pKey, (- 16));
            ((void ) 0);
            (eType = (3 + pIdx->aSortOrder[0]));
            sqlite3VdbeJumpHere(v, iAddr);
            if ((prNotFound && (! pTab->aCol[iCol].notNull))) {
              ((*prNotFound) = ++pParse->nMem);
              sqlite3VdbeAddOp2(v, 24, 0, (*prNotFound));
            }  
          }  
        }
      }
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((pParse->nErr == 0) && isCandidateForInOpt(p))) {
      sqlite3 *db =  pParse->db;
      Table *pTab;
      Expr *pExpr;
      int iCol;
      int iDb;
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      (pTab = p->pSrc->a[0].pTab);
      (pExpr = p->pEList->a[0].pExpr);
      (iCol = pExpr->iColumn);
      (iDb = sqlite3SchemaToIndex(db, pTab->pSchema));
      sqlite3CodeVerifySchema(pParse, iDb);
      sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
      ((void ) 0);
      if ((iCol < 0)) {
        int iAddr;
        (iAddr = sqlite3CodeOnce(pParse));
        sqlite3OpenTable(pParse, iTab, iDb, pTab, 48);
        (eType = 1);
        sqlite3VdbeJumpHere(v, iAddr);
      }  
      else {
        Index *pIdx;
        CollSeq *pReq =  sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pExpr);
        int affinity_ok =  sqlite3IndexAffinityOk(pX, pTab->aCol[iCol].affinity);
        for ((pIdx = pTab->pIndex); (pIdx && (eType == 0) && affinity_ok); (pIdx = pIdx->pNext)) {
          if (((pIdx->aiColumn[0] == iCol) && (sqlite3FindCollSeq(db, db->aDb[0].pSchema->enc, pIdx->azColl[0], 0) == pReq) && ((! mustBeUnique) || ((pIdx->nColumn == 1) && (pIdx->onError != 0))))) {
            int iAddr;
            char *pKey;
            (pKey = ((char *) sqlite3IndexKeyinfo(pParse, pIdx)));
            (iAddr = sqlite3CodeOnce(pParse));
            sqlite3VdbeAddOp4(v, 48, iTab, pIdx->tnum, iDb, pKey, (- 16));
            ((void ) 0);
            (eType = (3 + pIdx->aSortOrder[0]));
            sqlite3VdbeJumpHere(v, iAddr);
            if ((prNotFound && (! pTab->aCol[iCol].notNull))) {
              ((*prNotFound) = ++pParse->nMem);
              sqlite3VdbeAddOp2(v, 24, 0, (*prNotFound));
            }  
          }  
        }
      }
    }  
  }  
  if ((eType == 0)) {
    u32 savedNQueryLoop =  pParse->nQueryLoop;
    int rMayHaveNull =  0;
    (eType = 2);
    if (prNotFound) {
      ((*prNotFound) = (rMayHaveNull = ++pParse->nMem));
      sqlite3VdbeAddOp2(v, 24, 0, (*prNotFound));
    }  
    else {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pParse->nQueryLoop > 0)) {
          sqlite3Coverage(77636);
        }  
      }  
      (pParse->nQueryLoop = 0);
      if (((pX->pLeft->iColumn < 0) && (! ((pX->flags & 0x000800) != 0)))) {
        (eType = 1);
      }  
    }
    sqlite3CodeSubselect(pParse, pX, rMayHaveNull, (eType == 1));
    (pParse->nQueryLoop = savedNQueryLoop);
  }  
  else {
    (pX->iTable = iTab);
  }
  return eType;
}
static  int sqlite3CodeSubselect(Parse *pParse , Expr *pExpr , int rMayHaveNull , int isRowid )  {
  int testAddr =  (- 1);
  int rReg =  0;
  Vdbe *v =  sqlite3GetVdbe(pParse);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return 0;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((v == 0)) {
      return 0;
    }  
  }  
  sqlite3ExprCachePush(pParse);
  if ((! ((pExpr->flags & 0x000020) != 0))) {
    (testAddr = sqlite3CodeOnce(pParse));
  }  
  if ((((! id2i_sqlite_omit_explain) ) )) {
    if ((pParse->explain == 2)) {
      char *zMsg =  sqlite3MPrintf(pParse->db, "EXECUTE %s%s SUBQUERY %d", ((testAddr >= 0) ? "" : "CORRELATED "), ((pExpr->op == 72) ? "LIST" : "SCALAR"), pParse->_1272_iNextSelectId);
      sqlite3VdbeAddOp4(v, 150, pParse->_1272_iSelectId, 0, 0, zMsg, (- 1));
    }  
  }  
  switch (pExpr->op) {
    case 72:
    {
      char affinity;
      int addr;
      Expr *pLeft =  pExpr->pLeft;
      KeyInfo *pKeyInfo =  0;
      if (rMayHaveNull) {
        sqlite3VdbeAddOp2(v, 24, 0, rMayHaveNull);
      }  
      (affinity = sqlite3ExprAffinity(pLeft));
      (pExpr->iTable = pParse->nTab++);
      (addr = sqlite3VdbeAddOp2(v, 51, pExpr->iTable, (! isRowid)));
      if ((rMayHaveNull == 0)) {
        sqlite3VdbeChangeP5(v, 8);
      }  
      (pKeyInfo = (isRowid ? 0 : sqlite3KeyInfoAlloc(pParse->db, 1)));
      if (((pExpr->flags & 0x000800) != 0)) {
        SelectDest dest;
        ExprList *pEList;
        ((void ) 0);
        sqlite3SelectDestInit((&dest), 7, pExpr->iTable);
        (dest.affSdst = ((u8 ) affinity));
        ((void ) 0);
        (pExpr->x.pSelect->iLimit = 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pKeyInfo == 0)) {
            sqlite3Coverage(77766);
          }  
        }  
        if (sqlite3Select(pParse, pExpr->x.pSelect, (&dest))) {
          sqlite3DbFree(pParse->db, pKeyInfo);
          return 0;
        }  
        (pEList = pExpr->x.pSelect->pEList);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (pKeyInfo->aColl[0] = sqlite3BinaryCompareCollSeq(pParse, pExpr->pLeft, pEList->a[0].pExpr));
      } 
      else if ((((id2i_sqlite_coverage_test ) ) && 1)) {
        int i;
        ExprList *pList =  pExpr->x.pList;
        struct  ExprList_item   *pItem;
        int r1, r2, r3;
        if ((! affinity)) {
          (affinity = 'b');
        }  
        if (pKeyInfo) {
          (pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft));
        }  
        (r1 = sqlite3GetTempReg(pParse));
        (r2 = sqlite3GetTempReg(pParse));
        sqlite3VdbeAddOp2(v, 24, 0, r2);
        for ((i = pList->nExpr), (pItem = pList->a); (i > 0); i--, pItem++) {
          Expr *pE2 =  pItem->pExpr;
          int iValToIns;
          if (((testAddr >= 0) && (! sqlite3ExprIsConstant(pE2)))) {
            sqlite3VdbeChangeToNoop(v, testAddr);
            (testAddr = (- 1));
          }  
          if ((isRowid && sqlite3ExprIsInteger(pE2, (&iValToIns)))) {
            sqlite3VdbeAddOp3(v, 67, pExpr->iTable, r2, iValToIns);
          }  
          else {
            (r3 = sqlite3ExprCodeTarget(pParse, pE2, r1));
            if (isRowid) {
              sqlite3VdbeAddOp2(v, 33, r3, (sqlite3VdbeCurrentAddr(v) + 2));
              sqlite3VdbeAddOp3(v, 66, pExpr->iTable, r2, r3);
            }  
            else {
              sqlite3VdbeAddOp4(v, 43, r3, 1, r2, (&affinity), 1);
              sqlite3ExprCacheAffinityChange(pParse, r3, 1);
              sqlite3VdbeAddOp2(v, 103, pExpr->iTable, r2);
            }
          }
        }
        sqlite3ReleaseTempReg(pParse, r1);
        sqlite3ReleaseTempReg(pParse, r2);
      }
      
      else if (((((! id2i_sqlite_coverage_test) ) ) && (pExpr->x.pList != 0))) {
        int i;
        ExprList *pList =  pExpr->x.pList;
        struct  ExprList_item   *pItem;
        int r1, r2, r3;
        if ((! affinity)) {
          (affinity = 'b');
        }  
        if (pKeyInfo) {
          (pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft));
        }  
        (r1 = sqlite3GetTempReg(pParse));
        (r2 = sqlite3GetTempReg(pParse));
        sqlite3VdbeAddOp2(v, 24, 0, r2);
        for ((i = pList->nExpr), (pItem = pList->a); (i > 0); i--, pItem++) {
          Expr *pE2 =  pItem->pExpr;
          int iValToIns;
          if (((testAddr >= 0) && (! sqlite3ExprIsConstant(pE2)))) {
            sqlite3VdbeChangeToNoop(v, testAddr);
            (testAddr = (- 1));
          }  
          if ((isRowid && sqlite3ExprIsInteger(pE2, (&iValToIns)))) {
            sqlite3VdbeAddOp3(v, 67, pExpr->iTable, r2, iValToIns);
          }  
          else {
            (r3 = sqlite3ExprCodeTarget(pParse, pE2, r1));
            if (isRowid) {
              sqlite3VdbeAddOp2(v, 33, r3, (sqlite3VdbeCurrentAddr(v) + 2));
              sqlite3VdbeAddOp3(v, 66, pExpr->iTable, r2, r3);
            }  
            else {
              sqlite3VdbeAddOp4(v, 43, r3, 1, r2, (&affinity), 1);
              sqlite3ExprCacheAffinityChange(pParse, r3, 1);
              sqlite3VdbeAddOp2(v, 103, pExpr->iTable, r2);
            }
          }
        }
        sqlite3ReleaseTempReg(pParse, r1);
        sqlite3ReleaseTempReg(pParse, r2);
      } 
      if (pKeyInfo) {
        sqlite3VdbeChangeP4(v, addr, ((void *) pKeyInfo), (- 16));
      }  
      break;
    }
    case 20:
    case 116:
    id2i_label_1:
    default:
    {
      Select *pSel;
      SelectDest dest;
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pExpr->op == 20)) {
          sqlite3Coverage(77852);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pExpr->op == 116)) {
          sqlite3Coverage(77853);
        }  
      }  
      ((void ) 0);
      ((void ) 0);
      (pSel = pExpr->x.pSelect);
      sqlite3SelectDestInit((&dest), 0, ++pParse->nMem);
      if ((pExpr->op == 116)) {
        (dest.eDest = 6);
        sqlite3VdbeAddOp2(v, 24, 0, dest.iSDParm);
      }  
      else {
        (dest.eDest = 3);
        sqlite3VdbeAddOp2(v, 21, 0, dest.iSDParm);
      }
      sqlite3ExprDelete(pParse->db, pSel->pLimit);
      (pSel->pLimit = sqlite3PExpr(pParse, 129, 0, 0, (&sqlite3IntTokens[1])));
      (pSel->iLimit = 0);
      if (sqlite3Select(pParse, pSel, (&dest))) {
        return 0;
      }  
      (rReg = dest.iSDParm);
      break;
    }
  }
  if ((testAddr >= 0)) {
    sqlite3VdbeJumpHere(v, testAddr);
  }  
  sqlite3ExprCachePop(pParse, 1);
  return rReg;
}
static  void sqlite3ExprCodeIN(Parse *pParse , Expr *pExpr , int destIfFalse , int destIfNull )  {
  int rRhsHasNull =  0;
  char affinity;
  int eType;
  int r1;
  Vdbe *v;
  (v = pParse->pVdbe);
  ((void ) 0);
  (eType = sqlite3FindInIndex(pParse, pExpr, (&rRhsHasNull)));
  (affinity = comparisonAffinity(pExpr));
  sqlite3ExprCachePush(pParse);
  (r1 = sqlite3GetTempReg(pParse));
  sqlite3ExprCode(pParse, pExpr->pLeft, r1);
  if ((destIfNull == destIfFalse)) {
    sqlite3VdbeAddOp2(v, 73, r1, destIfNull);
  }  
  else {
    int addr1 =  sqlite3VdbeAddOp1(v, 74, r1);
    sqlite3VdbeAddOp2(v, 101, pExpr->iTable, destIfFalse);
    sqlite3VdbeAddOp2(v, 14, 0, destIfNull);
    sqlite3VdbeJumpHere(v, addr1);
  }
  if ((eType == 1)) {
    sqlite3VdbeAddOp2(v, 33, r1, destIfFalse);
    sqlite3VdbeAddOp3(v, 63, pExpr->iTable, destIfFalse, r1);
  }  
  else {
    sqlite3VdbeAddOp4(v, 42, r1, 1, 0, (&affinity), 1);
    if (((rRhsHasNull == 0) || (destIfFalse == destIfNull))) {
      sqlite3VdbeAddOp4Int(v, 60, pExpr->iTable, destIfFalse, r1, 1);
    }  
    else {
      int j1, j2, j3;
      (j1 = sqlite3VdbeAddOp4Int(v, 61, pExpr->iTable, 0, r1, 1));
      (j2 = sqlite3VdbeAddOp1(v, 74, rRhsHasNull));
      (j3 = sqlite3VdbeAddOp4Int(v, 61, pExpr->iTable, 0, rRhsHasNull, 1));
      sqlite3VdbeAddOp2(v, 21, (- 1), rRhsHasNull);
      sqlite3VdbeJumpHere(v, j3);
      sqlite3VdbeAddOp2(v, 32, rRhsHasNull, 1);
      sqlite3VdbeJumpHere(v, j2);
      sqlite3VdbeAddOp2(v, 39, rRhsHasNull, destIfNull);
      sqlite3VdbeAddOp2(v, 14, 0, destIfFalse);
      sqlite3VdbeJumpHere(v, j1);
    }
  }
  sqlite3ReleaseTempReg(pParse, r1);
  sqlite3ExprCachePop(pParse, 1);
}
static  char *dup8bytes(Vdbe *v , const  char *in )  {
  char *out =  sqlite3DbMallocRaw(sqlite3VdbeDb(v), 8);
  if (out) {
    memcpy(out, in, 8);
  }  
  return out;
}
static  void codeReal(Vdbe *v , const  char *z , int negateFlag , int iMem )  {
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      double value;
      char *zV;
      sqlite3AtoF(z, (&value), sqlite3Strlen30(z), 1);
      ((void ) 0);
      if (negateFlag) {
        (value = (- value));
      }  
      (zV = dup8bytes(v, ((char *) (&value))));
      sqlite3VdbeAddOp4(v, 130, 0, iMem, 0, zV, (- 12));
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((z != 0)) {
      double value;
      char *zV;
      sqlite3AtoF(z, (&value), sqlite3Strlen30(z), 1);
      ((void ) 0);
      if (negateFlag) {
        (value = (- value));
      }  
      (zV = dup8bytes(v, ((char *) (&value))));
      sqlite3VdbeAddOp4(v, 130, 0, iMem, 0, zV, (- 12));
    }  
  }  
}
static  void codeInteger(Parse *pParse , Expr *pExpr , int negFlag , int iMem )  {
  Vdbe *v =  pParse->pVdbe;
  if ((pExpr->flags & 0x000400)) {
    int i =  pExpr->u.iValue;
    ((void ) 0);
    if (negFlag) {
      (i = (- i));
    }  
    sqlite3VdbeAddOp2(v, 21, i, iMem);
  }  
  else {
    int c;
    i64 value;
    const char *z =  pExpr->u.zToken;
    ((void ) 0);
    (c = sqlite3Atoi64(z, (&value), sqlite3Strlen30(z), 1));
    if (((c == 0) || ((c == 2) && negFlag))) {
      char *zV;
      if (negFlag) {
        (value = ((c == 2) ? (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32))) : (- value)));
      }  
      (zV = dup8bytes(v, ((char *) (&value))));
      sqlite3VdbeAddOp4(v, 22, 0, iMem, 0, zV, (- 13));
    }  
    else {
      codeReal(v, z, negFlag, iMem);
    }
  }
}
static  void cacheEntryClear(Parse *pParse , struct  yColCache   *p )  {
  if (p->tempReg) {
    if ((pParse->nTempReg < ((int ) (sizeof(pParse->aTempReg) / sizeof(pParse->aTempReg[0]))))) {
      (pParse->aTempReg[pParse->nTempReg++] = p->iReg);
    }  
    (p->tempReg = 0);
  }  
}
static  void sqlite3ExprCacheStore(Parse *pParse , int iTab , int iCol , int iReg )  {
  int i;
  int minLru;
  int idxLru;
  struct  yColCache   *p;
  ((void ) 0);
  ((void ) 0);
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    if (((pParse->db->dbOptFlags & 0x0002) != 0)) {
      return;
    }  
  }  
  if (((id2i_sqlite_omit_builtin_test ) )) {
    if (0) {
      return;
    }  
  }  
  for ((i = 0), (p = pParse->aColCache); (i < 10); i++, p++) {
    if ((p->iReg == 0)) {
      (p->iLevel = pParse->iCacheLevel);
      (p->iTable = iTab);
      (p->iColumn = iCol);
      (p->iReg = iReg);
      (p->tempReg = 0);
      (p->lru = pParse->iCacheCnt++);
      return;
    }  
  }
  (minLru = 0x7fffffff);
  (idxLru = (- 1));
  for ((i = 0), (p = pParse->aColCache); (i < 10); i++, p++) {
    if ((p->lru < minLru)) {
      (idxLru = i);
      (minLru = p->lru);
    }  
  }
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      (p = (&pParse->aColCache[idxLru]));
      (p->iLevel = pParse->iCacheLevel);
      (p->iTable = iTab);
      (p->iColumn = iCol);
      (p->iReg = iReg);
      (p->tempReg = 0);
      (p->lru = pParse->iCacheCnt++);
      return;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((idxLru >= 0)) {
      (p = (&pParse->aColCache[idxLru]));
      (p->iLevel = pParse->iCacheLevel);
      (p->iTable = iTab);
      (p->iColumn = iCol);
      (p->iReg = iReg);
      (p->tempReg = 0);
      (p->lru = pParse->iCacheCnt++);
      return;
    }  
  }  
}
static  void sqlite3ExprCacheRemove(Parse *pParse , int iReg , int nReg )  {
  int i;
  int iLast =  (iReg + nReg - 1);
  struct  yColCache   *p;
  for ((i = 0), (p = pParse->aColCache); (i < 10); i++, p++) {
    int r =  p->iReg;
    if (((r >= iReg) && (r <= iLast))) {
      cacheEntryClear(pParse, p);
      (p->iReg = 0);
    }  
  }
}
static  void sqlite3ExprCachePush(Parse *pParse )  {
  pParse->iCacheLevel++;
}
static  void sqlite3ExprCachePop(Parse *pParse , int N )  {
  int i;
  struct  yColCache   *p;
  ((void ) 0);
  ((void ) 0);
  (pParse->iCacheLevel -= N);
  for ((i = 0), (p = pParse->aColCache); (i < 10); i++, p++) {
    if ((p->iReg && (p->iLevel > pParse->iCacheLevel))) {
      cacheEntryClear(pParse, p);
      (p->iReg = 0);
    }  
  }
}
static  void sqlite3ExprCachePinRegister(Parse *pParse , int iReg )  {
  int i;
  struct  yColCache   *p;
  for ((i = 0), (p = pParse->aColCache); (i < 10); i++, p++) {
    if ((p->iReg == iReg)) {
      (p->tempReg = 0);
    }  
  }
}
static  void sqlite3ExprCodeGetColumnOfTable(Vdbe *v , Table *pTab , int iTabCur , int iCol , int regOut )  {
  if (((iCol < 0) || (iCol == pTab->iPKey))) {
    sqlite3VdbeAddOp2(v, 96, iTabCur, regOut);
  }  
  else {
    int op =  (((pTab->tabFlags & 0x10) != 0) ? 138 : 41);
    sqlite3VdbeAddOp3(v, op, iTabCur, iCol, regOut);
  }
  if ((iCol >= 0)) {
    sqlite3ColumnDefault(v, pTab, iCol, regOut);
  }  
}
static  int sqlite3ExprCodeGetColumn(Parse *pParse , Table *pTab , int iColumn , int iTable , int iReg , u8 p5 )  {
  Vdbe *v =  pParse->pVdbe;
  int i;
  struct  yColCache   *p;
  for ((i = 0), (p = pParse->aColCache); (i < 10); i++, p++) {
    if (((p->iReg > 0) && (p->iTable == iTable) && (p->iColumn == iColumn))) {
      (p->lru = pParse->iCacheCnt++);
      sqlite3ExprCachePinRegister(pParse, p->iReg);
      return p->iReg;
    }  
  }
  ((void ) 0);
  sqlite3ExprCodeGetColumnOfTable(v, pTab, iTable, iColumn, iReg);
  if (p5) {
    sqlite3VdbeChangeP5(v, p5);
  }  
  else {
    sqlite3ExprCacheStore(pParse, iTable, iColumn, iReg);
  }
  return iReg;
}
static  void sqlite3ExprCacheClear(Parse *pParse )  {
  int i;
  struct  yColCache   *p;
  for ((i = 0), (p = pParse->aColCache); (i < 10); i++, p++) {
    if (p->iReg) {
      cacheEntryClear(pParse, p);
      (p->iReg = 0);
    }  
  }
}
static  void sqlite3ExprCacheAffinityChange(Parse *pParse , int iStart , int iCount )  {
  sqlite3ExprCacheRemove(pParse, iStart, iCount);
}
static  void sqlite3ExprCodeMove(Parse *pParse , int iFrom , int iTo , int nReg )  {
  int i;
  struct  yColCache   *p;
  ((void ) 0);
  sqlite3VdbeAddOp3(pParse->pVdbe, 27, iFrom, iTo, (nReg - 1));
  for ((i = 0), (p = pParse->aColCache); (i < 10); i++, p++) {
    int x =  p->iReg;
    if (((x >= iFrom) && (x < (iFrom + nReg)))) {
      (p->iReg += (iTo - iFrom));
    }  
  }
}
static  int usedAsColumnCache(Parse *pParse , int iFrom , int iTo )  {
  int i;
  struct  yColCache   *p;
  for ((i = 0), (p = pParse->aColCache); (i < 10); i++, p++) {
    int r =  p->iReg;
    if (((r >= iFrom) && (r <= iTo))) {
      return 1;
    }  
  }
  return 0;
}
static  void exprToRegister(Expr *p , int iReg )  {
  (p->op2 = p->op);
  (p->op = 132);
  (p->iTable = iReg);
  (p->flags &= (~ 0x001000));
}
static  int sqlite3ExprCodeTarget(Parse *pParse , Expr *pExpr , int target )  {
  Vdbe *v =  pParse->pVdbe;
  int op;
  int inReg =  target;
  int regFree1 =  0;
  int regFree2 =  0;
  int r1, r2, r3, r4;
  sqlite3 *db =  pParse->db;
  ((void ) 0);
  if ((v == 0)) {
    ((void ) 0);
    return 0;
  }  
  if ((pExpr == 0)) {
    (op = 98);
  }  
  else {
    (op = pExpr->op);
  }
  switch (op) {
    case 154:
    {
      AggInfo *pAggInfo =  pExpr->pAggInfo;
      struct  AggInfo_col   *pCol =  (&pAggInfo->aCol[pExpr->iAgg]);
      if ((! pAggInfo->directMode)) {
        ((void ) 0);
        (inReg = pCol->iMem);
        break;
      } 
      else if (pAggInfo->useSortingIdx) {
        sqlite3VdbeAddOp3(v, 41, pAggInfo->sortingIdxPTab, pCol->iSorterColumn, target);
        break;
      } 
    }
    case 152:
    {
      int iTab =  pExpr->iTable;
      if ((iTab < 0)) {
        if ((pParse->ckBase > 0)) {
          (inReg = (pExpr->iColumn + pParse->ckBase));
          break;
        }  
        else {
          (iTab = pParse->iPartIdxTab);
        }
      }  
      (inReg = sqlite3ExprCodeGetColumn(pParse, pExpr->pTab, pExpr->iColumn, iTab, target, pExpr->op2));
      break;
    }
    case 129:
    {
      codeInteger(pParse, pExpr, 0, target);
      break;
    }
    case 130:
    {
      ((void ) 0);
      codeReal(v, pExpr->u.zToken, 0, target);
      break;
    }
    case 94:
    {
      ((void ) 0);
      sqlite3VdbeAddOp4(v, 94, 0, target, 0, pExpr->u.zToken, 0);
      break;
    }
    case 98:
    {
      sqlite3VdbeAddOp2(v, 24, 0, target);
      break;
    }
    case 131:
    if ((((! id2i_sqlite_omit_blob_literal) ) )) {
      int n;
      const char *z;
      char *zBlob;
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      (z = (&pExpr->u.zToken[2]));
      (n = (sqlite3Strlen30(z) - 1));
      ((void ) 0);
      (zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n));
      sqlite3VdbeAddOp4(v, 25, (n / 2), target, 0, zBlob, (- 1));
      break;
    }  
    if (((id2i_sqlite_omit_blob_literal ) )) {
      if ((op == 131)) {
        goto id2i_label_1;
      }  
    }  
    case 133:
    {
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      sqlite3VdbeAddOp2(v, 26, pExpr->iColumn, target);
      if ((pExpr->u.zToken[1] != 0)) {
        ((void ) 0);
        sqlite3VdbeChangeP4(v, (- 1), pParse->azVar[(pExpr->iColumn - 1)], (- 2));
      }  
      break;
    }
    case 132:
    {
      (inReg = pExpr->iTable);
      break;
    }
    case 24:
    {
      (inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target));
      break;
    }
    case 37:
    if ((((! id2i_sqlite_omit_cast) ) )) {
      int aff, to_op;
      (inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target));
      ((void ) 0);
      (aff = sqlite3AffinityType(pExpr->u.zToken, 0));
      (to_op = (aff - 'a' + 141));
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((to_op == 141)) {
          sqlite3Coverage(78490);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((to_op == 142)) {
          sqlite3Coverage(78491);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((to_op == 143)) {
          sqlite3Coverage(78492);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((to_op == 144)) {
          sqlite3Coverage(78493);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((to_op == 145)) {
          sqlite3Coverage(78494);
        }  
      }  
      if ((inReg != target)) {
        sqlite3VdbeAddOp2(v, 29, inReg, target);
        (inReg = target);
      }  
      sqlite3VdbeAddOp1(v, to_op, inReg);
      if (((id2i_sqlite_coverage_test ) )) {
        if (usedAsColumnCache(pParse, inReg, inReg)) {
          sqlite3Coverage(78500);
        }  
      }  
      sqlite3ExprCacheAffinityChange(pParse, inReg, 1);
      break;
    }  
    if (((id2i_sqlite_omit_cast ) )) {
      if ((op == 37)) {
        goto id2i_label_1;
      }  
    }  
    case 79:
    case 78:
    case 77:
    case 80:
    case 75:
    case 76:
    {
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 79)) {
          sqlite3Coverage(78517);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 78)) {
          sqlite3Coverage(78518);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 77)) {
          sqlite3Coverage(78519);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 80)) {
          sqlite3Coverage(78520);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 76)) {
          sqlite3Coverage(78521);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 75)) {
          sqlite3Coverage(78522);
        }  
      }  
      (r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, (&regFree1)));
      (r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, (&regFree2)));
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, inReg, 0x10);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(78527);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree2 == 0)) {
          sqlite3Coverage(78528);
        }  
      }  
      break;
    }
    case 70:
    case 146:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 70)) {
          sqlite3Coverage(78533);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 146)) {
          sqlite3Coverage(78534);
        }  
      }  
      (r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, (&regFree1)));
      (r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, (&regFree2)));
      (op = ((op == 70) ? 76 : 75));
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, inReg, (0x10 | 0x80));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(78540);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree2 == 0)) {
          sqlite3Coverage(78541);
        }  
      }  
      break;
    }
    case 69:
    case 68:
    case 86:
    case 88:
    case 87:
    case 90:
    case 82:
    case 83:
    case 89:
    case 84:
    case 85:
    case 91:
    {
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 69)) {
          sqlite3Coverage(78567);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 68)) {
          sqlite3Coverage(78568);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 86)) {
          sqlite3Coverage(78569);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 87)) {
          sqlite3Coverage(78570);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 90)) {
          sqlite3Coverage(78571);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 82)) {
          sqlite3Coverage(78572);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 83)) {
          sqlite3Coverage(78573);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 89)) {
          sqlite3Coverage(78574);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 84)) {
          sqlite3Coverage(78575);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 85)) {
          sqlite3Coverage(78576);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 91)) {
          sqlite3Coverage(78577);
        }  
      }  
      (r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, (&regFree1)));
      (r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, (&regFree2)));
      sqlite3VdbeAddOp3(v, op, r2, r1, target);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(78581);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree2 == 0)) {
          sqlite3Coverage(78582);
        }  
      }  
      break;
    }
    case 156:
    {
      Expr *pLeft =  pExpr->pLeft;
      ((void ) 0);
      if ((pLeft->op == 129)) {
        codeInteger(pParse, pLeft, 1, target);
      } 
      else if ((pLeft->op == 130)) {
        ((void ) 0);
        codeReal(v, pLeft->u.zToken, 1, target);
      } 
      else {
        (regFree1 = (r1 = sqlite3GetTempReg(pParse)));
        sqlite3VdbeAddOp2(v, 21, 0, r1);
        (r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, (&regFree2)));
        sqlite3VdbeAddOp3(v, 87, r2, r1, target);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((regFree2 == 0)) {
            sqlite3Coverage(78600);
          }  
        }  
      }
      (inReg = target);
      break;
    }
    case 93:
    case 19:
    {
      ((void ) 0);
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 93)) {
          sqlite3Coverage(78609);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 19)) {
          sqlite3Coverage(78610);
        }  
      }  
      (r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, (&regFree1)));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(78612);
        }  
      }  
      (inReg = target);
      sqlite3VdbeAddOp2(v, op, r1, inReg);
      break;
    }
    case 73:
    case 74:
    {
      int addr;
      ((void ) 0);
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 73)) {
          sqlite3Coverage(78622);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 74)) {
          sqlite3Coverage(78623);
        }  
      }  
      sqlite3VdbeAddOp2(v, 21, 1, target);
      (r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, (&regFree1)));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(78626);
        }  
      }  
      (addr = sqlite3VdbeAddOp1(v, op, r1));
      sqlite3VdbeAddOp2(v, 32, target, (- 1));
      sqlite3VdbeJumpHere(v, addr);
      break;
    }
    case 153:
    {
      AggInfo *pInfo =  pExpr->pAggInfo;
      if ((pInfo == 0)) {
        ((void ) 0);
        sqlite3ErrorMsg(pParse, "misuse of aggregate: %s()", pExpr->u.zToken);
      }  
      else {
        (inReg = pInfo->aFunc[pExpr->iAgg].iMem);
      }
      break;
    }
    case 155:
    case 151:
    {
      ExprList *pFarg;
      int nFarg;
      FuncDef *pDef;
      int nId;
      const char *zId;
      int constMask =  0;
      int i;
      u8 enc =  db->aDb[0].pSchema->enc;
      CollSeq *pColl =  0;
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 155)) {
          sqlite3Coverage(78655);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 151)) {
          sqlite3Coverage(78656);
        }  
      }  
      if (((pExpr->flags & 0x004000) != 0)) {
        (pFarg = 0);
      }  
      else {
        (pFarg = pExpr->x.pList);
      }
      (nFarg = (pFarg ? pFarg->nExpr : 0));
      ((void ) 0);
      (zId = pExpr->u.zToken);
      (nId = sqlite3Strlen30(zId));
      (pDef = sqlite3FindFunction(db, zId, nId, nFarg, enc, 0));
      if ((pDef == 0)) {
        sqlite3ErrorMsg(pParse, "unknown function: %.*s()", nId, zId);
        break;
      }  
      if ((pDef->funcFlags & 0x200)) {
        int endCoalesce =  sqlite3VdbeMakeLabel(v);
        ((void ) 0);
        sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);
        for ((i = 1); (i < nFarg); i++) {
          sqlite3VdbeAddOp2(v, 74, target, endCoalesce);
          sqlite3ExprCacheRemove(pParse, target, 1);
          sqlite3ExprCachePush(pParse);
          sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);
          sqlite3ExprCachePop(pParse, 1);
        }
        sqlite3VdbeResolveLabel(v, endCoalesce);
        break;
      }  
      if ((pDef->funcFlags & 0x400)) {
        ((void ) 0);
        sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);
        break;
      }  
      if (pFarg) {
        (r1 = sqlite3GetTempRange(pParse, nFarg));
        if (((pDef->funcFlags & (0x040 | 0x080)) != 0)) {
          u8 exprOp;
          ((void ) 0);
          ((void ) 0);
          (exprOp = pFarg->a[0].pExpr->op);
          if (((exprOp == 152) || (exprOp == 154))) {
            ((void ) 0);
            ((void ) 0);
            if (((id2i_sqlite_coverage_test ) )) {
              if (((pDef->funcFlags & (~ 0x003)) == 0x040)) {
                sqlite3Coverage(78717);
              }  
            }  
            (pFarg->a[0].pExpr->op2 = (pDef->funcFlags & (~ 0x003)));
          }  
        }  
        sqlite3ExprCachePush(pParse);
        sqlite3ExprCodeExprList(pParse, pFarg, r1, 1);
        sqlite3ExprCachePop(pParse, 1);
      }  
      else {
        (r1 = 0);
      }
      if (((nFarg >= 2) && (pExpr->flags & 0x000080))) {
        (pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr));
      } 
      else if ((nFarg > 0)) {
        (pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr));
      } 
      for ((i = 0); (i < nFarg); i++) {
        if (((i < 32) && sqlite3ExprIsConstant(pFarg->a[i].pExpr))) {
          (constMask |= (1 << i));
        }  
        if ((((pDef->funcFlags & 0x020) != 0) && (! pColl))) {
          (pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr));
        }  
      }
      if ((pDef->funcFlags & 0x020)) {
        if ((! pColl)) {
          (pColl = db->pDfltColl);
        }  
        sqlite3VdbeAddOp4(v, 31, 0, 0, 0, ((char *) pColl), (- 4));
      }  
      sqlite3VdbeAddOp4(v, 1, constMask, r1, target, ((char *) pDef), (- 5));
      sqlite3VdbeChangeP5(v, ((u8 ) nFarg));
      if (nFarg) {
        sqlite3ReleaseTempRange(pParse, r1, nFarg);
      }  
      break;
    }
    case 20:
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((op == 20)) {
        goto id2i_label_1;
      }  
    }  
    case 116:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 20)) {
          sqlite3Coverage(78770);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 116)) {
          sqlite3Coverage(78771);
        }  
      }  
      (inReg = sqlite3CodeSubselect(pParse, pExpr, 0, 0));
      break;
    }  
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((op == 116)) {
        goto id2i_label_1;
      }  
    }  
    case 72:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      int destIfFalse =  sqlite3VdbeMakeLabel(v);
      int destIfNull =  sqlite3VdbeMakeLabel(v);
      sqlite3VdbeAddOp2(v, 24, 0, target);
      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
      sqlite3VdbeAddOp2(v, 21, 1, target);
      sqlite3VdbeResolveLabel(v, destIfFalse);
      sqlite3VdbeAddOp2(v, 32, target, 0);
      sqlite3VdbeResolveLabel(v, destIfNull);
      break;
    }  
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((op == 72)) {
        goto id2i_label_1;
      }  
    }  
    case 71:
    {
      Expr *pLeft =  pExpr->pLeft;
      struct  ExprList_item   *pLItem =  pExpr->x.pList->a;
      Expr *pRight =  pLItem->pExpr;
      (r1 = sqlite3ExprCodeTemp(pParse, pLeft, (&regFree1)));
      (r2 = sqlite3ExprCodeTemp(pParse, pRight, (&regFree2)));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(78807);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree2 == 0)) {
          sqlite3Coverage(78808);
        }  
      }  
      (r3 = sqlite3GetTempReg(pParse));
      (r4 = sqlite3GetTempReg(pParse));
      codeCompare(pParse, pLeft, pRight, 80, r1, r2, r3, 0x10);
      pLItem++;
      (pRight = pLItem->pExpr);
      sqlite3ReleaseTempReg(pParse, regFree2);
      (r2 = sqlite3ExprCodeTemp(pParse, pRight, (&regFree2)));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree2 == 0)) {
          sqlite3Coverage(78817);
        }  
      }  
      codeCompare(pParse, pLeft, pRight, 78, r1, r2, r4, 0x10);
      sqlite3VdbeAddOp3(v, 69, r3, r4, target);
      sqlite3ReleaseTempReg(pParse, r3);
      sqlite3ReleaseTempReg(pParse, r4);
      break;
    }
    case 92:
    case 157:
    {
      (inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target));
      break;
    }
    case 60:
    {
      Table *pTab =  pExpr->pTab;
      int p1 =  ((pExpr->iTable * (pTab->nCol + 1)) + 1 + pExpr->iColumn);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      sqlite3VdbeAddOp2(v, 122, p1, target);
      if (((pExpr->iColumn >= 0) && (pTab->aCol[pExpr->iColumn].affinity == 'e'))) {
        sqlite3VdbeAddOp1(v, 34, target);
      }  
      break;
    }
    id2i_label_1:
    default:
    ((void ) 0);
    {
      int endLabel;
      int nextCase;
      int nExpr;
      int i;
      ExprList *pEList;
      struct  ExprList_item   *aListelem;
      Expr opCompare;
      Expr cacheX;
      Expr *pX;
      Expr *pTest =  0;
      ((void ) 0);
      ((void ) 0);
      (pEList = pExpr->x.pList);
      (aListelem = pEList->a);
      (nExpr = pEList->nExpr);
      (endLabel = sqlite3VdbeMakeLabel(v));
      if (((pX = pExpr->pLeft) != 0)) {
        (cacheX = (*pX));
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pX->op == 152)) {
            sqlite3Coverage(78926);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pX->op == 132)) {
            sqlite3Coverage(78927);
          }  
        }  
        exprToRegister((&cacheX), sqlite3ExprCodeTemp(pParse, pX, (&regFree1)));
        if (((id2i_sqlite_coverage_test ) )) {
          if ((regFree1 == 0)) {
            sqlite3Coverage(78929);
          }  
        }  
        (opCompare.op = 76);
        (opCompare.pLeft = (&cacheX));
        (pTest = (&opCompare));
        (regFree1 = 0);
      }  
      for ((i = 0); (i < (nExpr - 1)); (i = (i + 2))) {
        sqlite3ExprCachePush(pParse);
        if (pX) {
          ((void ) 0);
          (opCompare.pRight = aListelem[i].pExpr);
        }  
        else {
          (pTest = aListelem[i].pExpr);
        }
        (nextCase = sqlite3VdbeMakeLabel(v));
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pTest->op == 152)) {
            sqlite3Coverage(78948);
          }  
        }  
        sqlite3ExprIfFalse(pParse, pTest, nextCase, 0x08);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((aListelem[(i + 1)].pExpr->op == 152)) {
            sqlite3Coverage(78950);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((aListelem[(i + 1)].pExpr->op == 132)) {
            sqlite3Coverage(78951);
          }  
        }  
        sqlite3ExprCode(pParse, aListelem[(i + 1)].pExpr, target);
        sqlite3VdbeAddOp2(v, 14, 0, endLabel);
        sqlite3ExprCachePop(pParse, 1);
        sqlite3VdbeResolveLabel(v, nextCase);
      }
      if (((nExpr & 1) != 0)) {
        sqlite3ExprCachePush(pParse);
        sqlite3ExprCode(pParse, pEList->a[(nExpr - 1)].pExpr, target);
        sqlite3ExprCachePop(pParse, 1);
      }  
      else {
        sqlite3VdbeAddOp2(v, 24, 0, target);
      }
      ((void ) 0);
      sqlite3VdbeResolveLabel(v, endLabel);
      break;
    }
    case 56:
    {
      ((void ) 0);
      if ((! pParse->pTriggerTab)) {
        sqlite3ErrorMsg(pParse, "RAISE() may only be used within a trigger-program");
        return 0;
      }  
      if ((pExpr->affinity == 2)) {
        sqlite3MayAbort(pParse);
      }  
      ((void ) 0);
      if ((pExpr->affinity == 4)) {
        sqlite3VdbeAddOp4(v, 20, 0, 4, 0, pExpr->u.zToken, 0);
      }  
      else {
        sqlite3HaltConstraint(pParse, (19 | (7 << 8)), pExpr->affinity, pExpr->u.zToken, 0);
      }
      break;
    }
  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
  return inReg;
}
static  int sqlite3ExprCodeTemp(Parse *pParse , Expr *pExpr , int *pReg )  {
  int r1 =  sqlite3GetTempReg(pParse);
  int r2 =  sqlite3ExprCodeTarget(pParse, pExpr, r1);
  if ((r2 == r1)) {
    ((*pReg) = r1);
  }  
  else {
    sqlite3ReleaseTempReg(pParse, r1);
    ((*pReg) = 0);
  }
  return r2;
}
static  int sqlite3ExprCode(Parse *pParse , Expr *pExpr , int target )  {
  int inReg;
  ((void ) 0);
  if ((pExpr && (pExpr->op == 132))) {
    sqlite3VdbeAddOp2(pParse->pVdbe, 28, pExpr->iTable, target);
  }  
  else {
    (inReg = sqlite3ExprCodeTarget(pParse, pExpr, target));
    ((void ) 0);
    if (((inReg != target) && pParse->pVdbe)) {
      sqlite3VdbeAddOp2(pParse->pVdbe, 29, inReg, target);
    }  
  }
  return target;
}
static  int sqlite3ExprCodeAndCache(Parse *pParse , Expr *pExpr , int target )  {
  Vdbe *v =  pParse->pVdbe;
  int inReg;
  (inReg = sqlite3ExprCode(pParse, pExpr, target));
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      int iMem;
      (iMem = ++pParse->nMem);
      sqlite3VdbeAddOp2(v, 28, inReg, iMem);
      exprToRegister(pExpr, iMem);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pExpr->op != 132)) {
      int iMem;
      (iMem = ++pParse->nMem);
      sqlite3VdbeAddOp2(v, 28, inReg, iMem);
      exprToRegister(pExpr, iMem);
    }  
  }  
  return inReg;
}
static  void sqlite3ExplainExpr(Vdbe *pOut , Expr *pExpr )  {
  int op;
  const char *zBinOp =  0;
  const char *zUniOp =  0;
  if ((pExpr == 0)) {
    (op = 98);
  }  
  else {
    (op = pExpr->op);
  }
  switch (op) {
    case 154:
    {
      sqlite3ExplainPrintf(pOut, "AGG{%d:%d}", pExpr->iTable, pExpr->iColumn);
      break;
    }
    case 152:
    {
      if ((pExpr->iTable < 0)) {
        sqlite3ExplainPrintf(pOut, "COLUMN(%d)", pExpr->iColumn);
      }  
      else {
        sqlite3ExplainPrintf(pOut, "{%d:%d}", pExpr->iTable, pExpr->iColumn);
      }
      break;
    }
    case 129:
    {
      if ((pExpr->flags & 0x000400)) {
        sqlite3ExplainPrintf(pOut, "%d", pExpr->u.iValue);
      }  
      else {
        sqlite3ExplainPrintf(pOut, "%s", pExpr->u.zToken);
      }
      break;
    }
    case 130:
    {
      sqlite3ExplainPrintf(pOut, "%s", pExpr->u.zToken);
      break;
    }
    case 94:
    {
      sqlite3ExplainPrintf(pOut, "%Q", pExpr->u.zToken);
      break;
    }
    case 98:
    {
      sqlite3ExplainPrintf(pOut, "NULL");
      break;
    }
    case 131:
    if ((((! id2i_sqlite_omit_blob_literal) ) )) {
      sqlite3ExplainPrintf(pOut, "%s", pExpr->u.zToken);
      break;
    }  
    if (((id2i_sqlite_omit_blob_literal ) )) {
      if ((op == 131)) {
        break;
      }  
    }  
    case 133:
    {
      sqlite3ExplainPrintf(pOut, "VARIABLE(%s,%d)", pExpr->u.zToken, pExpr->iColumn);
      break;
    }
    case 132:
    {
      sqlite3ExplainPrintf(pOut, "REGISTER(%d)", pExpr->iTable);
      break;
    }
    case 24:
    {
      sqlite3ExplainExpr(pOut, pExpr->pLeft);
      break;
    }
    case 37:
    if ((((! id2i_sqlite_omit_cast) ) )) {
      const char *zAff =  "unk";
      switch (sqlite3AffinityType(pExpr->u.zToken, 0)) {
        case 'a':
        (zAff = "TEXT");
        break;
        case 'b':
        (zAff = "NONE");
        break;
        case 'c':
        (zAff = "NUMERIC");
        break;
        case 'd':
        (zAff = "INTEGER");
        break;
        case 'e':
        (zAff = "REAL");
        break;
      }
      sqlite3ExplainPrintf(pOut, "CAST-%s(", zAff);
      sqlite3ExplainExpr(pOut, pExpr->pLeft);
      sqlite3ExplainPrintf(pOut, ")");
      break;
    }  
    if (((id2i_sqlite_omit_cast ) )) {
      if ((op == 37)) {
        break;
      }  
    }  
    case 79:
    (zBinOp = "LT");
    break;
    case 78:
    (zBinOp = "LE");
    break;
    case 77:
    (zBinOp = "GT");
    break;
    case 80:
    (zBinOp = "GE");
    break;
    case 75:
    (zBinOp = "NE");
    break;
    case 76:
    (zBinOp = "EQ");
    break;
    case 70:
    (zBinOp = "IS");
    break;
    case 146:
    (zBinOp = "ISNOT");
    break;
    case 69:
    (zBinOp = "AND");
    break;
    case 68:
    (zBinOp = "OR");
    break;
    case 86:
    (zBinOp = "ADD");
    break;
    case 88:
    (zBinOp = "MUL");
    break;
    case 87:
    (zBinOp = "SUB");
    break;
    case 90:
    (zBinOp = "REM");
    break;
    case 82:
    (zBinOp = "BITAND");
    break;
    case 83:
    (zBinOp = "BITOR");
    break;
    case 89:
    (zBinOp = "DIV");
    break;
    case 84:
    (zBinOp = "LSHIFT");
    break;
    case 85:
    (zBinOp = "RSHIFT");
    break;
    case 91:
    (zBinOp = "CONCAT");
    break;
    case 156:
    (zUniOp = "UMINUS");
    break;
    case 157:
    (zUniOp = "UPLUS");
    break;
    case 93:
    (zUniOp = "BITNOT");
    break;
    case 19:
    (zUniOp = "NOT");
    break;
    case 73:
    (zUniOp = "ISNULL");
    break;
    case 74:
    (zUniOp = "NOTNULL");
    break;
    case 92:
    {
      sqlite3ExplainExpr(pOut, pExpr->pLeft);
      sqlite3ExplainPrintf(pOut, ".COLLATE(%s)", pExpr->u.zToken);
      break;
    }
    case 153:
    case 155:
    case 151:
    {
      ExprList *pFarg;
      if (((pExpr->flags & 0x004000) != 0)) {
        (pFarg = 0);
      }  
      else {
        (pFarg = pExpr->x.pList);
      }
      if ((op == 153)) {
        sqlite3ExplainPrintf(pOut, "AGG_FUNCTION%d:%s(", pExpr->op2, pExpr->u.zToken);
      }  
      else {
        sqlite3ExplainPrintf(pOut, "FUNCTION:%s(", pExpr->u.zToken);
      }
      if (pFarg) {
        sqlite3ExplainExprList(pOut, pFarg);
      }  
      sqlite3ExplainPrintf(pOut, ")");
      break;
    }
    case 20:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      sqlite3ExplainPrintf(pOut, "EXISTS(");
      sqlite3ExplainSelect(pOut, pExpr->x.pSelect);
      sqlite3ExplainPrintf(pOut, ")");
      break;
    }  
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((op == 20)) {
        break;
      }  
    }  
    case 116:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      sqlite3ExplainPrintf(pOut, "(");
      sqlite3ExplainSelect(pOut, pExpr->x.pSelect);
      sqlite3ExplainPrintf(pOut, ")");
      break;
    }  
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((op == 116)) {
        break;
      }  
    }  
    case 72:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      sqlite3ExplainPrintf(pOut, "IN(");
      sqlite3ExplainExpr(pOut, pExpr->pLeft);
      sqlite3ExplainPrintf(pOut, ",");
      if (((pExpr->flags & 0x000800) != 0)) {
        sqlite3ExplainSelect(pOut, pExpr->x.pSelect);
      }  
      else {
        sqlite3ExplainExprList(pOut, pExpr->x.pList);
      }
      sqlite3ExplainPrintf(pOut, ")");
      break;
    }  
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((op == 72)) {
        break;
      }  
    }  
    case 71:
    {
      Expr *pX =  pExpr->pLeft;
      Expr *pY =  pExpr->x.pList->a[0].pExpr;
      Expr *pZ =  pExpr->x.pList->a[1].pExpr;
      sqlite3ExplainPrintf(pOut, "BETWEEN(");
      sqlite3ExplainExpr(pOut, pX);
      sqlite3ExplainPrintf(pOut, ",");
      sqlite3ExplainExpr(pOut, pY);
      sqlite3ExplainPrintf(pOut, ",");
      sqlite3ExplainExpr(pOut, pZ);
      sqlite3ExplainPrintf(pOut, ")");
      break;
    }
    case 60:
    {
      sqlite3ExplainPrintf(pOut, "%s(%d)", (pExpr->iTable ? "NEW" : "OLD"), pExpr->iColumn);
      break;
    }
    case 134:
    {
      sqlite3ExplainPrintf(pOut, "CASE(");
      sqlite3ExplainExpr(pOut, pExpr->pLeft);
      sqlite3ExplainPrintf(pOut, ",");
      sqlite3ExplainExprList(pOut, pExpr->x.pList);
      break;
    }
    case 56:
    {
      const char *zType =  "unk";
      switch (pExpr->affinity) {
        case 1:
        (zType = "rollback");
        break;
        case 2:
        (zType = "abort");
        break;
        case 3:
        (zType = "fail");
        break;
        case 4:
        (zType = "ignore");
        break;
      }
      sqlite3ExplainPrintf(pOut, "RAISE-%s(%s)", zType, pExpr->u.zToken);
      break;
    }
  }
  if (zBinOp) {
    sqlite3ExplainPrintf(pOut, "%s(", zBinOp);
    sqlite3ExplainExpr(pOut, pExpr->pLeft);
    sqlite3ExplainPrintf(pOut, ",");
    sqlite3ExplainExpr(pOut, pExpr->pRight);
    sqlite3ExplainPrintf(pOut, ")");
  } 
  else if (zUniOp) {
    sqlite3ExplainPrintf(pOut, "%s(", zUniOp);
    sqlite3ExplainExpr(pOut, pExpr->pLeft);
    sqlite3ExplainPrintf(pOut, ")");
  } 
}
static  void sqlite3ExplainExprList(Vdbe *pOut , ExprList *pList )  {
  int i;
  if (((pList == 0) || (pList->nExpr == 0))) {
    sqlite3ExplainPrintf(pOut, "(empty-list)");
    return;
  } 
  else if ((pList->nExpr == 1)) {
    sqlite3ExplainExpr(pOut, pList->a[0].pExpr);
  } 
  else {
    sqlite3ExplainPush(pOut);
    for ((i = 0); (i < pList->nExpr); i++) {
      sqlite3ExplainPrintf(pOut, "item[%d] = ", i);
      sqlite3ExplainPush(pOut);
      sqlite3ExplainExpr(pOut, pList->a[i].pExpr);
      sqlite3ExplainPop(pOut);
      if (pList->a[i].zName) {
        sqlite3ExplainPrintf(pOut, " AS %s", pList->a[i].zName);
      }  
      if (pList->a[i].bSpanIsTab) {
        sqlite3ExplainPrintf(pOut, " (%s)", pList->a[i].zSpan);
      }  
      if ((i < (pList->nExpr - 1))) {
        sqlite3ExplainNL(pOut);
      }  
    }
    sqlite3ExplainPop(pOut);
  }
}
static  int isAppropriateForFactoring(Expr *p )  {
  if ((! sqlite3ExprIsConstantNotJoin(p))) {
    return 0;
  }  
  if (((p->flags & 0x000200) == 0)) {
    return 1;
  }  
  while ((p->op == 157)) {
    (p = p->pLeft);
  }
  switch (p->op) {
    case 131:
    if (((id2i_sqlite_omit_blob_literal ) )) {
      if ((p->op == 131)) {
        goto id2i_label_1;
      }  
    }  
    case 133:
    case 129:
    case 130:
    case 98:
    case 94:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((p->op == 131)) {
          sqlite3Coverage(79383);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((p->op == 133)) {
          sqlite3Coverage(79384);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((p->op == 129)) {
          sqlite3Coverage(79385);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((p->op == 130)) {
          sqlite3Coverage(79386);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((p->op == 98)) {
          sqlite3Coverage(79387);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((p->op == 94)) {
          sqlite3Coverage(79388);
        }  
      }  
      return 0;
    }
    case 156:
    {
      if (((p->pLeft->op == 130) || (p->pLeft->op == 129))) {
        return 0;
      }  
      break;
    }
    id2i_label_1:
    default:
    {
      break;
    }
  }
  return 1;
}
static  int evalConstExpr(Walker *pWalker , Expr *pExpr )  {
  Parse *pParse =  pWalker->pParse;
  switch (pExpr->op) {
    case 72:
    case 132:
    {
      return 1;
    }
    case 92:
    {
      return 0;
    }
    case 151:
    case 153:
    case 155:
    {
      ExprList *pList =  pExpr->x.pList;
      ((void ) 0);
      if (pList) {
        int i =  pList->nExpr;
        struct  ExprList_item   *pItem =  pList->a;
        for (; (i > 0); i--, pItem++) {
          if (((id2i_sqlite_coverage_test ) )) {
            if (1) {
              (pItem->pExpr->flags |= 0x000200);
            }  
          }  
          if ((((! id2i_sqlite_coverage_test) ) )) {
            if (pItem->pExpr) {
              (pItem->pExpr->flags |= 0x000200);
            }  
          }  
        }
      }  
      break;
    }
  }
  if (isAppropriateForFactoring(pExpr)) {
    int r1 =  ++pParse->nMem;
    int r2 =  sqlite3ExprCodeTarget(pParse, pExpr, r1);
    ((void ) 0);
    exprToRegister(pExpr, r2);
    return 1;
  }  
  return 0;
}
static  void sqlite3ExprCodeConstants(Parse *pParse , Expr *pExpr )  {
  Walker w;
  if (pParse->cookieGoto) {
    return;
  }  
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    if (((pParse->db->dbOptFlags & 0x0008) != 0)) {
      return;
    }  
  }  
  if (((id2i_sqlite_omit_builtin_test ) )) {
    if (0) {
      return;
    }  
  }  
  memset((&w), 0, sizeof(w));
  (w.xExprCallback = evalConstExpr);
  (w.pParse = pParse);
  sqlite3WalkExpr((&w), pExpr);
}
static  int sqlite3ExprCodeExprList(Parse *pParse , ExprList *pList , int target , int doHardCopy )  {
  struct  ExprList_item   *pItem;
  int i, n;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (n = pList->nExpr);
  for ((pItem = pList->a), (i = 0); (i < n); i++, pItem++) {
    Expr *pExpr =  pItem->pExpr;
    int inReg =  sqlite3ExprCodeTarget(pParse, pExpr, (target + i));
    if ((inReg != (target + i))) {
      sqlite3VdbeAddOp2(pParse->pVdbe, (doHardCopy ? 28 : 29), inReg, (target + i));
    }  
  }
  return n;
}
static  void exprCodeBetween(Parse *pParse , Expr *pExpr , int dest , int jumpIfTrue , int jumpIfNull )  {
  Expr exprAnd;
  Expr compLeft;
  Expr compRight;
  Expr exprX;
  int regFree1 =  0;
  ((void ) 0);
  (exprX = (*pExpr->pLeft));
  (exprAnd.op = 69);
  (exprAnd.pLeft = (&compLeft));
  (exprAnd.pRight = (&compRight));
  (compLeft.op = 80);
  (compLeft.pLeft = (&exprX));
  (compLeft.pRight = pExpr->x.pList->a[0].pExpr);
  (compRight.op = 78);
  (compRight.pLeft = (&exprX));
  (compRight.pRight = pExpr->x.pList->a[1].pExpr);
  exprToRegister((&exprX), sqlite3ExprCodeTemp(pParse, (&exprX), (&regFree1)));
  if (jumpIfTrue) {
    sqlite3ExprIfTrue(pParse, (&exprAnd), dest, jumpIfNull);
  }  
  else {
    sqlite3ExprIfFalse(pParse, (&exprAnd), dest, jumpIfNull);
  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  if (((id2i_sqlite_coverage_test ) )) {
    if (((jumpIfTrue == 0) && (jumpIfNull == 0) && (regFree1 == 0))) {
      sqlite3Coverage(79557);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((jumpIfTrue == 0) && (jumpIfNull == 0) && (regFree1 != 0))) {
      sqlite3Coverage(79558);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((jumpIfTrue == 0) && (jumpIfNull != 0) && (regFree1 == 0))) {
      sqlite3Coverage(79559);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((jumpIfTrue == 0) && (jumpIfNull != 0) && (regFree1 != 0))) {
      sqlite3Coverage(79560);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((jumpIfTrue != 0) && (jumpIfNull == 0) && (regFree1 == 0))) {
      sqlite3Coverage(79561);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((jumpIfTrue != 0) && (jumpIfNull == 0) && (regFree1 != 0))) {
      sqlite3Coverage(79562);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((jumpIfTrue != 0) && (jumpIfNull != 0) && (regFree1 == 0))) {
      sqlite3Coverage(79563);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((jumpIfTrue != 0) && (jumpIfNull != 0) && (regFree1 != 0))) {
      sqlite3Coverage(79564);
    }  
  }  
}
static  void sqlite3ExprIfTrue(Parse *pParse , Expr *pExpr , int dest , int jumpIfNull )  {
  Vdbe *v =  pParse->pVdbe;
  int op =  0;
  int regFree1 =  0;
  int regFree2 =  0;
  int r1, r2;
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((v == 0)) {
      return;
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pExpr == 0)) {
      return;
    }  
  }  
  (op = pExpr->op);
  switch (op) {
    case 69:
    {
      int d2 =  sqlite3VdbeMakeLabel(v);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((jumpIfNull == 0)) {
          sqlite3Coverage(79595);
        }  
      }  
      sqlite3ExprCachePush(pParse);
      sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2, (jumpIfNull ^ 0x08));
      sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
      sqlite3VdbeResolveLabel(v, d2);
      sqlite3ExprCachePop(pParse, 1);
      break;
    }
    case 68:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((jumpIfNull == 0)) {
          sqlite3Coverage(79604);
        }  
      }  
      sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
      sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
      break;
    }
    case 19:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((jumpIfNull == 0)) {
          sqlite3Coverage(79610);
        }  
      }  
      sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
      break;
    }
    case 79:
    case 78:
    case 77:
    case 80:
    case 75:
    case 76:
    {
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 79)) {
          sqlite3Coverage(79626);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 78)) {
          sqlite3Coverage(79627);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 77)) {
          sqlite3Coverage(79628);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 80)) {
          sqlite3Coverage(79629);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 76)) {
          sqlite3Coverage(79630);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 75)) {
          sqlite3Coverage(79631);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((jumpIfNull == 0)) {
          sqlite3Coverage(79632);
        }  
      }  
      (r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, (&regFree1)));
      (r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, (&regFree2)));
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(79637);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree2 == 0)) {
          sqlite3Coverage(79638);
        }  
      }  
      break;
    }
    case 70:
    case 146:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 70)) {
          sqlite3Coverage(79643);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 146)) {
          sqlite3Coverage(79644);
        }  
      }  
      (r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, (&regFree1)));
      (r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, (&regFree2)));
      (op = ((op == 70) ? 76 : 75));
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, 0x80);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(79650);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree2 == 0)) {
          sqlite3Coverage(79651);
        }  
      }  
      break;
    }
    case 73:
    case 74:
    {
      ((void ) 0);
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 73)) {
          sqlite3Coverage(79658);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 74)) {
          sqlite3Coverage(79659);
        }  
      }  
      (r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, (&regFree1)));
      sqlite3VdbeAddOp2(v, op, r1, dest);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(79662);
        }  
      }  
      break;
    }
    case 71:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((jumpIfNull == 0)) {
          sqlite3Coverage(79666);
        }  
      }  
      exprCodeBetween(pParse, pExpr, dest, 1, jumpIfNull);
      break;
    }
    case 72:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      int destIfFalse =  sqlite3VdbeMakeLabel(v);
      int destIfNull =  (jumpIfNull ? dest : destIfFalse);
      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
      sqlite3VdbeAddOp2(v, 14, 0, dest);
      sqlite3VdbeResolveLabel(v, destIfFalse);
      break;
    }  
    id2i_label_1:
    default:
    {
      (r1 = sqlite3ExprCodeTemp(pParse, pExpr, (&regFree1)));
      sqlite3VdbeAddOp3(v, 39, r1, dest, (jumpIfNull != 0));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(79683);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((jumpIfNull == 0)) {
          sqlite3Coverage(79684);
        }  
      }  
      break;
    }
  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
}
static  void sqlite3ExprIfFalse(Parse *pParse , Expr *pExpr , int dest , int jumpIfNull )  {
  Vdbe *v =  pParse->pVdbe;
  int op =  0;
  int regFree1 =  0;
  int regFree2 =  0;
  int r1, r2;
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((v == 0)) {
      return;
    }  
  }  
  if ((pExpr == 0)) {
    return;
  }  
  (op = (((pExpr->op + (73 & 1)) ^ 1) - (73 & 1)));
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  switch (pExpr->op) {
    case 69:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((jumpIfNull == 0)) {
          sqlite3Coverage(79745);
        }  
      }  
      sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
      sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
      break;
    }
    case 68:
    {
      int d2 =  sqlite3VdbeMakeLabel(v);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((jumpIfNull == 0)) {
          sqlite3Coverage(79752);
        }  
      }  
      sqlite3ExprCachePush(pParse);
      sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2, (jumpIfNull ^ 0x08));
      sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
      sqlite3VdbeResolveLabel(v, d2);
      sqlite3ExprCachePop(pParse, 1);
      break;
    }
    case 19:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((jumpIfNull == 0)) {
          sqlite3Coverage(79761);
        }  
      }  
      sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
      break;
    }
    case 79:
    case 78:
    case 77:
    case 80:
    case 75:
    case 76:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 79)) {
          sqlite3Coverage(79771);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 78)) {
          sqlite3Coverage(79772);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 77)) {
          sqlite3Coverage(79773);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 80)) {
          sqlite3Coverage(79774);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 76)) {
          sqlite3Coverage(79775);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 75)) {
          sqlite3Coverage(79776);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((jumpIfNull == 0)) {
          sqlite3Coverage(79777);
        }  
      }  
      (r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, (&regFree1)));
      (r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, (&regFree2)));
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(79782);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree2 == 0)) {
          sqlite3Coverage(79783);
        }  
      }  
      break;
    }
    case 70:
    case 146:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pExpr->op == 70)) {
          sqlite3Coverage(79788);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pExpr->op == 146)) {
          sqlite3Coverage(79789);
        }  
      }  
      (r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, (&regFree1)));
      (r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, (&regFree2)));
      (op = ((pExpr->op == 70) ? 75 : 76));
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, 0x80);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(79795);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree2 == 0)) {
          sqlite3Coverage(79796);
        }  
      }  
      break;
    }
    case 73:
    case 74:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 73)) {
          sqlite3Coverage(79801);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 74)) {
          sqlite3Coverage(79802);
        }  
      }  
      (r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, (&regFree1)));
      sqlite3VdbeAddOp2(v, op, r1, dest);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(79805);
        }  
      }  
      break;
    }
    case 71:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((jumpIfNull == 0)) {
          sqlite3Coverage(79809);
        }  
      }  
      exprCodeBetween(pParse, pExpr, dest, 0, jumpIfNull);
      break;
    }
    case 72:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      if (jumpIfNull) {
        sqlite3ExprCodeIN(pParse, pExpr, dest, dest);
      }  
      else {
        int destIfNull =  sqlite3VdbeMakeLabel(v);
        sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);
        sqlite3VdbeResolveLabel(v, destIfNull);
      }
      break;
    }  
    id2i_label_1:
    default:
    {
      (r1 = sqlite3ExprCodeTemp(pParse, pExpr, (&regFree1)));
      sqlite3VdbeAddOp3(v, 40, r1, dest, (jumpIfNull != 0));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((regFree1 == 0)) {
          sqlite3Coverage(79828);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((jumpIfNull == 0)) {
          sqlite3Coverage(79829);
        }  
      }  
      break;
    }
  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
}
static  int sqlite3ExprCompare(Expr *pA , Expr *pB , int iTab )  {
  if (((pA == 0) || (pB == 0))) {
    return ((pB == pA) ? 0 : 2);
  }  
  ((void ) 0);
  ((void ) 0);
  if ((((pA->flags & 0x000800) != 0) || ((pB->flags & 0x000800) != 0))) {
    return 2;
  }  
  if (((pA->flags & 0x000010) != (pB->flags & 0x000010))) {
    return 2;
  }  
  if (((pA->op != pB->op) && ((pA->op != 132) || (pA->op2 != pB->op)))) {
    if (((pA->op == 92) && (sqlite3ExprCompare(pA->pLeft, pB, iTab) < 2))) {
      return 1;
    }  
    if (((pB->op == 92) && (sqlite3ExprCompare(pA, pB->pLeft, iTab) < 2))) {
      return 1;
    }  
    return 2;
  }  
  if (sqlite3ExprCompare(pA->pLeft, pB->pLeft, iTab)) {
    return 2;
  }  
  if (sqlite3ExprCompare(pA->pRight, pB->pRight, iTab)) {
    return 2;
  }  
  if (sqlite3ExprListCompare(pA->x.pList, pB->x.pList, iTab)) {
    return 2;
  }  
  if ((pA->iColumn != pB->iColumn)) {
    return 2;
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((pA->iTable != pB->iTable) && (pA->op != 132) && ((pA->iTable != iTab) || (pB->iTable >= 0)))) {
      return 2;
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((pA->iTable != pB->iTable) && (pA->op != 132) && ((pA->iTable != iTab) || 0))) {
      return 2;
    }  
  }  
  if (((pA->flags & 0x000400) != 0)) {
    if (((! ((pB->flags & 0x000400) != 0)) || (pA->u.iValue != pB->u.iValue))) {
      return 2;
    }  
  } 
  else if (((((! id2i_sqlite_coverage_test) ) ) && ((pA->op != 152) && (pA->op != 154) && pA->u.zToken))) {
    if ((((pB->flags & 0x000400) != 0) || (pB->u.zToken == 0))) {
      return 2;
    }  
    if ((strcmp(pA->u.zToken, pB->u.zToken) != 0)) {
      return ((pA->op == 92) ? 1 : 2);
    }  
  }
  
  else if ((((id2i_sqlite_coverage_test ) ) && ((pA->op != 152) && 1 && pA->u.zToken))) {
    if ((((pB->flags & 0x000400) != 0) || 0)) {
      return 2;
    }  
    if ((strcmp(pA->u.zToken, pB->u.zToken) != 0)) {
      return ((pA->op == 92) ? 1 : 2);
    }  
  } 
  return 0;
}
static  int sqlite3ExprListCompare(ExprList *pA , ExprList *pB , int iTab )  {
  int i;
  if (((pA == 0) && (pB == 0))) {
    return 0;
  }  
  if (((pA == 0) || (pB == 0))) {
    return 1;
  }  
  if ((pA->nExpr != pB->nExpr)) {
    return 1;
  }  
  for ((i = 0); (i < pA->nExpr); i++) {
    Expr *pExprA =  pA->a[i].pExpr;
    Expr *pExprB =  pB->a[i].pExpr;
    if ((pA->a[i].sortOrder != pB->a[i].sortOrder)) {
      return 1;
    }  
    if (sqlite3ExprCompare(pExprA, pExprB, iTab)) {
      return 1;
    }  
  }
  return 0;
}
static  int sqlite3ExprImpliesExpr(Expr *pE1 , Expr *pE2 , int iTab )  {
  if ((sqlite3ExprCompare(pE1, pE2, iTab) == 0)) {
    return 1;
  }  
  if (((pE2->op == 68) && (sqlite3ExprImpliesExpr(pE1, pE2->pLeft, iTab) || sqlite3ExprImpliesExpr(pE1, pE2->pRight, iTab)))) {
    return 1;
  }  
  if (((pE2->op == 74) && (sqlite3ExprCompare(pE1->pLeft, pE2->pLeft, iTab) == 0) && ((pE1->op != 73) && (pE1->op != 70)))) {
    return 1;
  }  
  return 0;
}
struct  SrcCount {
  SrcList *pSrc ;
  int nThis ;
  int nOther ;
}  ;
static  int exprSrcCount(Walker *pWalker , Expr *pExpr )  {
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((pExpr->op == 152) || (pExpr->op == 154))) {
      int i;
      struct  SrcCount   *p =  pWalker->u.pSrcCount;
      SrcList *pSrc =  p->pSrc;
      for ((i = 0); (i < pSrc->nSrc); i++) {
        if ((pExpr->iTable == pSrc->a[i].iCursor)) {
          break;
        }  
      }
      if ((i < pSrc->nSrc)) {
        p->nThis++;
      }  
      else {
        p->nOther++;
      }
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((pExpr->op == 152) || 0)) {
      int i;
      struct  SrcCount   *p =  pWalker->u.pSrcCount;
      SrcList *pSrc =  p->pSrc;
      for ((i = 0); (i < pSrc->nSrc); i++) {
        if ((pExpr->iTable == pSrc->a[i].iCursor)) {
          break;
        }  
      }
      if ((i < pSrc->nSrc)) {
        p->nThis++;
      }  
      else {
        p->nOther++;
      }
    }  
  }  
  return 0;
}
static  int sqlite3FunctionUsesThisSrc(Expr *pExpr , SrcList *pSrcList )  {
  Walker w;
  struct  SrcCount   cnt;
  ((void ) 0);
  memset((&w), 0, sizeof(w));
  (w.xExprCallback = exprSrcCount);
  (w.u.pSrcCount = (&cnt));
  (cnt.pSrc = pSrcList);
  (cnt.nThis = 0);
  (cnt.nOther = 0);
  sqlite3WalkExprList((&w), pExpr->x.pList);
  return ((cnt.nThis > 0) || (cnt.nOther == 0));
}
static  int addAggInfoColumn(sqlite3 *db , AggInfo *pInfo )  {
  int i;
  (pInfo->aCol = sqlite3ArrayAllocate(db, pInfo->aCol, sizeof(pInfo->aCol[0]), (&pInfo->nColumn), (&i)));
  return i;
}
static  int addAggInfoFunc(sqlite3 *db , AggInfo *pInfo )  {
  int i;
  (pInfo->aFunc = sqlite3ArrayAllocate(db, pInfo->aFunc, sizeof(pInfo->aFunc[0]), (&pInfo->nFunc), (&i)));
  return i;
}
static  int analyzeAggregate(Walker *pWalker , Expr *pExpr )  {
  int i;
  NameContext *pNC =  pWalker->u.pNC;
  Parse *pParse =  pNC->pParse;
  SrcList *pSrcList =  pNC->pSrcList;
  AggInfo *pAggInfo =  pNC->pAggInfo;
  switch (pExpr->op) {
    case 154:
    case 152:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pExpr->op == 154)) {
          sqlite3Coverage(80070);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pExpr->op == 152)) {
          sqlite3Coverage(80071);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if (1) {
          struct  SrcList_item   *pItem =  pSrcList->a;
          for ((i = 0); (i < pSrcList->nSrc); i++, pItem++) {
            struct  AggInfo_col   *pCol;
            ((void ) 0);
            if ((pExpr->iTable == pItem->iCursor)) {
              int k;
              (pCol = pAggInfo->aCol);
              for ((k = 0); (k < pAggInfo->nColumn); k++, pCol++) {
                if (((pCol->iTable == pExpr->iTable) && (pCol->iColumn == pExpr->iColumn))) {
                  break;
                }  
              }
              if (((k >= pAggInfo->nColumn) && ((k = addAggInfoColumn(pParse->db, pAggInfo)) >= 0))) {
                (pCol = (&pAggInfo->aCol[k]));
                (pCol->pTab = pExpr->pTab);
                (pCol->iTable = pExpr->iTable);
                (pCol->iColumn = pExpr->iColumn);
                (pCol->iMem = ++pParse->nMem);
                (pCol->iSorterColumn = (- 1));
                (pCol->pExpr = pExpr);
                if (pAggInfo->pGroupBy) {
                  int j, n;
                  ExprList *pGB =  pAggInfo->pGroupBy;
                  struct  ExprList_item   *pTerm =  pGB->a;
                  (n = pGB->nExpr);
                  for ((j = 0); (j < n); j++, pTerm++) {
                    Expr *pE =  pTerm->pExpr;
                    if (((pE->op == 152) && (pE->iTable == pExpr->iTable) && (pE->iColumn == pExpr->iColumn))) {
                      (pCol->iSorterColumn = j);
                      break;
                    }  
                  }
                }  
                if ((pCol->iSorterColumn < 0)) {
                  (pCol->iSorterColumn = pAggInfo->nSortingColumn++);
                }  
              }  
              (pExpr->pAggInfo = pAggInfo);
              (pExpr->op = 154);
              (pExpr->iAgg = ((i16 ) k));
              break;
            }  
          }
        }  
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if ((pSrcList != 0)) {
          struct  SrcList_item   *pItem =  pSrcList->a;
          for ((i = 0); (i < pSrcList->nSrc); i++, pItem++) {
            struct  AggInfo_col   *pCol;
            ((void ) 0);
            if ((pExpr->iTable == pItem->iCursor)) {
              int k;
              (pCol = pAggInfo->aCol);
              for ((k = 0); (k < pAggInfo->nColumn); k++, pCol++) {
                if (((pCol->iTable == pExpr->iTable) && (pCol->iColumn == pExpr->iColumn))) {
                  break;
                }  
              }
              if (((k >= pAggInfo->nColumn) && ((k = addAggInfoColumn(pParse->db, pAggInfo)) >= 0))) {
                (pCol = (&pAggInfo->aCol[k]));
                (pCol->pTab = pExpr->pTab);
                (pCol->iTable = pExpr->iTable);
                (pCol->iColumn = pExpr->iColumn);
                (pCol->iMem = ++pParse->nMem);
                (pCol->iSorterColumn = (- 1));
                (pCol->pExpr = pExpr);
                if (pAggInfo->pGroupBy) {
                  int j, n;
                  ExprList *pGB =  pAggInfo->pGroupBy;
                  struct  ExprList_item   *pTerm =  pGB->a;
                  (n = pGB->nExpr);
                  for ((j = 0); (j < n); j++, pTerm++) {
                    Expr *pE =  pTerm->pExpr;
                    if (((pE->op == 152) && (pE->iTable == pExpr->iTable) && (pE->iColumn == pExpr->iColumn))) {
                      (pCol->iSorterColumn = j);
                      break;
                    }  
                  }
                }  
                if ((pCol->iSorterColumn < 0)) {
                  (pCol->iSorterColumn = pAggInfo->nSortingColumn++);
                }  
              }  
              (pExpr->pAggInfo = pAggInfo);
              (pExpr->op = 154);
              (pExpr->iAgg = ((i16 ) k));
              break;
            }  
          }
        }  
      }  
      return 1;
    }
    case 153:
    {
      if ((((pNC->ncFlags & 0x08) == 0) && (pWalker->walkerDepth == pExpr->op2))) {
        struct  AggInfo_func   *pItem =  pAggInfo->aFunc;
        for ((i = 0); (i < pAggInfo->nFunc); i++, pItem++) {
          if ((sqlite3ExprCompare(pItem->pExpr, pExpr, (- 1)) == 0)) {
            break;
          }  
        }
        if ((i >= pAggInfo->nFunc)) {
          u8 enc =  pParse->db->aDb[0].pSchema->enc;
          (i = addAggInfoFunc(pParse->db, pAggInfo));
          if ((i >= 0)) {
            ((void ) 0);
            (pItem = (&pAggInfo->aFunc[i]));
            (pItem->pExpr = pExpr);
            (pItem->iMem = ++pParse->nMem);
            ((void ) 0);
            (pItem->pFunc = sqlite3FindFunction(pParse->db, pExpr->u.zToken, sqlite3Strlen30(pExpr->u.zToken), (pExpr->x.pList ? pExpr->x.pList->nExpr : 0), enc, 0));
            if ((pExpr->flags & 0x000010)) {
              (pItem->iDistinct = pParse->nTab++);
            }  
            else {
              (pItem->iDistinct = (- 1));
            }
          }  
        }  
        ((void ) 0);
        (pExpr->iAgg = ((i16 ) i));
        (pExpr->pAggInfo = pAggInfo);
        return 1;
      }  
      else {
        return 0;
      }
    }
  }
  return 0;
}
static  int analyzeAggregatesInSelect(Walker *pWalker , Select *pSelect )  {
  ((void ) pWalker);
  ((void ) pSelect);
  return 0;
}
static  void sqlite3ExprAnalyzeAggregates(NameContext *pNC , Expr *pExpr )  {
  Walker w;
  memset((&w), 0, sizeof(w));
  (w.xExprCallback = analyzeAggregate);
  (w.xSelectCallback = analyzeAggregatesInSelect);
  (w.u.pNC = pNC);
  ((void ) 0);
  sqlite3WalkExpr((&w), pExpr);
}
static  void sqlite3ExprAnalyzeAggList(NameContext *pNC , ExprList *pList )  {
  struct  ExprList_item   *pItem;
  int i;
  if (pList) {
    for ((pItem = pList->a), (i = 0); (i < pList->nExpr); i++, pItem++) {
      sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr);
    }
  }  
}
static  int sqlite3GetTempReg(Parse *pParse )  {
  if ((pParse->nTempReg == 0)) {
    return ++pParse->nMem;
  }  
  return pParse->aTempReg[--pParse->nTempReg];
}
static  void sqlite3ReleaseTempReg(Parse *pParse , int iReg )  {
  if ((iReg && (pParse->nTempReg < ((int ) (sizeof(pParse->aTempReg) / sizeof(pParse->aTempReg[0])))))) {
    int i;
    struct  yColCache   *p;
    for ((i = 0), (p = pParse->aColCache); (i < 10); i++, p++) {
      if ((p->iReg == iReg)) {
        (p->tempReg = 1);
        return;
      }  
    }
    (pParse->aTempReg[pParse->nTempReg++] = iReg);
  }  
}
static  int sqlite3GetTempRange(Parse *pParse , int nReg )  {
  int i, n;
  (i = pParse->iRangeReg);
  (n = pParse->nRangeReg);
  if ((nReg <= n)) {
    ((void ) 0);
    (pParse->iRangeReg += nReg);
    (pParse->nRangeReg -= nReg);
  }  
  else {
    (i = (pParse->nMem + 1));
    (pParse->nMem += nReg);
  }
  return i;
}
static  void sqlite3ReleaseTempRange(Parse *pParse , int iReg , int nReg )  {
  sqlite3ExprCacheRemove(pParse, iReg, nReg);
  if ((nReg > pParse->nRangeReg)) {
    (pParse->nRangeReg = nReg);
    (pParse->iRangeReg = iReg);
  }  
}
static  void sqlite3ClearTempRegCache(Parse *pParse )  {
  (pParse->nTempReg = 0);
  (pParse->nRangeReg = 0);
}
static  void renameTableFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv )  {
  unsigned char const *zSql =  sqlite3_value_text(argv[0]);
  unsigned char const *zTableName =  sqlite3_value_text(argv[1]);
  int token;
  Token tname;
  unsigned char const *zCsr =  zSql;
  int len =  0;
  char *zRet;
  sqlite3 *db =  sqlite3_context_db_handle(context);
  ((void ) NotUsed);
  if (zSql) {
    do {
      if ((! (*zCsr))) {
        return;
      }  
      (tname.z = ((char *) zCsr));
      (tname.n = len);
      do {
        (zCsr += len);
        (len = sqlite3GetToken(zCsr, (&token)));
      } while ((token == 149));
      ((void ) 0);
    } while (((token != 22) && (token != 121)));
    (zRet = sqlite3MPrintf(db, "%.*s\"%w\"%s", (((u8 *) tname.z) - zSql), zSql, zTableName, (tname.z + tname.n)));
    sqlite3_result_text(context, zRet, (- 1), ((sqlite3_destructor_type ) sqlite3MallocSize));
  }  
}
static  void renameParentFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv )  {
  sqlite3 *db =  sqlite3_context_db_handle(context);
  char *zOutput =  0;
  char *zResult;
  unsigned char const *zInput =  sqlite3_value_text(argv[0]);
  unsigned char const *zOld =  sqlite3_value_text(argv[1]);
  unsigned char const *zNew =  sqlite3_value_text(argv[2]);
  unsigned const char *z;
  int n;
  int token;
  ((void ) NotUsed);
  for ((z = zInput); (*z); (z = (z + n))) {
    (n = sqlite3GetToken(z, (&token)));
    if ((token == 102)) {
      char *zParent;
      do {
        (z += n);
        (n = sqlite3GetToken(z, (&token)));
      } while ((token == 149));
      (zParent = sqlite3DbStrNDup(db, ((const  char *) z), n));
      if ((zParent == 0)) {
        break;
      }  
      sqlite3Dequote(zParent);
      if ((0 == sqlite3_stricmp(((const  char *) zOld), zParent))) {
        char *zOut =  sqlite3MPrintf(db, "%s%.*s\"%w\"", (zOutput ? zOutput : ""), (z - zInput), zInput, ((const  char *) zNew));
        sqlite3DbFree(db, zOutput);
        (zOutput = zOut);
        (zInput = (&z[n]));
      }  
      sqlite3DbFree(db, zParent);
    }  
  }
  (zResult = sqlite3MPrintf(db, "%s%s", (zOutput ? zOutput : ""), zInput)), sqlite3_result_text(context, zResult, (- 1), ((sqlite3_destructor_type ) sqlite3MallocSize));
  sqlite3DbFree(db, zOutput);
}
static  void renameTriggerFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv )  {
  unsigned char const *zSql =  sqlite3_value_text(argv[0]);
  unsigned char const *zTableName =  sqlite3_value_text(argv[1]);
  int token;
  Token tname;
  int dist =  3;
  unsigned char const *zCsr =  zSql;
  int len =  0;
  char *zRet;
  sqlite3 *db =  sqlite3_context_db_handle(context);
  ((void ) NotUsed);
  if (zSql) {
    do {
      if ((! (*zCsr))) {
        return;
      }  
      (tname.z = ((char *) zCsr));
      (tname.n = len);
      do {
        (zCsr += len);
        (len = sqlite3GetToken(zCsr, (&token)));
      } while ((token == 149));
      ((void ) 0);
      dist++;
      if (((token == 118) || (token == 104))) {
        (dist = 0);
      }  
    } while (((dist != 2) || ((token != 135) && (token != 45) && (token != 5))));
    (zRet = sqlite3MPrintf(db, "%.*s\"%w\"%s", (((u8 *) tname.z) - zSql), zSql, zTableName, (tname.z + tname.n)));
    sqlite3_result_text(context, zRet, (- 1), ((sqlite3_destructor_type ) sqlite3MallocSize));
  }  
}
static  void sqlite3AlterFunctions(void )  {
  static FuncDef _1329_aAlterTableFuncs[] =  { { 2,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  renameTableFunc,  0,  0,  "sqlite_rename_table",  0,  0},  { 2,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  renameTriggerFunc,  0,  0,  "sqlite_rename_trigger",  0,  0}};
  static FuncDef _1278_aAlterTableFuncs[] =  { { 2,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  renameTableFunc,  0,  0,  "sqlite_rename_table",  0,  0},  { 2,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  renameTriggerFunc,  0,  0,  "sqlite_rename_trigger",  0,  0},  { 3,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  renameParentFunc,  0,  0,  "sqlite_rename_parent",  0,  0}};
  int i;
  FuncDefHash *pHash =  (&sqlite3GlobalFunctions);
  FuncDef *aFunc =  ((((! id2i_sqlite_omit_foreign_key) ) ) ? ((FuncDef *) (&_1278_aAlterTableFuncs)) : ((FuncDef *) (&_1329_aAlterTableFuncs)));
  for ((i = 0); ((((! id2i_sqlite_omit_foreign_key) ) ) ? (i < ((int ) (sizeof(_1278_aAlterTableFuncs) / sizeof(_1278_aAlterTableFuncs[0])))) : (i < ((int ) (sizeof(_1329_aAlterTableFuncs) / sizeof(_1329_aAlterTableFuncs[0]))))); i++) {
    sqlite3FuncDefInsert(pHash, (&aFunc[i]));
  }
}
static  char *whereOrName(sqlite3 *db , char *zWhere , char *zConstant )  {
  char *zNew;
  if ((! zWhere)) {
    (zNew = sqlite3MPrintf(db, "name=%Q", zConstant));
  }  
  else {
    (zNew = sqlite3MPrintf(db, "%s OR name=%Q", zWhere, zConstant));
    sqlite3DbFree(db, zWhere);
  }
  return zNew;
}
static  char *whereForeignKeys(Parse *pParse , Table *pTab )  {
  FKey *p;
  char *zWhere =  0;
  for ((p = sqlite3FkReferences(pTab)); p; (p = p->pNextTo)) {
    (zWhere = whereOrName(pParse->db, zWhere, p->pFrom->zName));
  }
  return zWhere;
}
static  char *whereTempTriggers(Parse *pParse , Table *pTab )  {
  Trigger *pTrig;
  char *zWhere =  0;
  const Schema *pTempSchema =  pParse->db->aDb[1].pSchema;
  if ((pTab->pSchema != pTempSchema)) {
    sqlite3 *db =  pParse->db;
    for ((pTrig = sqlite3TriggerList(pParse, pTab)); pTrig; (pTrig = pTrig->pNext)) {
      if ((pTrig->pSchema == pTempSchema)) {
        (zWhere = whereOrName(db, zWhere, pTrig->zName));
      }  
    }
  }  
  if (zWhere) {
    char *zNew =  sqlite3MPrintf(pParse->db, "type='trigger' AND (%s)", zWhere);
    sqlite3DbFree(pParse->db, zWhere);
    (zWhere = zNew);
  }  
  return zWhere;
}
static  void reloadTableSchema(Parse *pParse , Table *pTab , const  char *zName )  {
  Vdbe *v;
  char *zWhere;
  int iDb;
  Trigger *pTrig;
  (v = sqlite3GetVdbe(pParse));
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((v == 0)) {
      return;
    }  
  }  
  ((void ) 0);
  (iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema));
  ((void ) 0);
  for ((pTrig = sqlite3TriggerList(pParse, pTab)); pTrig; (pTrig = pTrig->pNext)) {
    int iTrigDb =  sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);
    ((void ) 0);
    sqlite3VdbeAddOp4(v, 116, iTrigDb, 0, 0, pTrig->zName, 0);
  }
  sqlite3VdbeAddOp4(v, 114, iDb, 0, 0, pTab->zName, 0);
  (zWhere = sqlite3MPrintf(pParse->db, "tbl_name=%Q", zName));
  if ((! zWhere)) {
    return;
  }  
  sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere);
  if (((zWhere = whereTempTriggers(pParse, pTab)) != 0)) {
    sqlite3VdbeAddParseSchemaOp(v, 1, zWhere);
  }  
}
static  int isSystemTable(Parse *pParse , const  char *zName )  {
  if (((sqlite3Strlen30(zName) > 6) && (0 == sqlite3_strnicmp(zName, "sqlite_", 7)))) {
    sqlite3ErrorMsg(pParse, "table %s may not be altered", zName);
    return 1;
  }  
  return 0;
}
static  void sqlite3AlterRenameTable(Parse *pParse , SrcList *pSrc , Token *pName )  {
  int iDb;
  char *zDb;
  Table *pTab;
  char *zName =  0;
  sqlite3 *db =  pParse->db;
  int nTabName;
  const char *zTabName;
  Vdbe *v;
  char *zWhere =  0;
  VTable *pVTab =  0;
  int savedDbFlags;
  (savedDbFlags = db->flags);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      goto exit_rename_table;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (db->mallocFailed) {
      goto exit_rename_table;
    }  
  }  
  ((void ) 0);
  ((void ) 0);
  (pTab = sqlite3LocateTableItem(pParse, 0, (&pSrc->a[0])));
  if ((! pTab)) {
    goto exit_rename_table;
  }  
  (iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema));
  (zDb = db->aDb[iDb].zName);
  (db->flags |= 0x00200000);
  (zName = sqlite3NameFromToken(db, pName));
  if ((! zName)) {
    goto exit_rename_table;
  }  
  if ((sqlite3FindTable(db, zName, zDb) || sqlite3FindIndex(db, zName, zDb))) {
    sqlite3ErrorMsg(pParse, "there is already another table or index with this name: %s", zName);
    goto exit_rename_table;
  }  
  if ((0 != isSystemTable(pParse, pTab->zName))) {
    goto exit_rename_table;
  }  
  if ((0 != sqlite3CheckObjectName(pParse, zName))) {
    goto exit_rename_table;
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if (pTab->pSelect) {
      sqlite3ErrorMsg(pParse, "view %s may not be altered", pTab->zName);
      goto exit_rename_table;
    }  
  }  
  if (sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0)) {
    goto exit_rename_table;
  }  
  if (sqlite3ViewGetColumnNames(pParse, pTab)) {
    goto exit_rename_table;
  }  
  if (((pTab->tabFlags & 0x10) != 0)) {
    (pVTab = sqlite3GetVTable(db, pTab));
    if ((pVTab->pVtab->pModule->xRename == 0)) {
      (pVTab = 0);
    }  
  }  
  (v = sqlite3GetVdbe(pParse));
  if ((v == 0)) {
    goto exit_rename_table;
  }  
  sqlite3BeginWriteOperation(pParse, (pVTab != 0), iDb);
  sqlite3ChangeCookie(pParse, iDb);
  if (pVTab) {
    int i =  ++pParse->nMem;
    sqlite3VdbeAddOp4(v, 94, 0, i, 0, zName, 0);
    sqlite3VdbeAddOp4(v, 140, i, 0, 0, ((const  char *) pVTab), (- 10));
    sqlite3MayAbort(pParse);
  }  
  (zTabName = pTab->zName);
  (nTabName = sqlite3Utf8CharLen(zTabName, (- 1)));
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if ((db->flags & 0x00080000)) {
      if (((zWhere = whereForeignKeys(pParse, pTab)) != 0)) {
        sqlite3NestedParse(pParse, "UPDATE \"%w\".%s SET " "sql = sqlite_rename_parent(sql, %Q, %Q) " "WHERE %s;", zDb, (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"), zTabName, zName, zWhere);
        sqlite3DbFree(db, zWhere);
      }  
    }  
  }  
  sqlite3NestedParse(pParse, "UPDATE %Q.%s SET " "sql = CASE " "WHEN type = 'trigger' THEN sqlite_rename_trigger(sql, %Q)" "ELSE sqlite_rename_table(sql, %Q) END, " "tbl_name = %Q, " "name = CASE " "WHEN type='table' THEN %Q " "WHEN name LIKE 'sqlite_autoindex%%' AND type='index' THEN " "'sqlite_autoindex_' || %Q || substr(name,%d+18) " "ELSE name END " "WHERE tbl_name=%Q COLLATE nocase AND " "(type='table' OR type='index' OR type='trigger');", zDb, (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"), zName, zName, zName, zName, zName, nTabName, zTabName);
  if (sqlite3FindTable(db, "sqlite_sequence", zDb)) {
    sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q", zDb, zName, pTab->zName);
  }  
  if (((zWhere = whereTempTriggers(pParse, pTab)) != 0)) {
    sqlite3NestedParse(pParse, "UPDATE sqlite_temp_master SET " "sql = sqlite_rename_trigger(sql, %Q), " "tbl_name = %Q " "WHERE %s;", zName, zName, zWhere);
    sqlite3DbFree(db, zWhere);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if ((db->flags & 0x00080000)) {
      FKey *p;
      for ((p = sqlite3FkReferences(pTab)); p; (p = p->pNextTo)) {
        Table *pFrom =  p->pFrom;
        if ((pFrom != pTab)) {
          reloadTableSchema(pParse, p->pFrom, pFrom->zName);
        }  
      }
    }  
  }  
  reloadTableSchema(pParse, pTab, zName);
  exit_rename_table:
  sqlite3SrcListDelete(db, pSrc);
  sqlite3DbFree(db, zName);
  (db->flags = savedDbFlags);
}
static  void sqlite3MinimumFileFormat(Parse *pParse , int iDb , int minFormat )  {
  Vdbe *v;
  (v = sqlite3GetVdbe(pParse));
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      int r1 =  sqlite3GetTempReg(pParse);
      int r2 =  sqlite3GetTempReg(pParse);
      int j1;
      sqlite3VdbeAddOp3(v, 45, iDb, r1, 2);
      sqlite3VdbeUsesBtree(v, iDb);
      sqlite3VdbeAddOp2(v, 21, minFormat, r2);
      (j1 = sqlite3VdbeAddOp3(v, 80, r2, 0, r1));
      sqlite3VdbeAddOp3(v, 46, iDb, 2, r2);
      sqlite3VdbeJumpHere(v, j1);
      sqlite3ReleaseTempReg(pParse, r1);
      sqlite3ReleaseTempReg(pParse, r2);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (v) {
      int r1 =  sqlite3GetTempReg(pParse);
      int r2 =  sqlite3GetTempReg(pParse);
      int j1;
      sqlite3VdbeAddOp3(v, 45, iDb, r1, 2);
      sqlite3VdbeUsesBtree(v, iDb);
      sqlite3VdbeAddOp2(v, 21, minFormat, r2);
      (j1 = sqlite3VdbeAddOp3(v, 80, r2, 0, r1));
      sqlite3VdbeAddOp3(v, 46, iDb, 2, r2);
      sqlite3VdbeJumpHere(v, j1);
      sqlite3ReleaseTempReg(pParse, r1);
      sqlite3ReleaseTempReg(pParse, r2);
    }  
  }  
}
static  void sqlite3AlterFinishAddColumn(Parse *pParse , Token *pColDef )  {
  Table *pNew;
  Table *pTab;
  int iDb;
  const char *zDb;
  const char *zTab;
  char *zCol;
  Column *pCol;
  Expr *pDflt;
  sqlite3 *db;
  (db = pParse->db);
  if ((pParse->nErr || db->mallocFailed)) {
    return;
  }  
  (pNew = pParse->pNewTable);
  ((void ) 0);
  ((void ) 0);
  (iDb = sqlite3SchemaToIndex(db, pNew->pSchema));
  (zDb = db->aDb[iDb].zName);
  (zTab = (&pNew->zName[16]));
  (pCol = (&pNew->aCol[(pNew->nCol - 1)]));
  (pDflt = pCol->pDflt);
  (pTab = sqlite3FindTable(db, zTab, zDb));
  ((void ) 0);
  if (sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0)) {
    return;
  }  
  if ((pDflt && (pDflt->op == 98))) {
    (pDflt = 0);
  }  
  if ((pCol->colFlags & 0x0001)) {
    sqlite3ErrorMsg(pParse, "Cannot add a PRIMARY KEY column");
    return;
  }  
  if (pNew->pIndex) {
    sqlite3ErrorMsg(pParse, "Cannot add a UNIQUE column");
    return;
  }  
  if (((db->flags & 0x00080000) && pNew->pFKey && pDflt)) {
    sqlite3ErrorMsg(pParse, "Cannot add a REFERENCES column with non-NULL default value");
    return;
  }  
  if ((pCol->notNull && (! pDflt))) {
    sqlite3ErrorMsg(pParse, "Cannot add a NOT NULL column with default value NULL");
    return;
  }  
  if (pDflt) {
    sqlite3_value *pVal =  0;
    if (sqlite3ValueFromExpr(db, pDflt, 1, 'b', (&pVal))) {
      (db->mallocFailed = 1);
      return;
    }  
    if ((! pVal)) {
      sqlite3ErrorMsg(pParse, "Cannot add a column with non-constant default");
      return;
    }  
    sqlite3ValueFree(pVal);
  }  
  (zCol = sqlite3DbStrNDup(db, ((char *) pColDef->z), pColDef->n));
  if (zCol) {
    char *zEnd =  (&zCol[(pColDef->n - 1)]);
    int savedDbFlags =  db->flags;
    while (((zEnd > zCol) && (((*zEnd) == ';') || (sqlite3CtypeMap[((unsigned  char ) (*zEnd))] & 0x01)))) {
      ((*zEnd--) = '\0');
    }
    (db->flags |= 0x00200000);
    sqlite3NestedParse(pParse, "UPDATE \"%w\".%s SET " "sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) " "WHERE type = 'table' AND name = %Q", zDb, (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"), pNew->addColOffset, zCol, (pNew->addColOffset + 1), zTab);
    sqlite3DbFree(db, zCol);
    (db->flags = savedDbFlags);
  }  
  sqlite3MinimumFileFormat(pParse, iDb, (pDflt ? 3 : 2));
  reloadTableSchema(pParse, pTab, pTab->zName);
}
static  void sqlite3AlterBeginAddColumn(Parse *pParse , SrcList *pSrc )  {
  Table *pNew;
  Table *pTab;
  Vdbe *v;
  int iDb;
  int i;
  int nAlloc;
  sqlite3 *db =  pParse->db;
  ((void ) 0);
  ((void ) 0);
  if (db->mallocFailed) {
    goto exit_begin_add_column;
  }  
  (pTab = sqlite3LocateTableItem(pParse, 0, (&pSrc->a[0])));
  if ((! pTab)) {
    goto exit_begin_add_column;
  }  
  if (((pTab->tabFlags & 0x10) != 0)) {
    sqlite3ErrorMsg(pParse, "virtual tables may not be altered");
    goto exit_begin_add_column;
  }  
  if (pTab->pSelect) {
    sqlite3ErrorMsg(pParse, "Cannot add a column to a view");
    goto exit_begin_add_column;
  }  
  if ((0 != isSystemTable(pParse, pTab->zName))) {
    goto exit_begin_add_column;
  }  
  ((void ) 0);
  (iDb = sqlite3SchemaToIndex(db, pTab->pSchema));
  (pNew = ((Table *) sqlite3DbMallocZero(db, sizeof(Table ))));
  if ((! pNew)) {
    goto exit_begin_add_column;
  }  
  (pParse->pNewTable = pNew);
  (pNew->nRef = 1);
  (pNew->nCol = pTab->nCol);
  ((void ) 0);
  (nAlloc = ((((pNew->nCol - 1) / 8) * 8) + 8));
  ((void ) 0);
  (pNew->aCol = ((Column *) sqlite3DbMallocZero(db, (sizeof(Column ) * nAlloc))));
  (pNew->zName = sqlite3MPrintf(db, "sqlite_altertab_%s", pTab->zName));
  if (((! pNew->aCol) || (! pNew->zName))) {
    (db->mallocFailed = 1);
    goto exit_begin_add_column;
  }  
  memcpy(pNew->aCol, pTab->aCol, (sizeof(Column ) * pNew->nCol));
  for ((i = 0); (i < pNew->nCol); i++) {
    Column *pCol =  (&pNew->aCol[i]);
    (pCol->zName = sqlite3DbStrDup(db, pCol->zName));
    (pCol->zColl = 0);
    (pCol->zType = 0);
    (pCol->pDflt = 0);
    (pCol->zDflt = 0);
  }
  (pNew->pSchema = db->aDb[iDb].pSchema);
  (pNew->addColOffset = pTab->addColOffset);
  (pNew->nRef = 1);
  sqlite3BeginWriteOperation(pParse, 0, iDb);
  (v = sqlite3GetVdbe(pParse));
  if ((! v)) {
    goto exit_begin_add_column;
  }  
  sqlite3ChangeCookie(pParse, iDb);
  exit_begin_add_column:
  sqlite3SrcListDelete(db, pSrc);
  return;
}
static  void openStatTable(Parse *pParse , int iDb , int iStatCur , const  char *zWhere , const  char *zWhereType )  {
  static const struct   {
    const  char *zName ;
    const  char *zCols ;
  }  aTable[] =  { { "sqlite_stat1",  "tbl,idx,stat"},  { "sqlite_stat3",  0},  { "sqlite_stat4",  0}};
  int i;
  sqlite3 *db =  pParse->db;
  Db *pDb;
  Vdbe *v =  sqlite3GetVdbe(pParse);
  int aRoot[((int ) (sizeof(aTable) / sizeof(aTable[0])))];
  u8 aCreateTbl[((int ) (sizeof(aTable) / sizeof(aTable[0])))];
  if ((v == 0)) {
    return;
  }  
  ((void ) 0);
  ((void ) 0);
  (pDb = (&db->aDb[iDb]));
  for ((i = 0); (i < ((int ) (sizeof(aTable) / sizeof(aTable[0])))); i++) {
    const char *zTab =  aTable[i].zName;
    Table *pStat;
    if (((pStat = sqlite3FindTable(db, zTab, pDb->zName)) == 0)) {
      if (aTable[i].zCols) {
        sqlite3NestedParse(pParse, "CREATE TABLE %Q.%s(%s)", pDb->zName, zTab, aTable[i].zCols);
        (aRoot[i] = pParse->regRoot);
        (aCreateTbl[i] = 0x02);
      }  
    }  
    else {
      (aRoot[i] = pStat->tnum);
      (aCreateTbl[i] = 0);
      sqlite3TableLock(pParse, iDb, aRoot[i], 1, zTab);
      if (zWhere) {
        sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE %s=%Q", pDb->zName, zTab, zWhereType, zWhere);
      }  
      else {
        sqlite3VdbeAddOp2(v, 109, aRoot[i], iDb);
      }
    }
  }
  for ((i = 0); aTable[i].zCols; i++) {
    ((void ) 0);
    sqlite3VdbeAddOp3(v, 49, (iStatCur + i), aRoot[i], iDb);
    sqlite3VdbeChangeP4(v, (- 1), ((char *) 3), (- 14));
    sqlite3VdbeChangeP5(v, aCreateTbl[i]);
  }
}
typedef struct  _1330_Stat4Accum   _1330_Stat4Accum;
typedef struct  _1330_Stat4Sample   _1330_Stat4Sample;
struct  _1330_Stat4Sample {
  tRowcnt *anEq ;
  tRowcnt *anDLt ;
}  ;
struct  _1330_Stat4Accum {
  tRowcnt nRow ;
  tRowcnt nPSample ;
  int nCol ;
  int mxSample ;
  _1330_Stat4Sample current ;
  u32 iPrn ;
  _1330_Stat4Sample *aBest ;
  int iMin ;
  int nSample ;
  int iGet ;
  _1330_Stat4Sample *a ;
}  ;
static  void statInit(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  _1330_Stat4Accum *p;
  int nCol;
  int nColUp;
  int n;
  ((void ) argc);
  (nCol = sqlite3_value_int(argv[0]));
  ((void ) 0);
  (nColUp = ((sizeof(tRowcnt ) < 8) ? ((nCol + 1) & (~ 1)) : nCol));
  (n = (sizeof((*p)) + (sizeof(tRowcnt ) * nColUp) + (sizeof(tRowcnt ) * nColUp)));
  (p = sqlite3MallocZero(n));
  if ((p == 0)) {
    sqlite3_result_error_nomem(context);
    return;
  }  
  (p->nRow = 0);
  (p->nCol = nCol);
  (p->current.anDLt = ((tRowcnt *) (&p[1])));
  (p->current.anEq = (&p->current.anDLt[nColUp]));
  sqlite3_result_blob(context, p, sizeof(p), sqlite3_free);
}
static const FuncDef statInitFuncdef =  { (1 + (0 + 0)),  1,  0,  0,  statInit,  0,  0,  "stat_init",  0,  0};
static  void samplePushPrevious(_1330_Stat4Accum *p , int iChng )  {
  ((void ) p);
  ((void ) iChng);
}
static  void statPush(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  int i;
  _1330_Stat4Accum *p =  ((_1330_Stat4Accum *) sqlite3_value_blob(argv[0]));
  int iChng =  sqlite3_value_int(argv[1]);
  ((void ) argc);
  ((void ) context);
  ((void ) 0);
  ((void ) 0);
  if ((p->nRow == 0)) {
    for ((i = 0); (i < p->nCol); i++) {
      (p->current.anEq[i] = 1);
    }
  }  
  else {
    samplePushPrevious(p, iChng);
    for ((i = 0); (i < iChng); i++) {
      p->current.anEq[i]++;
    }
    for ((i = iChng); (i < p->nCol); i++) {
      p->current.anDLt[i]++;
      (p->current.anEq[i] = 1);
    }
  }
  p->nRow++;
}
static const FuncDef statPushFuncdef =  { (2 + (0 + 0)),  1,  0,  0,  statPush,  0,  0,  "stat_push",  0,  0};
static  void statGet(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  _1330_Stat4Accum *p =  ((_1330_Stat4Accum *) sqlite3_value_blob(argv[0]));
  ((void ) 0);
  {
    char *z;
    int i;
    char *zRet =  sqlite3MallocZero((p->nCol * 25));
    if ((zRet == 0)) {
      sqlite3_result_error_nomem(context);
      return;
    }  
    sqlite3_snprintf(24, zRet, "%llu", ((u64 ) p->nRow));
    (z = (zRet + sqlite3Strlen30(zRet)));
    for ((i = 0); (i < (p->nCol - 1)); i++) {
      u64 nDistinct =  (p->current.anDLt[i] + 1);
      u64 iVal =  ((p->nRow + nDistinct - 1) / nDistinct);
      sqlite3_snprintf(24, z, " %llu", iVal);
      (z += sqlite3Strlen30(z));
      ((void ) 0);
    }
    ((void ) 0);
    sqlite3_result_text(context, zRet, (- 1), sqlite3_free);
  }
  ((void ) argc);
}
static const FuncDef statGetFuncdef =  { (1 + (0 + 0)),  1,  0,  0,  statGet,  0,  0,  "stat_get",  0,  0};
static  void callStatGet(Vdbe *v , int regStat4 , int iParam , int regOut )  {
  ((void ) 0);
  ((void ) iParam);
  sqlite3VdbeAddOp3(v, 1, 0, regStat4, regOut);
  sqlite3VdbeChangeP4(v, (- 1), ((char *) (&statGetFuncdef)), (- 5));
  sqlite3VdbeChangeP5(v, (1 + (0 + 0)));
}
static  void analyzeOneTable(Parse *pParse , Table *pTab , Index *pOnlyIdx , int iStatCur , int iMem , int iTab )  {
  sqlite3 *db =  pParse->db;
  Index *pIdx;
  int iIdxCur;
  int iTabCur;
  Vdbe *v;
  int i;
  int jZeroRows =  (- 1);
  int iDb;
  u8 needTableCnt =  1;
  int regNewRowid =  iMem++;
  int regStat4 =  iMem++;
  int regChng =  iMem++;
  int regTemp =  iMem++;
  int regTabname =  iMem++;
  int regIdxname =  iMem++;
  int regStat1 =  iMem++;
  int regPrev =  iMem;
  (pParse->nMem = ((pParse->nMem > iMem) ? pParse->nMem : iMem));
  (v = sqlite3GetVdbe(pParse));
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((v == 0) || (pTab == 0))) {
      return;
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((v == 0) || 0)) {
      return;
    }  
  }  
  if ((pTab->tnum == 0)) {
    return;
  }  
  if ((sqlite3_strnicmp(pTab->zName, "sqlite_", 7) == 0)) {
    return;
  }  
  ((void ) 0);
  (iDb = sqlite3SchemaToIndex(db, pTab->pSchema));
  ((void ) 0);
  ((void ) 0);
  if (sqlite3AuthCheck(pParse, 28, pTab->zName, 0, db->aDb[iDb].zName)) {
    return;
  }  
  sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
  (iTabCur = iTab++);
  (iIdxCur = iTab++);
  (pParse->nTab = ((pParse->nTab > iTab) ? pParse->nTab : iTab));
  sqlite3OpenTable(pParse, iTabCur, iDb, pTab, 48);
  sqlite3VdbeAddOp4(v, 94, 0, regTabname, 0, pTab->zName, 0);
  for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
    int nCol;
    KeyInfo *pKey;
    int *aGotoChng;
    int addrRewind;
    int addrGotoChng0;
    int addrNextRow;
    if ((pOnlyIdx && (pOnlyIdx != pIdx))) {
      continue;
    }  
    if ((pIdx->pPartIdxWhere == 0)) {
      (needTableCnt = 0);
    }  
    (nCol = pIdx->nColumn);
    (aGotoChng = sqlite3DbMallocRaw(db, (sizeof(int ) * (nCol + 1))));
    if ((aGotoChng == 0)) {
      continue;
    }  
    (pKey = sqlite3IndexKeyinfo(pParse, pIdx));
    sqlite3VdbeAddOp4(v, 94, 0, regIdxname, 0, pIdx->zName, 0);
    (pParse->nMem = ((pParse->nMem > (regPrev + nCol)) ? pParse->nMem : (regPrev + nCol)));
    ((void ) 0);
    sqlite3VdbeAddOp3(v, 48, iIdxCur, pIdx->tnum, iDb);
    sqlite3VdbeChangeP4(v, (- 1), ((char *) pKey), (- 16));
    sqlite3VdbeAddOp2(v, 21, (nCol + 1), (regStat4 + 1));
    sqlite3VdbeAddOp3(v, 1, 0, (regStat4 + 1), regStat4);
    sqlite3VdbeChangeP4(v, (- 1), ((char *) (&statInitFuncdef)), (- 5));
    sqlite3VdbeChangeP5(v, (1 + (0 + 0)));
    (addrRewind = sqlite3VdbeAddOp1(v, 101, iIdxCur));
    sqlite3VdbeAddOp2(v, 21, 0, regChng);
    (addrGotoChng0 = sqlite3VdbeAddOp0(v, 14));
    (addrNextRow = sqlite3VdbeCurrentAddr(v));
    for ((i = 0); (i < nCol); i++) {
      char *pColl =  ((char *) sqlite3LocateCollSeq(pParse, pIdx->azColl[i]));
      sqlite3VdbeAddOp2(v, 21, i, regChng);
      sqlite3VdbeAddOp3(v, 41, iIdxCur, i, regTemp);
      (aGotoChng[i] = sqlite3VdbeAddOp4(v, 75, regTemp, 0, (regPrev + i), pColl, (- 4)));
      sqlite3VdbeChangeP5(v, 0x80);
    }
    sqlite3VdbeAddOp2(v, 21, nCol, regChng);
    (aGotoChng[nCol] = sqlite3VdbeAddOp0(v, 14));
    sqlite3VdbeJumpHere(v, addrGotoChng0);
    for ((i = 0); (i < nCol); i++) {
      sqlite3VdbeJumpHere(v, aGotoChng[i]);
      sqlite3VdbeAddOp3(v, 41, iIdxCur, i, (regPrev + i));
    }
    sqlite3VdbeJumpHere(v, aGotoChng[nCol]);
    ((void ) 0);
    sqlite3VdbeAddOp3(v, 1, 1, regStat4, regTemp);
    sqlite3VdbeChangeP4(v, (- 1), ((char *) (&statPushFuncdef)), (- 5));
    sqlite3VdbeChangeP5(v, (2 + (0 + 0)));
    sqlite3VdbeAddOp2(v, 7, iIdxCur, addrNextRow);
    callStatGet(v, regStat4, 0, regStat1);
    sqlite3VdbeAddOp4(v, 43, regTabname, 3, regTemp, "aaa", 0);
    sqlite3VdbeAddOp2(v, 65, iStatCur, regNewRowid);
    sqlite3VdbeAddOp3(v, 66, iStatCur, regTemp, regNewRowid);
    sqlite3VdbeChangeP5(v, 0x08);
    sqlite3VdbeJumpHere(v, addrRewind);
    sqlite3DbFree(db, aGotoChng);
  }
  if (((pOnlyIdx == 0) && needTableCnt)) {
    sqlite3VdbeAddOp2(v, 44, iTabCur, regStat1);
    (jZeroRows = sqlite3VdbeAddOp1(v, 40, regStat1));
    sqlite3VdbeAddOp2(v, 24, 0, regIdxname);
    sqlite3VdbeAddOp4(v, 43, regTabname, 3, regTemp, "aaa", 0);
    sqlite3VdbeAddOp2(v, 65, iStatCur, regNewRowid);
    sqlite3VdbeAddOp3(v, 66, iStatCur, regTemp, regNewRowid);
    sqlite3VdbeChangeP5(v, 0x08);
    sqlite3VdbeJumpHere(v, jZeroRows);
  }  
}
static  void loadAnalysis(Parse *pParse , int iDb )  {
  Vdbe *v =  sqlite3GetVdbe(pParse);
  if (v) {
    sqlite3VdbeAddOp1(v, 113, iDb);
  }  
}
static  void analyzeDatabase(Parse *pParse , int iDb )  {
  sqlite3 *db =  pParse->db;
  Schema *pSchema =  db->aDb[iDb].pSchema;
  HashElem *k;
  int iStatCur;
  int iMem;
  int iTab;
  sqlite3BeginWriteOperation(pParse, 0, iDb);
  (iStatCur = pParse->nTab);
  (pParse->nTab += 3);
  openStatTable(pParse, iDb, iStatCur, 0, 0);
  (iMem = (pParse->nMem + 1));
  (iTab = pParse->nTab);
  ((void ) 0);
  for ((k = (&pSchema->tblHash)->first); k; (k = k->next)) {
    Table *pTab =  ((Table *) k->data);
    analyzeOneTable(pParse, pTab, 0, iStatCur, iMem, iTab);
  }
  loadAnalysis(pParse, iDb);
}
static  void analyzeTable(Parse *pParse , Table *pTab , Index *pOnlyIdx )  {
  int iDb;
  int iStatCur;
  ((void ) 0);
  ((void ) 0);
  (iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema));
  sqlite3BeginWriteOperation(pParse, 0, iDb);
  (iStatCur = pParse->nTab);
  (pParse->nTab += 3);
  if (pOnlyIdx) {
    openStatTable(pParse, iDb, iStatCur, pOnlyIdx->zName, "idx");
  }  
  else {
    openStatTable(pParse, iDb, iStatCur, pTab->zName, "tbl");
  }
  analyzeOneTable(pParse, pTab, pOnlyIdx, iStatCur, (pParse->nMem + 1), pParse->nTab);
  loadAnalysis(pParse, iDb);
}
static  void sqlite3Analyze(Parse *pParse , Token *pName1 , Token *pName2 )  {
  sqlite3 *db =  pParse->db;
  int iDb;
  int i;
  char *z, *zDb;
  Table *pTab;
  Index *pIdx;
  Token *pTableName;
  ((void ) 0);
  if ((0 != sqlite3ReadSchema(pParse))) {
    return;
  }  
  ((void ) 0);
  if ((pName1 == 0)) {
    for ((i = 0); (i < db->nDb); i++) {
      if ((i == 1)) {
        continue;
      }  
      analyzeDatabase(pParse, i);
    }
  } 
  else if ((pName2->n == 0)) {
    (iDb = sqlite3FindDb(db, pName1));
    if ((iDb >= 0)) {
      analyzeDatabase(pParse, iDb);
    }  
    else {
      (z = sqlite3NameFromToken(db, pName1));
      if (z) {
        if (((pIdx = sqlite3FindIndex(db, z, 0)) != 0)) {
          analyzeTable(pParse, pIdx->pTable, pIdx);
        } 
        else if (((pTab = sqlite3LocateTable(pParse, 0, z, 0)) != 0)) {
          analyzeTable(pParse, pTab, 0);
        } 
        sqlite3DbFree(db, z);
      }  
    }
  } 
  else {
    (iDb = sqlite3TwoPartName(pParse, pName1, pName2, (&pTableName)));
    if ((iDb >= 0)) {
      (zDb = db->aDb[iDb].zName);
      (z = sqlite3NameFromToken(db, pTableName));
      if (z) {
        if (((pIdx = sqlite3FindIndex(db, z, zDb)) != 0)) {
          analyzeTable(pParse, pIdx->pTable, pIdx);
        } 
        else if (((pTab = sqlite3LocateTable(pParse, 0, z, zDb)) != 0)) {
          analyzeTable(pParse, pTab, 0);
        } 
        sqlite3DbFree(db, z);
      }  
    }  
  }
}
typedef struct  _1330_analysisInfo   _1330_analysisInfo;
struct  _1330_analysisInfo {
  sqlite3 *db ;
  const  char *zDatabase ;
}  ;
static  void decodeIntArray(char *zIntArray , int nOut , tRowcnt *aOut , Index *pIndex )  {
  char *z =  zIntArray;
  int c;
  int i;
  tRowcnt v;
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      (z = "");
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((z == 0)) {
      (z = "");
    }  
  }  
  for ((i = 0); ((*z) && (i < nOut)); i++) {
    (v = 0);
    while ((((c = z[0]) >= '0') && (c <= '9'))) {
      (v = ((v * 10) + c - '0'));
      z++;
    }
    (aOut[i] = v);
    if (((*z) == ' ')) {
      z++;
    }  
  }
  ((void ) 0);
  {
    if ((strcmp(z, "unordered") == 0)) {
      (pIndex->bUnordered = 1);
    } 
    else if ((sqlite3_strglob("sz=[0-9]*", z) == 0)) {
      int v32 =  0;
      sqlite3GetInt32((z + 3), (&v32));
      (pIndex->szIdxRow = sqlite3LogEst(v32));
    } 
  }
}
static  int analysisLoader(void *pData , int argc , char **argv , char **NotUsed )  {
  _1330_analysisInfo *pInfo =  ((_1330_analysisInfo *) pData);
  Index *pIndex;
  Table *pTable;
  const char *z;
  ((void ) 0);
  ((void ) NotUsed), ((void ) argc);
  if (((argv == 0) || (argv[0] == 0) || (argv[2] == 0))) {
    return 0;
  }  
  (pTable = sqlite3FindTable(pInfo->db, argv[0], pInfo->zDatabase));
  if ((pTable == 0)) {
    return 0;
  }  
  if (argv[1]) {
    (pIndex = sqlite3FindIndex(pInfo->db, argv[1], pInfo->zDatabase));
  }  
  else {
    (pIndex = 0);
  }
  (z = argv[2]);
  if (pIndex) {
    decodeIntArray(((char *) z), (pIndex->nColumn + 1), pIndex->aiRowEst, pIndex);
    if ((pIndex->pPartIdxWhere == 0)) {
      (pTable->nRowEst = pIndex->aiRowEst[0]);
    }  
  }  
  else {
    Index fakeIdx;
    (fakeIdx.szIdxRow = pTable->szTabRow);
    decodeIntArray(((char *) z), 1, (&pTable->nRowEst), (&fakeIdx));
    (pTable->szTabRow = fakeIdx.szIdxRow);
  }
  return 0;
}
static  void sqlite3DeleteIndexSamples(sqlite3 *db , Index *pIdx )  {
  ((void ) db);
  ((void ) pIdx);
}
static  int sqlite3AnalysisLoad(sqlite3 *db , int iDb )  {
  _1330_analysisInfo sInfo;
  HashElem *i;
  char *zSql;
  int rc;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  for ((i = (&db->aDb[iDb].pSchema->idxHash)->first); i; (i = i->next)) {
    Index *pIdx =  i->data;
    sqlite3DefaultRowEst(pIdx);
  }
  (sInfo.db = db);
  (sInfo.zDatabase = db->aDb[iDb].zName);
  if ((sqlite3FindTable(db, "sqlite_stat1", sInfo.zDatabase) == 0)) {
    return 1;
  }  
  (zSql = sqlite3MPrintf(db, "SELECT tbl,idx,stat FROM %Q.sqlite_stat1", sInfo.zDatabase));
  if ((zSql == 0)) {
    (rc = 7);
  }  
  else {
    (rc = sqlite3_exec(db, zSql, analysisLoader, (&sInfo), 0));
    sqlite3DbFree(db, zSql);
  }
  if ((rc == 7)) {
    (db->mallocFailed = 1);
  }  
  return rc;
}
static  int resolveAttachExpr(NameContext *pName , Expr *pExpr )  {
  int rc =  0;
  if (pExpr) {
    if ((pExpr->op != 26)) {
      (rc = sqlite3ResolveExprNames(pName, pExpr));
      if (((rc == 0) && (! sqlite3ExprIsConstant(pExpr)))) {
        sqlite3ErrorMsg(pName->pParse, "invalid name: \"%s\"", pExpr->u.zToken);
        return 1;
      }  
    }  
    else {
      (pExpr->op = 94);
    }
  }  
  return rc;
}
static  void attachFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv )  {
  int i;
  int rc =  0;
  sqlite3 *db =  sqlite3_context_db_handle(context);
  const char *zName;
  const char *zFile;
  char *zPath =  0;
  char *zErr =  0;
  unsigned int flags;
  Db *aNew;
  char *zErrDyn =  0;
  sqlite3_vfs *pVfs;
  ((void ) NotUsed);
  (zFile = ((const  char *) sqlite3_value_text(argv[0])));
  (zName = ((const  char *) sqlite3_value_text(argv[1])));
  if ((zFile == 0)) {
    (zFile = "");
  }  
  if ((zName == 0)) {
    (zName = "");
  }  
  if ((db->nDb >= (db->aLimit[7] + 2))) {
    (zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d", db->aLimit[7]));
    goto attach_error;
  }  
  if ((! db->autoCommit)) {
    (zErrDyn = sqlite3MPrintf(db, "cannot ATTACH database within transaction"));
    goto attach_error;
  }  
  for ((i = 0); (i < db->nDb); i++) {
    char *z =  db->aDb[i].zName;
    ((void ) 0);
    if ((sqlite3_stricmp(z, zName) == 0)) {
      (zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName));
      goto attach_error;
    }  
  }
  if ((db->aDb == db->aDbStatic)) {
    (aNew = sqlite3DbMallocRaw(db, (sizeof(db->aDb[0]) * 3)));
    if ((aNew == 0)) {
      return;
    }  
    memcpy(aNew, db->aDb, (sizeof(db->aDb[0]) * 2));
  }  
  else {
    (aNew = sqlite3DbRealloc(db, db->aDb, (sizeof(db->aDb[0]) * (db->nDb + 1))));
    if ((aNew == 0)) {
      return;
    }  
  }
  (db->aDb = aNew);
  (aNew = (&db->aDb[db->nDb]));
  memset(aNew, 0, sizeof((*aNew)));
  (flags = db->openFlags);
  (rc = sqlite3ParseUri(db->pVfs->zName, zFile, (&flags), (&pVfs), (&zPath), (&zErr)));
  if ((rc != 0)) {
    if ((rc == 7)) {
      (db->mallocFailed = 1);
    }  
    sqlite3_result_error(context, zErr, (- 1));
    sqlite3_free(zErr);
    return;
  }  
  ((void ) 0);
  (flags |= 0x00000100);
  (rc = sqlite3BtreeOpen(pVfs, zPath, db, (&aNew->pBt), 0, flags));
  sqlite3_free(zPath);
  db->nDb++;
  if ((rc == 19)) {
    (rc = 1);
    (zErrDyn = sqlite3MPrintf(db, "database is already attached"));
  } 
  else if ((rc == 0)) {
    Pager *pPager;
    (aNew->pSchema = sqlite3SchemaGet(db, aNew->pBt));
    if ((! aNew->pSchema)) {
      (rc = 7);
    } 
    else if ((aNew->pSchema->file_format && (aNew->pSchema->enc != db->aDb[0].pSchema->enc))) {
      (zErrDyn = sqlite3MPrintf(db, "attached databases must use the same text encoding as main database"));
      (rc = 1);
    } 
    (pPager = sqlite3BtreePager(aNew->pBt));
    sqlite3PagerLockingMode(pPager, db->dfltLockMode);
    sqlite3BtreeSecureDelete(aNew->pBt, sqlite3BtreeSecureDelete(db->aDb[0].pBt, (- 1)));
    if ((((! id2i_sqlite_omit_attach) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      sqlite3BtreeSetPagerFlags(aNew->pBt, (3 | (db->flags & 0x1c)));
    }  
  } 
  (aNew->safety_level = 3);
  (aNew->zName = sqlite3DbStrDup(db, zName));
  if (((rc == 0) && (aNew->zName == 0))) {
    (rc = 7);
  }  
  if ((rc == 0)) {
    sqlite3BtreeEnterAll(db);
    (rc = sqlite3Init(db, (&zErrDyn)));
  }  
  if (rc) {
    int iDb =  (db->nDb - 1);
    ((void ) 0);
    if (db->aDb[iDb].pBt) {
      sqlite3BtreeClose(db->aDb[iDb].pBt);
      (db->aDb[iDb].pBt = 0);
      (db->aDb[iDb].pSchema = 0);
    }  
    sqlite3ResetAllSchemasOfConnection(db);
    (db->nDb = iDb);
    if (((rc == 7) || (rc == (10 | (12 << 8))))) {
      (db->mallocFailed = 1);
      sqlite3DbFree(db, zErrDyn);
      (zErrDyn = sqlite3MPrintf(db, "out of memory"));
    } 
    else if ((zErrDyn == 0)) {
      (zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile));
    } 
    goto attach_error;
  }  
  return;
  attach_error:
  if (zErrDyn) {
    sqlite3_result_error(context, zErrDyn, (- 1));
    sqlite3DbFree(db, zErrDyn);
  }  
  if (rc) {
    sqlite3_result_error_code(context, rc);
  }  
}
static  void detachFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv )  {
  const char *zName =  ((const  char *) sqlite3_value_text(argv[0]));
  sqlite3 *db =  sqlite3_context_db_handle(context);
  int i;
  Db *pDb =  0;
  char zErr[128];
  ((void ) NotUsed);
  if ((zName == 0)) {
    (zName = "");
  }  
  for ((i = 0); (i < db->nDb); i++) {
    (pDb = (&db->aDb[i]));
    if ((pDb->pBt == 0)) {
      continue;
    }  
    if ((sqlite3_stricmp(pDb->zName, zName) == 0)) {
      break;
    }  
  }
  if ((i >= db->nDb)) {
    sqlite3_snprintf(sizeof(zErr), zErr, "no such database: %s", zName);
    goto detach_error;
  }  
  if ((i < 2)) {
    sqlite3_snprintf(sizeof(zErr), zErr, "cannot detach database %s", zName);
    goto detach_error;
  }  
  if ((! db->autoCommit)) {
    sqlite3_snprintf(sizeof(zErr), zErr, "cannot DETACH database within transaction");
    goto detach_error;
  }  
  if ((sqlite3BtreeIsInReadTrans(pDb->pBt) || sqlite3BtreeIsInBackup(pDb->pBt))) {
    sqlite3_snprintf(sizeof(zErr), zErr, "database %s is locked", zName);
    goto detach_error;
  }  
  sqlite3BtreeClose(pDb->pBt);
  (pDb->pBt = 0);
  (pDb->pSchema = 0);
  sqlite3ResetAllSchemasOfConnection(db);
  return;
  detach_error:
  sqlite3_result_error(context, zErr, (- 1));
}
static  void codeAttach(Parse *pParse , int type , FuncDef  const *pFunc , Expr *pAuthArg , Expr *pFilename , Expr *pDbname , Expr *pKey )  {
  int rc;
  NameContext sName;
  Vdbe *v;
  sqlite3 *db =  pParse->db;
  int regArgs;
  memset((&sName), 0, sizeof(NameContext ));
  (sName.pParse = pParse);
  if (((0 != (rc = resolveAttachExpr((&sName), pFilename))) || (0 != (rc = resolveAttachExpr((&sName), pDbname))) || (0 != (rc = resolveAttachExpr((&sName), pKey))))) {
    pParse->nErr++;
    goto attach_end;
  }  
  if (pAuthArg) {
    char *zAuthArg;
    if ((pAuthArg->op == 94)) {
      (zAuthArg = pAuthArg->u.zToken);
    }  
    else {
      (zAuthArg = 0);
    }
    (rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0));
    if ((rc != 0)) {
      goto attach_end;
    }  
  }  
  (v = sqlite3GetVdbe(pParse));
  (regArgs = sqlite3GetTempRange(pParse, 4));
  sqlite3ExprCode(pParse, pFilename, regArgs);
  sqlite3ExprCode(pParse, pDbname, (regArgs + 1));
  sqlite3ExprCode(pParse, pKey, (regArgs + 2));
  ((void ) 0);
  if (v) {
    sqlite3VdbeAddOp3(v, 1, 0, (regArgs + 3 - pFunc->nArg), (regArgs + 3));
    ((void ) 0);
    sqlite3VdbeChangeP5(v, ((u8 ) pFunc->nArg));
    sqlite3VdbeChangeP4(v, (- 1), ((char *) pFunc), (- 5));
    sqlite3VdbeAddOp1(v, 132, (type == 24));
  }  
  attach_end:
  sqlite3ExprDelete(db, pFilename);
  sqlite3ExprDelete(db, pDbname);
  sqlite3ExprDelete(db, pKey);
}
static  void sqlite3Detach(Parse *pParse , Expr *pDbname )  {
  static const FuncDef detach_func =  { 1,  1,  0,  0,  detachFunc,  0,  0,  "sqlite_detach",  0,  0};
  codeAttach(pParse, 25, (&detach_func), pDbname, 0, 0, pDbname);
}
static  void sqlite3Attach(Parse *pParse , Expr *p , Expr *pDbname , Expr *pKey )  {
  static const FuncDef attach_func =  { 3,  1,  0,  0,  attachFunc,  0,  0,  "sqlite_attach",  0,  0};
  codeAttach(pParse, 24, (&attach_func), p, p, pDbname, pKey);
}
static  void sqlite3FixInit(DbFixer *pFix , Parse *pParse , int iDb , const  char *zType , const  Token *pName )  {
  sqlite3 *db;
  (db = pParse->db);
  ((void ) 0);
  (pFix->pParse = pParse);
  (pFix->zDb = db->aDb[iDb].zName);
  (pFix->pSchema = db->aDb[iDb].pSchema);
  (pFix->zType = zType);
  (pFix->pName = pName);
  (pFix->bVarOnly = (iDb == 1));
}
static  int sqlite3FixSrcList(DbFixer *pFix , SrcList *pList )  {
  int i;
  const char *zDb;
  struct  SrcList_item   *pItem;
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return 0;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pList == 0)) {
      return 0;
    }  
  }  
  (zDb = pFix->zDb);
  for ((i = 0), (pItem = pList->a); (i < pList->nSrc); i++, pItem++) {
    if ((pFix->bVarOnly == 0)) {
      if ((pItem->zDatabase && sqlite3_stricmp(pItem->zDatabase, zDb))) {
        sqlite3ErrorMsg(pFix->pParse, "%s %T cannot reference objects in database %s", pFix->zType, pFix->pName, pItem->zDatabase);
        return 1;
      }  
      sqlite3DbFree(pFix->pParse->db, pItem->zDatabase);
      (pItem->zDatabase = 0);
      (pItem->pSchema = pFix->pSchema);
    }  
    if (sqlite3FixSelect(pFix, pItem->pSelect)) {
      return 1;
    }  
    if (sqlite3FixExpr(pFix, pItem->pOn)) {
      return 1;
    }  
  }
  return 0;
}
static  int sqlite3FixSelect(DbFixer *pFix , Select *pSelect )  {
  while (pSelect) {
    if (sqlite3FixExprList(pFix, pSelect->pEList)) {
      return 1;
    }  
    if (sqlite3FixSrcList(pFix, pSelect->pSrc)) {
      return 1;
    }  
    if (sqlite3FixExpr(pFix, pSelect->pWhere)) {
      return 1;
    }  
    if (sqlite3FixExprList(pFix, pSelect->pGroupBy)) {
      return 1;
    }  
    if (sqlite3FixExpr(pFix, pSelect->pHaving)) {
      return 1;
    }  
    if (sqlite3FixExprList(pFix, pSelect->pOrderBy)) {
      return 1;
    }  
    if (sqlite3FixExpr(pFix, pSelect->pLimit)) {
      return 1;
    }  
    if (sqlite3FixExpr(pFix, pSelect->pOffset)) {
      return 1;
    }  
    (pSelect = pSelect->pPrior);
  }
  return 0;
}
static  int sqlite3FixExpr(DbFixer *pFix , Expr *pExpr )  {
  while (pExpr) {
    if ((pExpr->op == 133)) {
      if (pFix->pParse->db->init.busy) {
        (pExpr->op = 98);
      }  
      else {
        sqlite3ErrorMsg(pFix->pParse, "%s cannot use variables", pFix->zType);
        return 1;
      }
    }  
    if (((pExpr->flags & 0x004000) != 0)) {
      break;
    }  
    if (((pExpr->flags & 0x000800) != 0)) {
      if (sqlite3FixSelect(pFix, pExpr->x.pSelect)) {
        return 1;
      }  
    }  
    else {
      if (sqlite3FixExprList(pFix, pExpr->x.pList)) {
        return 1;
      }  
    }
    if (sqlite3FixExpr(pFix, pExpr->pRight)) {
      return 1;
    }  
    (pExpr = pExpr->pLeft);
  }
  return 0;
}
static  int sqlite3FixExprList(DbFixer *pFix , ExprList *pList )  {
  int i;
  struct  ExprList_item   *pItem;
  if ((pList == 0)) {
    return 0;
  }  
  for ((i = 0), (pItem = pList->a); (i < pList->nExpr); i++, pItem++) {
    if (sqlite3FixExpr(pFix, pItem->pExpr)) {
      return 1;
    }  
  }
  return 0;
}
static  int sqlite3FixTriggerStep(DbFixer *pFix , TriggerStep *pStep )  {
  while (pStep) {
    if (sqlite3FixSelect(pFix, pStep->pSelect)) {
      return 1;
    }  
    if (sqlite3FixExpr(pFix, pStep->pWhere)) {
      return 1;
    }  
    if (sqlite3FixExprList(pFix, pStep->pExprList)) {
      return 1;
    }  
    (pStep = pStep->pNext);
  }
  return 0;
}
int sqlite3_set_authorizer(sqlite3 *db , int ( *xAuth)(void * , int , const  char * , const  char * , const  char * , const  char * ) , void *pArg )  {
  (db->xAuth = xAuth);
  (db->pAuthArg = pArg);
  sqlite3ExpirePreparedStatements(db);
  return 0;
}
static  void sqliteAuthBadReturnCode(Parse *pParse )  {
  sqlite3ErrorMsg(pParse, "authorizer malfunction");
  (pParse->rc = 1);
}
static  int sqlite3AuthReadCol(Parse *pParse , const  char *zTab , const  char *zCol , int iDb )  {
  sqlite3 *db =  pParse->db;
  char *zDb =  db->aDb[iDb].zName;
  int rc;
  (rc = db->xAuth(db->pAuthArg, 20, zTab, zCol, zDb, pParse->zAuthContext));
  if ((rc == 1)) {
    if (((db->nDb > 2) || (iDb != 0))) {
      sqlite3ErrorMsg(pParse, "access to %s.%s.%s is prohibited", zDb, zTab, zCol);
    }  
    else {
      sqlite3ErrorMsg(pParse, "access to %s.%s is prohibited", zTab, zCol);
    }
    (pParse->rc = 23);
  } 
  else if (((rc != 2) && (rc != 0))) {
    sqliteAuthBadReturnCode(pParse);
  } 
  return rc;
}
static  void sqlite3AuthRead(Parse *pParse , Expr *pExpr , Schema *pSchema , SrcList *pTabList )  {
  sqlite3 *db =  pParse->db;
  Table *pTab =  0;
  const char *zCol;
  int iSrc;
  int iDb;
  int iCol;
  if ((db->xAuth == 0)) {
    return;
  }  
  (iDb = sqlite3SchemaToIndex(pParse->db, pSchema));
  if ((iDb < 0)) {
    return;
  }  
  ((void ) 0);
  if ((pExpr->op == 60)) {
    (pTab = pParse->pTriggerTab);
  }  
  else {
    ((void ) 0);
    if (((id2i_sqlite_coverage_test ) )) {
      for ((iSrc = 0); 1; iSrc++) {
        if ((pExpr->iTable == pTabList->a[iSrc].iCursor)) {
          (pTab = pTabList->a[iSrc].pTab);
          break;
        }  
      }
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      for ((iSrc = 0); (iSrc < pTabList->nSrc); iSrc++) {
        if ((pExpr->iTable == pTabList->a[iSrc].iCursor)) {
          (pTab = pTabList->a[iSrc].pTab);
          break;
        }  
      }
    }  
  }
  (iCol = pExpr->iColumn);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pTab == 0)) {
      return;
    }  
  }  
  if ((iCol >= 0)) {
    ((void ) 0);
    (zCol = pTab->aCol[iCol].zName);
  } 
  else if ((pTab->iPKey >= 0)) {
    ((void ) 0);
    (zCol = pTab->aCol[pTab->iPKey].zName);
  } 
  else {
    (zCol = "ROWID");
  }
  ((void ) 0);
  if ((2 == sqlite3AuthReadCol(pParse, pTab->zName, zCol, iDb))) {
    (pExpr->op = 98);
  }  
}
static  int sqlite3AuthCheck(Parse *pParse , int code , const  char *zArg1 , const  char *zArg2 , const  char *zArg3 )  {
  sqlite3 *db =  pParse->db;
  int rc;
  if ((db->init.busy || pParse->declareVtab)) {
    return 0;
  }  
  if ((db->xAuth == 0)) {
    return 0;
  }  
  (rc = db->xAuth(db->pAuthArg, code, zArg1, zArg2, zArg3, pParse->zAuthContext));
  if ((rc == 1)) {
    sqlite3ErrorMsg(pParse, "not authorized");
    (pParse->rc = 23);
  } 
  else if (((rc != 0) && (rc != 2))) {
    (rc = 1);
    sqliteAuthBadReturnCode(pParse);
  } 
  return rc;
}
static  void sqlite3AuthContextPush(Parse *pParse , AuthContext *pContext , const  char *zContext )  {
  ((void ) 0);
  (pContext->pParse = pParse);
  (pContext->zAuthContext = pParse->zAuthContext);
  (pParse->zAuthContext = zContext);
}
static  void sqlite3AuthContextPop(AuthContext *pContext )  {
  if (pContext->pParse) {
    (pContext->pParse->zAuthContext = pContext->zAuthContext);
    (pContext->pParse = 0);
  }  
}
static  void sqlite3BeginParse(Parse *pParse , int explainFlag )  {
  (pParse->explain = ((u8 ) explainFlag));
  (pParse->nVar = 0);
}
struct  TableLock {
  int iDb ;
  int iTab ;
  u8 isWriteLock ;
  const  char *zName ;
}  ;
static  void sqlite3TableLock(Parse *pParse , int iDb , int iTab , u8 isWriteLock , const  char *zName )  {
  Parse *pToplevel =  (pParse->pToplevel ? pParse->pToplevel : pParse);
  int i;
  int nBytes;
  TableLock *p;
  ((void ) 0);
  for ((i = 0); (i < pToplevel->nTableLock); i++) {
    (p = (&pToplevel->aTableLock[i]));
    if (((p->iDb == iDb) && (p->iTab == iTab))) {
      (p->isWriteLock = (p->isWriteLock || isWriteLock));
      return;
    }  
  }
  (nBytes = (sizeof(TableLock ) * (pToplevel->nTableLock + 1)));
  (pToplevel->aTableLock = sqlite3DbReallocOrFree(pToplevel->db, pToplevel->aTableLock, nBytes));
  if (pToplevel->aTableLock) {
    (p = (&pToplevel->aTableLock[pToplevel->nTableLock++]));
    (p->iDb = iDb);
    (p->iTab = iTab);
    (p->isWriteLock = isWriteLock);
    (p->zName = zName);
  }  
  else {
    (pToplevel->nTableLock = 0);
    (pToplevel->db->mallocFailed = 1);
  }
}
static  void codeTableLocks(Parse *pParse )  {
  int i;
  Vdbe *pVdbe;
  (pVdbe = sqlite3GetVdbe(pParse));
  ((void ) 0);
  for ((i = 0); (i < pParse->nTableLock); i++) {
    TableLock *p =  (&pParse->aTableLock[i]);
    int p1 =  p->iDb;
    sqlite3VdbeAddOp4(pVdbe, 133, p1, p->iTab, p->isWriteLock, p->zName, (- 2));
  }
}
static  void sqlite3FinishCoding(Parse *pParse )  {
  sqlite3 *db;
  Vdbe *v;
  ((void ) 0);
  (db = pParse->db);
  if (db->mallocFailed) {
    return;
  }  
  if (pParse->nested) {
    return;
  }  
  if (pParse->nErr) {
    return;
  }  
  (v = sqlite3GetVdbe(pParse));
  ((void ) 0);
  if (v) {
    sqlite3VdbeAddOp0(v, 20);
    if ((pParse->cookieGoto > 0)) {
      yDbMask mask;
      int iDb;
      sqlite3VdbeJumpHere(v, (pParse->cookieGoto - 1));
      for ((iDb = 0), (mask = 1); (iDb < db->nDb); (mask <<= 1), iDb++) {
        if (((mask & pParse->cookieMask) == 0)) {
          continue;
        }  
        sqlite3VdbeUsesBtree(v, iDb);
        sqlite3VdbeAddOp2(v, 4, iDb, ((mask & pParse->writeMask) != 0));
        if ((db->init.busy == 0)) {
          ((void ) 0);
          sqlite3VdbeAddOp3(v, 47, iDb, pParse->cookieValue[iDb], db->aDb[iDb].pSchema->iGeneration);
        }  
      }
      {
        int i;
        for ((i = 0); (i < pParse->nVtabLock); i++) {
          char *vtab =  ((char *) sqlite3GetVTable(db, pParse->apVtabLock[i]));
          sqlite3VdbeAddOp4(v, 134, 0, 0, 0, vtab, (- 10));
        }
        (pParse->nVtabLock = 0);
      }
      codeTableLocks(pParse);
      sqlite3AutoincrementBegin(pParse);
      sqlite3VdbeAddOp2(v, 14, 0, pParse->cookieGoto);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((v && (pParse->nErr == 0) && (! db->mallocFailed))) {
      ((void ) 0);
      if (((pParse->pAinc != 0) && (pParse->nTab == 0))) {
        (pParse->nTab = 1);
      }  
      sqlite3VdbeMakeReady(v, pParse);
      (pParse->rc = 101);
      (pParse->colNamesSet = 0);
    }  
    else {
      (pParse->rc = 1);
    }
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((v && 1 && (! db->mallocFailed))) {
      ((void ) 0);
      if (((pParse->pAinc != 0) && (pParse->nTab == 0))) {
        (pParse->nTab = 1);
      }  
      sqlite3VdbeMakeReady(v, pParse);
      (pParse->rc = 101);
      (pParse->colNamesSet = 0);
    }  
    else {
      (pParse->rc = 1);
    }
  }  
  (pParse->nTab = 0);
  (pParse->nMem = 0);
  (pParse->nSet = 0);
  (pParse->nVar = 0);
  (pParse->cookieMask = 0);
  (pParse->cookieGoto = 0);
}
static  void sqlite3NestedParse(Parse *pParse , const  char *zFormat , ...)  {
  va_list ap;
  char *zSql;
  char *zErrMsg =  0;
  sqlite3 *db =  pParse->db;
  char saveBuf[(sizeof(Parse ) - __builtin_offsetof(Parse , nVar))];
  if (pParse->nErr) {
    return;
  }  
  ((void ) 0);
  __builtin_va_start(ap, zFormat);
  (zSql = sqlite3VMPrintf(db, zFormat, ap));
  __builtin_va_end(ap);
  if ((zSql == 0)) {
    return;
  }  
  pParse->nested++;
  memcpy(saveBuf, (&pParse->nVar), (sizeof(Parse ) - __builtin_offsetof(Parse , nVar)));
  memset((&pParse->nVar), 0, (sizeof(Parse ) - __builtin_offsetof(Parse , nVar)));
  sqlite3RunParser(pParse, zSql, (&zErrMsg));
  sqlite3DbFree(db, zErrMsg);
  sqlite3DbFree(db, zSql);
  memcpy((&pParse->nVar), saveBuf, (sizeof(Parse ) - __builtin_offsetof(Parse , nVar)));
  pParse->nested--;
}
static  Table *sqlite3FindTable(sqlite3 *db , const  char *zName , const  char *zDatabase )  {
  Table *p =  0;
  int i;
  int nName;
  ((void ) 0);
  (nName = sqlite3Strlen30(zName));
  ((void ) 0);
  for ((i = 0); (i < db->nDb); i++) {
    int j =  ((i < 2) ? (i ^ 1) : i);
    if (((zDatabase != 0) && sqlite3_stricmp(zDatabase, db->aDb[j].zName))) {
      continue;
    }  
    ((void ) 0);
    (p = sqlite3HashFind((&db->aDb[j].pSchema->tblHash), zName, nName));
    if (p) {
      break;
    }  
  }
  return p;
}
static  Table *sqlite3LocateTable(Parse *pParse , int isView , const  char *zName , const  char *zDbase )  {
  Table *p;
  if ((0 != sqlite3ReadSchema(pParse))) {
    return 0;
  }  
  (p = sqlite3FindTable(pParse->db, zName, zDbase));
  if ((p == 0)) {
    const char *zMsg =  (isView ? "no such view" : "no such table");
    if (zDbase) {
      sqlite3ErrorMsg(pParse, "%s: %s.%s", zMsg, zDbase, zName);
    }  
    else {
      sqlite3ErrorMsg(pParse, "%s: %s", zMsg, zName);
    }
    (pParse->checkSchema = 1);
  }  
  return p;
}
static  Table *sqlite3LocateTableItem(Parse *pParse , int isView , struct  SrcList_item   *p )  {
  const char *zDb;
  ((void ) 0);
  if (p->pSchema) {
    int iDb =  sqlite3SchemaToIndex(pParse->db, p->pSchema);
    (zDb = pParse->db->aDb[iDb].zName);
  }  
  else {
    (zDb = p->zDatabase);
  }
  return sqlite3LocateTable(pParse, isView, p->zName, zDb);
}
static  Index *sqlite3FindIndex(sqlite3 *db , const  char *zName , const  char *zDb )  {
  Index *p =  0;
  int i;
  int nName =  sqlite3Strlen30(zName);
  ((void ) 0);
  for ((i = 0); (i < db->nDb); i++) {
    int j =  ((i < 2) ? (i ^ 1) : i);
    Schema *pSchema =  db->aDb[j].pSchema;
    ((void ) 0);
    if ((zDb && sqlite3_stricmp(zDb, db->aDb[j].zName))) {
      continue;
    }  
    ((void ) 0);
    (p = sqlite3HashFind((&pSchema->idxHash), zName, nName));
    if (p) {
      break;
    }  
  }
  return p;
}
static  void freeIndex(sqlite3 *db , Index *p )  {
  if ((((! id2i_sqlite_omit_analyze) ) )) {
    sqlite3DeleteIndexSamples(db, p);
  }  
  sqlite3ExprDelete(db, p->pPartIdxWhere);
  sqlite3DbFree(db, p->zColAff);
  sqlite3DbFree(db, p);
}
static  void sqlite3UnlinkAndDeleteIndex(sqlite3 *db , int iDb , const  char *zIdxName )  {
  Index *pIndex;
  int len;
  Hash *pHash;
  ((void ) 0);
  (pHash = (&db->aDb[iDb].pSchema->idxHash));
  (len = sqlite3Strlen30(zIdxName));
  (pIndex = sqlite3HashInsert(pHash, zIdxName, len, 0));
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      if ((pIndex->pTable->pIndex == pIndex)) {
        (pIndex->pTable->pIndex = pIndex->pNext);
      }  
      else {
        Index *p;
        (p = pIndex->pTable->pIndex);
        while ((1 && (p->pNext != pIndex))) {
          (p = p->pNext);
        }
        if (1) {
          (p->pNext = pIndex->pNext);
        }  
      }
      freeIndex(db, pIndex);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pIndex) {
      if ((pIndex->pTable->pIndex == pIndex)) {
        (pIndex->pTable->pIndex = pIndex->pNext);
      }  
      else {
        Index *p;
        (p = pIndex->pTable->pIndex);
        while ((p && (p->pNext != pIndex))) {
          (p = p->pNext);
        }
        if ((p && (p->pNext == pIndex))) {
          (p->pNext = pIndex->pNext);
        }  
      }
      freeIndex(db, pIndex);
    }  
  }  
  (db->flags |= 0x00000002);
}
static  void sqlite3CollapseDatabaseArray(sqlite3 *db )  {
  int i, j;
  for ((i = (j = 2)); (i < db->nDb); i++) {
    struct  Db   *pDb =  (&db->aDb[i]);
    if ((pDb->pBt == 0)) {
      sqlite3DbFree(db, pDb->zName);
      (pDb->zName = 0);
      continue;
    }  
    if ((j < i)) {
      (db->aDb[j] = db->aDb[i]);
    }  
    j++;
  }
  memset((&db->aDb[j]), 0, ((db->nDb - j) * sizeof(db->aDb[j])));
  (db->nDb = j);
  if (((db->nDb <= 2) && (db->aDb != db->aDbStatic))) {
    memcpy(db->aDbStatic, db->aDb, (2 * sizeof(db->aDb[0])));
    sqlite3DbFree(db, db->aDb);
    (db->aDb = db->aDbStatic);
  }  
}
static  void sqlite3ResetOneSchema(sqlite3 *db , int iDb )  {
  Db *pDb;
  ((void ) 0);
  (pDb = (&db->aDb[iDb]));
  ((void ) 0);
  ((void ) 0);
  sqlite3SchemaClear(pDb->pSchema);
  if ((iDb != 1)) {
    (pDb = (&db->aDb[1]));
    ((void ) 0);
    sqlite3SchemaClear(pDb->pSchema);
  }  
  return;
}
static  void sqlite3ResetAllSchemasOfConnection(sqlite3 *db )  {
  int i;
  sqlite3BtreeEnterAll(db);
  for ((i = 0); (i < db->nDb); i++) {
    Db *pDb =  (&db->aDb[i]);
    if (pDb->pSchema) {
      sqlite3SchemaClear(pDb->pSchema);
    }  
  }
  (db->flags &= (~ 0x00000002));
  sqlite3VtabUnlockList(db);
  sqlite3CollapseDatabaseArray(db);
}
static  void sqlite3CommitInternalChanges(sqlite3 *db )  {
  (db->flags &= (~ 0x00000002));
}
static  void sqliteDeleteColumnNames(sqlite3 *db , Table *pTable )  {
  int i;
  Column *pCol;
  ((void ) 0);
  if (((pCol = pTable->aCol) != 0)) {
    for ((i = 0); (i < pTable->nCol); i++, pCol++) {
      sqlite3DbFree(db, pCol->zName);
      sqlite3ExprDelete(db, pCol->pDflt);
      sqlite3DbFree(db, pCol->zDflt);
      sqlite3DbFree(db, pCol->zType);
      sqlite3DbFree(db, pCol->zColl);
    }
    sqlite3DbFree(db, pTable->aCol);
  }  
}
static  void sqlite3DeleteTable(sqlite3 *db , Table *pTable )  {
  Index *pIndex, *pNext;
  int _1267_nLookaside;
  ((void ) 0);
  if ((! pTable)) {
    return;
  }  
  if ((((! db) || (db->pnBytesFreed == 0)) && (--pTable->nRef > 0))) {
    return;
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    (_1267_nLookaside = ((db && ((pTable->tabFlags & 0x02) == 0)) ? db->lookaside.nOut : 0));
  }  
  for ((pIndex = pTable->pIndex); pIndex; (pIndex = pNext)) {
    (pNext = pIndex->pNext);
    ((void ) 0);
    if (((! db) || (db->pnBytesFreed == 0))) {
      char *zName =  pIndex->zName;
      Index *_1267_pOld =  sqlite3HashInsert((&pIndex->pSchema->idxHash), zName, sqlite3Strlen30(zName), 0);
      if ((((! id2i_sqlite_coverage_test) ) )) {
        sqlite3HashInsert((&pIndex->pSchema->idxHash), zName, sqlite3Strlen30(zName), 0);
      }  
      ((void ) 0);
      ((void ) 0);
    }  
    freeIndex(db, pIndex);
  }
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    sqlite3FkDelete(db, pTable);
  }  
  sqliteDeleteColumnNames(db, pTable);
  sqlite3DbFree(db, pTable->zName);
  sqlite3DbFree(db, pTable->zColAff);
  sqlite3SelectDelete(db, pTable->pSelect);
  sqlite3ExprListDelete(db, pTable->pCheck);
  sqlite3VtabClear(db, pTable);
  sqlite3DbFree(db, pTable);
  ((void ) 0);
}
static  void sqlite3UnlinkAndDeleteTable(sqlite3 *db , int iDb , const  char *zTabName )  {
  Table *p;
  Db *pDb;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((zTabName[0] == 0)) {
      sqlite3Coverage(84204);
    }  
  }  
  (pDb = (&db->aDb[iDb]));
  (p = sqlite3HashInsert((&pDb->pSchema->tblHash), zTabName, sqlite3Strlen30(zTabName), 0));
  sqlite3DeleteTable(db, p);
  (db->flags |= 0x00000002);
}
static  char *sqlite3NameFromToken(sqlite3 *db , Token *pName )  {
  char *zName;
  if (pName) {
    (zName = sqlite3DbStrNDup(db, ((char *) pName->z), pName->n));
    sqlite3Dequote(zName);
  }  
  else {
    (zName = 0);
  }
  return zName;
}
static  void sqlite3OpenMasterTable(Parse *p , int iDb )  {
  Vdbe *v =  sqlite3GetVdbe(p);
  sqlite3TableLock(p, iDb, 1, 1, (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"));
  sqlite3VdbeAddOp3(v, 49, 0, 1, iDb);
  sqlite3VdbeChangeP4(v, (- 1), ((char *) 5), (- 14));
  if ((p->nTab == 0)) {
    (p->nTab = 1);
  }  
}
static  int sqlite3FindDbName(sqlite3 *db , const  char *zName )  {
  int i =  (- 1);
  if (zName) {
    Db *pDb;
    int n =  sqlite3Strlen30(zName);
    for ((i = (db->nDb - 1)), (pDb = (&db->aDb[i])); (i >= 0); i--, pDb--) {
      if ((((! 0) || (i != 1)) && (n == sqlite3Strlen30(pDb->zName)) && (0 == sqlite3_stricmp(pDb->zName, zName)))) {
        break;
      }  
    }
  }  
  return i;
}
static  int sqlite3FindDb(sqlite3 *db , Token *pName )  {
  int i;
  char *zName;
  (zName = sqlite3NameFromToken(db, pName));
  (i = sqlite3FindDbName(db, zName));
  sqlite3DbFree(db, zName);
  return i;
}
static  int sqlite3TwoPartName(Parse *pParse , Token *pName1 , Token *pName2 , Token **pUnqual )  {
  int iDb;
  sqlite3 *db =  pParse->db;
  if (((id2i_sqlite_coverage_test ) )) {
    if ((1 && (pName2->n > 0))) {
      if (db->init.busy) {
        sqlite3ErrorMsg(pParse, "corrupt database");
        pParse->nErr++;
        return (- 1);
      }  
      ((*pUnqual) = pName2);
      (iDb = sqlite3FindDb(db, pName1));
      if ((iDb < 0)) {
        sqlite3ErrorMsg(pParse, "unknown database %T", pName1);
        pParse->nErr++;
        return (- 1);
      }  
    }  
    else {
      ((void ) 0);
      (iDb = db->init.iDb);
      ((*pUnqual) = pName1);
    }
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((pName2 != 0) && (pName2->n > 0))) {
      if (db->init.busy) {
        sqlite3ErrorMsg(pParse, "corrupt database");
        pParse->nErr++;
        return (- 1);
      }  
      ((*pUnqual) = pName2);
      (iDb = sqlite3FindDb(db, pName1));
      if ((iDb < 0)) {
        sqlite3ErrorMsg(pParse, "unknown database %T", pName1);
        pParse->nErr++;
        return (- 1);
      }  
    }  
    else {
      ((void ) 0);
      (iDb = db->init.iDb);
      ((*pUnqual) = pName1);
    }
  }  
  return iDb;
}
static  int sqlite3CheckObjectName(Parse *pParse , const  char *zName )  {
  if (((! pParse->db->init.busy) && (pParse->nested == 0) && ((pParse->db->flags & 0x00000800) == 0) && (0 == sqlite3_strnicmp(zName, "sqlite_", 7)))) {
    sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s", zName);
    return 1;
  }  
  return 0;
}
static  void sqlite3StartTable(Parse *pParse , Token *pName1 , Token *pName2 , int isTemp , int isView , int isVirtual , int noErr )  {
  Table *pTable;
  char *zName =  0;
  sqlite3 *db =  pParse->db;
  Vdbe *v;
  int iDb;
  Token *pName;
  (iDb = sqlite3TwoPartName(pParse, pName1, pName2, (&pName)));
  if ((iDb < 0)) {
    return;
  }  
  if (((! 0) && isTemp && (pName2->n > 0) && (iDb != 1))) {
    sqlite3ErrorMsg(pParse, "temporary table name must be unqualified");
    return;
  }  
  if (((! 0) && isTemp)) {
    (iDb = 1);
  }  
  (pParse->sNameToken = (*pName));
  (zName = sqlite3NameFromToken(db, pName));
  if ((zName == 0)) {
    return;
  }  
  if ((0 != sqlite3CheckObjectName(pParse, zName))) {
    goto begin_table_error;
  }  
  if ((db->init.iDb == 1)) {
    (isTemp = 1);
  }  
  ((void ) 0);
  {
    int code;
    char *zDb =  db->aDb[iDb].zName;
    if (sqlite3AuthCheck(pParse, 18, (((! 0) && (isTemp == 1)) ? "sqlite_temp_master" : "sqlite_master"), 0, zDb)) {
      goto begin_table_error;
    }  
    if (isView) {
      if (((! 0) && isTemp)) {
        (code = 6);
      }  
      else {
        (code = 8);
      }
    }  
    else {
      if (((! 0) && isTemp)) {
        (code = 4);
      }  
      else {
        (code = 2);
      }
    }
    if (((! isVirtual) && sqlite3AuthCheck(pParse, code, zName, 0, zDb))) {
      goto begin_table_error;
    }  
  }
  if ((! pParse->declareVtab)) {
    char *zDb =  db->aDb[iDb].zName;
    if ((0 != sqlite3ReadSchema(pParse))) {
      goto begin_table_error;
    }  
    (pTable = sqlite3FindTable(db, zName, zDb));
    if (pTable) {
      if ((! noErr)) {
        sqlite3ErrorMsg(pParse, "table %T already exists", pName);
      }  
      else {
        ((void ) 0);
        sqlite3CodeVerifySchema(pParse, iDb);
      }
      goto begin_table_error;
    }  
    if ((sqlite3FindIndex(db, zName, zDb) != 0)) {
      sqlite3ErrorMsg(pParse, "there is already an index named %s", zName);
      goto begin_table_error;
    }  
  }  
  (pTable = sqlite3DbMallocZero(db, sizeof(Table )));
  if ((pTable == 0)) {
    (db->mallocFailed = 1);
    (pParse->rc = 7);
    pParse->nErr++;
    goto begin_table_error;
  }  
  (pTable->zName = zName);
  (pTable->iPKey = (- 1));
  (pTable->pSchema = db->aDb[iDb].pSchema);
  (pTable->nRef = 1);
  (pTable->nRowEst = 1048576);
  ((void ) 0);
  (pParse->pNewTable = pTable);
  if (((! pParse->nested) && (strcmp(zName, "sqlite_sequence") == 0))) {
    ((void ) 0);
    (pTable->pSchema->pSeqTab = pTable);
  }  
  if (((! db->init.busy) && ((v = sqlite3GetVdbe(pParse)) != 0))) {
    int j1;
    int fileFormat;
    int reg1, reg2, reg3;
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    if (isVirtual) {
      sqlite3VdbeAddOp0(v, 134);
    }  
    (reg1 = (pParse->regRowid = ++pParse->nMem));
    (reg2 = (pParse->regRoot = ++pParse->nMem));
    (reg3 = ++pParse->nMem);
    sqlite3VdbeAddOp3(v, 45, iDb, reg3, 2);
    sqlite3VdbeUsesBtree(v, iDb);
    (j1 = sqlite3VdbeAddOp1(v, 39, reg3));
    (fileFormat = (((db->flags & 0x00008000) != 0) ? 1 : 4));
    sqlite3VdbeAddOp2(v, 21, fileFormat, reg3);
    sqlite3VdbeAddOp3(v, 46, iDb, 2, reg3);
    sqlite3VdbeAddOp2(v, 21, db->aDb[0].pSchema->enc, reg3);
    sqlite3VdbeAddOp3(v, 46, iDb, 5, reg3);
    sqlite3VdbeJumpHere(v, j1);
    if ((isView || isVirtual)) {
      sqlite3VdbeAddOp2(v, 21, 0, reg2);
    }  
    else {
      sqlite3VdbeAddOp2(v, 111, iDb, reg2);
    }
    sqlite3OpenMasterTable(pParse, iDb);
    sqlite3VdbeAddOp2(v, 65, 0, reg1);
    sqlite3VdbeAddOp2(v, 24, 0, reg3);
    sqlite3VdbeAddOp3(v, 66, 0, reg3, reg1);
    sqlite3VdbeChangeP5(v, 0x08);
    sqlite3VdbeAddOp0(v, 54);
  }  
  return;
  begin_table_error:
  sqlite3DbFree(db, zName);
  return;
}
static  void sqlite3AddColumn(Parse *pParse , Token *pName )  {
  Table *p;
  int i;
  char *z;
  Column *pCol;
  sqlite3 *db =  pParse->db;
  if (((p = pParse->pNewTable) == 0)) {
    return;
  }  
  if (((p->nCol + 1) > db->aLimit[2])) {
    sqlite3ErrorMsg(pParse, "too many columns on %s", p->zName);
    return;
  }  
  (z = sqlite3NameFromToken(db, pName));
  if ((z == 0)) {
    return;
  }  
  for ((i = 0); (i < p->nCol); i++) {
    if ((((! id2i_sqlite_ebcdic) ) )) {
      if (((_1281_sqlite3UpperToLower[(*((unsigned  char *) z))] == _1281_sqlite3UpperToLower[(*((unsigned  char *) p->aCol[i].zName))]) && (sqlite3_stricmp((z + 1), (p->aCol[i].zName + 1)) == 0))) {
        sqlite3ErrorMsg(pParse, "duplicate column name: %s", z);
        sqlite3DbFree(db, z);
        return;
      }  
    }  
    if (((id2i_sqlite_ebcdic ) )) {
      if (((_1282_sqlite3UpperToLower[(*((unsigned  char *) z))] == _1282_sqlite3UpperToLower[(*((unsigned  char *) p->aCol[i].zName))]) && (sqlite3_stricmp((z + 1), (p->aCol[i].zName + 1)) == 0))) {
        sqlite3ErrorMsg(pParse, "duplicate column name: %s", z);
        sqlite3DbFree(db, z);
        return;
      }  
    }  
  }
  if (((p->nCol & 0x7) == 0)) {
    Column *aNew;
    (aNew = sqlite3DbRealloc(db, p->aCol, ((p->nCol + 8) * sizeof(p->aCol[0]))));
    if ((aNew == 0)) {
      sqlite3DbFree(db, z);
      return;
    }  
    (p->aCol = aNew);
  }  
  (pCol = (&p->aCol[p->nCol]));
  memset(pCol, 0, sizeof(p->aCol[0]));
  (pCol->zName = z);
  (pCol->affinity = 'b');
  (pCol->szEst = 1);
  p->nCol++;
}
static  void sqlite3AddNotNull(Parse *pParse , int onError )  {
  Table *p;
  (p = pParse->pNewTable);
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((p == 0) || (p->nCol < 1))) {
      return;
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((p == 0) || 0)) {
      return;
    }  
  }  
  (p->aCol[(p->nCol - 1)].notNull = ((u8 ) onError));
}
static  char sqlite3AffinityType(const  char *zIn , u8 *pszEst )  {
  u32 h =  0;
  char aff =  'c';
  const char *zChar =  0;
  if ((zIn == 0)) {
    return aff;
  }  
  while (zIn[0]) {
    if ((((! id2i_sqlite_ebcdic) ) )) {
      (h = ((h << 8) + _1281_sqlite3UpperToLower[((*zIn) & 0xff)]));
    }  
    if (((id2i_sqlite_ebcdic ) )) {
      (h = ((h << 8) + _1282_sqlite3UpperToLower[((*zIn) & 0xff)]));
    }  
    zIn++;
    if ((h == (('c' << 24) + ('h' << 16) + ('a' << 8) + 'r'))) {
      (aff = 'a');
      (zChar = zIn);
    } 
    else if ((h == (('c' << 24) + ('l' << 16) + ('o' << 8) + 'b'))) {
      (aff = 'a');
    }
    
    else if ((h == (('t' << 24) + ('e' << 16) + ('x' << 8) + 't'))) {
      (aff = 'a');
    }
    
    else if (((h == (('b' << 24) + ('l' << 16) + ('o' << 8) + 'b')) && ((aff == 'c') || (aff == 'e')))) {
      (aff = 'b');
      if ((zIn[0] == '(')) {
        (zChar = zIn);
      }  
    }
    
    else if (((h == (('r' << 24) + ('e' << 16) + ('a' << 8) + 'l')) && (aff == 'c'))) {
      (aff = 'e');
    }
    
    else if (((h == (('f' << 24) + ('l' << 16) + ('o' << 8) + 'a')) && (aff == 'c'))) {
      (aff = 'e');
    }
    
    else if (((h == (('d' << 24) + ('o' << 16) + ('u' << 8) + 'b')) && (aff == 'c'))) {
      (aff = 'e');
    }
    
    else if (((h & 0x00FFFFFF) == (('i' << 16) + ('n' << 8) + 't'))) {
      (aff = 'd');
      break;
    } 
  }
  if (pszEst) {
    ((*pszEst) = 1);
    if ((aff <= 'b')) {
      if (zChar) {
        while (zChar[0]) {
          if ((sqlite3CtypeMap[((unsigned  char ) zChar[0])] & 0x04)) {
            int v =  0;
            sqlite3GetInt32(zChar, (&v));
            (v = ((v / 4) + 1));
            if ((v > 255)) {
              (v = 255);
            }  
            ((*pszEst) = v);
            break;
          }  
          zChar++;
        }
      }  
      else {
        ((*pszEst) = 5);
      }
    }  
  }  
  return aff;
}
static  void sqlite3AddColumnType(Parse *pParse , Token *pType )  {
  Table *p;
  Column *pCol;
  (p = pParse->pNewTable);
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((p == 0) || (p->nCol < 1))) {
      return;
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((p == 0) || 0)) {
      return;
    }  
  }  
  (pCol = (&p->aCol[(p->nCol - 1)]));
  ((void ) 0);
  (pCol->zType = sqlite3NameFromToken(pParse->db, pType));
  (pCol->affinity = sqlite3AffinityType(pCol->zType, (&pCol->szEst)));
}
static  void sqlite3AddDefaultValue(Parse *pParse , ExprSpan *pSpan )  {
  Table *p;
  Column *pCol;
  sqlite3 *db =  pParse->db;
  (p = pParse->pNewTable);
  if ((p != 0)) {
    (pCol = (&p->aCol[(p->nCol - 1)]));
    if ((! sqlite3ExprIsConstantOrFunction(pSpan->pExpr))) {
      sqlite3ErrorMsg(pParse, "default value of column [%s] is not constant", pCol->zName);
    }  
    else {
      sqlite3ExprDelete(db, pCol->pDflt);
      (pCol->pDflt = sqlite3ExprDup(db, pSpan->pExpr, 0x0001));
      sqlite3DbFree(db, pCol->zDflt);
      (pCol->zDflt = sqlite3DbStrNDup(db, ((char *) pSpan->zStart), ((int ) (pSpan->zEnd - pSpan->zStart))));
    }
  }  
  sqlite3ExprDelete(db, pSpan->pExpr);
}
static  void sqlite3AddPrimaryKey(Parse *pParse , ExprList *pList , int onError , int autoInc , int sortOrder )  {
  Table *pTab =  pParse->pNewTable;
  char *zType =  0;
  int iCol =  (- 1), i;
  if (((pTab == 0) || pParse->declareVtab)) {
    goto primary_key_exit;
  }  
  if ((pTab->tabFlags & 0x04)) {
    sqlite3ErrorMsg(pParse, "table \"%s\" has more than one primary key", pTab->zName);
    goto primary_key_exit;
  }  
  (pTab->tabFlags |= 0x04);
  if ((pList == 0)) {
    (iCol = (pTab->nCol - 1));
    (pTab->aCol[iCol].colFlags |= 0x0001);
  }  
  else {
    for ((i = 0); (i < pList->nExpr); i++) {
      for ((iCol = 0); (iCol < pTab->nCol); iCol++) {
        if ((sqlite3_stricmp(pList->a[i].zName, pTab->aCol[iCol].zName) == 0)) {
          break;
        }  
      }
      if ((iCol < pTab->nCol)) {
        (pTab->aCol[iCol].colFlags |= 0x0001);
      }  
    }
    if ((pList->nExpr > 1)) {
      (iCol = (- 1));
    }  
  }
  if (((iCol >= 0) && (iCol < pTab->nCol))) {
    (zType = pTab->aCol[iCol].zType);
  }  
  if ((zType && (sqlite3_stricmp(zType, "INTEGER") == 0) && (sortOrder == 0))) {
    (pTab->iPKey = iCol);
    (pTab->keyConf = ((u8 ) onError));
    ((void ) 0);
    (pTab->tabFlags |= (autoInc * 0x08));
  } 
  else if (autoInc) {
    sqlite3ErrorMsg(pParse, "AUTOINCREMENT is only allowed on an " "INTEGER PRIMARY KEY");
  } 
  else {
    Index *p;
    (p = sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0, 0, sortOrder, 0));
    if (p) {
      (p->autoIndex = 2);
    }  
    (pList = 0);
  }
  primary_key_exit:
  sqlite3ExprListDelete(pParse->db, pList);
  return;
}
static  void sqlite3AddCheckConstraint(Parse *pParse , Expr *pCheckExpr )  {
  Table *pTab =  pParse->pNewTable;
  if ((pTab && (! pParse->declareVtab))) {
    (pTab->pCheck = sqlite3ExprListAppend(pParse, pTab->pCheck, pCheckExpr));
    if (pParse->constraintName.n) {
      sqlite3ExprListSetName(pParse, pTab->pCheck, (&pParse->constraintName), 1);
    }  
  }  
  else {
    sqlite3ExprDelete(pParse->db, pCheckExpr);
  }
}
static  void sqlite3AddCollateType(Parse *pParse , Token *pToken )  {
  Table *p;
  int i;
  char *zColl;
  sqlite3 *db;
  if (((p = pParse->pNewTable) == 0)) {
    return;
  }  
  (i = (p->nCol - 1));
  (db = pParse->db);
  (zColl = sqlite3NameFromToken(db, pToken));
  if ((! zColl)) {
    return;
  }  
  if (sqlite3LocateCollSeq(pParse, zColl)) {
    Index *pIdx;
    sqlite3DbFree(db, p->aCol[i].zColl);
    (p->aCol[i].zColl = zColl);
    for ((pIdx = p->pIndex); pIdx; (pIdx = pIdx->pNext)) {
      ((void ) 0);
      if ((pIdx->aiColumn[0] == i)) {
        (pIdx->azColl[0] = p->aCol[i].zColl);
      }  
    }
  }  
  else {
    sqlite3DbFree(db, zColl);
  }
}
static  CollSeq *sqlite3LocateCollSeq(Parse *pParse , const  char *zName )  {
  sqlite3 *db =  pParse->db;
  u8 enc =  db->aDb[0].pSchema->enc;
  u8 initbusy =  db->init.busy;
  CollSeq *pColl;
  (pColl = sqlite3FindCollSeq(db, enc, zName, initbusy));
  if (((! initbusy) && ((! pColl) || (! pColl->xCmp)))) {
    (pColl = sqlite3GetCollSeq(pParse, enc, pColl, zName));
  }  
  return pColl;
}
static  void sqlite3ChangeCookie(Parse *pParse , int iDb )  {
  int r1 =  sqlite3GetTempReg(pParse);
  sqlite3 *db =  pParse->db;
  Vdbe *v =  pParse->pVdbe;
  ((void ) 0);
  sqlite3VdbeAddOp2(v, 21, (db->aDb[iDb].pSchema->schema_cookie + 1), r1);
  sqlite3VdbeAddOp3(v, 46, iDb, 1, r1);
  sqlite3ReleaseTempReg(pParse, r1);
}
static  int identLength(const  char *z )  {
  int n;
  for ((n = 0); (*z); n++, z++) {
    if (((*z) == '"')) {
      n++;
    }  
  }
  return (n + 2);
}
static  void identPut(char *z , int *pIdx , char *zSignedIdent )  {
  unsigned char *zIdent =  ((unsigned  char *) zSignedIdent);
  int i, j, needQuote;
  (i = (*pIdx));
  for ((j = 0); zIdent[j]; j++) {
    if (((! (sqlite3CtypeMap[((unsigned  char ) zIdent[j])] & 0x06)) && (zIdent[j] != '_'))) {
      break;
    }  
  }
  (needQuote = ((sqlite3CtypeMap[((unsigned  char ) zIdent[0])] & 0x04) || (sqlite3KeywordCode(zIdent, j) != 26)));
  if ((! needQuote)) {
    (needQuote = zIdent[j]);
  }  
  if (needQuote) {
    (z[i++] = '"');
  }  
  for ((j = 0); zIdent[j]; j++) {
    (z[i++] = zIdent[j]);
    if ((zIdent[j] == '"')) {
      (z[i++] = '"');
    }  
  }
  if (needQuote) {
    (z[i++] = '"');
  }  
  (z[i] = 0);
  ((*pIdx) = i);
}
static  char *createTableStmt(sqlite3 *db , Table *p )  {
  int i, k, n;
  char *zStmt;
  char *zSep, *zSep2, *zEnd;
  Column *pCol;
  (n = 0);
  for ((pCol = p->aCol), (i = 0); (i < p->nCol); i++, pCol++) {
    (n += (identLength(pCol->zName) + 5));
  }
  (n += identLength(p->zName));
  if ((n < 50)) {
    (zSep = "");
    (zSep2 = ",");
    (zEnd = ")");
  }  
  else {
    (zSep = "\n  ");
    (zSep2 = ",\n  ");
    (zEnd = "\n)");
  }
  (n += (35 + (6 * p->nCol)));
  (zStmt = sqlite3DbMallocRaw(0, n));
  if ((zStmt == 0)) {
    (db->mallocFailed = 1);
    return 0;
  }  
  sqlite3_snprintf(n, zStmt, "CREATE TABLE ");
  (k = sqlite3Strlen30(zStmt));
  identPut(zStmt, (&k), p->zName);
  (zStmt[k++] = '(');
  for ((pCol = p->aCol), (i = 0); (i < p->nCol); i++, pCol++) {
    static const char *const azType[] =  { " TEXT",  "",  " NUM",  " INT",  " REAL"};
    int len;
    const char *zType;
    sqlite3_snprintf((n - k), (&zStmt[k]), zSep);
    (k += sqlite3Strlen30((&zStmt[k])));
    (zSep = zSep2);
    identPut(zStmt, (&k), pCol->zName);
    ((void ) 0);
    ((void ) 0);
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pCol->affinity == 'a')) {
        sqlite3Coverage(85089);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pCol->affinity == 'b')) {
        sqlite3Coverage(85090);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pCol->affinity == 'c')) {
        sqlite3Coverage(85091);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pCol->affinity == 'd')) {
        sqlite3Coverage(85092);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pCol->affinity == 'e')) {
        sqlite3Coverage(85093);
      }  
    }  
    (zType = azType[(pCol->affinity - 'a')]);
    (len = sqlite3Strlen30(zType));
    ((void ) 0);
    memcpy((&zStmt[k]), zType, len);
    (k += len);
    ((void ) 0);
  }
  sqlite3_snprintf((n - k), (&zStmt[k]), "%s", zEnd);
  return zStmt;
}
static  void estimateTableWidth(Table *pTab )  {
  unsigned wTable =  0;
  const Column *pTabCol;
  int i;
  for ((i = pTab->nCol), (pTabCol = pTab->aCol); (i > 0); i--, pTabCol++) {
    (wTable += pTabCol->szEst);
  }
  if ((pTab->iPKey < 0)) {
    wTable++;
  }  
  (pTab->szTabRow = sqlite3LogEst((wTable * 4)));
}
static  void estimateIndexWidth(Index *pIdx )  {
  unsigned wIndex =  1;
  int i;
  const Column *aCol =  pIdx->pTable->aCol;
  for ((i = 0); (i < pIdx->nColumn); i++) {
    ((void ) 0);
    (wIndex += aCol[pIdx->aiColumn[i]].szEst);
  }
  (pIdx->szIdxRow = sqlite3LogEst((wIndex * 4)));
}
static  void sqlite3EndTable(Parse *pParse , Token *pCons , Token *pEnd , Select *pSelect )  {
  Table *p;
  sqlite3 *db =  pParse->db;
  int iDb;
  Index *pIdx;
  if ((((pEnd == 0) && (pSelect == 0)) || db->mallocFailed)) {
    return;
  }  
  (p = pParse->pNewTable);
  if ((p == 0)) {
    return;
  }  
  ((void ) 0);
  (iDb = sqlite3SchemaToIndex(db, p->pSchema));
  if (p->pCheck) {
    sqlite3ResolveSelfReference(pParse, p, 0x04, 0, p->pCheck);
  }  
  estimateTableWidth(p);
  for ((pIdx = p->pIndex); pIdx; (pIdx = pIdx->pNext)) {
    estimateIndexWidth(pIdx);
  }
  if (db->init.busy) {
    (p->tnum = db->init.newTnum);
  }  
  if ((! db->init.busy)) {
    int n;
    Vdbe *v;
    char *zType;
    char *zType2;
    char *zStmt;
    (v = sqlite3GetVdbe(pParse));
    if (((id2i_sqlite_coverage_test ) )) {
      if (0) {
        return;
      }  
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      if ((v == 0)) {
        return;
      }  
    }  
    sqlite3VdbeAddOp1(v, 54, 0);
    if ((((! id2i_sqlite_omit_view) ) )) {
      if ((p->pSelect == 0)) {
        (zType = "table");
        (zType2 = "TABLE");
      }  
      else {
        (zType = "view");
        (zType2 = "VIEW");
      }
    }  
    if (((id2i_sqlite_omit_view ) )) {
      if ((p->pSelect == 0)) {
        (zType = "table");
        (zType2 = "TABLE");
      }  
    }  
    if (pSelect) {
      SelectDest dest;
      Table *pSelTab;
      ((void ) 0);
      sqlite3VdbeAddOp3(v, 49, 1, pParse->regRoot, iDb);
      sqlite3VdbeChangeP5(v, 0x02);
      (pParse->nTab = 2);
      sqlite3SelectDestInit((&dest), 8, 1);
      sqlite3Select(pParse, pSelect, (&dest));
      sqlite3VdbeAddOp1(v, 54, 1);
      if ((pParse->nErr == 0)) {
        (pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect));
        if ((pSelTab == 0)) {
          return;
        }  
        ((void ) 0);
        (p->nCol = pSelTab->nCol);
        (p->aCol = pSelTab->aCol);
        (pSelTab->nCol = 0);
        (pSelTab->aCol = 0);
        sqlite3DeleteTable(db, pSelTab);
      }  
    }  
    if (pSelect) {
      (zStmt = createTableStmt(db, p));
    }  
    else {
      (n = (((int ) (pEnd->z - pParse->sNameToken.z)) + 1));
      (zStmt = sqlite3MPrintf(db, "CREATE %s %.*s", zType2, n, pParse->sNameToken.z));
    }
    sqlite3NestedParse(pParse, "UPDATE %Q.%s " "SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q " "WHERE rowid=#%d", db->aDb[iDb].zName, (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"), zType, p->zName, p->zName, pParse->regRoot, zStmt, pParse->regRowid);
    sqlite3DbFree(db, zStmt);
    sqlite3ChangeCookie(pParse, iDb);
    if ((p->tabFlags & 0x08)) {
      Db *pDb =  (&db->aDb[iDb]);
      ((void ) 0);
      if ((pDb->pSchema->pSeqTab == 0)) {
        sqlite3NestedParse(pParse, "CREATE TABLE %Q.sqlite_sequence(name,seq)", pDb->zName);
      }  
    }  
    sqlite3VdbeAddParseSchemaOp(v, iDb, sqlite3MPrintf(db, "tbl_name='%q'", p->zName));
  }  
  if (db->init.busy) {
    Table *pOld;
    Schema *pSchema =  p->pSchema;
    ((void ) 0);
    (pOld = sqlite3HashInsert((&pSchema->tblHash), p->zName, sqlite3Strlen30(p->zName), p));
    if (pOld) {
      ((void ) 0);
      (db->mallocFailed = 1);
      return;
    }  
    (pParse->pNewTable = 0);
    (db->flags |= 0x00000002);
    if ((! p->pSelect)) {
      const char *zName =  ((const  char *) pParse->sNameToken.z);
      int nName;
      ((void ) 0);
      if ((pCons->z == 0)) {
        (pCons = pEnd);
      }  
      (nName = ((int ) (((const  char *) pCons->z) - zName)));
      (p->addColOffset = (13 + sqlite3Utf8CharLen(zName, nName)));
    }  
  }  
}
static  void sqlite3CreateView(Parse *pParse , Token *pBegin , Token *pName1 , Token *pName2 , Select *pSelect , int isTemp , int noErr )  {
  Table *p;
  int n;
  const char *z;
  Token sEnd;
  DbFixer sFix;
  Token *pName =  0;
  int iDb;
  sqlite3 *db =  pParse->db;
  if ((pParse->nVar > 0)) {
    sqlite3ErrorMsg(pParse, "parameters are not allowed in views");
    sqlite3SelectDelete(db, pSelect);
    return;
  }  
  sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);
  (p = pParse->pNewTable);
  if (((p == 0) || pParse->nErr)) {
    sqlite3SelectDelete(db, pSelect);
    return;
  }  
  sqlite3TwoPartName(pParse, pName1, pName2, (&pName));
  (iDb = sqlite3SchemaToIndex(db, p->pSchema));
  sqlite3FixInit((&sFix), pParse, iDb, "view", pName);
  if (sqlite3FixSelect((&sFix), pSelect)) {
    sqlite3SelectDelete(db, pSelect);
    return;
  }  
  (p->pSelect = sqlite3SelectDup(db, pSelect, 0x0001));
  sqlite3SelectDelete(db, pSelect);
  if (db->mallocFailed) {
    return;
  }  
  if ((! db->init.busy)) {
    sqlite3ViewGetColumnNames(pParse, p);
  }  
  (sEnd = pParse->sLastToken);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((1 && (sEnd.z[0] != ';'))) {
      (sEnd.z += sEnd.n);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((sEnd.z[0] != 0) && (sEnd.z[0] != ';'))) {
      (sEnd.z += sEnd.n);
    }  
  }  
  (sEnd.n = 0);
  (n = ((int ) (sEnd.z - pBegin->z)));
  (z = pBegin->z);
  if (((id2i_sqlite_coverage_test ) )) {
    while ((1 && (sqlite3CtypeMap[((unsigned  char ) z[(n - 1)])] & 0x01))) {
      n--;
    }
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    while (((n > 0) && (sqlite3CtypeMap[((unsigned  char ) z[(n - 1)])] & 0x01))) {
      n--;
    }
  }  
  (sEnd.z = (&z[(n - 1)]));
  (sEnd.n = 1);
  sqlite3EndTable(pParse, 0, (&sEnd), 0);
  return;
}
static  int sqlite3ViewGetColumnNames(Parse *pParse , Table *pTable )  {
  Table *pSelTab;
  Select *pSel;
  int nErr =  0;
  int n;
  sqlite3 *db =  pParse->db;
  int ( *xAuth)(void * , int , const  char * , const  char * , const  char * , const  char * );
  ((void ) 0);
  if (sqlite3VtabCallConnect(pParse, pTable)) {
    return 1;
  }  
  if (((pTable->tabFlags & 0x10) != 0)) {
    return 0;
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if ((pTable->nCol > 0)) {
      return 0;
    }  
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if ((pTable->nCol < 0)) {
      sqlite3ErrorMsg(pParse, "view %s is circularly defined", pTable->zName);
      return 1;
    }  
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    ((void ) 0);
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    ((void ) 0);
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    (pSel = sqlite3SelectDup(db, pTable->pSelect, 0));
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if (pSel) {
      u8 enableLookaside =  db->lookaside.bEnabled;
      (n = pParse->nTab);
      sqlite3SrcListAssignCursors(pParse, pSel->pSrc);
      (pTable->nCol = (- 1));
      (db->lookaside.bEnabled = 0);
      (xAuth = db->xAuth);
      (db->xAuth = 0);
      (pSelTab = sqlite3ResultSetOfSelect(pParse, pSel));
      (db->xAuth = xAuth);
      (db->lookaside.bEnabled = enableLookaside);
      (pParse->nTab = n);
      if (pSelTab) {
        ((void ) 0);
        (pTable->nCol = pSelTab->nCol);
        (pTable->aCol = pSelTab->aCol);
        (pSelTab->nCol = 0);
        (pSelTab->aCol = 0);
        sqlite3DeleteTable(db, pSelTab);
        ((void ) 0);
        (pTable->pSchema->flags |= 0x0002);
      }  
      else {
        (pTable->nCol = 0);
        nErr++;
      }
      sqlite3SelectDelete(db, pSel);
    }  
    else {
      nErr++;
    }
  }  
  return nErr;
}
static  void sqliteViewResetAll(sqlite3 *db , int idx )  {
  HashElem *i;
  ((void ) 0);
  if ((! ((db->aDb[idx].pSchema->flags & 0x0002) == 0x0002))) {
    return;
  }  
  for ((i = (&db->aDb[idx].pSchema->tblHash)->first); i; (i = i->next)) {
    Table *pTab =  i->data;
    if (pTab->pSelect) {
      sqliteDeleteColumnNames(db, pTab);
      (pTab->aCol = 0);
      (pTab->nCol = 0);
    }  
  }
  (db->aDb[idx].pSchema->flags &= (~ 0x0002));
}
static  void sqlite3RootPageMoved(sqlite3 *db , int iDb , int iFrom , int iTo )  {
  HashElem *pElem;
  Hash *pHash;
  Db *pDb;
  ((void ) 0);
  (pDb = (&db->aDb[iDb]));
  (pHash = (&pDb->pSchema->tblHash));
  for ((pElem = pHash->first); pElem; (pElem = pElem->next)) {
    Table *pTab =  pElem->data;
    if ((pTab->tnum == iFrom)) {
      (pTab->tnum = iTo);
    }  
  }
  (pHash = (&pDb->pSchema->idxHash));
  for ((pElem = pHash->first); pElem; (pElem = pElem->next)) {
    Index *pIdx =  pElem->data;
    if ((pIdx->tnum == iFrom)) {
      (pIdx->tnum = iTo);
    }  
  }
}
static  void destroyRootPage(Parse *pParse , int iTable , int iDb )  {
  Vdbe *v =  sqlite3GetVdbe(pParse);
  int r1 =  sqlite3GetTempReg(pParse);
  sqlite3VdbeAddOp3(v, 108, iTable, r1, iDb);
  sqlite3MayAbort(pParse);
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    sqlite3NestedParse(pParse, "UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d", pParse->db->aDb[iDb].zName, (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"), iTable, r1, r1);
  }  
  sqlite3ReleaseTempReg(pParse, r1);
}
static  void destroyTable(Parse *pParse , Table *pTab )  {
  Index *_1332_pIdx;
  int _1332_iDb =  sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  if (((id2i_sqlite_omit_autovacuum ) )) {
    destroyRootPage(pParse, pTab->tnum, _1332_iDb);
  }  
  if (((id2i_sqlite_omit_autovacuum ) )) {
    for ((_1332_pIdx = pTab->pIndex); _1332_pIdx; (_1332_pIdx = _1332_pIdx->pNext)) {
      destroyRootPage(pParse, _1332_pIdx->tnum, _1332_iDb);
    }
  }  
  int _1312_iTab =  pTab->tnum;
  int iDestroyed =  0;
  if ((((! id2i_sqlite_omit_autovacuum) ) )) {
    while (1) {
      Index *pIdx;
      int iLargest =  0;
      if (((iDestroyed == 0) || (_1312_iTab < iDestroyed))) {
        (iLargest = _1312_iTab);
      }  
      for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
        int iIdx =  pIdx->tnum;
        ((void ) 0);
        if ((((iDestroyed == 0) || (iIdx < iDestroyed)) && (iIdx > iLargest))) {
          (iLargest = iIdx);
        }  
      }
      if ((iLargest == 0)) {
        return;
      }  
      else {
        int iDb =  sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
        ((void ) 0);
        destroyRootPage(pParse, iLargest, iDb);
        (iDestroyed = iLargest);
      }
    }
  }  
}
static  void sqlite3ClearStatTables(Parse *pParse , int iDb , const  char *zType , const  char *zName )  {
  int i;
  const char *zDbName =  pParse->db->aDb[iDb].zName;
  for ((i = 1); (i <= 4); i++) {
    char zTab[24];
    sqlite3_snprintf(sizeof(zTab), zTab, "sqlite_stat%d", i);
    if (sqlite3FindTable(pParse->db, zTab, zDbName)) {
      sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE %s=%Q", zDbName, zTab, zType, zName);
    }  
  }
}
static  void sqlite3CodeDropTable(Parse *pParse , Table *pTab , int iDb , int isView )  {
  Vdbe *v;
  sqlite3 *db =  pParse->db;
  Trigger *pTrigger;
  Db *pDb =  (&db->aDb[iDb]);
  (v = sqlite3GetVdbe(pParse));
  ((void ) 0);
  sqlite3BeginWriteOperation(pParse, 1, iDb);
  if (((pTab->tabFlags & 0x10) != 0)) {
    sqlite3VdbeAddOp0(v, 134);
  }  
  (pTrigger = sqlite3TriggerList(pParse, pTab));
  while (pTrigger) {
    ((void ) 0);
    sqlite3DropTriggerPtr(pParse, pTrigger);
    (pTrigger = pTrigger->pNext);
  }
  if ((pTab->tabFlags & 0x08)) {
    sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_sequence WHERE name=%Q", pDb->zName, pTab->zName);
  }  
  sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'", pDb->zName, (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"), pTab->zName);
  if (((! isView) && (! ((pTab->tabFlags & 0x10) != 0)))) {
    destroyTable(pParse, pTab);
  }  
  if (((pTab->tabFlags & 0x10) != 0)) {
    sqlite3VdbeAddOp4(v, 136, iDb, 0, 0, pTab->zName, 0);
  }  
  sqlite3VdbeAddOp4(v, 114, iDb, 0, 0, pTab->zName, 0);
  sqlite3ChangeCookie(pParse, iDb);
  if ((((! id2i_sqlite_omit_view) ) )) {
    sqliteViewResetAll(db, iDb);
  }  
}
static  void sqlite3DropTable(Parse *pParse , SrcList *pName , int isView , int noErr )  {
  Table *pTab;
  Vdbe *v;
  sqlite3 *db =  pParse->db;
  int iDb;
  if (db->mallocFailed) {
    goto exit_drop_table;
  }  
  ((void ) 0);
  ((void ) 0);
  if (noErr) {
    db->suppressErr++;
  }  
  (pTab = sqlite3LocateTableItem(pParse, isView, (&pName->a[0])));
  if (noErr) {
    db->suppressErr--;
  }  
  if ((pTab == 0)) {
    if (noErr) {
      sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);
    }  
    goto exit_drop_table;
  }  
  (iDb = sqlite3SchemaToIndex(db, pTab->pSchema));
  ((void ) 0);
  if ((((pTab->tabFlags & 0x10) != 0) && sqlite3ViewGetColumnNames(pParse, pTab))) {
    goto exit_drop_table;
  }  
  {
    int code;
    const char *zTab =  (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master");
    const char *zDb =  db->aDb[iDb].zName;
    const char *zArg2 =  0;
    if (sqlite3AuthCheck(pParse, 9, zTab, 0, zDb)) {
      goto exit_drop_table;
    }  
    if (isView) {
      if (((! 0) && (iDb == 1))) {
        (code = 15);
      }  
      else {
        (code = 17);
      }
    } 
    else if (((pTab->tabFlags & 0x10) != 0)) {
      (code = 30);
      (zArg2 = sqlite3GetVTable(db, pTab)->pMod->zName);
    } 
    else {
      if (((! 0) && (iDb == 1))) {
        (code = 13);
      }  
      else {
        (code = 11);
      }
    }
    if (sqlite3AuthCheck(pParse, code, pTab->zName, zArg2, zDb)) {
      goto exit_drop_table;
    }  
    if (sqlite3AuthCheck(pParse, 9, pTab->zName, 0, zDb)) {
      goto exit_drop_table;
    }  
  }
  if (((sqlite3_strnicmp(pTab->zName, "sqlite_", 7) == 0) && (sqlite3_strnicmp(pTab->zName, "sqlite_stat", 11) != 0))) {
    sqlite3ErrorMsg(pParse, "table %s may not be dropped", pTab->zName);
    goto exit_drop_table;
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if ((isView && (pTab->pSelect == 0))) {
      sqlite3ErrorMsg(pParse, "use DROP TABLE to delete table %s", pTab->zName);
      goto exit_drop_table;
    }  
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if (((! isView) && pTab->pSelect)) {
      sqlite3ErrorMsg(pParse, "use DROP VIEW to delete view %s", pTab->zName);
      goto exit_drop_table;
    }  
  }  
  (v = sqlite3GetVdbe(pParse));
  if (v) {
    sqlite3BeginWriteOperation(pParse, 1, iDb);
    sqlite3ClearStatTables(pParse, iDb, "tbl", pTab->zName);
    if ((((! id2i_sqlite_omit_foreign_key) ) )) {
      sqlite3FkDropTable(pParse, pName, pTab);
    }  
    sqlite3CodeDropTable(pParse, pTab, iDb, isView);
  }  
  exit_drop_table:
  sqlite3SrcListDelete(db, pName);
}
static  void sqlite3CreateForeignKey(Parse *pParse , ExprList *pFromCol , Token *pTo , ExprList *pToCol , int flags )  {
  sqlite3 *db =  pParse->db;
  FKey *_1278_pFKey =  0;
  FKey *_1278_pNextTo;
  Table *_1278_p =  pParse->pNewTable;
  int _1278_nByte;
  int _1278_i;
  int _1278_nCol;
  char *_1278_z;
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    ((void ) 0);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if (((_1278_p == 0) || pParse->declareVtab)) {
      goto _1278_fk_end;
    }  
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if ((pFromCol == 0)) {
      int iCol =  (_1278_p->nCol - 1);
      if (((id2i_sqlite_coverage_test ) )) {
        if (0) {
          goto _1278_fk_end;
        }  
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if ((iCol < 0)) {
          goto _1278_fk_end;
        }  
      }  
      if ((pToCol && (pToCol->nExpr != 1))) {
        sqlite3ErrorMsg(pParse, "foreign key on %s" " should reference only one column of table %T", _1278_p->aCol[iCol].zName, pTo);
        goto _1278_fk_end;
      }  
      (_1278_nCol = 1);
    } 
    else if ((pToCol && (pToCol->nExpr != pFromCol->nExpr))) {
      sqlite3ErrorMsg(pParse, "number of columns in foreign key does not match the number of " "columns in the referenced table");
      goto _1278_fk_end;
    } 
    else {
      (_1278_nCol = pFromCol->nExpr);
    }
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_nByte = (sizeof((*_1278_pFKey)) + ((_1278_nCol - 1) * sizeof(_1278_pFKey->aCol[0])) + pTo->n + 1));
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if (pToCol) {
      for ((_1278_i = 0); (_1278_i < pToCol->nExpr); _1278_i++) {
        (_1278_nByte += (sqlite3Strlen30(pToCol->a[_1278_i].zName) + 1));
      }
    }  
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_pFKey = sqlite3DbMallocZero(db, _1278_nByte));
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if ((_1278_pFKey == 0)) {
      goto _1278_fk_end;
    }  
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_pFKey->pFrom = _1278_p);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_pFKey->pNextFrom = _1278_p->pFKey);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_z = ((char *) (&_1278_pFKey->aCol[_1278_nCol])));
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_pFKey->zTo = _1278_z);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    memcpy(_1278_z, pTo->z, pTo->n);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_z[pTo->n] = 0);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    sqlite3Dequote(_1278_z);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_z += (pTo->n + 1));
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_pFKey->nCol = _1278_nCol);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if ((pFromCol == 0)) {
      (_1278_pFKey->aCol[0].iFrom = (_1278_p->nCol - 1));
    }  
    else {
      for ((_1278_i = 0); (_1278_i < _1278_nCol); _1278_i++) {
        int j;
        for ((j = 0); (j < _1278_p->nCol); j++) {
          if ((sqlite3_stricmp(_1278_p->aCol[j].zName, pFromCol->a[_1278_i].zName) == 0)) {
            (_1278_pFKey->aCol[_1278_i].iFrom = j);
            break;
          }  
        }
        if ((j >= _1278_p->nCol)) {
          sqlite3ErrorMsg(pParse, "unknown column \"%s\" in foreign key definition", pFromCol->a[_1278_i].zName);
          goto _1278_fk_end;
        }  
      }
    }
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if (pToCol) {
      for ((_1278_i = 0); (_1278_i < _1278_nCol); _1278_i++) {
        int n =  sqlite3Strlen30(pToCol->a[_1278_i].zName);
        (_1278_pFKey->aCol[_1278_i].zCol = _1278_z);
        memcpy(_1278_z, pToCol->a[_1278_i].zName, n);
        (_1278_z[n] = 0);
        (_1278_z += (n + 1));
      }
    }  
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_pFKey->isDeferred = 0);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_pFKey->aAction[0] = ((u8 ) (flags & 0xff)));
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_pFKey->aAction[1] = ((u8 ) ((flags >> 8) & 0xff)));
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    ((void ) 0);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_pNextTo = ((FKey *) sqlite3HashInsert((&_1278_p->pSchema->fkeyHash), _1278_pFKey->zTo, sqlite3Strlen30(_1278_pFKey->zTo), ((void *) _1278_pFKey))));
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if ((_1278_pNextTo == _1278_pFKey)) {
      (db->mallocFailed = 1);
      goto _1278_fk_end;
    }  
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if (_1278_pNextTo) {
      ((void ) 0);
      (_1278_pFKey->pNextTo = _1278_pNextTo);
      (_1278_pNextTo->pPrevTo = _1278_pFKey);
    }  
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_p->pFKey = _1278_pFKey);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_pFKey = 0);
  }  
  _1278_fk_end:
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    sqlite3DbFree(db, _1278_pFKey);
  }  
  sqlite3ExprListDelete(db, pFromCol);
  sqlite3ExprListDelete(db, pToCol);
}
static  void sqlite3DeferForeignKey(Parse *pParse , int isDeferred )  {
  Table *_1278_pTab;
  FKey *_1278_pFKey;
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if ((((_1278_pTab = pParse->pNewTable) == 0) || ((_1278_pFKey = _1278_pTab->pFKey) == 0))) {
      return;
    }  
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    ((void ) 0);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (_1278_pFKey->isDeferred = ((u8 ) isDeferred));
  }  
}
static  void sqlite3RefillIndex(Parse *pParse , Index *pIndex , int memRootPage )  {
  Table *pTab =  pIndex->pTable;
  int iTab =  pParse->nTab++;
  int iIdx =  pParse->nTab++;
  int iSorter;
  int addr1;
  int addr2;
  int tnum;
  int iPartIdxLabel;
  Vdbe *v;
  KeyInfo *pKey;
  int regRecord;
  sqlite3 *db =  pParse->db;
  int iDb =  sqlite3SchemaToIndex(db, pIndex->pSchema);
  if (sqlite3AuthCheck(pParse, 27, pIndex->zName, 0, db->aDb[iDb].zName)) {
    return;
  }  
  sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);
  (v = sqlite3GetVdbe(pParse));
  if ((v == 0)) {
    return;
  }  
  if ((memRootPage >= 0)) {
    (tnum = memRootPage);
  }  
  else {
    (tnum = pIndex->tnum);
    sqlite3VdbeAddOp2(v, 109, tnum, iDb);
  }
  (pKey = sqlite3IndexKeyinfo(pParse, pIndex));
  sqlite3VdbeAddOp4(v, 49, iIdx, tnum, iDb, ((char *) pKey), (- 16));
  sqlite3VdbeChangeP5(v, (0x01 | ((memRootPage >= 0) ? 0x02 : 0)));
  (iSorter = pParse->nTab++);
  sqlite3VdbeAddOp4(v, 52, iSorter, 0, 0, ((char *) pKey), (- 6));
  sqlite3OpenTable(pParse, iTab, iDb, pTab, 48);
  (addr1 = sqlite3VdbeAddOp2(v, 101, iTab, 0));
  (regRecord = sqlite3GetTempReg(pParse));
  sqlite3GenerateIndexKey(pParse, pIndex, iTab, regRecord, 1, (&iPartIdxLabel));
  sqlite3VdbeAddOp2(v, 102, iSorter, regRecord);
  sqlite3VdbeResolveLabel(v, iPartIdxLabel);
  sqlite3VdbeAddOp2(v, 7, iTab, (addr1 + 1));
  sqlite3VdbeJumpHere(v, addr1);
  (addr1 = sqlite3VdbeAddOp2(v, 99, iSorter, 0));
  if ((pIndex->onError != 0)) {
    int j2 =  (sqlite3VdbeCurrentAddr(v) + 3);
    sqlite3VdbeAddOp2(v, 14, 0, j2);
    (addr2 = sqlite3VdbeCurrentAddr(v));
    sqlite3VdbeAddOp3(v, 72, iSorter, j2, regRecord);
    sqlite3HaltConstraint(pParse, (19 | (8 << 8)), 2, "indexed columns are not unique", (- 2));
  }  
  else {
    (addr2 = sqlite3VdbeCurrentAddr(v));
  }
  sqlite3VdbeAddOp2(v, 81, iSorter, regRecord);
  sqlite3VdbeAddOp3(v, 103, iIdx, regRecord, 1);
  sqlite3VdbeChangeP5(v, 0x10);
  sqlite3ReleaseTempReg(pParse, regRecord);
  sqlite3VdbeAddOp2(v, 5, iSorter, addr2);
  sqlite3VdbeJumpHere(v, addr1);
  sqlite3VdbeAddOp1(v, 54, iTab);
  sqlite3VdbeAddOp1(v, 54, iIdx);
  sqlite3VdbeAddOp1(v, 54, iSorter);
}
static  Index *sqlite3CreateIndex(Parse *pParse , Token *pName1 , Token *pName2 , SrcList *pTblName , ExprList *pList , int onError , Token *pStart , Expr *pPIWhere , int sortOrder , int ifNotExist )  {
  Index *pRet =  0;
  Table *pTab =  0;
  Index *pIndex =  0;
  char *zName =  0;
  int nName;
  int i, j;
  Token nullId;
  DbFixer sFix;
  int sortOrderMask;
  sqlite3 *db =  pParse->db;
  Db *pDb;
  int iDb;
  Token *pName =  0;
  struct  ExprList_item   *pListItem;
  const Column *pTabCol;
  int nCol;
  int nExtra =  0;
  char *zExtra;
  ((void ) 0);
  if ((db->mallocFailed || pParse->declareVtab)) {
    goto exit_create_index;
  }  
  if ((0 != sqlite3ReadSchema(pParse))) {
    goto exit_create_index;
  }  
  if ((pTblName != 0)) {
    ((void ) 0);
    (iDb = sqlite3TwoPartName(pParse, pName1, pName2, (&pName)));
    if ((iDb < 0)) {
      goto exit_create_index;
    }  
    ((void ) 0);
    if ((! db->init.busy)) {
      (pTab = sqlite3SrcListLookup(pParse, pTblName));
      if (((pName2->n == 0) && pTab && (pTab->pSchema == db->aDb[1].pSchema))) {
        (iDb = 1);
      }  
    }  
    sqlite3FixInit((&sFix), pParse, iDb, "index", pName);
    if (sqlite3FixSrcList((&sFix), pTblName)) {
      ((void ) 0);
    }  
    (pTab = sqlite3LocateTableItem(pParse, 0, (&pTblName->a[0])));
    ((void ) 0);
    if ((pTab == 0)) {
      goto exit_create_index;
    }  
    if (((iDb == 1) && (db->aDb[iDb].pSchema != pTab->pSchema))) {
      sqlite3ErrorMsg(pParse, "cannot create a TEMP index on non-TEMP table \"%s\"", pTab->zName);
      goto exit_create_index;
    }  
  }  
  else {
    ((void ) 0);
    ((void ) 0);
    (pTab = pParse->pNewTable);
    if ((! pTab)) {
      goto exit_create_index;
    }  
    (iDb = sqlite3SchemaToIndex(db, pTab->pSchema));
  }
  (pDb = (&db->aDb[iDb]));
  ((void ) 0);
  ((void ) 0);
  if (((sqlite3_strnicmp(pTab->zName, "sqlite_", 7) == 0) && (sqlite3_strnicmp((&pTab->zName[7]), "altertab_", 9) != 0))) {
    sqlite3ErrorMsg(pParse, "table %s may not be indexed", pTab->zName);
    goto exit_create_index;
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if (pTab->pSelect) {
      sqlite3ErrorMsg(pParse, "views may not be indexed");
      goto exit_create_index;
    }  
  }  
  if (((pTab->tabFlags & 0x10) != 0)) {
    sqlite3ErrorMsg(pParse, "virtual tables may not be indexed");
    goto exit_create_index;
  }  
  if (pName) {
    (zName = sqlite3NameFromToken(db, pName));
    if ((zName == 0)) {
      goto exit_create_index;
    }  
    ((void ) 0);
    if ((0 != sqlite3CheckObjectName(pParse, zName))) {
      goto exit_create_index;
    }  
    if ((! db->init.busy)) {
      if ((sqlite3FindTable(db, zName, 0) != 0)) {
        sqlite3ErrorMsg(pParse, "there is already a table named %s", zName);
        goto exit_create_index;
      }  
    }  
    if ((sqlite3FindIndex(db, zName, pDb->zName) != 0)) {
      if ((! ifNotExist)) {
        sqlite3ErrorMsg(pParse, "index %s already exists", zName);
      }  
      else {
        ((void ) 0);
        sqlite3CodeVerifySchema(pParse, iDb);
      }
      goto exit_create_index;
    }  
  }  
  else {
    int n;
    Index *pLoop;
    for ((pLoop = pTab->pIndex), (n = 1); pLoop; (pLoop = pLoop->pNext), n++) {
      
    }
    (zName = sqlite3MPrintf(db, "sqlite_autoindex_%s_%d", pTab->zName, n));
    if ((zName == 0)) {
      goto exit_create_index;
    }  
  }
  {
    const char *zDb =  pDb->zName;
    if (sqlite3AuthCheck(pParse, 18, (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"), 0, zDb)) {
      goto exit_create_index;
    }  
    (i = 1);
    if (((! 0) && (iDb == 1))) {
      (i = 3);
    }  
    if (sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb)) {
      goto exit_create_index;
    }  
  }
  if ((pList == 0)) {
    (nullId.z = pTab->aCol[(pTab->nCol - 1)].zName);
    (nullId.n = sqlite3Strlen30(((char *) nullId.z)));
    (pList = sqlite3ExprListAppend(pParse, 0, 0));
    if ((pList == 0)) {
      goto exit_create_index;
    }  
    sqlite3ExprListSetName(pParse, pList, (&nullId), 0);
    (pList->a[0].sortOrder = ((u8 ) sortOrder));
  }  
  for ((i = 0); (i < pList->nExpr); i++) {
    Expr *pExpr =  pList->a[i].pExpr;
    if (pExpr) {
      ((void ) 0);
      (nExtra += (1 + sqlite3Strlen30(pExpr->u.zToken)));
    }  
  }
  (nName = sqlite3Strlen30(zName));
  (nCol = pList->nExpr);
  (pIndex = sqlite3DbMallocZero(db, (((sizeof(Index ) + 7) & (~ 7)) + (((sizeof(tRowcnt ) * (nCol + 1)) + 7) & (~ 7)) + (sizeof(char *) * nCol) + (sizeof(int ) * nCol) + (sizeof(u8 ) * nCol) + nName + 1 + nExtra)));
  if (db->mallocFailed) {
    goto exit_create_index;
  }  
  (zExtra = ((char *) pIndex));
  (pIndex->aiRowEst = ((tRowcnt *) (&zExtra[((sizeof(Index ) + 7) & (~ 7))])));
  (pIndex->azColl = ((char **) (((char *) pIndex->aiRowEst) + ((((sizeof(tRowcnt ) * nCol) + 1) + 7) & (~ 7)))));
  ((void ) 0);
  ((void ) 0);
  (pIndex->aiColumn = ((int *) (&pIndex->azColl[nCol])));
  (pIndex->aSortOrder = ((u8 *) (&pIndex->aiColumn[nCol])));
  (pIndex->zName = ((char *) (&pIndex->aSortOrder[nCol])));
  (zExtra = ((char *) (&pIndex->zName[(nName + 1)])));
  memcpy(pIndex->zName, zName, (nName + 1));
  (pIndex->pTable = pTab);
  (pIndex->nColumn = pList->nExpr);
  (pIndex->onError = ((u8 ) onError));
  (pIndex->uniqNotNull = (onError == 2));
  (pIndex->autoIndex = ((u8 ) (pName == 0)));
  (pIndex->pSchema = db->aDb[iDb].pSchema);
  if (pPIWhere) {
    sqlite3ResolveSelfReference(pParse, pTab, 0x10, pPIWhere, 0);
    (pIndex->pPartIdxWhere = pPIWhere);
    (pPIWhere = 0);
  }  
  ((void ) 0);
  if ((pDb->pSchema->file_format >= 4)) {
    (sortOrderMask = (- 1));
  }  
  else {
    (sortOrderMask = 0);
  }
  for ((i = 0), (pListItem = pList->a); (i < pList->nExpr); i++, pListItem++) {
    const char *zColName =  pListItem->zName;
    int requestedSortOrder;
    char *zColl;
    for ((j = 0), (pTabCol = pTab->aCol); (j < pTab->nCol); j++, pTabCol++) {
      if ((sqlite3_stricmp(zColName, pTabCol->zName) == 0)) {
        break;
      }  
    }
    if ((j >= pTab->nCol)) {
      sqlite3ErrorMsg(pParse, "table %s has no column named %s", pTab->zName, zColName);
      (pParse->checkSchema = 1);
      goto exit_create_index;
    }  
    (pIndex->aiColumn[i] = j);
    if (pListItem->pExpr) {
      int nColl;
      ((void ) 0);
      (zColl = pListItem->pExpr->u.zToken);
      (nColl = (sqlite3Strlen30(zColl) + 1));
      ((void ) 0);
      memcpy(zExtra, zColl, nColl);
      (zColl = zExtra);
      (zExtra += nColl);
      (nExtra -= nColl);
    }  
    else {
      (zColl = pTab->aCol[j].zColl);
      if ((! zColl)) {
        (zColl = "BINARY");
      }  
    }
    if (((! db->init.busy) && (! sqlite3LocateCollSeq(pParse, zColl)))) {
      goto exit_create_index;
    }  
    (pIndex->azColl[i] = zColl);
    (requestedSortOrder = (pListItem->sortOrder & sortOrderMask));
    (pIndex->aSortOrder[i] = ((u8 ) requestedSortOrder));
    if ((pTab->aCol[j].notNull == 0)) {
      (pIndex->uniqNotNull = 0);
    }  
  }
  sqlite3DefaultRowEst(pIndex);
  if ((pParse->pNewTable == 0)) {
    estimateIndexWidth(pIndex);
  }  
  if ((pTab == pParse->pNewTable)) {
    Index *pIdx;
    for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
      int k;
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      if ((pIdx->nColumn != pIndex->nColumn)) {
        continue;
      }  
      for ((k = 0); (k < pIdx->nColumn); k++) {
        const char *z1;
        const char *z2;
        if ((pIdx->aiColumn[k] != pIndex->aiColumn[k])) {
          break;
        }  
        (z1 = pIdx->azColl[k]);
        (z2 = pIndex->azColl[k]);
        if (((z1 != z2) && sqlite3_stricmp(z1, z2))) {
          break;
        }  
      }
      if ((k == pIdx->nColumn)) {
        if ((pIdx->onError != pIndex->onError)) {
          if ((! ((pIdx->onError == 10) || (pIndex->onError == 10)))) {
            sqlite3ErrorMsg(pParse, "conflicting ON CONFLICT clauses specified", 0);
          }  
          if ((pIdx->onError == 10)) {
            (pIdx->onError = pIndex->onError);
          }  
        }  
        goto exit_create_index;
      }  
    }
  }  
  if (db->init.busy) {
    Index *p;
    ((void ) 0);
    (p = sqlite3HashInsert((&pIndex->pSchema->idxHash), pIndex->zName, sqlite3Strlen30(pIndex->zName), pIndex));
    if (p) {
      ((void ) 0);
      (db->mallocFailed = 1);
      goto exit_create_index;
    }  
    (db->flags |= 0x00000002);
    if ((pTblName != 0)) {
      (pIndex->tnum = db->init.newTnum);
    }  
  } 
  else if ((pParse->nErr == 0)) {
    Vdbe *v;
    char *zStmt;
    int iMem =  ++pParse->nMem;
    (v = sqlite3GetVdbe(pParse));
    if ((v == 0)) {
      goto exit_create_index;
    }  
    sqlite3BeginWriteOperation(pParse, 1, iDb);
    sqlite3VdbeAddOp2(v, 110, iDb, iMem);
    if (pStart) {
      int n =  (((int ) (pParse->sLastToken.z - pName->z)) + pParse->sLastToken.n);
      if ((pName->z[(n - 1)] == ';')) {
        n--;
      }  
      (zStmt = sqlite3MPrintf(db, "CREATE%s INDEX %.*s", ((onError == 0) ? "" : " UNIQUE"), n, pName->z));
    }  
    else {
      (zStmt = 0);
    }
    sqlite3NestedParse(pParse, "INSERT INTO %Q.%s VALUES('index',%Q,%Q,#%d,%Q);", db->aDb[iDb].zName, (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"), pIndex->zName, pTab->zName, iMem, zStmt);
    sqlite3DbFree(db, zStmt);
    if (pTblName) {
      sqlite3RefillIndex(pParse, pIndex, iMem);
      sqlite3ChangeCookie(pParse, iDb);
      sqlite3VdbeAddParseSchemaOp(v, iDb, sqlite3MPrintf(db, "name='%q' AND type='index'", pIndex->zName));
      sqlite3VdbeAddOp1(v, 132, 0);
    }  
  } 
  if ((db->init.busy || (pTblName == 0))) {
    if (((onError != 5) || (pTab->pIndex == 0) || (pTab->pIndex->onError == 5))) {
      (pIndex->pNext = pTab->pIndex);
      (pTab->pIndex = pIndex);
    }  
    else {
      Index *pOther =  pTab->pIndex;
      while ((pOther->pNext && (pOther->pNext->onError != 5))) {
        (pOther = pOther->pNext);
      }
      (pIndex->pNext = pOther->pNext);
      (pOther->pNext = pIndex);
    }
    (pRet = pIndex);
    (pIndex = 0);
  }  
  exit_create_index:
  if (pIndex) {
    freeIndex(db, pIndex);
  }  
  sqlite3ExprDelete(db, pPIWhere);
  sqlite3ExprListDelete(db, pList);
  sqlite3SrcListDelete(db, pTblName);
  sqlite3DbFree(db, zName);
  return pRet;
}
static  void sqlite3DefaultRowEst(Index *pIdx )  {
  tRowcnt *a =  pIdx->aiRowEst;
  int i;
  tRowcnt n;
  ((void ) 0);
  (a[0] = pIdx->pTable->nRowEst);
  if ((a[0] < 10)) {
    (a[0] = 10);
  }  
  (n = 10);
  for ((i = 1); (i <= pIdx->nColumn); i++) {
    (a[i] = n);
    if ((n > 5)) {
      n--;
    }  
  }
  if ((pIdx->onError != 0)) {
    (a[pIdx->nColumn] = 1);
  }  
}
static  void sqlite3DropIndex(Parse *pParse , SrcList *pName , int ifExists )  {
  Index *pIndex;
  Vdbe *v;
  sqlite3 *db =  pParse->db;
  int iDb;
  ((void ) 0);
  if (db->mallocFailed) {
    goto exit_drop_index;
  }  
  ((void ) 0);
  if ((0 != sqlite3ReadSchema(pParse))) {
    goto exit_drop_index;
  }  
  (pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase));
  if ((pIndex == 0)) {
    if ((! ifExists)) {
      sqlite3ErrorMsg(pParse, "no such index: %S", pName, 0);
    }  
    else {
      sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);
    }
    (pParse->checkSchema = 1);
    goto exit_drop_index;
  }  
  if (pIndex->autoIndex) {
    sqlite3ErrorMsg(pParse, "index associated with UNIQUE " "or PRIMARY KEY constraint cannot be dropped", 0);
    goto exit_drop_index;
  }  
  (iDb = sqlite3SchemaToIndex(db, pIndex->pSchema));
  {
    int code =  10;
    Table *pTab =  pIndex->pTable;
    const char *zDb =  db->aDb[iDb].zName;
    const char *zTab =  (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master");
    if (sqlite3AuthCheck(pParse, 9, zTab, 0, zDb)) {
      goto exit_drop_index;
    }  
    if (((! 0) && iDb)) {
      (code = 12);
    }  
    if (sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb)) {
      goto exit_drop_index;
    }  
  }
  (v = sqlite3GetVdbe(pParse));
  if (v) {
    sqlite3BeginWriteOperation(pParse, 1, iDb);
    sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE name=%Q AND type='index'", db->aDb[iDb].zName, (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"), pIndex->zName);
    sqlite3ClearStatTables(pParse, iDb, "idx", pIndex->zName);
    sqlite3ChangeCookie(pParse, iDb);
    destroyRootPage(pParse, pIndex->tnum, iDb);
    sqlite3VdbeAddOp4(v, 115, iDb, 0, 0, pIndex->zName, 0);
  }  
  exit_drop_index:
  sqlite3SrcListDelete(db, pName);
}
static  void *sqlite3ArrayAllocate(sqlite3 *db , void *pArray , int szEntry , int *pnEntry , int *pIdx )  {
  char *z;
  int n =  (*pnEntry);
  if (((n & (n - 1)) == 0)) {
    int sz =  ((n == 0) ? 1 : (2 * n));
    void *pNew =  sqlite3DbRealloc(db, pArray, (sz * szEntry));
    if ((pNew == 0)) {
      ((*pIdx) = (- 1));
      return pArray;
    }  
    (pArray = pNew);
  }  
  (z = ((char *) pArray));
  memset((&z[(n * szEntry)]), 0, szEntry);
  ((*pIdx) = n);
  ++(*pnEntry);
  return pArray;
}
static  IdList *sqlite3IdListAppend(sqlite3 *db , IdList *pList , Token *pToken )  {
  int i;
  if ((pList == 0)) {
    (pList = sqlite3DbMallocZero(db, sizeof(IdList )));
    if ((pList == 0)) {
      return 0;
    }  
  }  
  (pList->a = sqlite3ArrayAllocate(db, pList->a, sizeof(pList->a[0]), (&pList->nId), (&i)));
  if ((i < 0)) {
    sqlite3IdListDelete(db, pList);
    return 0;
  }  
  (pList->a[i].zName = sqlite3NameFromToken(db, pToken));
  return pList;
}
static  void sqlite3IdListDelete(sqlite3 *db , IdList *pList )  {
  int i;
  if ((pList == 0)) {
    return;
  }  
  for ((i = 0); (i < pList->nId); i++) {
    sqlite3DbFree(db, pList->a[i].zName);
  }
  sqlite3DbFree(db, pList->a);
  sqlite3DbFree(db, pList);
}
static  int sqlite3IdListIndex(IdList *pList , const  char *zName )  {
  int i;
  if ((pList == 0)) {
    return (- 1);
  }  
  for ((i = 0); (i < pList->nId); i++) {
    if ((sqlite3_stricmp(pList->a[i].zName, zName) == 0)) {
      return i;
    }  
  }
  return (- 1);
}
static  SrcList *sqlite3SrcListEnlarge(sqlite3 *db , SrcList *pSrc , int nExtra , int iStart )  {
  int i;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((pSrc->nSrc + nExtra) > pSrc->nAlloc)) {
    SrcList *pNew;
    int nAlloc =  (pSrc->nSrc + nExtra);
    int nGot;
    (pNew = sqlite3DbRealloc(db, pSrc, (sizeof((*pSrc)) + ((nAlloc - 1) * sizeof(pSrc->a[0])))));
    if ((pNew == 0)) {
      ((void ) 0);
      return pSrc;
    }  
    (pSrc = pNew);
    (nGot = (((sqlite3DbMallocSize(db, pNew) - sizeof((*pSrc))) / sizeof(pSrc->a[0])) + 1));
    (pSrc->nAlloc = ((u8 ) nGot));
  }  
  for ((i = (pSrc->nSrc - 1)); (i >= iStart); i--) {
    (pSrc->a[(i + nExtra)] = pSrc->a[i]);
  }
  (pSrc->nSrc += ((i8 ) nExtra));
  memset((&pSrc->a[iStart]), 0, (sizeof(pSrc->a[0]) * nExtra));
  for ((i = iStart); (i < (iStart + nExtra)); i++) {
    (pSrc->a[i].iCursor = (- 1));
  }
  return pSrc;
}
static  SrcList *sqlite3SrcListAppend(sqlite3 *db , SrcList *pList , Token *pTable , Token *pDatabase )  {
  struct  SrcList_item   *pItem;
  ((void ) 0);
  if ((pList == 0)) {
    (pList = sqlite3DbMallocZero(db, sizeof(SrcList )));
    if ((pList == 0)) {
      return 0;
    }  
    (pList->nAlloc = 1);
  }  
  (pList = sqlite3SrcListEnlarge(db, pList, 1, pList->nSrc));
  if (db->mallocFailed) {
    sqlite3SrcListDelete(db, pList);
    return 0;
  }  
  (pItem = (&pList->a[(pList->nSrc - 1)]));
  if ((pDatabase && (pDatabase->z == 0))) {
    (pDatabase = 0);
  }  
  if (pDatabase) {
    Token *pTemp =  pDatabase;
    (pDatabase = pTable);
    (pTable = pTemp);
  }  
  (pItem->zName = sqlite3NameFromToken(db, pTable));
  (pItem->zDatabase = sqlite3NameFromToken(db, pDatabase));
  return pList;
}
static  void sqlite3SrcListAssignCursors(Parse *pParse , SrcList *pList )  {
  int i;
  struct  SrcList_item   *pItem;
  ((void ) 0);
  if (pList) {
    for ((i = 0), (pItem = pList->a); (i < pList->nSrc); i++, pItem++) {
      if ((pItem->iCursor >= 0)) {
        break;
      }  
      (pItem->iCursor = pParse->nTab++);
      if (pItem->pSelect) {
        sqlite3SrcListAssignCursors(pParse, pItem->pSelect->pSrc);
      }  
    }
  }  
}
static  void sqlite3SrcListDelete(sqlite3 *db , SrcList *pList )  {
  int i;
  struct  SrcList_item   *pItem;
  if ((pList == 0)) {
    return;
  }  
  for ((pItem = pList->a), (i = 0); (i < pList->nSrc); i++, pItem++) {
    sqlite3DbFree(db, pItem->zDatabase);
    sqlite3DbFree(db, pItem->zName);
    sqlite3DbFree(db, pItem->zAlias);
    sqlite3DbFree(db, pItem->zIndex);
    sqlite3DeleteTable(db, pItem->pTab);
    sqlite3SelectDelete(db, pItem->pSelect);
    sqlite3ExprDelete(db, pItem->pOn);
    sqlite3IdListDelete(db, pItem->pUsing);
  }
  sqlite3DbFree(db, pList);
}
static  SrcList *sqlite3SrcListAppendFromTerm(Parse *pParse , SrcList *p , Token *pTable , Token *pDatabase , Token *pAlias , Select *pSubquery , Expr *pOn , IdList *pUsing )  {
  struct  SrcList_item   *pItem;
  sqlite3 *db =  pParse->db;
  if (((! p) && (pOn || pUsing))) {
    sqlite3ErrorMsg(pParse, "a JOIN clause is required before %s", (pOn ? "ON" : "USING"));
    goto append_from_error;
  }  
  (p = sqlite3SrcListAppend(db, p, pTable, pDatabase));
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((p == 0) || (p->nSrc == 0))) {
      goto append_from_error;
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((p == 0) || 0)) {
      goto append_from_error;
    }  
  }  
  (pItem = (&p->a[(p->nSrc - 1)]));
  ((void ) 0);
  if (pAlias->n) {
    (pItem->zAlias = sqlite3NameFromToken(db, pAlias));
  }  
  (pItem->pSelect = pSubquery);
  (pItem->pOn = pOn);
  (pItem->pUsing = pUsing);
  return p;
  append_from_error:
  ((void ) 0);
  sqlite3ExprDelete(db, pOn);
  sqlite3IdListDelete(db, pUsing);
  sqlite3SelectDelete(db, pSubquery);
  return 0;
}
static  void sqlite3SrcListIndexedBy(Parse *pParse , SrcList *p , Token *pIndexedBy )  {
  ((void ) 0);
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((p && (p->nSrc > 0))) {
      struct  SrcList_item   *pItem =  (&p->a[(p->nSrc - 1)]);
      ((void ) 0);
      if (((pIndexedBy->n == 1) && (! pIndexedBy->z))) {
        (pItem->notIndexed = 1);
      }  
      else {
        (pItem->zIndex = sqlite3NameFromToken(pParse->db, pIndexedBy));
      }
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((p && 1)) {
      struct  SrcList_item   *pItem =  (&p->a[(p->nSrc - 1)]);
      ((void ) 0);
      if (((pIndexedBy->n == 1) && (! pIndexedBy->z))) {
        (pItem->notIndexed = 1);
      }  
      else {
        (pItem->zIndex = sqlite3NameFromToken(pParse->db, pIndexedBy));
      }
    }  
  }  
}
static  void sqlite3SrcListShiftJoinType(SrcList *p )  {
  if (p) {
    int i;
    ((void ) 0);
    for ((i = (p->nSrc - 1)); (i > 0); i--) {
      (p->a[i].jointype = p->a[(i - 1)].jointype);
    }
    (p->a[0].jointype = 0);
  }  
}
static  void sqlite3BeginTransaction(Parse *pParse , int type )  {
  sqlite3 *db;
  Vdbe *v;
  int i;
  ((void ) 0);
  (db = pParse->db);
  ((void ) 0);
  if (sqlite3AuthCheck(pParse, 22, "BEGIN", 0, 0)) {
    return;
  }  
  (v = sqlite3GetVdbe(pParse));
  if ((! v)) {
    return;
  }  
  if ((type != 7)) {
    for ((i = 0); (i < db->nDb); i++) {
      sqlite3VdbeAddOp2(v, 4, i, ((type == 9) + 1));
      sqlite3VdbeUsesBtree(v, i);
    }
  }  
  sqlite3VdbeAddOp2(v, 3, 0, 0);
}
static  void sqlite3CommitTransaction(Parse *pParse )  {
  Vdbe *v;
  ((void ) 0);
  ((void ) 0);
  if (sqlite3AuthCheck(pParse, 22, "COMMIT", 0, 0)) {
    return;
  }  
  (v = sqlite3GetVdbe(pParse));
  if (v) {
    sqlite3VdbeAddOp2(v, 3, 1, 0);
  }  
}
static  void sqlite3RollbackTransaction(Parse *pParse )  {
  Vdbe *v;
  ((void ) 0);
  ((void ) 0);
  if (sqlite3AuthCheck(pParse, 22, "ROLLBACK", 0, 0)) {
    return;
  }  
  (v = sqlite3GetVdbe(pParse));
  if (v) {
    sqlite3VdbeAddOp2(v, 3, 1, 1);
  }  
}
static  void sqlite3Savepoint(Parse *pParse , int op , Token *pName )  {
  char *zName =  sqlite3NameFromToken(pParse->db, pName);
  if (zName) {
    Vdbe *v =  sqlite3GetVdbe(pParse);
    static const char *const az[] =  { "BEGIN",  "RELEASE",  "ROLLBACK"};
    ((void ) 0);
    if (((! v) || sqlite3AuthCheck(pParse, 32, az[op], zName, 0))) {
      sqlite3DbFree(pParse->db, zName);
      return;
    }  
    sqlite3VdbeAddOp4(v, 2, op, 0, 0, zName, (- 1));
  }  
}
static  int sqlite3OpenTempDatabase(Parse *pParse )  {
  sqlite3 *db =  pParse->db;
  if (((db->aDb[1].pBt == 0) && (! pParse->explain))) {
    int rc;
    Btree *pBt;
    static const int flags =  (0x00000002 | 0x00000004 | 0x00000010 | 0x00000008 | 0x00000200);
    (rc = sqlite3BtreeOpen(db->pVfs, 0, db, (&pBt), 0, flags));
    if ((rc != 0)) {
      sqlite3ErrorMsg(pParse, "unable to open a temporary database " "file for storing temporary tables");
      (pParse->rc = rc);
      return 1;
    }  
    (db->aDb[1].pBt = pBt);
    ((void ) 0);
    if ((7 == sqlite3BtreeSetPageSize(pBt, db->nextPagesize, (- 1), 0))) {
      (db->mallocFailed = 1);
      return 1;
    }  
  }  
  return 0;
}
static  void sqlite3CodeVerifySchema(Parse *pParse , int iDb )  {
  Parse *pToplevel =  (pParse->pToplevel ? pParse->pToplevel : pParse);
  if ((pToplevel != pParse)) {
    (pParse->cookieGoto = (- 1));
  }  
  if ((pToplevel->cookieGoto == 0)) {
    Vdbe *v =  sqlite3GetVdbe(pToplevel);
    if ((v == 0)) {
      return;
    }  
    (pToplevel->cookieGoto = (sqlite3VdbeAddOp2(v, 14, 0, 0) + 1));
  }  
  if ((iDb >= 0)) {
    sqlite3 *db =  pToplevel->db;
    yDbMask mask;
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    (mask = (((yDbMask ) 1) << iDb));
    if (((pToplevel->cookieMask & mask) == 0)) {
      (pToplevel->cookieMask |= mask);
      (pToplevel->cookieValue[iDb] = db->aDb[iDb].pSchema->schema_cookie);
      if (((! 0) && (iDb == 1))) {
        sqlite3OpenTempDatabase(pToplevel);
      }  
    }  
  }  
}
static  void sqlite3CodeVerifyNamedSchema(Parse *pParse , const  char *zDb )  {
  sqlite3 *db =  pParse->db;
  int i;
  for ((i = 0); (i < db->nDb); i++) {
    Db *pDb =  (&db->aDb[i]);
    if ((pDb->pBt && ((! zDb) || (0 == sqlite3_stricmp(zDb, pDb->zName))))) {
      sqlite3CodeVerifySchema(pParse, i);
    }  
  }
}
static  void sqlite3BeginWriteOperation(Parse *pParse , int setStatement , int iDb )  {
  Parse *pToplevel =  (pParse->pToplevel ? pParse->pToplevel : pParse);
  sqlite3CodeVerifySchema(pParse, iDb);
  (pToplevel->writeMask |= (((yDbMask ) 1) << iDb));
  (pToplevel->isMultiWrite |= setStatement);
}
static  void sqlite3MultiWrite(Parse *pParse )  {
  Parse *pToplevel =  (pParse->pToplevel ? pParse->pToplevel : pParse);
  (pToplevel->isMultiWrite = 1);
}
static  void sqlite3MayAbort(Parse *pParse )  {
  Parse *pToplevel =  (pParse->pToplevel ? pParse->pToplevel : pParse);
  (pToplevel->mayAbort = 1);
}
static  void sqlite3HaltConstraint(Parse *pParse , int errCode , int onError , char *p4 , int p4type )  {
  Vdbe *v =  sqlite3GetVdbe(pParse);
  ((void ) 0);
  if ((onError == 2)) {
    sqlite3MayAbort(pParse);
  }  
  sqlite3VdbeAddOp4(v, 20, errCode, onError, 0, p4, p4type);
}
static  int collationMatch(const  char *zColl , Index *pIndex )  {
  int i;
  ((void ) 0);
  for ((i = 0); (i < pIndex->nColumn); i++) {
    const char *z =  pIndex->azColl[i];
    ((void ) 0);
    if ((0 == sqlite3_stricmp(z, zColl))) {
      return 1;
    }  
  }
  return 0;
}
static  void reindexTable(Parse *pParse , Table *pTab , char  const *zColl )  {
  Index *pIndex;
  for ((pIndex = pTab->pIndex); pIndex; (pIndex = pIndex->pNext)) {
    if (((zColl == 0) || collationMatch(zColl, pIndex))) {
      int iDb =  sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
      sqlite3BeginWriteOperation(pParse, 0, iDb);
      sqlite3RefillIndex(pParse, pIndex, (- 1));
    }  
  }
}
static  void reindexDatabases(Parse *pParse , char  const *zColl )  {
  Db *pDb;
  int iDb;
  sqlite3 *db =  pParse->db;
  HashElem *k;
  Table *pTab;
  ((void ) 0);
  for ((iDb = 0), (pDb = db->aDb); (iDb < db->nDb); iDb++, pDb++) {
    ((void ) 0);
    for ((k = (&pDb->pSchema->tblHash)->first); k; (k = k->next)) {
      (pTab = ((Table *) k->data));
      reindexTable(pParse, pTab, zColl);
    }
  }
}
static  void sqlite3Reindex(Parse *pParse , Token *pName1 , Token *pName2 )  {
  CollSeq *pColl;
  char *z;
  const char *zDb;
  Table *pTab;
  Index *pIndex;
  int iDb;
  sqlite3 *db =  pParse->db;
  Token *pObjName;
  if ((0 != sqlite3ReadSchema(pParse))) {
    return;
  }  
  if ((pName1 == 0)) {
    reindexDatabases(pParse, 0);
    return;
  } 
  else if ((((id2i_sqlite_coverage_test ) ) && (0 || (pName2->z == 0)))) {
    char *zColl;
    ((void ) 0);
    (zColl = sqlite3NameFromToken(pParse->db, pName1));
    if ((! zColl)) {
      return;
    }  
    (pColl = sqlite3FindCollSeq(db, db->aDb[0].pSchema->enc, zColl, 0));
    if (pColl) {
      reindexDatabases(pParse, zColl);
      sqlite3DbFree(db, zColl);
      return;
    }  
    sqlite3DbFree(db, zColl);
  }
  
  else if (((((! id2i_sqlite_coverage_test) ) ) && ((pName2 == 0) || (pName2->z == 0)))) {
    char *zColl;
    ((void ) 0);
    (zColl = sqlite3NameFromToken(pParse->db, pName1));
    if ((! zColl)) {
      return;
    }  
    (pColl = sqlite3FindCollSeq(db, db->aDb[0].pSchema->enc, zColl, 0));
    if (pColl) {
      reindexDatabases(pParse, zColl);
      sqlite3DbFree(db, zColl);
      return;
    }  
    sqlite3DbFree(db, zColl);
  } 
  (iDb = sqlite3TwoPartName(pParse, pName1, pName2, (&pObjName)));
  if ((iDb < 0)) {
    return;
  }  
  (z = sqlite3NameFromToken(db, pObjName));
  if ((z == 0)) {
    return;
  }  
  (zDb = db->aDb[iDb].zName);
  (pTab = sqlite3FindTable(db, z, zDb));
  if (pTab) {
    reindexTable(pParse, pTab, 0);
    sqlite3DbFree(db, z);
    return;
  }  
  (pIndex = sqlite3FindIndex(db, z, zDb));
  sqlite3DbFree(db, z);
  if (pIndex) {
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    sqlite3RefillIndex(pParse, pIndex, (- 1));
    return;
  }  
  sqlite3ErrorMsg(pParse, "unable to identify the object to be reindexed");
}
static  KeyInfo *sqlite3IndexKeyinfo(Parse *pParse , Index *pIdx )  {
  int i;
  int nCol =  pIdx->nColumn;
  KeyInfo *pKey;
  (pKey = sqlite3KeyInfoAlloc(pParse->db, nCol));
  if (pKey) {
    for ((i = 0); (i < nCol); i++) {
      char *zColl =  pIdx->azColl[i];
      ((void ) 0);
      (pKey->aColl[i] = sqlite3LocateCollSeq(pParse, zColl));
      (pKey->aSortOrder[i] = pIdx->aSortOrder[i]);
    }
  }  
  if (pParse->nErr) {
    sqlite3DbFree(pParse->db, pKey);
    (pKey = 0);
  }  
  return pKey;
}
static  void callCollNeeded(sqlite3 *db , int enc , const  char *zName )  {
  ((void ) 0);
  if (db->xCollNeeded) {
    char *zExternal =  sqlite3DbStrDup(db, zName);
    if ((! zExternal)) {
      return;
    }  
    db->xCollNeeded(db->pCollNeededArg, db, enc, zExternal);
    sqlite3DbFree(db, zExternal);
  }  
  if (db->xCollNeeded16) {
    char const *zExternal;
    sqlite3_value *pTmp =  sqlite3ValueNew(db);
    sqlite3ValueSetStr(pTmp, (- 1), zName, 1, ((sqlite3_destructor_type ) 0));
    (zExternal = sqlite3ValueText(pTmp, 2));
    if (zExternal) {
      db->xCollNeeded16(db->pCollNeededArg, db, ((int ) db->aDb[0].pSchema->enc), zExternal);
    }  
    sqlite3ValueFree(pTmp);
  }  
}
static  int synthCollSeq(sqlite3 *db , CollSeq *pColl )  {
  CollSeq *pColl2;
  char *z =  pColl->zName;
  int i;
  static const u8 aEnc[] =  { 3,  2,  1};
  for ((i = 0); (i < 3); i++) {
    (pColl2 = sqlite3FindCollSeq(db, aEnc[i], z, 0));
    if ((pColl2->xCmp != 0)) {
      memcpy(pColl, pColl2, sizeof(CollSeq ));
      (pColl->xDel = 0);
      return 0;
    }  
  }
  return 1;
}
static  CollSeq *sqlite3GetCollSeq(Parse *pParse , u8 enc , CollSeq *pColl , const  char *zName )  {
  CollSeq *p;
  sqlite3 *db =  pParse->db;
  (p = pColl);
  if ((! p)) {
    (p = sqlite3FindCollSeq(db, enc, zName, 0));
  }  
  if (((! p) || (! p->xCmp))) {
    callCollNeeded(db, enc, zName);
    (p = sqlite3FindCollSeq(db, enc, zName, 0));
  }  
  if ((p && (! p->xCmp) && synthCollSeq(db, p))) {
    (p = 0);
  }  
  ((void ) 0);
  if ((p == 0)) {
    sqlite3ErrorMsg(pParse, "no such collation sequence: %s", zName);
  }  
  return p;
}
static  int sqlite3CheckCollSeq(Parse *pParse , CollSeq *pColl )  {
  if (pColl) {
    const char *zName =  pColl->zName;
    sqlite3 *db =  pParse->db;
    CollSeq *p =  sqlite3GetCollSeq(pParse, db->aDb[0].pSchema->enc, pColl, zName);
    if ((! p)) {
      return 1;
    }  
    ((void ) 0);
  }  
  return 0;
}
static  CollSeq *findCollSeqEntry(sqlite3 *db , const  char *zName , int create )  {
  CollSeq *pColl;
  int nName =  sqlite3Strlen30(zName);
  (pColl = sqlite3HashFind((&db->aCollSeq), zName, nName));
  if (((0 == pColl) && create)) {
    (pColl = sqlite3DbMallocZero(db, ((3 * sizeof((*pColl))) + nName + 1)));
    if (pColl) {
      CollSeq *pDel =  0;
      (pColl[0].zName = ((char *) (&pColl[3])));
      (pColl[0].enc = 1);
      (pColl[1].zName = ((char *) (&pColl[3])));
      (pColl[1].enc = 2);
      (pColl[2].zName = ((char *) (&pColl[3])));
      (pColl[2].enc = 3);
      memcpy(pColl[0].zName, zName, nName);
      (pColl[0].zName[nName] = 0);
      (pDel = sqlite3HashInsert((&db->aCollSeq), pColl[0].zName, nName, pColl));
      ((void ) 0);
      if ((pDel != 0)) {
        (db->mallocFailed = 1);
        sqlite3DbFree(db, pDel);
        (pColl = 0);
      }  
    }  
  }  
  return pColl;
}
static  CollSeq *sqlite3FindCollSeq(sqlite3 *db , u8 enc , const  char *zName , int create )  {
  CollSeq *pColl;
  if (zName) {
    (pColl = findCollSeqEntry(db, zName, create));
  }  
  else {
    (pColl = db->pDfltColl);
  }
  ((void ) 0);
  ((void ) 0);
  if (pColl) {
    (pColl += (enc - 1));
  }  
  return pColl;
}
static  int matchQuality(FuncDef *p , int nArg , u8 enc )  {
  int match;
  if ((nArg == (- 2))) {
    return (((p->xFunc == 0) && (p->xStep == 0)) ? 0 : 6);
  }  
  if (((p->nArg != nArg) && (p->nArg >= 0))) {
    return 0;
  }  
  if ((p->nArg == nArg)) {
    (match = 4);
  }  
  else {
    (match = 1);
  }
  if ((enc == (p->funcFlags & 0x003))) {
    (match += 2);
  } 
  else if (((enc & p->funcFlags & 2) != 0)) {
    (match += 1);
  } 
  return match;
}
static  FuncDef *functionSearch(FuncDefHash *pHash , int h , const  char *zFunc , int nFunc )  {
  FuncDef *p;
  for ((p = pHash->a[h]); p; (p = p->pHash)) {
    if (((sqlite3_strnicmp(p->zName, zFunc, nFunc) == 0) && (p->zName[nFunc] == 0))) {
      return p;
    }  
  }
  return 0;
}
static  void sqlite3FuncDefInsert(FuncDefHash *pHash , FuncDef *pDef )  {
  FuncDef *pOther;
  int nName =  sqlite3Strlen30(pDef->zName);
  u8 c1 =  ((u8 ) pDef->zName[0]);
  int h =  (((id2i_sqlite_ebcdic ) ) ? ((_1282_sqlite3UpperToLower[c1] + nName) % ((int ) (sizeof(pHash->a) / sizeof(pHash->a[0])))) : ((_1281_sqlite3UpperToLower[c1] + nName) % ((int ) (sizeof(pHash->a) / sizeof(pHash->a[0])))));
  (pOther = functionSearch(pHash, h, pDef->zName, nName));
  if (pOther) {
    ((void ) 0);
    (pDef->pNext = pOther->pNext);
    (pOther->pNext = pDef);
  }  
  else {
    (pDef->pNext = 0);
    (pDef->pHash = pHash->a[h]);
    (pHash->a[h] = pDef);
  }
}
static  FuncDef *sqlite3FindFunction(sqlite3 *db , const  char *zName , int nName , int nArg , u8 enc , u8 createFlag )  {
  FuncDef *p;
  FuncDef *pBest =  0;
  int bestScore =  0;
  int h;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((((! id2i_sqlite_ebcdic) ) )) {
    (h = ((_1281_sqlite3UpperToLower[((u8 ) zName[0])] + nName) % ((int ) (sizeof(db->aFunc.a) / sizeof(db->aFunc.a[0])))));
  }  
  if (((id2i_sqlite_ebcdic ) )) {
    (h = ((_1282_sqlite3UpperToLower[((u8 ) zName[0])] + nName) % ((int ) (sizeof(db->aFunc.a) / sizeof(db->aFunc.a[0])))));
  }  
  (p = functionSearch((&db->aFunc), h, zName, nName));
  while (p) {
    int score =  matchQuality(p, nArg, enc);
    if ((score > bestScore)) {
      (pBest = p);
      (bestScore = score);
    }  
    (p = p->pNext);
  }
  if (((! createFlag) && ((pBest == 0) || ((db->flags & 0x00200000) != 0)))) {
    FuncDefHash *pHash =  (&sqlite3GlobalFunctions);
    (bestScore = 0);
    (p = functionSearch(pHash, h, zName, nName));
    while (p) {
      int score =  matchQuality(p, nArg, enc);
      if ((score > bestScore)) {
        (pBest = p);
        (bestScore = score);
      }  
      (p = p->pNext);
    }
  }  
  if ((createFlag && (bestScore < 6) && ((pBest = sqlite3DbMallocZero(db, (sizeof((*pBest)) + nName + 1))) != 0))) {
    (pBest->zName = ((char *) (&pBest[1])));
    (pBest->nArg = ((u16 ) nArg));
    (pBest->funcFlags = enc);
    memcpy(pBest->zName, zName, nName);
    (pBest->zName[nName] = 0);
    sqlite3FuncDefInsert((&db->aFunc), pBest);
  }  
  if ((pBest && (pBest->xStep || pBest->xFunc || createFlag))) {
    return pBest;
  }  
  return 0;
}
static  void sqlite3SchemaClear(void *p )  {
  Hash temp1;
  Hash temp2;
  HashElem *pElem;
  Schema *pSchema =  ((Schema *) p);
  (temp1 = pSchema->tblHash);
  (temp2 = pSchema->trigHash);
  sqlite3HashInit((&pSchema->trigHash));
  sqlite3HashClear((&pSchema->idxHash));
  for ((pElem = (&temp2)->first); pElem; (pElem = pElem->next)) {
    sqlite3DeleteTrigger(0, ((Trigger *) pElem->data));
  }
  sqlite3HashClear((&temp2));
  sqlite3HashInit((&pSchema->tblHash));
  for ((pElem = (&temp1)->first); pElem; (pElem = pElem->next)) {
    Table *pTab =  pElem->data;
    sqlite3DeleteTable(0, pTab);
  }
  sqlite3HashClear((&temp1));
  sqlite3HashClear((&pSchema->fkeyHash));
  (pSchema->pSeqTab = 0);
  if ((pSchema->flags & 0x0001)) {
    pSchema->iGeneration++;
    (pSchema->flags &= (~ 0x0001));
  }  
}
static  Schema *sqlite3SchemaGet(sqlite3 *db , Btree *pBt )  {
  Schema *p;
  if (pBt) {
    (p = ((Schema *) sqlite3BtreeSchema(pBt, sizeof(Schema ), sqlite3SchemaClear)));
  }  
  else {
    (p = ((Schema *) sqlite3DbMallocZero(0, sizeof(Schema ))));
  }
  if ((! p)) {
    (db->mallocFailed = 1);
  } 
  else if ((0 == p->file_format)) {
    sqlite3HashInit((&p->tblHash));
    sqlite3HashInit((&p->idxHash));
    sqlite3HashInit((&p->trigHash));
    sqlite3HashInit((&p->fkeyHash));
    (p->enc = 1);
  } 
  return p;
}
static  Table *sqlite3SrcListLookup(Parse *pParse , SrcList *pSrc )  {
  struct  SrcList_item   *pItem =  pSrc->a;
  Table *pTab;
  ((void ) 0);
  (pTab = sqlite3LocateTableItem(pParse, 0, pItem));
  sqlite3DeleteTable(pParse->db, pItem->pTab);
  (pItem->pTab = pTab);
  if (pTab) {
    pTab->nRef++;
  }  
  if (sqlite3IndexedByLookup(pParse, pItem)) {
    (pTab = 0);
  }  
  return pTab;
}
static  int sqlite3IsReadOnly(Parse *pParse , Table *pTab , int viewOk )  {
  if (((((pTab->tabFlags & 0x10) != 0) && (sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate == 0)) || (((pTab->tabFlags & 0x01) != 0) && ((pParse->db->flags & 0x00000800) == 0) && (pParse->nested == 0)))) {
    sqlite3ErrorMsg(pParse, "table %s may not be modified", pTab->zName);
    return 1;
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if (((! viewOk) && pTab->pSelect)) {
      sqlite3ErrorMsg(pParse, "cannot modify %s because it is a view", pTab->zName);
      return 1;
    }  
  }  
  return 0;
}
static  void sqlite3MaterializeView(Parse *pParse , Table *pView , Expr *pWhere , int iCur )  {
  SelectDest dest;
  Select *pSel;
  SrcList *pFrom;
  sqlite3 *db =  pParse->db;
  int iDb =  sqlite3SchemaToIndex(db, pView->pSchema);
  (pWhere = sqlite3ExprDup(db, pWhere, 0));
  (pFrom = sqlite3SrcListAppend(db, 0, 0, 0));
  if (pFrom) {
    ((void ) 0);
    (pFrom->a[0].zName = sqlite3DbStrDup(db, pView->zName));
    (pFrom->a[0].zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zName));
    ((void ) 0);
    ((void ) 0);
  }  
  (pSel = sqlite3SelectNew(pParse, 0, pFrom, pWhere, 0, 0, 0, 0, 0, 0));
  if (pSel) {
    (pSel->selFlags |= 0x0100);
  }  
  sqlite3SelectDestInit((&dest), 9, iCur);
  sqlite3Select(pParse, pSel, (&dest));
  sqlite3SelectDelete(db, pSel);
}
static  void sqlite3DeleteFrom(Parse *pParse , SrcList *pTabList , Expr *pWhere )  {
  Vdbe *v;
  Table *pTab;
  const char *zDb;
  int end, addr =  0;
  int i;
  WhereInfo *pWInfo;
  Index *pIdx;
  int iCur;
  sqlite3 *db;
  AuthContext sContext;
  NameContext sNC;
  int iDb;
  int memCnt =  (- 1);
  int rcauth;
  int isView;
  Trigger *pTrigger;
  memset((&sContext), 0, sizeof(sContext));
  (db = pParse->db);
  if ((pParse->nErr || db->mallocFailed)) {
    goto delete_from_cleanup;
  }  
  ((void ) 0);
  (pTab = sqlite3SrcListLookup(pParse, pTabList));
  if ((pTab == 0)) {
    goto delete_from_cleanup;
  }  
  (pTrigger = sqlite3TriggersExist(pParse, pTab, 106, 0, 0));
  (isView = (pTab->pSelect != 0));
  if (sqlite3ViewGetColumnNames(pParse, pTab)) {
    goto delete_from_cleanup;
  }  
  if (sqlite3IsReadOnly(pParse, pTab, (pTrigger ? 1 : 0))) {
    goto delete_from_cleanup;
  }  
  (iDb = sqlite3SchemaToIndex(db, pTab->pSchema));
  ((void ) 0);
  (zDb = db->aDb[iDb].zName);
  (rcauth = sqlite3AuthCheck(pParse, 9, pTab->zName, 0, zDb));
  ((void ) 0);
  if ((rcauth == 1)) {
    goto delete_from_cleanup;
  }  
  ((void ) 0);
  ((void ) 0);
  (iCur = (pTabList->a[0].iCursor = pParse->nTab++));
  for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
    pParse->nTab++;
  }
  if (((id2i_sqlite_omit_view ) )) {
    if (0) {
      sqlite3AuthContextPush(pParse, (&sContext), pTab->zName);
    }  
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if (isView) {
      sqlite3AuthContextPush(pParse, (&sContext), pTab->zName);
    }  
  }  
  (v = sqlite3GetVdbe(pParse));
  if ((v == 0)) {
    goto delete_from_cleanup;
  }  
  if ((pParse->nested == 0)) {
    sqlite3VdbeCountChanges(v);
  }  
  sqlite3BeginWriteOperation(pParse, 1, iDb);
  if ((((! id2i_sqlite_omit_view) ) )) {
    if (isView) {
      sqlite3MaterializeView(pParse, pTab, pWhere, iCur);
    }  
  }  
  memset((&sNC), 0, sizeof(sNC));
  (sNC.pParse = pParse);
  (sNC.pSrcList = pTabList);
  if (sqlite3ResolveExprNames((&sNC), pWhere)) {
    goto delete_from_cleanup;
  }  
  if ((db->flags & 0x00000080)) {
    (memCnt = ++pParse->nMem);
    sqlite3VdbeAddOp2(v, 21, 0, memCnt);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if (((rcauth == 0) && (pWhere == 0) && (! pTrigger) && (! ((pTab->tabFlags & 0x10) != 0)) && (0 == sqlite3FkRequired(pParse, pTab, 0, 0)))) {
      ((void ) 0);
      sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);
      sqlite3VdbeAddOp4(v, 109, pTab->tnum, iDb, memCnt, pTab->zName, (- 2));
      for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
        ((void ) 0);
        sqlite3VdbeAddOp2(v, 109, pIdx->tnum, iDb);
      }
    }  
    else {
      int iRowSet =  ++pParse->nMem;
      int iRowid =  ++pParse->nMem;
      int regRowid;
      sqlite3VdbeAddOp2(v, 24, 0, iRowSet);
      (pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, 0x0008, 0));
      if ((pWInfo == 0)) {
        goto delete_from_cleanup;
      }  
      (regRowid = sqlite3ExprCodeGetColumn(pParse, pTab, (- 1), iCur, iRowid, 0));
      sqlite3VdbeAddOp2(v, 118, iRowSet, regRowid);
      if ((db->flags & 0x00000080)) {
        sqlite3VdbeAddOp2(v, 32, memCnt, 1);
      }  
      sqlite3WhereEnd(pWInfo);
      (end = sqlite3VdbeMakeLabel(v));
      if (((id2i_sqlite_omit_view ) )) {
        if ((! 0)) {
          sqlite3OpenTableAndIndices(pParse, pTab, iCur, 49);
        }  
      }  
      if ((((! id2i_sqlite_omit_view) ) )) {
        if ((! isView)) {
          sqlite3OpenTableAndIndices(pParse, pTab, iCur, 49);
        }  
      }  
      (addr = sqlite3VdbeAddOp3(v, 119, iRowSet, end, iRowid));
      if (((pTab->tabFlags & 0x10) != 0)) {
        const char *pVTab =  ((const  char *) sqlite3GetVTable(db, pTab));
        sqlite3VtabMakeWritable(pParse, pTab);
        sqlite3VdbeAddOp4(v, 13, 0, 1, iRowid, pVTab, (- 10));
        sqlite3VdbeChangeP5(v, 2);
        sqlite3MayAbort(pParse);
      }  
      else {
        int count =  (pParse->nested == 0);
        sqlite3GenerateRowDelete(pParse, pTab, iCur, iRowid, count, pTrigger, 10);
      }
      sqlite3VdbeAddOp2(v, 14, 0, addr);
      sqlite3VdbeResolveLabel(v, end);
      if (((id2i_sqlite_omit_view ) )) {
        if (((! 0) && (! ((pTab->tabFlags & 0x10) != 0)))) {
          for ((i = 1), (pIdx = pTab->pIndex); pIdx; i++, (pIdx = pIdx->pNext)) {
            sqlite3VdbeAddOp2(v, 54, (iCur + i), pIdx->tnum);
          }
          sqlite3VdbeAddOp1(v, 54, iCur);
        }  
      }  
      if ((((! id2i_sqlite_omit_view) ) )) {
        if (((! isView) && (! ((pTab->tabFlags & 0x10) != 0)))) {
          for ((i = 1), (pIdx = pTab->pIndex); pIdx; i++, (pIdx = pIdx->pNext)) {
            sqlite3VdbeAddOp2(v, 54, (iCur + i), pIdx->tnum);
          }
          sqlite3VdbeAddOp1(v, 54, iCur);
        }  
      }  
    }
  }  
  if (((id2i_sqlite_omit_foreign_key ) )) {
    if (((rcauth == 0) && (pWhere == 0) && (! pTrigger) && (! ((pTab->tabFlags & 0x10) != 0)) && (0 == 0))) {
      ((void ) 0);
      sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);
      sqlite3VdbeAddOp4(v, 109, pTab->tnum, iDb, memCnt, pTab->zName, (- 2));
      for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
        ((void ) 0);
        sqlite3VdbeAddOp2(v, 109, pIdx->tnum, iDb);
      }
    }  
    else {
      int iRowSet =  ++pParse->nMem;
      int iRowid =  ++pParse->nMem;
      int regRowid;
      sqlite3VdbeAddOp2(v, 24, 0, iRowSet);
      (pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, 0x0008, 0));
      if ((pWInfo == 0)) {
        goto delete_from_cleanup;
      }  
      (regRowid = sqlite3ExprCodeGetColumn(pParse, pTab, (- 1), iCur, iRowid, 0));
      sqlite3VdbeAddOp2(v, 118, iRowSet, regRowid);
      if ((db->flags & 0x00000080)) {
        sqlite3VdbeAddOp2(v, 32, memCnt, 1);
      }  
      sqlite3WhereEnd(pWInfo);
      (end = sqlite3VdbeMakeLabel(v));
      if (((id2i_sqlite_omit_view ) )) {
        if ((! 0)) {
          sqlite3OpenTableAndIndices(pParse, pTab, iCur, 49);
        }  
      }  
      if ((((! id2i_sqlite_omit_view) ) )) {
        if ((! isView)) {
          sqlite3OpenTableAndIndices(pParse, pTab, iCur, 49);
        }  
      }  
      (addr = sqlite3VdbeAddOp3(v, 119, iRowSet, end, iRowid));
      if (((pTab->tabFlags & 0x10) != 0)) {
        const char *pVTab =  ((const  char *) sqlite3GetVTable(db, pTab));
        sqlite3VtabMakeWritable(pParse, pTab);
        sqlite3VdbeAddOp4(v, 13, 0, 1, iRowid, pVTab, (- 10));
        sqlite3VdbeChangeP5(v, 2);
        sqlite3MayAbort(pParse);
      }  
      else {
        int count =  (pParse->nested == 0);
        sqlite3GenerateRowDelete(pParse, pTab, iCur, iRowid, count, pTrigger, 10);
      }
      sqlite3VdbeAddOp2(v, 14, 0, addr);
      sqlite3VdbeResolveLabel(v, end);
      if (((id2i_sqlite_omit_view ) )) {
        if (((! 0) && (! ((pTab->tabFlags & 0x10) != 0)))) {
          for ((i = 1), (pIdx = pTab->pIndex); pIdx; i++, (pIdx = pIdx->pNext)) {
            sqlite3VdbeAddOp2(v, 54, (iCur + i), pIdx->tnum);
          }
          sqlite3VdbeAddOp1(v, 54, iCur);
        }  
      }  
      if ((((! id2i_sqlite_omit_view) ) )) {
        if (((! isView) && (! ((pTab->tabFlags & 0x10) != 0)))) {
          for ((i = 1), (pIdx = pTab->pIndex); pIdx; i++, (pIdx = pIdx->pNext)) {
            sqlite3VdbeAddOp2(v, 54, (iCur + i), pIdx->tnum);
          }
          sqlite3VdbeAddOp1(v, 54, iCur);
        }  
      }  
    }
  }  
  if (((pParse->nested == 0) && (pParse->pTriggerTab == 0))) {
    sqlite3AutoincrementEnd(pParse);
  }  
  if (((db->flags & 0x00000080) && (! pParse->nested) && (! pParse->pTriggerTab))) {
    sqlite3VdbeAddOp2(v, 30, memCnt, 1);
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "rows deleted", ((sqlite3_destructor_type ) 0));
  }  
  delete_from_cleanup:
  sqlite3AuthContextPop((&sContext));
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprDelete(db, pWhere);
  return;
}
static  void sqlite3GenerateRowDelete(Parse *pParse , Table *pTab , int iCur , int iRowid , int count , Trigger *pTrigger , int onconf )  {
  Vdbe *v =  pParse->pVdbe;
  int iOld =  0;
  int iLabel;
  ((void ) 0);
  (iLabel = sqlite3VdbeMakeLabel(v));
  sqlite3VdbeAddOp3(v, 63, iCur, iLabel, iRowid);
  if (((id2i_sqlite_omit_foreign_key ) )) {
    if ((0 || pTrigger)) {
      u32 mask;
      int iCol;
      (mask = sqlite3TriggerColmask(pParse, pTrigger, 0, 0, (1 | 2), pTab, onconf));
      (mask |= 0);
      (iOld = (pParse->nMem + 1));
      (pParse->nMem += (1 + pTab->nCol));
      sqlite3VdbeAddOp2(v, 28, iRowid, iOld);
      for ((iCol = 0); (iCol < pTab->nCol); iCol++) {
        if (((mask == 0xffffffff) || (mask & (1 << iCol)))) {
          sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, (iOld + iCol + 1));
        }  
      }
      sqlite3CodeRowTrigger(pParse, pTrigger, 106, 0, 1, pTab, iOld, onconf, iLabel);
      sqlite3VdbeAddOp3(v, 63, iCur, iLabel, iRowid);
    }  
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if ((sqlite3FkRequired(pParse, pTab, 0, 0) || pTrigger)) {
      u32 mask;
      int iCol;
      (mask = sqlite3TriggerColmask(pParse, pTrigger, 0, 0, (1 | 2), pTab, onconf));
      (mask |= sqlite3FkOldmask(pParse, pTab));
      (iOld = (pParse->nMem + 1));
      (pParse->nMem += (1 + pTab->nCol));
      sqlite3VdbeAddOp2(v, 28, iRowid, iOld);
      for ((iCol = 0); (iCol < pTab->nCol); iCol++) {
        if (((mask == 0xffffffff) || (mask & (1 << iCol)))) {
          sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, (iOld + iCol + 1));
        }  
      }
      sqlite3CodeRowTrigger(pParse, pTrigger, 106, 0, 1, pTab, iOld, onconf, iLabel);
      sqlite3VdbeAddOp3(v, 63, iCur, iLabel, iRowid);
      sqlite3FkCheck(pParse, pTab, iOld, 0, 0, 0);
    }  
  }  
  if ((pTab->pSelect == 0)) {
    sqlite3GenerateRowIndexDelete(pParse, pTab, iCur, 0);
    sqlite3VdbeAddOp2(v, 70, iCur, (count ? 0x01 : 0));
    if (count) {
      sqlite3VdbeChangeP4(v, (- 1), pTab->zName, 0);
    }  
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    sqlite3FkActions(pParse, pTab, 0, iOld, 0, 0);
  }  
  sqlite3CodeRowTrigger(pParse, pTrigger, 106, 0, 2, pTab, iOld, onconf, iLabel);
  sqlite3VdbeResolveLabel(v, iLabel);
}
static  void sqlite3GenerateRowIndexDelete(Parse *pParse , Table *pTab , int iCur , int *aRegIdx )  {
  int i;
  Index *pIdx;
  int r1;
  int iPartIdxLabel;
  Vdbe *v =  pParse->pVdbe;
  for ((i = 1), (pIdx = pTab->pIndex); pIdx; i++, (pIdx = pIdx->pNext)) {
    if (((aRegIdx != 0) && (aRegIdx[(i - 1)] == 0))) {
      continue;
    }  
    (r1 = sqlite3GenerateIndexKey(pParse, pIdx, iCur, 0, 0, (&iPartIdxLabel)));
    sqlite3VdbeAddOp3(v, 104, (iCur + i), r1, (pIdx->nColumn + 1));
    sqlite3VdbeResolveLabel(v, iPartIdxLabel);
  }
}
static  int sqlite3GenerateIndexKey(Parse *pParse , Index *pIdx , int iCur , int regOut , int doMakeRec , int *piPartIdxLabel )  {
  Vdbe *v =  pParse->pVdbe;
  int j;
  Table *pTab =  pIdx->pTable;
  int regBase;
  int nCol;
  if (piPartIdxLabel) {
    if (pIdx->pPartIdxWhere) {
      ((*piPartIdxLabel) = sqlite3VdbeMakeLabel(v));
      (pParse->iPartIdxTab = iCur);
      sqlite3ExprIfFalse(pParse, pIdx->pPartIdxWhere, (*piPartIdxLabel), 0x08);
    }  
    else {
      ((*piPartIdxLabel) = 0);
    }
  }  
  (nCol = pIdx->nColumn);
  (regBase = sqlite3GetTempRange(pParse, (nCol + 1)));
  sqlite3VdbeAddOp2(v, 96, iCur, (regBase + nCol));
  for ((j = 0); (j < nCol); j++) {
    int idx =  pIdx->aiColumn[j];
    if ((idx == pTab->iPKey)) {
      sqlite3VdbeAddOp2(v, 29, (regBase + nCol), (regBase + j));
    }  
    else {
      sqlite3VdbeAddOp3(v, 41, iCur, idx, (regBase + j));
      sqlite3ColumnDefault(v, pTab, idx, (- 1));
    }
  }
  if (doMakeRec) {
    const char *zAff;
    if (((id2i_sqlite_omit_builtin_test ) )) {
      if ((pTab->pSelect || 0)) {
        (zAff = 0);
      }  
      else {
        (zAff = sqlite3IndexAffinityStr(v, pIdx));
      }
    }  
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      if ((pTab->pSelect || ((pParse->db->dbOptFlags & 0x0010) != 0))) {
        (zAff = 0);
      }  
      else {
        (zAff = sqlite3IndexAffinityStr(v, pIdx));
      }
    }  
    sqlite3VdbeAddOp3(v, 43, regBase, (nCol + 1), regOut);
    sqlite3VdbeChangeP4(v, (- 1), zAff, 0);
  }  
  sqlite3ReleaseTempRange(pParse, regBase, (nCol + 1));
  return regBase;
}
static  CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context )  {
  return context->pColl;
}
static  void sqlite3SkipAccumulatorLoad(sqlite3_context *context )  {
  (context->skipFlag = 1);
}
static  void minmaxFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  int i;
  int mask;
  int iBest;
  CollSeq *pColl;
  ((void ) 0);
  (mask = ((sqlite3_user_data(context) == 0) ? 0 : (- 1)));
  (pColl = sqlite3GetFuncCollSeq(context));
  ((void ) 0);
  ((void ) 0);
  (iBest = 0);
  if ((sqlite3_value_type(argv[0]) == 5)) {
    return;
  }  
  for ((i = 1); (i < argc); i++) {
    if ((sqlite3_value_type(argv[i]) == 5)) {
      return;
    }  
    if (((sqlite3MemCompare(argv[iBest], argv[i], pColl) ^ mask) >= 0)) {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((mask == 0)) {
          sqlite3Coverage(88704);
        }  
      }  
      (iBest = i);
    }  
  }
  sqlite3_result_value(context, argv[iBest]);
}
static  void typeofFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv )  {
  const char *z =  0;
  ((void ) NotUsed);
  switch (sqlite3_value_type(argv[0])) {
    case 1:
    (z = "integer");
    break;
    case 3:
    (z = "text");
    break;
    case 2:
    (z = "real");
    break;
    case 4:
    (z = "blob");
    break;
    id2i_label_1:
    default:
    (z = "null");
    break;
  }
  sqlite3_result_text(context, z, (- 1), ((sqlite3_destructor_type ) 0));
}
static  void lengthFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  int len;
  ((void ) 0);
  ((void ) argc);
  switch (sqlite3_value_type(argv[0])) {
    case 4:
    case 1:
    case 2:
    {
      sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));
      break;
    }
    case 3:
    {
      const unsigned char *z =  sqlite3_value_text(argv[0]);
      if ((z == 0)) {
        return;
      }  
      (len = 0);
      while ((*z)) {
        len++;
        {
          if (((*z++) >= 0xc0)) {
            while ((((*z) & 0xc0) == 0x80)) {
              z++;
            }
          }  
        }
      }
      sqlite3_result_int(context, len);
      break;
    }
    id2i_label_1:
    default:
    {
      sqlite3_result_null(context);
      break;
    }
  }
}
static  void absFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  ((void ) 0);
  ((void ) argc);
  switch (sqlite3_value_type(argv[0])) {
    case 1:
    {
      i64 iVal =  sqlite3_value_int64(argv[0]);
      if ((iVal < 0)) {
        if (((iVal << 1) == 0)) {
          sqlite3_result_error(context, "integer overflow", (- 1));
          return;
        }  
        (iVal = (- iVal));
      }  
      sqlite3_result_int64(context, iVal);
      break;
    }
    case 5:
    {
      sqlite3_result_null(context);
      break;
    }
    id2i_label_1:
    default:
    {
      double rVal =  sqlite3_value_double(argv[0]);
      if ((rVal < 0)) {
        (rVal = (- rVal));
      }  
      sqlite3_result_double(context, rVal);
      break;
    }
  }
}
static  void instrFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  const unsigned char *zHaystack;
  const unsigned char *zNeedle;
  int nHaystack;
  int nNeedle;
  int typeHaystack, typeNeedle;
  int N =  1;
  int isText;
  ((void ) argc);
  (typeHaystack = sqlite3_value_type(argv[0]));
  (typeNeedle = sqlite3_value_type(argv[1]));
  if (((typeHaystack == 5) || (typeNeedle == 5))) {
    return;
  }  
  (nHaystack = sqlite3_value_bytes(argv[0]));
  (nNeedle = sqlite3_value_bytes(argv[1]));
  if (((typeHaystack == 4) && (typeNeedle == 4))) {
    (zHaystack = sqlite3_value_blob(argv[0]));
    (zNeedle = sqlite3_value_blob(argv[1]));
    (isText = 0);
  }  
  else {
    (zHaystack = sqlite3_value_text(argv[0]));
    (zNeedle = sqlite3_value_text(argv[1]));
    (isText = 1);
  }
  while (((nNeedle <= nHaystack) && (memcmp(zHaystack, zNeedle, nNeedle) != 0))) {
    N++;
    do {
      nHaystack--;
      zHaystack++;
    } while ((isText && ((zHaystack[0] & 0xc0) == 0x80)));
  }
  if ((nNeedle > nHaystack)) {
    (N = 0);
  }  
  sqlite3_result_int(context, N);
}
static  void substrFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  const unsigned char *z;
  const unsigned char *z2;
  int len;
  int p0type;
  i64 p1, p2;
  int negP2 =  0;
  ((void ) 0);
  if (((sqlite3_value_type(argv[1]) == 5) || ((argc == 3) && (sqlite3_value_type(argv[2]) == 5)))) {
    return;
  }  
  (p0type = sqlite3_value_type(argv[0]));
  (p1 = sqlite3_value_int(argv[1]));
  if ((p0type == 4)) {
    (len = sqlite3_value_bytes(argv[0]));
    (z = sqlite3_value_blob(argv[0]));
    if ((z == 0)) {
      return;
    }  
    ((void ) 0);
  }  
  else {
    (z = sqlite3_value_text(argv[0]));
    if ((z == 0)) {
      return;
    }  
    (len = 0);
    if ((p1 < 0)) {
      for ((z2 = z); (*z2); len++) {
        {
          if (((*z2++) >= 0xc0)) {
            while ((((*z2) & 0xc0) == 0x80)) {
              z2++;
            }
          }  
        }
      }
    }  
  }
  if ((argc == 3)) {
    (p2 = sqlite3_value_int(argv[2]));
    if ((p2 < 0)) {
      (p2 = (- p2));
      (negP2 = 1);
    }  
  }  
  else {
    (p2 = sqlite3_context_db_handle(context)->aLimit[0]);
  }
  if ((p1 < 0)) {
    (p1 += len);
    if ((p1 < 0)) {
      (p2 += p1);
      if ((p2 < 0)) {
        (p2 = 0);
      }  
      (p1 = 0);
    }  
  } 
  else if ((p1 > 0)) {
    p1--;
  }
  
  else if ((p2 > 0)) {
    p2--;
  } 
  if (negP2) {
    (p1 -= p2);
    if ((p1 < 0)) {
      (p2 += p1);
      (p1 = 0);
    }  
  }  
  ((void ) 0);
  if ((p0type != 4)) {
    while (((*z) && p1)) {
      {
        if (((*z++) >= 0xc0)) {
          while ((((*z) & 0xc0) == 0x80)) {
            z++;
          }
        }  
      }
      p1--;
    }
    for ((z2 = z); ((*z2) && p2); p2--) {
      {
        if (((*z2++) >= 0xc0)) {
          while ((((*z2) & 0xc0) == 0x80)) {
            z2++;
          }
        }  
      }
    }
    sqlite3_result_text(context, ((char *) z), ((int ) (z2 - z)), ((sqlite3_destructor_type ) (- 1)));
  }  
  else {
    if (((p1 + p2) > len)) {
      (p2 = (len - p1));
      if ((p2 < 0)) {
        (p2 = 0);
      }  
    }  
    sqlite3_result_blob(context, ((char *) (&z[p1])), ((int ) p2), ((sqlite3_destructor_type ) (- 1)));
  }
}
static  void roundFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  int n =  0;
  double r;
  char *zBuf;
  ((void ) 0);
  if ((argc == 2)) {
    if ((5 == sqlite3_value_type(argv[1]))) {
      return;
    }  
    (n = sqlite3_value_int(argv[1]));
    if ((n > 30)) {
      (n = 30);
    }  
    if ((n < 0)) {
      (n = 0);
    }  
  }  
  if ((sqlite3_value_type(argv[0]) == 5)) {
    return;
  }  
  (r = sqlite3_value_double(argv[0]));
  if (((n == 0) && (r >= 0) && (r < ((0xffffffff | (((i64 ) 0x7fffffff) << 32)) - 1)))) {
    (r = ((double ) ((sqlite_int64 ) (r + 0.5))));
  } 
  else if (((n == 0) && (r < 0) && ((- r) < ((0xffffffff | (((i64 ) 0x7fffffff) << 32)) - 1)))) {
    (r = (- ((double ) ((sqlite_int64 ) ((- r) + 0.5)))));
  } 
  else {
    (zBuf = sqlite3_mprintf("%.*f", n, r));
    if ((zBuf == 0)) {
      sqlite3_result_error_nomem(context);
      return;
    }  
    sqlite3AtoF(zBuf, (&r), sqlite3Strlen30(zBuf), 1);
    sqlite3_free(zBuf);
  }
  sqlite3_result_double(context, r);
}
static  void *contextMalloc(sqlite3_context *context , i64 nByte )  {
  char *z;
  sqlite3 *db =  sqlite3_context_db_handle(context);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((nByte == db->aLimit[0])) {
      sqlite3Coverage(89006);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((nByte == (db->aLimit[0] + 1))) {
      sqlite3Coverage(89007);
    }  
  }  
  if ((nByte > db->aLimit[0])) {
    sqlite3_result_error_toobig(context);
    (z = 0);
  }  
  else {
    (z = sqlite3Malloc(((int ) nByte)));
    if ((! z)) {
      sqlite3_result_error_nomem(context);
    }  
  }
  return z;
}
static  void upperFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  char *z1;
  const char *z2;
  int i, n;
  ((void ) argc);
  (z2 = ((char *) sqlite3_value_text(argv[0])));
  (n = sqlite3_value_bytes(argv[0]));
  ((void ) 0);
  if (z2) {
    (z1 = contextMalloc(context, (((i64 ) n) + 1)));
    if (z1) {
      for ((i = 0); (i < n); i++) {
        (z1[i] = ((char ) (z2[i] & (~ (sqlite3CtypeMap[((unsigned  char ) z2[i])] & 0x20)))));
      }
      sqlite3_result_text(context, z1, n, sqlite3_free);
    }  
  }  
}
static  void lowerFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  char *z1;
  const char *z2;
  int i, n;
  ((void ) argc);
  (z2 = ((char *) sqlite3_value_text(argv[0])));
  (n = sqlite3_value_bytes(argv[0]));
  ((void ) 0);
  if (z2) {
    (z1 = contextMalloc(context, (((i64 ) n) + 1)));
    if (z1) {
      for ((i = 0); (i < n); i++) {
        if ((((! id2i_sqlite_ebcdic) ) )) {
          (z1[i] = _1281_sqlite3UpperToLower[((unsigned  char ) z2[i])]);
        }  
        if (((id2i_sqlite_ebcdic ) )) {
          (z1[i] = _1282_sqlite3UpperToLower[((unsigned  char ) z2[i])]);
        }  
      }
      sqlite3_result_text(context, z1, n, sqlite3_free);
    }  
  }  
}
static  void randomFunc(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 )  {
  sqlite_int64 r;
  ((void ) NotUsed), ((void ) NotUsed2);
  sqlite3_randomness(sizeof(r), (&r));
  if ((r < 0)) {
    (r = (- (r & (0xffffffff | (((i64 ) 0x7fffffff) << 32)))));
  }  
  sqlite3_result_int64(context, r);
}
static  void randomBlob(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  int n;
  unsigned char *p;
  ((void ) 0);
  ((void ) argc);
  (n = sqlite3_value_int(argv[0]));
  if ((n < 1)) {
    (n = 1);
  }  
  (p = contextMalloc(context, n));
  if (p) {
    sqlite3_randomness(n, p);
    sqlite3_result_blob(context, ((char *) p), n, sqlite3_free);
  }  
}
static  void last_insert_rowid(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 )  {
  sqlite3 *db =  sqlite3_context_db_handle(context);
  ((void ) NotUsed), ((void ) NotUsed2);
  sqlite3_result_int64(context, sqlite3_last_insert_rowid(db));
}
static  void changes(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 )  {
  sqlite3 *db =  sqlite3_context_db_handle(context);
  ((void ) NotUsed), ((void ) NotUsed2);
  sqlite3_result_int(context, sqlite3_changes(db));
}
static  void total_changes(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 )  {
  sqlite3 *db =  sqlite3_context_db_handle(context);
  ((void ) NotUsed), ((void ) NotUsed2);
  sqlite3_result_int(context, sqlite3_total_changes(db));
}
struct  compareInfo {
  u8 matchAll ;
  u8 matchOne ;
  u8 matchSet ;
  u8 noCase ;
}  ;
static const struct  compareInfo   globInfo =  { '*',  '?',  '[',  0};
static const struct  compareInfo   likeInfoNorm =  { '%',  '_',  0,  1};
static const struct  compareInfo   likeInfoAlt =  { '%',  '_',  0,  0};
static  int patternCompare(const  u8 *zPattern , const  u8 *zString , const  struct  compareInfo   *pInfo , u32 esc )  {
  u32 c, c2;
  int invert;
  int seen;
  u8 matchOne =  pInfo->matchOne;
  u8 matchAll =  pInfo->matchAll;
  u8 matchSet =  pInfo->matchSet;
  u8 noCase =  pInfo->noCase;
  int prevEscape =  0;
  if (((id2i_sqlite_ebcdic ) )) {
    while (((c = (*(*(&zPattern))++)) != 0)) {
      if (((c == matchAll) && (! prevEscape))) {
        while ((((c = (*(*(&zPattern))++)) == matchAll) || (c == matchOne))) {
          if (((c == matchOne) && ((*(*(&zString))++) == 0))) {
            return 0;
          }  
        }
        if ((c == 0)) {
          return 1;
        } 
        else if ((c == esc)) {
          (c = (*(*(&zPattern))++));
          if ((c == 0)) {
            return 0;
          }  
        }
        
        else if ((c == matchSet)) {
          ((void ) 0);
          ((void ) 0);
          while (((*zString) && (patternCompare((&zPattern[(- 1)]), zString, pInfo, esc) == 0))) {
            {
              if (((*zString++) >= 0xc0)) {
                while ((((*zString) & 0xc0) == 0x80)) {
                  zString++;
                }
              }  
            }
          }
          return ((*zString) != 0);
        } 
        while (((c2 = (*(*(&zString))++)) != 0)) {
          if (noCase) {
            (c2 = _1282_sqlite3UpperToLower[c2]);
            (c = _1282_sqlite3UpperToLower[c]);
            while (((c2 != 0) && (c2 != c))) {
              (c2 = (*(*(&zString))++));
              (c2 = _1282_sqlite3UpperToLower[c2]);
            }
          }  
          else {
            while (((c2 != 0) && (c2 != c))) {
              (c2 = (*(*(&zString))++));
            }
          }
          if ((c2 == 0)) {
            return 0;
          }  
          if (patternCompare(zPattern, zString, pInfo, esc)) {
            return 1;
          }  
        }
        return 0;
      } 
      else if (((c == matchOne) && (! prevEscape))) {
        if (((*(*(&zString))++) == 0)) {
          return 0;
        }  
      }
      
      else if ((c == matchSet)) {
        u32 prior_c =  0;
        ((void ) 0);
        (seen = 0);
        (invert = 0);
        (c = (*(*(&zString))++));
        if ((c == 0)) {
          return 0;
        }  
        (c2 = (*(*(&zPattern))++));
        if ((c2 == '^')) {
          (invert = 1);
          (c2 = (*(*(&zPattern))++));
        }  
        if ((c2 == ']')) {
          if ((c == ']')) {
            (seen = 1);
          }  
          (c2 = (*(*(&zPattern))++));
        }  
        while ((c2 && (c2 != ']'))) {
          if (((c2 == '-') && (zPattern[0] != ']') && (zPattern[0] != 0) && (prior_c > 0))) {
            (c2 = (*(*(&zPattern))++));
            if (((c >= prior_c) && (c <= c2))) {
              (seen = 1);
            }  
            (prior_c = 0);
          }  
          else {
            if ((c == c2)) {
              (seen = 1);
            }  
            (prior_c = c2);
          }
          (c2 = (*(*(&zPattern))++));
        }
        if (((c2 == 0) || ((seen ^ invert) == 0))) {
          return 0;
        }  
      }
      
      else if (((esc == c) && (! prevEscape))) {
        (prevEscape = 1);
      } 
      else {
        (c2 = (*(*(&zString))++));
        if (noCase) {
          (c = _1282_sqlite3UpperToLower[c]);
          (c2 = _1282_sqlite3UpperToLower[c2]);
        }  
        if ((c != c2)) {
          return 0;
        }  
        (prevEscape = 0);
      }
    }
  }  
  if ((((! id2i_sqlite_ebcdic) ) )) {
    while (((c = sqlite3Utf8Read((&zPattern))) != 0)) {
      if (((c == matchAll) && (! prevEscape))) {
        while ((((c = sqlite3Utf8Read((&zPattern))) == matchAll) || (c == matchOne))) {
          if (((c == matchOne) && (sqlite3Utf8Read((&zString)) == 0))) {
            return 0;
          }  
        }
        if ((c == 0)) {
          return 1;
        } 
        else if ((c == esc)) {
          (c = sqlite3Utf8Read((&zPattern)));
          if ((c == 0)) {
            return 0;
          }  
        }
        
        else if ((c == matchSet)) {
          ((void ) 0);
          ((void ) 0);
          while (((*zString) && (patternCompare((&zPattern[(- 1)]), zString, pInfo, esc) == 0))) {
            {
              if (((*zString++) >= 0xc0)) {
                while ((((*zString) & 0xc0) == 0x80)) {
                  zString++;
                }
              }  
            }
          }
          return ((*zString) != 0);
        } 
        while (((c2 = sqlite3Utf8Read((&zString))) != 0)) {
          if (noCase) {
            if ((! (c2 & (~ 0x7f)))) {
              (c2 = _1281_sqlite3UpperToLower[c2]);
            }  
            if ((! (c & (~ 0x7f)))) {
              (c = _1281_sqlite3UpperToLower[c]);
            }  
            while (((c2 != 0) && (c2 != c))) {
              (c2 = sqlite3Utf8Read((&zString)));
              if ((! (c2 & (~ 0x7f)))) {
                (c2 = _1281_sqlite3UpperToLower[c2]);
              }  
            }
          }  
          else {
            while (((c2 != 0) && (c2 != c))) {
              (c2 = sqlite3Utf8Read((&zString)));
            }
          }
          if ((c2 == 0)) {
            return 0;
          }  
          if (patternCompare(zPattern, zString, pInfo, esc)) {
            return 1;
          }  
        }
        return 0;
      } 
      else if (((c == matchOne) && (! prevEscape))) {
        if ((sqlite3Utf8Read((&zString)) == 0)) {
          return 0;
        }  
      }
      
      else if ((c == matchSet)) {
        u32 prior_c =  0;
        ((void ) 0);
        (seen = 0);
        (invert = 0);
        (c = sqlite3Utf8Read((&zString)));
        if ((c == 0)) {
          return 0;
        }  
        (c2 = sqlite3Utf8Read((&zPattern)));
        if ((c2 == '^')) {
          (invert = 1);
          (c2 = sqlite3Utf8Read((&zPattern)));
        }  
        if ((c2 == ']')) {
          if ((c == ']')) {
            (seen = 1);
          }  
          (c2 = sqlite3Utf8Read((&zPattern)));
        }  
        while ((c2 && (c2 != ']'))) {
          if (((c2 == '-') && (zPattern[0] != ']') && (zPattern[0] != 0) && (prior_c > 0))) {
            (c2 = sqlite3Utf8Read((&zPattern)));
            if (((c >= prior_c) && (c <= c2))) {
              (seen = 1);
            }  
            (prior_c = 0);
          }  
          else {
            if ((c == c2)) {
              (seen = 1);
            }  
            (prior_c = c2);
          }
          (c2 = sqlite3Utf8Read((&zPattern)));
        }
        if (((c2 == 0) || ((seen ^ invert) == 0))) {
          return 0;
        }  
      }
      
      else if (((esc == c) && (! prevEscape))) {
        (prevEscape = 1);
      } 
      else {
        (c2 = sqlite3Utf8Read((&zString)));
        if (noCase) {
          if ((! (c & (~ 0x7f)))) {
            (c = _1281_sqlite3UpperToLower[c]);
          }  
          if ((! (c2 & (~ 0x7f)))) {
            (c2 = _1281_sqlite3UpperToLower[c2]);
          }  
        }  
        if ((c != c2)) {
          return 0;
        }  
        (prevEscape = 0);
      }
    }
  }  
  return ((*zString) == 0);
}
int sqlite3_strglob(const  char *zGlobPattern , const  char *zString )  {
  return (patternCompare(((u8 *) zGlobPattern), ((u8 *) zString), (&globInfo), 0) == 0);
}
static  void likeFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  const unsigned char *zA, *zB;
  u32 escape =  0;
  int nPat;
  sqlite3 *db =  sqlite3_context_db_handle(context);
  (zB = sqlite3_value_text(argv[0]));
  (zA = sqlite3_value_text(argv[1]));
  (nPat = sqlite3_value_bytes(argv[0]));
  if (((id2i_sqlite_coverage_test ) )) {
    if ((nPat == db->aLimit[8])) {
      sqlite3Coverage(89384);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((nPat == (db->aLimit[8] + 1))) {
      sqlite3Coverage(89385);
    }  
  }  
  if ((nPat > db->aLimit[8])) {
    sqlite3_result_error(context, "LIKE or GLOB pattern too complex", (- 1));
    return;
  }  
  ((void ) 0);
  if ((argc == 3)) {
    const unsigned char *zEsc =  sqlite3_value_text(argv[2]);
    if ((zEsc == 0)) {
      return;
    }  
    if ((sqlite3Utf8CharLen(((char *) zEsc), (- 1)) != 1)) {
      sqlite3_result_error(context, "ESCAPE expression must be a single character", (- 1));
      return;
    }  
    if (((id2i_sqlite_ebcdic ) )) {
      (escape = (*(*(&zEsc))++));
    }  
    if ((((! id2i_sqlite_ebcdic) ) )) {
      (escape = sqlite3Utf8Read((&zEsc)));
    }  
  }  
  if ((zA && zB)) {
    struct  compareInfo   *pInfo =  sqlite3_user_data(context);
    sqlite3_result_int(context, patternCompare(zB, zA, pInfo, escape));
  }  
}
static  void nullifFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv )  {
  CollSeq *pColl =  sqlite3GetFuncCollSeq(context);
  ((void ) NotUsed);
  if ((sqlite3MemCompare(argv[0], argv[1], pColl) != 0)) {
    sqlite3_result_value(context, argv[0]);
  }  
}
static  void versionFunc(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 )  {
  ((void ) NotUsed), ((void ) NotUsed2);
  sqlite3_result_text(context, sqlite3_libversion(), (- 1), ((sqlite3_destructor_type ) 0));
}
static  void sourceidFunc(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 )  {
  ((void ) NotUsed), ((void ) NotUsed2);
  sqlite3_result_text(context, sqlite3_sourceid(), (- 1), ((sqlite3_destructor_type ) 0));
}
static  void errlogFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  ((void ) argc);
  ((void ) context);
  sqlite3_log(sqlite3_value_int(argv[0]), "%s", sqlite3_value_text(argv[1]));
}
static  void compileoptionusedFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  const char *zOptName;
  ((void ) 0);
  ((void ) argc);
  if (((zOptName = ((const  char *) sqlite3_value_text(argv[0]))) != 0)) {
    sqlite3_result_int(context, sqlite3_compileoption_used(zOptName));
  }  
}
static  void compileoptiongetFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  int n;
  ((void ) 0);
  ((void ) argc);
  (n = sqlite3_value_int(argv[0]));
  sqlite3_result_text(context, sqlite3_compileoption_get(n), (- 1), ((sqlite3_destructor_type ) 0));
}
static const char hexdigits[] =  { '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',  '8',  '9',  'A',  'B',  'C',  'D',  'E',  'F'};
static  void quoteFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  ((void ) 0);
  ((void ) argc);
  switch (sqlite3_value_type(argv[0])) {
    case 2:
    {
      double r1, r2;
      char zBuf[50];
      (r1 = sqlite3_value_double(argv[0]));
      sqlite3_snprintf(sizeof(zBuf), zBuf, "%!.15g", r1);
      sqlite3AtoF(zBuf, (&r2), 20, 1);
      if ((r1 != r2)) {
        sqlite3_snprintf(sizeof(zBuf), zBuf, "%!.20e", r1);
      }  
      sqlite3_result_text(context, zBuf, (- 1), ((sqlite3_destructor_type ) (- 1)));
      break;
    }
    case 1:
    {
      sqlite3_result_value(context, argv[0]);
      break;
    }
    case 4:
    {
      char *zText =  0;
      char const *zBlob =  sqlite3_value_blob(argv[0]);
      int nBlob =  sqlite3_value_bytes(argv[0]);
      ((void ) 0);
      (zText = ((char *) contextMalloc(context, ((2 * ((i64 ) nBlob)) + 4))));
      if (zText) {
        int i;
        for ((i = 0); (i < nBlob); i++) {
          (zText[((i * 2) + 2)] = hexdigits[((zBlob[i] >> 4) & 0x0F)]);
          (zText[((i * 2) + 3)] = hexdigits[(zBlob[i] & 0x0F)]);
        }
        (zText[((nBlob * 2) + 2)] = '\'');
        (zText[((nBlob * 2) + 3)] = '\0');
        (zText[0] = 'X');
        (zText[1] = '\'');
        sqlite3_result_text(context, zText, (- 1), ((sqlite3_destructor_type ) (- 1)));
        sqlite3_free(zText);
      }  
      break;
    }
    case 3:
    {
      int i, j;
      u64 n;
      const unsigned char *zArg =  sqlite3_value_text(argv[0]);
      char *z;
      if ((zArg == 0)) {
        return;
      }  
      for ((i = 0), (n = 0); zArg[i]; i++) {
        if ((zArg[i] == '\'')) {
          n++;
        }  
      }
      (z = contextMalloc(context, (((i64 ) i) + ((i64 ) n) + 3)));
      if (z) {
        (z[0] = '\'');
        for ((i = 0), (j = 1); zArg[i]; i++) {
          (z[j++] = zArg[i]);
          if ((zArg[i] == '\'')) {
            (z[j++] = '\'');
          }  
        }
        (z[j++] = '\'');
        (z[j] = 0);
        sqlite3_result_text(context, z, j, sqlite3_free);
      }  
      break;
    }
    id2i_label_1:
    default:
    {
      ((void ) 0);
      sqlite3_result_text(context, "NULL", 4, ((sqlite3_destructor_type ) 0));
      break;
    }
  }
}
static  void unicodeFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  const unsigned char *z =  sqlite3_value_text(argv[0]);
  ((void ) argc);
  if ((z && z[0])) {
    if ((((! id2i_sqlite_ebcdic) ) )) {
      sqlite3_result_int(context, sqlite3Utf8Read((&z)));
    }  
    if (((id2i_sqlite_ebcdic ) )) {
      sqlite3_result_int(context, (*(*(&z))++));
    }  
  }  
}
static  void charFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  unsigned char *z, *zOut;
  int i;
  (zOut = (z = sqlite3_malloc((argc * 4))));
  if ((z == 0)) {
    sqlite3_result_error_nomem(context);
    return;
  }  
  for ((i = 0); (i < argc); i++) {
    sqlite3_int64 x;
    unsigned c;
    (x = sqlite3_value_int64(argv[i]));
    if (((x < 0) || (x > 0x10ffff))) {
      (x = 0xfffd);
    }  
    (c = ((unsigned ) (x & 0x1fffff)));
    if ((c < 0x00080)) {
      ((*zOut++) = ((u8 ) (c & 0xFF)));
    } 
    else if ((c < 0x00800)) {
      ((*zOut++) = (0xC0 + ((u8 ) ((c >> 6) & 0x1F))));
      ((*zOut++) = (0x80 + ((u8 ) (c & 0x3F))));
    }
    
    else if ((c < 0x10000)) {
      ((*zOut++) = (0xE0 + ((u8 ) ((c >> 12) & 0x0F))));
      ((*zOut++) = (0x80 + ((u8 ) ((c >> 6) & 0x3F))));
      ((*zOut++) = (0x80 + ((u8 ) (c & 0x3F))));
    } 
    else {
      ((*zOut++) = (0xF0 + ((u8 ) ((c >> 18) & 0x07))));
      ((*zOut++) = (0x80 + ((u8 ) ((c >> 12) & 0x3F))));
      ((*zOut++) = (0x80 + ((u8 ) ((c >> 6) & 0x3F))));
      ((*zOut++) = (0x80 + ((u8 ) (c & 0x3F))));
    }
  }
  sqlite3_result_text(context, ((char *) z), ((int ) (zOut - z)), sqlite3_free);
}
static  void hexFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  int i, n;
  const unsigned char *pBlob;
  char *zHex, *z;
  ((void ) 0);
  ((void ) argc);
  (pBlob = sqlite3_value_blob(argv[0]));
  (n = sqlite3_value_bytes(argv[0]));
  ((void ) 0);
  (z = (zHex = contextMalloc(context, ((((i64 ) n) * 2) + 1))));
  if (zHex) {
    for ((i = 0); (i < n); i++, pBlob++) {
      unsigned char c =  (*pBlob);
      ((*z++) = hexdigits[((c >> 4) & 0xf)]);
      ((*z++) = hexdigits[(c & 0xf)]);
    }
    ((*z) = 0);
    sqlite3_result_text(context, zHex, (n * 2), sqlite3_free);
  }  
}
static  void zeroblobFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  i64 n;
  sqlite3 *db =  sqlite3_context_db_handle(context);
  ((void ) 0);
  ((void ) argc);
  (n = sqlite3_value_int64(argv[0]));
  if (((id2i_sqlite_coverage_test ) )) {
    if ((n == db->aLimit[0])) {
      sqlite3Coverage(89708);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((n == (db->aLimit[0] + 1))) {
      sqlite3Coverage(89709);
    }  
  }  
  if ((n > db->aLimit[0])) {
    sqlite3_result_error_toobig(context);
  }  
  else {
    sqlite3_result_zeroblob(context, ((int ) n));
  }
}
static  void replaceFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  const unsigned char *zStr;
  const unsigned char *zPattern;
  const unsigned char *zRep;
  unsigned char *zOut;
  int nStr;
  int nPattern;
  int nRep;
  i64 nOut;
  int loopLimit;
  int i, j;
  ((void ) 0);
  ((void ) argc);
  (zStr = sqlite3_value_text(argv[0]));
  if ((zStr == 0)) {
    return;
  }  
  (nStr = sqlite3_value_bytes(argv[0]));
  ((void ) 0);
  (zPattern = sqlite3_value_text(argv[1]));
  if ((zPattern == 0)) {
    ((void ) 0);
    return;
  }  
  if ((zPattern[0] == 0)) {
    ((void ) 0);
    sqlite3_result_value(context, argv[0]);
    return;
  }  
  (nPattern = sqlite3_value_bytes(argv[1]));
  ((void ) 0);
  (zRep = sqlite3_value_text(argv[2]));
  if ((zRep == 0)) {
    return;
  }  
  (nRep = sqlite3_value_bytes(argv[2]));
  ((void ) 0);
  (nOut = (nStr + 1));
  ((void ) 0);
  (zOut = contextMalloc(context, ((i64 ) nOut)));
  if ((zOut == 0)) {
    return;
  }  
  (loopLimit = (nStr - nPattern));
  for ((i = (j = 0)); (i <= loopLimit); i++) {
    if (((zStr[i] != zPattern[0]) || memcmp((&zStr[i]), zPattern, nPattern))) {
      (zOut[j++] = zStr[i]);
    }  
    else {
      u8 *zOld;
      sqlite3 *db =  sqlite3_context_db_handle(context);
      (nOut += (nRep - nPattern));
      if (((id2i_sqlite_coverage_test ) )) {
        if (((nOut - 1) == db->aLimit[0])) {
          sqlite3Coverage(89776);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if (((nOut - 2) == db->aLimit[0])) {
          sqlite3Coverage(89777);
        }  
      }  
      if (((nOut - 1) > db->aLimit[0])) {
        sqlite3_result_error_toobig(context);
        sqlite3_free(zOut);
        return;
      }  
      (zOld = zOut);
      (zOut = sqlite3_realloc(zOut, ((int ) nOut)));
      if ((zOut == 0)) {
        sqlite3_result_error_nomem(context);
        sqlite3_free(zOld);
        return;
      }  
      memcpy((&zOut[j]), zRep, nRep);
      (j += nRep);
      (i += (nPattern - 1));
    }
  }
  ((void ) 0);
  memcpy((&zOut[j]), (&zStr[i]), (nStr - i));
  (j += (nStr - i));
  ((void ) 0);
  (zOut[j] = 0);
  sqlite3_result_text(context, ((char *) zOut), j, sqlite3_free);
}
static  void trimFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  const unsigned char *zIn;
  const unsigned char *zCharSet;
  int nIn;
  int flags;
  int i;
  unsigned char *aLen =  0;
  unsigned char **azChar =  0;
  int nChar;
  if ((sqlite3_value_type(argv[0]) == 5)) {
    return;
  }  
  (zIn = sqlite3_value_text(argv[0]));
  if ((zIn == 0)) {
    return;
  }  
  (nIn = sqlite3_value_bytes(argv[0]));
  ((void ) 0);
  if ((argc == 1)) {
    static const unsigned char lenOne[] =  { 1};
    static unsigned char *const azOne[] =  { ((u8 *) " ")};
    (nChar = 1);
    (aLen = ((u8 *) lenOne));
    (azChar = ((unsigned  char **) azOne));
    (zCharSet = 0);
  } 
  else if (((zCharSet = sqlite3_value_text(argv[1])) == 0)) {
    return;
  } 
  else {
    const unsigned char *z;
    for ((z = zCharSet), (nChar = 0); (*z); nChar++) {
      {
        if (((*z++) >= 0xc0)) {
          while ((((*z) & 0xc0) == 0x80)) {
            z++;
          }
        }  
      }
    }
    if ((nChar > 0)) {
      (azChar = contextMalloc(context, (((i64 ) nChar) * (sizeof(char *) + 1))));
      if ((azChar == 0)) {
        return;
      }  
      (aLen = ((unsigned  char *) (&azChar[nChar])));
      for ((z = zCharSet), (nChar = 0); (*z); nChar++) {
        (azChar[nChar] = ((unsigned  char *) z));
        {
          if (((*z++) >= 0xc0)) {
            while ((((*z) & 0xc0) == 0x80)) {
              z++;
            }
          }  
        }
        (aLen[nChar] = ((u8 ) (z - azChar[nChar])));
      }
    }  
  }
  if ((nChar > 0)) {
    (flags = ((int ) ((long  int ) sqlite3_user_data(context))));
    if ((flags & 1)) {
      while ((nIn > 0)) {
        int len =  0;
        for ((i = 0); (i < nChar); i++) {
          (len = aLen[i]);
          if (((len <= nIn) && (memcmp(zIn, azChar[i], len) == 0))) {
            break;
          }  
        }
        if ((i >= nChar)) {
          break;
        }  
        (zIn += len);
        (nIn -= len);
      }
    }  
    if ((flags & 2)) {
      while ((nIn > 0)) {
        int len =  0;
        for ((i = 0); (i < nChar); i++) {
          (len = aLen[i]);
          if (((len <= nIn) && (memcmp((&zIn[(nIn - len)]), azChar[i], len) == 0))) {
            break;
          }  
        }
        if ((i >= nChar)) {
          break;
        }  
        (nIn -= len);
      }
    }  
    if (zCharSet) {
      sqlite3_free(azChar);
    }  
  }  
  sqlite3_result_text(context, ((char *) zIn), nIn, ((sqlite3_destructor_type ) (- 1)));
}
typedef struct  SumCtx   SumCtx;
struct  SumCtx {
  double rSum ;
  i64 iSum ;
  i64 cnt ;
  u8 overflow ;
  u8 approx ;
}  ;
static  void sumStep(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  SumCtx *p;
  int type;
  ((void ) 0);
  ((void ) argc);
  (p = sqlite3_aggregate_context(context, sizeof((*p))));
  (type = sqlite3_value_numeric_type(argv[0]));
  if ((p && (type != 5))) {
    p->cnt++;
    if ((type == 1)) {
      i64 v =  sqlite3_value_int64(argv[0]);
      (p->rSum += v);
      if ((((p->approx | p->overflow) == 0) && sqlite3AddInt64((&p->iSum), v))) {
        (p->overflow = 1);
      }  
    }  
    else {
      (p->rSum += sqlite3_value_double(argv[0]));
      (p->approx = 1);
    }
  }  
}
static  void sumFinalize(sqlite3_context *context )  {
  SumCtx *p;
  (p = sqlite3_aggregate_context(context, 0));
  if ((p && (p->cnt > 0))) {
    if (p->overflow) {
      sqlite3_result_error(context, "integer overflow", (- 1));
    } 
    else if (p->approx) {
      sqlite3_result_double(context, p->rSum);
    } 
    else {
      sqlite3_result_int64(context, p->iSum);
    }
  }  
}
static  void avgFinalize(sqlite3_context *context )  {
  SumCtx *p;
  (p = sqlite3_aggregate_context(context, 0));
  if ((p && (p->cnt > 0))) {
    sqlite3_result_double(context, (p->rSum / ((double ) p->cnt)));
  }  
}
static  void totalFinalize(sqlite3_context *context )  {
  SumCtx *p;
  (p = sqlite3_aggregate_context(context, 0));
  sqlite3_result_double(context, (p ? p->rSum : ((double ) 0)));
}
typedef struct  CountCtx   CountCtx;
struct  CountCtx {
  i64 n ;
}  ;
static  void countStep(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  CountCtx *p;
  (p = sqlite3_aggregate_context(context, sizeof((*p))));
  if ((((argc == 0) || (5 != sqlite3_value_type(argv[0]))) && p)) {
    p->n++;
  }  
  if ((((! id2i_sqlite_omit_deprecated) ) )) {
    ((void ) 0);
  }  
}
static  void countFinalize(sqlite3_context *context )  {
  CountCtx *p;
  (p = sqlite3_aggregate_context(context, 0));
  sqlite3_result_int64(context, (p ? p->n : 0));
}
static  void minmaxStep(sqlite3_context *context , int NotUsed , sqlite3_value **argv )  {
  Mem *pArg =  ((Mem *) argv[0]);
  Mem *pBest;
  ((void ) NotUsed);
  (pBest = ((Mem *) sqlite3_aggregate_context(context, sizeof((*pBest)))));
  if ((! pBest)) {
    return;
  }  
  if ((sqlite3_value_type(argv[0]) == 5)) {
    if (pBest->flags) {
      sqlite3SkipAccumulatorLoad(context);
    }  
  } 
  else if (pBest->flags) {
    int max;
    int cmp;
    CollSeq *pColl =  sqlite3GetFuncCollSeq(context);
    (max = (sqlite3_user_data(context) != 0));
    (cmp = sqlite3MemCompare(pBest, pArg, pColl));
    if (((max && (cmp < 0)) || ((! max) && (cmp > 0)))) {
      sqlite3VdbeMemCopy(pBest, pArg);
    }  
    else {
      sqlite3SkipAccumulatorLoad(context);
    }
  } 
  else {
    sqlite3VdbeMemCopy(pBest, pArg);
  }
}
static  void minMaxFinalize(sqlite3_context *context )  {
  sqlite3_value *pRes;
  (pRes = ((sqlite3_value *) sqlite3_aggregate_context(context, 0)));
  if (pRes) {
    if (pRes->flags) {
      sqlite3_result_value(context, pRes);
    }  
    sqlite3VdbeMemRelease(pRes);
  }  
}
static  void groupConcatStep(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  const char *zVal;
  StrAccum *pAccum;
  const char *zSep;
  int nVal, nSep;
  ((void ) 0);
  if ((sqlite3_value_type(argv[0]) == 5)) {
    return;
  }  
  (pAccum = ((StrAccum *) sqlite3_aggregate_context(context, sizeof((*pAccum)))));
  if (pAccum) {
    sqlite3 *db =  sqlite3_context_db_handle(context);
    int firstTerm =  (pAccum->useMalloc == 0);
    (pAccum->useMalloc = 2);
    (pAccum->mxAlloc = db->aLimit[0]);
    if ((! firstTerm)) {
      if ((argc == 2)) {
        (zSep = ((char *) sqlite3_value_text(argv[1])));
        (nSep = sqlite3_value_bytes(argv[1]));
      }  
      else {
        (zSep = ",");
        (nSep = 1);
      }
      sqlite3StrAccumAppend(pAccum, zSep, nSep);
    }  
    (zVal = ((char *) sqlite3_value_text(argv[0])));
    (nVal = sqlite3_value_bytes(argv[0]));
    sqlite3StrAccumAppend(pAccum, zVal, nVal);
  }  
}
static  void groupConcatFinalize(sqlite3_context *context )  {
  StrAccum *pAccum;
  (pAccum = sqlite3_aggregate_context(context, 0));
  if (pAccum) {
    if ((pAccum->accError == 2)) {
      sqlite3_result_error_toobig(context);
    } 
    else if ((pAccum->accError == 1)) {
      sqlite3_result_error_nomem(context);
    } 
    else {
      sqlite3_result_text(context, sqlite3StrAccumFinish(pAccum), (- 1), sqlite3_free);
    }
  }  
}
static  void sqlite3RegisterBuiltinFunctions(sqlite3 *db )  {
  int rc =  sqlite3_overload_function(db, "MATCH", 2);
  ((void ) 0);
  if ((rc == 7)) {
    (db->mallocFailed = 1);
  }  
}
static  void setLikeOptFlag(sqlite3 *db , const  char *zName , u8 flagVal )  {
  FuncDef *pDef;
  (pDef = sqlite3FindFunction(db, zName, sqlite3Strlen30(zName), 2, 1, 0));
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      (pDef->funcFlags |= flagVal);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pDef) {
      (pDef->funcFlags |= flagVal);
    }  
  }  
}
static  void sqlite3RegisterLikeFunctions(sqlite3 *db , int caseSensitive )  {
  struct  compareInfo   *pInfo;
  if (caseSensitive) {
    (pInfo = ((struct  compareInfo   *) (&likeInfoAlt)));
  }  
  else {
    (pInfo = ((struct  compareInfo   *) (&likeInfoNorm)));
  }
  sqlite3CreateFunc(db, "like", 2, 1, pInfo, likeFunc, 0, 0, 0);
  sqlite3CreateFunc(db, "like", 3, 1, pInfo, likeFunc, 0, 0, 0);
  sqlite3CreateFunc(db, "glob", 2, 1, ((struct  compareInfo   *) (&globInfo)), likeFunc, 0, 0, 0);
  setLikeOptFlag(db, "glob", (0x004 | 0x008));
  setLikeOptFlag(db, "like", (caseSensitive ? (0x004 | 0x008) : 0x004));
}
static  int sqlite3IsLikeFunction(sqlite3 *db , Expr *pExpr , int *pIsNocase , char *aWc )  {
  FuncDef *pDef;
  if (((pExpr->op != 151) || (! pExpr->x.pList) || (pExpr->x.pList->nExpr != 2))) {
    return 0;
  }  
  ((void ) 0);
  (pDef = sqlite3FindFunction(db, pExpr->u.zToken, sqlite3Strlen30(pExpr->u.zToken), 2, 1, 0));
  if (((id2i_sqlite_coverage_test ) )) {
    if ((0 || ((pDef->funcFlags & 0x004) == 0))) {
      return 0;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((pDef == 0) || ((pDef->funcFlags & 0x004) == 0))) {
      return 0;
    }  
  }  
  memcpy(aWc, pDef->pUserData, 3);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((*pIsNocase) = ((pDef->funcFlags & 0x008) == 0));
  return 1;
}
static  void sqlite3RegisterGlobalFunctions(void )  {
  static FuncDef aBuiltinFunc[] =  { { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 1)),  0,  trimFunc,  0,  0,  "ltrim",  0,  0},  { 2,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 1)),  0,  trimFunc,  0,  0,  "ltrim",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 2)),  0,  trimFunc,  0,  0,  "rtrim",  0,  0},  { 2,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 2)),  0,  trimFunc,  0,  0,  "rtrim",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 3)),  0,  trimFunc,  0,  0,  "trim",  0,  0},  { 2,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 3)),  0,  trimFunc,  0,  0,  "trim",  0,  0},  { (- 1),  (1 | (1 * 0x020)),  ((void *) ((long  int ) 0)),  0,  minmaxFunc,  0,  0,  "min",  0,  0},  { 0,  (1 | (1 * 0x020)),  ((void *) ((long  int ) 0)),  0,  0,  0,  0,  "min",  0,  0},  { 1,  (1 | (1 * 0x020)),  ((void *) ((long  int ) 0)),  0,  0,  minmaxStep,  minMaxFinalize,  "min",  0,  0},  { (- 1),  (1 | (1 * 0x020)),  ((void *) ((long  int ) 1)),  0,  minmaxFunc,  0,  0,  "max",  0,  0},  { 0,  (1 | (1 * 0x020)),  ((void *) ((long  int ) 1)),  0,  0,  0,  0,  "max",  0,  0},  { 1,  (1 | (1 * 0x020)),  ((void *) ((long  int ) 1)),  0,  0,  minmaxStep,  minMaxFinalize,  "max",  0,  0},  { 1,  (1 | (0 * 0x020) | 0x080),  ((void *) ((long  int ) 0)),  0,  typeofFunc,  0,  0,  "typeof",  0,  0},  { 1,  (1 | (0 * 0x020) | 0x040),  ((void *) ((long  int ) 0)),  0,  lengthFunc,  0,  0,  "length",  0,  0},  { 2,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  instrFunc,  0,  0,  "instr",  0,  0},  { 2,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  substrFunc,  0,  0,  "substr",  0,  0},  { 3,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  substrFunc,  0,  0,  "substr",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  unicodeFunc,  0,  0,  "unicode",  0,  0},  { (- 1),  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  charFunc,  0,  0,  "char",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  absFunc,  0,  0,  "abs",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  roundFunc,  0,  0,  "round",  0,  0},  { 2,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  roundFunc,  0,  0,  "round",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  upperFunc,  0,  0,  "upper",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  lowerFunc,  0,  0,  "lower",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  0,  0,  0,  "coalesce",  0,  0},  { 0,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  0,  0,  0,  "coalesce",  0,  0},  { (- 1),  (1 | (0 * 0x020) | 0x200),  ((void *) ((long  int ) 0)),  0,  versionFunc,  0,  0,  "coalesce",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  hexFunc,  0,  0,  "hex",  0,  0},  { 2,  (1 | (0 * 0x020) | 0x200),  ((void *) ((long  int ) 0)),  0,  versionFunc,  0,  0,  "ifnull",  0,  0},  { 1,  (1 | (0 * 0x020) | 0x400),  ((void *) ((long  int ) 0)),  0,  versionFunc,  0,  0,  "unlikely",  0,  0},  { 2,  (1 | (0 * 0x020) | 0x400),  ((void *) ((long  int ) 0)),  0,  versionFunc,  0,  0,  "likelihood",  0,  0},  { 0,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  randomFunc,  0,  0,  "random",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  randomBlob,  0,  0,  "randomblob",  0,  0},  { 2,  (1 | (1 * 0x020)),  ((void *) ((long  int ) 0)),  0,  nullifFunc,  0,  0,  "nullif",  0,  0},  { 0,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  versionFunc,  0,  0,  "sqlite_version",  0,  0},  { 0,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  sourceidFunc,  0,  0,  "sqlite_source_id",  0,  0},  { 2,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  errlogFunc,  0,  0,  "sqlite_log",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  compileoptionusedFunc,  0,  0,  "sqlite_compileoption_used",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  compileoptiongetFunc,  0,  0,  "sqlite_compileoption_get",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  quoteFunc,  0,  0,  "quote",  0,  0},  { 0,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  last_insert_rowid,  0,  0,  "last_insert_rowid",  0,  0},  { 0,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  changes,  0,  0,  "changes",  0,  0},  { 0,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  total_changes,  0,  0,  "total_changes",  0,  0},  { 3,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  replaceFunc,  0,  0,  "replace",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  zeroblobFunc,  0,  0,  "zeroblob",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  0,  sumStep,  sumFinalize,  "sum",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  0,  sumStep,  totalFinalize,  "total",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  0,  sumStep,  avgFinalize,  "avg",  0,  0},  { 0,  (1 | 0x100),  0,  0,  0,  countStep,  countFinalize,  "count",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  0,  countStep,  countFinalize,  "count",  0,  0},  { 1,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  0,  groupConcatStep,  groupConcatFinalize,  "group_concat",  0,  0},  { 2,  (1 | (0 * 0x020)),  ((void *) ((long  int ) 0)),  0,  0,  groupConcatStep,  groupConcatFinalize,  "group_concat",  0,  0},  { 2,  (1 | 0x004 | 0x008),  ((void *) (&globInfo)),  0,  likeFunc,  0,  0,  "glob",  0,  0},  { 2,  (1 | 0x004),  ((void *) (&likeInfoNorm)),  0,  likeFunc,  0,  0,  "like",  0,  0},  { 3,  (1 | 0x004),  ((void *) (&likeInfoNorm)),  0,  likeFunc,  0,  0,  "like",  0,  0}};
  int i;
  FuncDefHash *pHash =  (&sqlite3GlobalFunctions);
  FuncDef *aFunc =  ((FuncDef *) (&aBuiltinFunc));
  for ((i = 0); (i < ((int ) (sizeof(aBuiltinFunc) / sizeof(aBuiltinFunc[0])))); i++) {
    sqlite3FuncDefInsert(pHash, (&aFunc[i]));
  }
  sqlite3RegisterDateTimeFunctions();
  sqlite3AlterFunctions();
}
static  int sqlite3FkLocateIndex(Parse *pParse , Table *pParent , FKey *pFKey , Index **ppIdx , int **paiCol )  {
  Index *pIdx =  0;
  int *aiCol =  0;
  int nCol =  pFKey->nCol;
  char *zKey =  pFKey->aCol[0].zCol;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((nCol == 1)) {
    if ((pParent->iPKey >= 0)) {
      if ((! zKey)) {
        return 0;
      }  
      if ((! sqlite3_stricmp(pParent->aCol[pParent->iPKey].zName, zKey))) {
        return 0;
      }  
    }  
  } 
  else if (paiCol) {
    ((void ) 0);
    (aiCol = ((int *) sqlite3DbMallocRaw(pParse->db, (nCol * sizeof(int )))));
    if ((! aiCol)) {
      return 1;
    }  
    ((*paiCol) = aiCol);
  } 
  for ((pIdx = pParent->pIndex); pIdx; (pIdx = pIdx->pNext)) {
    if (((pIdx->nColumn == nCol) && (pIdx->onError != 0))) {
      if ((zKey == 0)) {
        if ((pIdx->autoIndex == 2)) {
          if (aiCol) {
            int i;
            for ((i = 0); (i < nCol); i++) {
              (aiCol[i] = pFKey->aCol[i].iFrom);
            }
          }  
          break;
        }  
      }  
      else {
        int i, j;
        for ((i = 0); (i < nCol); i++) {
          int iCol =  pIdx->aiColumn[i];
          char *zDfltColl;
          char *zIdxCol;
          (zDfltColl = pParent->aCol[iCol].zColl);
          if ((! zDfltColl)) {
            (zDfltColl = "BINARY");
          }  
          if (sqlite3_stricmp(pIdx->azColl[i], zDfltColl)) {
            break;
          }  
          (zIdxCol = pParent->aCol[iCol].zName);
          for ((j = 0); (j < nCol); j++) {
            if ((sqlite3_stricmp(pFKey->aCol[j].zCol, zIdxCol) == 0)) {
              if (aiCol) {
                (aiCol[i] = pFKey->aCol[j].iFrom);
              }  
              break;
            }  
          }
          if ((j == nCol)) {
            break;
          }  
        }
        if ((i == nCol)) {
          break;
        }  
      }
    }  
  }
  if ((! pIdx)) {
    if ((! pParse->disableTriggers)) {
      sqlite3ErrorMsg(pParse, "foreign key mismatch - \"%w\" referencing \"%w\"", pFKey->pFrom->zName, pFKey->zTo);
    }  
    sqlite3DbFree(pParse->db, aiCol);
    return 1;
  }  
  ((*ppIdx) = pIdx);
  return 0;
}
static  void fkLookupParent(Parse *pParse , int iDb , Table *pTab , Index *pIdx , FKey *pFKey , int *aiCol , int regData , int nIncr , int isIgnore )  {
  int i;
  Vdbe *v =  sqlite3GetVdbe(pParse);
  int iCur =  (pParse->nTab - 1);
  int iOk =  sqlite3VdbeMakeLabel(v);
  if ((nIncr < 0)) {
    sqlite3VdbeAddOp2(v, 124, pFKey->isDeferred, iOk);
  }  
  for ((i = 0); (i < pFKey->nCol); i++) {
    int iReg =  (aiCol[i] + regData + 1);
    sqlite3VdbeAddOp2(v, 73, iReg, iOk);
  }
  if ((isIgnore == 0)) {
    if ((pIdx == 0)) {
      int iMustBeInt;
      int regTemp =  sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp2(v, 29, (aiCol[0] + 1 + regData), regTemp);
      (iMustBeInt = sqlite3VdbeAddOp2(v, 33, regTemp, 0));
      if (((pTab == pFKey->pFrom) && (nIncr == 1))) {
        sqlite3VdbeAddOp3(v, 76, regData, iOk, regTemp);
      }  
      sqlite3OpenTable(pParse, iCur, iDb, pTab, 48);
      sqlite3VdbeAddOp3(v, 63, iCur, 0, regTemp);
      sqlite3VdbeAddOp2(v, 14, 0, iOk);
      sqlite3VdbeJumpHere(v, (sqlite3VdbeCurrentAddr(v) - 2));
      sqlite3VdbeJumpHere(v, iMustBeInt);
      sqlite3ReleaseTempReg(pParse, regTemp);
    }  
    else {
      int nCol =  pFKey->nCol;
      int regTemp =  sqlite3GetTempRange(pParse, nCol);
      int regRec =  sqlite3GetTempReg(pParse);
      KeyInfo *pKey =  sqlite3IndexKeyinfo(pParse, pIdx);
      sqlite3VdbeAddOp3(v, 48, iCur, pIdx->tnum, iDb);
      sqlite3VdbeChangeP4(v, (- 1), ((char *) pKey), (- 16));
      for ((i = 0); (i < nCol); i++) {
        sqlite3VdbeAddOp2(v, 28, (aiCol[i] + 1 + regData), (regTemp + i));
      }
      if (((pTab == pFKey->pFrom) && (nIncr == 1))) {
        int iJump =  (sqlite3VdbeCurrentAddr(v) + nCol + 1);
        for ((i = 0); (i < nCol); i++) {
          int iChild =  (aiCol[i] + 1 + regData);
          int iParent =  (pIdx->aiColumn[i] + 1 + regData);
          ((void ) 0);
          if ((pIdx->aiColumn[i] == pTab->iPKey)) {
            (iParent = regData);
          }  
          sqlite3VdbeAddOp3(v, 75, iChild, iJump, iParent);
          sqlite3VdbeChangeP5(v, 0x08);
        }
        sqlite3VdbeAddOp2(v, 14, 0, iOk);
      }  
      sqlite3VdbeAddOp3(v, 43, regTemp, nCol, regRec);
      sqlite3VdbeChangeP4(v, (- 1), sqlite3IndexAffinityStr(v, pIdx), 0);
      sqlite3VdbeAddOp4Int(v, 61, iCur, iOk, regRec, 0);
      sqlite3ReleaseTempReg(pParse, regRec);
      sqlite3ReleaseTempRange(pParse, regTemp, nCol);
    }
  }  
  if (((! pFKey->isDeferred) && (! (pParse->db->flags & 0x01000000)) && (! pParse->pToplevel) && (! pParse->isMultiWrite))) {
    ((void ) 0);
    sqlite3HaltConstraint(pParse, (19 | (3 << 8)), 2, "foreign key constraint failed", (- 2));
  }  
  else {
    if (((nIncr > 0) && (pFKey->isDeferred == 0))) {
      ((pParse->pToplevel ? pParse->pToplevel : pParse)->mayAbort = 1);
    }  
    sqlite3VdbeAddOp2(v, 123, pFKey->isDeferred, nIncr);
  }
  sqlite3VdbeResolveLabel(v, iOk);
  sqlite3VdbeAddOp1(v, 54, iCur);
}
static  void fkScanChildren(Parse *pParse , SrcList *pSrc , Table *pTab , Index *pIdx , FKey *pFKey , int *aiCol , int regData , int nIncr )  {
  sqlite3 *db =  pParse->db;
  int i;
  Expr *pWhere =  0;
  NameContext sNameContext;
  WhereInfo *pWInfo;
  int iFkIfZero =  0;
  Vdbe *v =  sqlite3GetVdbe(pParse);
  ((void ) 0);
  if ((nIncr < 0)) {
    (iFkIfZero = sqlite3VdbeAddOp2(v, 124, pFKey->isDeferred, 0));
  }  
  for ((i = 0); (i < pFKey->nCol); i++) {
    Expr *pLeft;
    Expr *pRight;
    Expr *pEq;
    int iCol;
    const char *zCol;
    (pLeft = sqlite3Expr(db, 132, 0));
    if (pLeft) {
      if (pIdx) {
        Column *pCol;
        const char *zColl;
        (iCol = pIdx->aiColumn[i]);
        (pCol = (&pTab->aCol[iCol]));
        if ((pTab->iPKey == iCol)) {
          (iCol = (- 1));
        }  
        (pLeft->iTable = (regData + iCol + 1));
        (pLeft->affinity = pCol->affinity);
        (zColl = pCol->zColl);
        if ((zColl == 0)) {
          (zColl = db->pDfltColl->zName);
        }  
        (pLeft = sqlite3ExprAddCollateString(pParse, pLeft, zColl));
      }  
      else {
        (pLeft->iTable = regData);
        (pLeft->affinity = 'd');
      }
    }  
    (iCol = (aiCol ? aiCol[i] : pFKey->aCol[0].iFrom));
    ((void ) 0);
    (zCol = pFKey->pFrom->aCol[iCol].zName);
    (pRight = sqlite3Expr(db, 26, zCol));
    (pEq = sqlite3PExpr(pParse, 76, pLeft, pRight, 0));
    (pWhere = sqlite3ExprAnd(db, pWhere, pEq));
  }
  if (((pTab == pFKey->pFrom) && (nIncr > 0))) {
    Expr *pEq;
    Expr *pLeft;
    Expr *pRight;
    (pLeft = sqlite3Expr(db, 132, 0));
    (pRight = sqlite3Expr(db, 152, 0));
    if ((pLeft && pRight)) {
      (pLeft->iTable = regData);
      (pLeft->affinity = 'd');
      (pRight->iTable = pSrc->a[0].iCursor);
      (pRight->iColumn = (- 1));
    }  
    (pEq = sqlite3PExpr(pParse, 75, pLeft, pRight, 0));
    (pWhere = sqlite3ExprAnd(db, pWhere, pEq));
  }  
  memset((&sNameContext), 0, sizeof(NameContext ));
  (sNameContext.pSrcList = pSrc);
  (sNameContext.pParse = pParse);
  sqlite3ResolveExprNames((&sNameContext), pWhere);
  (pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0, 0, 0, 0));
  if (((nIncr > 0) && (pFKey->isDeferred == 0))) {
    ((pParse->pToplevel ? pParse->pToplevel : pParse)->mayAbort = 1);
  }  
  sqlite3VdbeAddOp2(v, 123, pFKey->isDeferred, nIncr);
  if (pWInfo) {
    sqlite3WhereEnd(pWInfo);
  }  
  sqlite3ExprDelete(db, pWhere);
  if (iFkIfZero) {
    sqlite3VdbeJumpHere(v, iFkIfZero);
  }  
}
static  FKey *sqlite3FkReferences(Table *pTab )  {
  int nName =  sqlite3Strlen30(pTab->zName);
  return ((FKey *) sqlite3HashFind((&pTab->pSchema->fkeyHash), pTab->zName, nName));
}
static  void fkTriggerDelete(sqlite3 *dbMem , Trigger *p )  {
  if (p) {
    TriggerStep *pStep =  p->step_list;
    sqlite3ExprDelete(dbMem, pStep->pWhere);
    sqlite3ExprListDelete(dbMem, pStep->pExprList);
    sqlite3SelectDelete(dbMem, pStep->pSelect);
    sqlite3ExprDelete(dbMem, p->pWhen);
    sqlite3DbFree(dbMem, p);
  }  
}
static  void sqlite3FkDropTable(Parse *pParse , SrcList *pName , Table *pTab )  {
  sqlite3 *db =  pParse->db;
  if (((db->flags & 0x00080000) && (! ((pTab->tabFlags & 0x10) != 0)) && (! pTab->pSelect))) {
    int iSkip =  0;
    Vdbe *v =  sqlite3GetVdbe(pParse);
    ((void ) 0);
    if ((sqlite3FkReferences(pTab) == 0)) {
      FKey *p;
      for ((p = pTab->pFKey); p; (p = p->pNextFrom)) {
        if ((p->isDeferred || (db->flags & 0x01000000))) {
          break;
        }  
      }
      if ((! p)) {
        return;
      }  
      (iSkip = sqlite3VdbeMakeLabel(v));
      sqlite3VdbeAddOp2(v, 124, 1, iSkip);
    }  
    (pParse->disableTriggers = 1);
    sqlite3DeleteFrom(pParse, sqlite3SrcListDup(db, pName, 0), 0);
    (pParse->disableTriggers = 0);
    if (((db->flags & 0x01000000) == 0)) {
      sqlite3VdbeAddOp2(v, 124, 0, (sqlite3VdbeCurrentAddr(v) + 2));
      sqlite3HaltConstraint(pParse, (19 | (3 << 8)), 2, "foreign key constraint failed", (- 2));
    }  
    if (iSkip) {
      sqlite3VdbeResolveLabel(v, iSkip);
    }  
  }  
}
static  int fkChildIsModified(Table *pTab , FKey *p , int *aChange , int bChngRowid )  {
  int i;
  for ((i = 0); (i < p->nCol); i++) {
    int iChildKey =  p->aCol[i].iFrom;
    if ((aChange[iChildKey] >= 0)) {
      return 1;
    }  
    if (((iChildKey == pTab->iPKey) && bChngRowid)) {
      return 1;
    }  
  }
  return 0;
}
static  int fkParentIsModified(Table *pTab , FKey *p , int *aChange , int bChngRowid )  {
  int i;
  for ((i = 0); (i < p->nCol); i++) {
    char *zKey =  p->aCol[i].zCol;
    int iKey;
    for ((iKey = 0); (iKey < pTab->nCol); iKey++) {
      if (((aChange[iKey] >= 0) || ((iKey == pTab->iPKey) && bChngRowid))) {
        Column *pCol =  (&pTab->aCol[iKey]);
        if (zKey) {
          if ((0 == sqlite3_stricmp(pCol->zName, zKey))) {
            return 1;
          }  
        } 
        else if ((pCol->colFlags & 0x0001)) {
          return 1;
        } 
      }  
    }
  }
  return 0;
}
static  void sqlite3FkCheck(Parse *pParse , Table *pTab , int regOld , int regNew , int *aChange , int bChngRowid )  {
  sqlite3 *db =  pParse->db;
  FKey *pFKey;
  int iDb;
  const char *zDb;
  int isIgnoreErrors =  pParse->disableTriggers;
  ((void ) 0);
  if (((db->flags & 0x00080000) == 0)) {
    return;
  }  
  (iDb = sqlite3SchemaToIndex(db, pTab->pSchema));
  (zDb = db->aDb[iDb].zName);
  for ((pFKey = pTab->pFKey); pFKey; (pFKey = pFKey->pNextFrom)) {
    Table *pTo;
    Index *pIdx =  0;
    int *aiFree =  0;
    int *aiCol;
    int iCol;
    int i;
    int isIgnore =  0;
    if ((aChange && (sqlite3_stricmp(pTab->zName, pFKey->zTo) != 0) && (fkChildIsModified(pTab, pFKey, aChange, bChngRowid) == 0))) {
      continue;
    }  
    if (pParse->disableTriggers) {
      (pTo = sqlite3FindTable(db, pFKey->zTo, zDb));
    }  
    else {
      (pTo = sqlite3LocateTable(pParse, 0, pFKey->zTo, zDb));
    }
    if (((! pTo) || sqlite3FkLocateIndex(pParse, pTo, pFKey, (&pIdx), (&aiFree)))) {
      ((void ) 0);
      if (((! isIgnoreErrors) || db->mallocFailed)) {
        return;
      }  
      if ((pTo == 0)) {
        Vdbe *v =  sqlite3GetVdbe(pParse);
        int iJump =  (sqlite3VdbeCurrentAddr(v) + pFKey->nCol + 1);
        for ((i = 0); (i < pFKey->nCol); i++) {
          int iReg =  (pFKey->aCol[i].iFrom + regOld + 1);
          sqlite3VdbeAddOp2(v, 73, iReg, iJump);
        }
        sqlite3VdbeAddOp2(v, 123, pFKey->isDeferred, (- 1));
      }  
      continue;
    }  
    ((void ) 0);
    if (aiFree) {
      (aiCol = aiFree);
    }  
    else {
      (iCol = pFKey->aCol[0].iFrom);
      (aiCol = (&iCol));
    }
    for ((i = 0); (i < pFKey->nCol); i++) {
      if ((aiCol[i] == pTab->iPKey)) {
        (aiCol[i] = (- 1));
      }  
      if (db->xAuth) {
        int rcauth;
        char *zCol =  pTo->aCol[(pIdx ? pIdx->aiColumn[i] : pTo->iPKey)].zName;
        (rcauth = sqlite3AuthReadCol(pParse, pTo->zName, zCol, iDb));
        (isIgnore = (rcauth == 2));
      }  
    }
    sqlite3TableLock(pParse, iDb, pTo->tnum, 0, pTo->zName);
    pParse->nTab++;
    if ((regOld != 0)) {
      fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regOld, (- 1), isIgnore);
    }  
    if ((regNew != 0)) {
      fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regNew, (+ 1), isIgnore);
    }  
    sqlite3DbFree(db, aiFree);
  }
  for ((pFKey = sqlite3FkReferences(pTab)); pFKey; (pFKey = pFKey->pNextTo)) {
    Index *pIdx =  0;
    SrcList *pSrc;
    int *aiCol =  0;
    if ((aChange && (fkParentIsModified(pTab, pFKey, aChange, bChngRowid) == 0))) {
      continue;
    }  
    if (((! pFKey->isDeferred) && (! (db->flags & 0x01000000)) && (! pParse->pToplevel) && (! pParse->isMultiWrite))) {
      ((void ) 0);
      continue;
    }  
    if (sqlite3FkLocateIndex(pParse, pTab, pFKey, (&pIdx), (&aiCol))) {
      if (((! isIgnoreErrors) || db->mallocFailed)) {
        return;
      }  
      continue;
    }  
    ((void ) 0);
    (pSrc = sqlite3SrcListAppend(db, 0, 0, 0));
    if (pSrc) {
      struct  SrcList_item   *pItem =  pSrc->a;
      (pItem->pTab = pFKey->pFrom);
      (pItem->zName = pFKey->pFrom->zName);
      pItem->pTab->nRef++;
      (pItem->iCursor = pParse->nTab++);
      if ((regNew != 0)) {
        fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regNew, (- 1));
      }  
      if ((regOld != 0)) {
        fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regOld, 1);
      }  
      (pItem->zName = 0);
      sqlite3SrcListDelete(db, pSrc);
    }  
    sqlite3DbFree(db, aiCol);
  }
}
static  u32 sqlite3FkOldmask(Parse *pParse , Table *pTab )  {
  u32 mask =  0;
  if ((pParse->db->flags & 0x00080000)) {
    FKey *p;
    int i;
    for ((p = pTab->pFKey); p; (p = p->pNextFrom)) {
      for ((i = 0); (i < p->nCol); i++) {
        (mask |= ((p->aCol[i].iFrom > 31) ? 0xffffffff : (((u32 ) 1) << p->aCol[i].iFrom)));
      }
    }
    for ((p = sqlite3FkReferences(pTab)); p; (p = p->pNextTo)) {
      Index *pIdx =  0;
      sqlite3FkLocateIndex(pParse, pTab, p, (&pIdx), 0);
      if (pIdx) {
        for ((i = 0); (i < pIdx->nColumn); i++) {
          (mask |= ((pIdx->aiColumn[i] > 31) ? 0xffffffff : (((u32 ) 1) << pIdx->aiColumn[i])));
        }
      }  
    }
  }  
  return mask;
}
static  int sqlite3FkRequired(Parse *pParse , Table *pTab , int *aChange , int chngRowid )  {
  if ((pParse->db->flags & 0x00080000)) {
    if ((! aChange)) {
      return (sqlite3FkReferences(pTab) || pTab->pFKey);
    }  
    else {
      FKey *p;
      for ((p = pTab->pFKey); p; (p = p->pNextFrom)) {
        if (fkChildIsModified(pTab, p, aChange, chngRowid)) {
          return 1;
        }  
      }
      for ((p = sqlite3FkReferences(pTab)); p; (p = p->pNextTo)) {
        if (fkParentIsModified(pTab, p, aChange, chngRowid)) {
          return 1;
        }  
      }
    }
  }  
  return 0;
}
static  Trigger *fkActionTrigger(Parse *pParse , Table *pTab , FKey *pFKey , ExprList *pChanges )  {
  sqlite3 *db =  pParse->db;
  int action;
  Trigger *pTrigger;
  int iAction =  (pChanges != 0);
  (action = pFKey->aAction[iAction]);
  (pTrigger = pFKey->apTrigger[iAction]);
  if (((action != 0) && (! pTrigger))) {
    u8 enableLookaside;
    char const *zFrom;
    int nFrom;
    Index *pIdx =  0;
    int *aiCol =  0;
    TriggerStep *pStep =  0;
    Expr *pWhere =  0;
    ExprList *pList =  0;
    Select *pSelect =  0;
    int i;
    Expr *pWhen =  0;
    if (sqlite3FkLocateIndex(pParse, pTab, pFKey, (&pIdx), (&aiCol))) {
      return 0;
    }  
    ((void ) 0);
    for ((i = 0); (i < pFKey->nCol); i++) {
      Token tOld =  { "old",  3};
      Token tNew =  { "new",  3};
      Token tFromCol;
      Token tToCol;
      int iFromCol;
      Expr *pEq;
      (iFromCol = (aiCol ? aiCol[i] : pFKey->aCol[0].iFrom));
      ((void ) 0);
      (tToCol.z = (pIdx ? pTab->aCol[pIdx->aiColumn[i]].zName : "oid"));
      (tFromCol.z = pFKey->pFrom->aCol[iFromCol].zName);
      (tToCol.n = sqlite3Strlen30(tToCol.z));
      (tFromCol.n = sqlite3Strlen30(tFromCol.z));
      (pEq = sqlite3PExpr(pParse, 76, sqlite3PExpr(pParse, 118, sqlite3PExpr(pParse, 26, 0, 0, (&tOld)), sqlite3PExpr(pParse, 26, 0, 0, (&tToCol)), 0), sqlite3PExpr(pParse, 26, 0, 0, (&tFromCol)), 0));
      (pWhere = sqlite3ExprAnd(db, pWhere, pEq));
      if (pChanges) {
        (pEq = sqlite3PExpr(pParse, 70, sqlite3PExpr(pParse, 118, sqlite3PExpr(pParse, 26, 0, 0, (&tOld)), sqlite3PExpr(pParse, 26, 0, 0, (&tToCol)), 0), sqlite3PExpr(pParse, 118, sqlite3PExpr(pParse, 26, 0, 0, (&tNew)), sqlite3PExpr(pParse, 26, 0, 0, (&tToCol)), 0), 0));
        (pWhen = sqlite3ExprAnd(db, pWhen, pEq));
      }  
      if (((action != 6) && ((action != 9) || pChanges))) {
        Expr *pNew;
        if ((action == 9)) {
          (pNew = sqlite3PExpr(pParse, 118, sqlite3PExpr(pParse, 26, 0, 0, (&tNew)), sqlite3PExpr(pParse, 26, 0, 0, (&tToCol)), 0));
        } 
        else if ((action == 8)) {
          Expr *pDflt =  pFKey->pFrom->aCol[iFromCol].pDflt;
          if (pDflt) {
            (pNew = sqlite3ExprDup(db, pDflt, 0));
          }  
          else {
            (pNew = sqlite3PExpr(pParse, 98, 0, 0, 0));
          }
        } 
        else {
          (pNew = sqlite3PExpr(pParse, 98, 0, 0, 0));
        }
        (pList = sqlite3ExprListAppend(pParse, pList, pNew));
        sqlite3ExprListSetName(pParse, pList, (&tFromCol), 0);
      }  
    }
    sqlite3DbFree(db, aiCol);
    (zFrom = pFKey->pFrom->zName);
    (nFrom = sqlite3Strlen30(zFrom));
    if ((action == 6)) {
      Token tFrom;
      Expr *pRaise;
      (tFrom.z = zFrom);
      (tFrom.n = nFrom);
      (pRaise = sqlite3Expr(db, 56, "foreign key constraint failed"));
      if (pRaise) {
        (pRaise->affinity = 2);
      }  
      (pSelect = sqlite3SelectNew(pParse, sqlite3ExprListAppend(pParse, 0, pRaise), sqlite3SrcListAppend(db, 0, (&tFrom), 0), pWhere, 0, 0, 0, 0, 0, 0));
      (pWhere = 0);
    }  
    (enableLookaside = db->lookaside.bEnabled);
    (db->lookaside.bEnabled = 0);
    (pTrigger = ((Trigger *) sqlite3DbMallocZero(db, (sizeof(Trigger ) + sizeof(TriggerStep ) + nFrom + 1))));
    if (pTrigger) {
      (pStep = (pTrigger->step_list = ((TriggerStep *) (&pTrigger[1]))));
      (pStep->target.z = ((char *) (&pStep[1])));
      (pStep->target.n = nFrom);
      memcpy(((char *) pStep->target.z), zFrom, nFrom);
      (pStep->pWhere = sqlite3ExprDup(db, pWhere, 0x0001));
      (pStep->pExprList = sqlite3ExprListDup(db, pList, 0x0001));
      (pStep->pSelect = sqlite3SelectDup(db, pSelect, 0x0001));
      if (pWhen) {
        (pWhen = sqlite3PExpr(pParse, 19, pWhen, 0, 0));
        (pTrigger->pWhen = sqlite3ExprDup(db, pWhen, 0x0001));
      }  
    }  
    (db->lookaside.bEnabled = enableLookaside);
    sqlite3ExprDelete(db, pWhere);
    sqlite3ExprDelete(db, pWhen);
    sqlite3ExprListDelete(db, pList);
    sqlite3SelectDelete(db, pSelect);
    if ((db->mallocFailed == 1)) {
      fkTriggerDelete(db, pTrigger);
      return 0;
    }  
    ((void ) 0);
    switch (action) {
      case 6:
      (pStep->op = 116);
      break;
      case 9:
      if ((! pChanges)) {
        (pStep->op = 106);
        break;
      }  
      id2i_label_1:
      default:
      (pStep->op = 107);
    }
    (pStep->pTrig = pTrigger);
    (pTrigger->pSchema = pTab->pSchema);
    (pTrigger->pTabSchema = pTab->pSchema);
    (pFKey->apTrigger[iAction] = pTrigger);
    (pTrigger->op = (pChanges ? 107 : 106));
  }  
  return pTrigger;
}
static  void sqlite3FkActions(Parse *pParse , Table *pTab , ExprList *pChanges , int regOld , int *aChange , int bChngRowid )  {
  if ((pParse->db->flags & 0x00080000)) {
    FKey *pFKey;
    for ((pFKey = sqlite3FkReferences(pTab)); pFKey; (pFKey = pFKey->pNextTo)) {
      if (((aChange == 0) || fkParentIsModified(pTab, pFKey, aChange, bChngRowid))) {
        Trigger *pAct =  fkActionTrigger(pParse, pTab, pFKey, pChanges);
        if (pAct) {
          sqlite3CodeRowTriggerDirect(pParse, pAct, pTab, regOld, 2, 0);
        }  
      }  
    }
  }  
}
static  void sqlite3FkDelete(sqlite3 *db , Table *pTab )  {
  FKey *pFKey;
  FKey *pNext;
  ((void ) 0);
  for ((pFKey = pTab->pFKey); pFKey; (pFKey = pNext)) {
    if (((! db) || (db->pnBytesFreed == 0))) {
      if (pFKey->pPrevTo) {
        (pFKey->pPrevTo->pNextTo = pFKey->pNextTo);
      }  
      else {
        void *p =  ((void *) pFKey->pNextTo);
        const char *z =  (p ? pFKey->pNextTo->zTo : pFKey->zTo);
        sqlite3HashInsert((&pTab->pSchema->fkeyHash), z, sqlite3Strlen30(z), p);
      }
      if (pFKey->pNextTo) {
        (pFKey->pNextTo->pPrevTo = pFKey->pPrevTo);
      }  
    }  
    ((void ) 0);
    fkTriggerDelete(db, pFKey->apTrigger[0]);
    fkTriggerDelete(db, pFKey->apTrigger[1]);
    (pNext = pFKey->pNextFrom);
    sqlite3DbFree(db, pFKey);
  }
}
static  void sqlite3OpenTable(Parse *p , int iCur , int iDb , Table *pTab , int opcode )  {
  Vdbe *v;
  ((void ) 0);
  (v = sqlite3GetVdbe(p));
  ((void ) 0);
  sqlite3TableLock(p, iDb, pTab->tnum, ((opcode == 49) ? 1 : 0), pTab->zName);
  sqlite3VdbeAddOp3(v, opcode, iCur, pTab->tnum, iDb);
  sqlite3VdbeChangeP4(v, (- 1), ((void *) ((long  int ) pTab->nCol)), (- 14));
}
static  const  char *sqlite3IndexAffinityStr(Vdbe *v , Index *pIdx )  {
  if ((! pIdx->zColAff)) {
    int n;
    Table *pTab =  pIdx->pTable;
    sqlite3 *db =  sqlite3VdbeDb(v);
    (pIdx->zColAff = ((char *) sqlite3DbMallocRaw(0, (pIdx->nColumn + 2))));
    if ((! pIdx->zColAff)) {
      (db->mallocFailed = 1);
      return 0;
    }  
    for ((n = 0); (n < pIdx->nColumn); n++) {
      (pIdx->zColAff[n] = pTab->aCol[pIdx->aiColumn[n]].affinity);
    }
    (pIdx->zColAff[n++] = 'd');
    (pIdx->zColAff[n] = 0);
  }  
  return pIdx->zColAff;
}
static  void sqlite3TableAffinityStr(Vdbe *v , Table *pTab )  {
  if ((! pTab->zColAff)) {
    char *zColAff;
    int i;
    sqlite3 *db =  sqlite3VdbeDb(v);
    (zColAff = ((char *) sqlite3DbMallocRaw(0, (pTab->nCol + 1))));
    if ((! zColAff)) {
      (db->mallocFailed = 1);
      return;
    }  
    for ((i = 0); (i < pTab->nCol); i++) {
      (zColAff[i] = pTab->aCol[i].affinity);
    }
    (zColAff[pTab->nCol] = '\0');
    (pTab->zColAff = zColAff);
  }  
  sqlite3VdbeChangeP4(v, (- 1), pTab->zColAff, 0);
}
static  int readsTable(Parse *p , int iStartAddr , int iDb , Table *pTab )  {
  Vdbe *v =  sqlite3GetVdbe(p);
  int i;
  int iEnd =  sqlite3VdbeCurrentAddr(v);
  VTable *pVTab =  (((pTab->tabFlags & 0x10) != 0) ? sqlite3GetVTable(p->db, pTab) : 0);
  for ((i = iStartAddr); (i < iEnd); i++) {
    VdbeOp *pOp =  sqlite3VdbeGetOp(v, i);
    ((void ) 0);
    if (((pOp->opcode == 48) && (pOp->p3 == iDb))) {
      Index *pIndex;
      int tnum =  pOp->p2;
      if ((tnum == pTab->tnum)) {
        return 1;
      }  
      for ((pIndex = pTab->pIndex); pIndex; (pIndex = pIndex->pNext)) {
        if ((tnum == pIndex->tnum)) {
          return 1;
        }  
      }
    }  
    if (((pOp->opcode == 137) && (pOp->p4.pVtab == pVTab))) {
      ((void ) 0);
      ((void ) 0);
      return 1;
    }  
  }
  return 0;
}
static  int autoIncBegin(Parse *pParse , int iDb , Table *pTab )  {
  int memId =  0;
  if ((pTab->tabFlags & 0x08)) {
    Parse *pToplevel =  (pParse->pToplevel ? pParse->pToplevel : pParse);
    AutoincInfo *pInfo;
    (pInfo = pToplevel->pAinc);
    while ((pInfo && (pInfo->pTab != pTab))) {
      (pInfo = pInfo->pNext);
    }
    if ((pInfo == 0)) {
      (pInfo = sqlite3DbMallocRaw(pParse->db, sizeof((*pInfo))));
      if ((pInfo == 0)) {
        return 0;
      }  
      (pInfo->pNext = pToplevel->pAinc);
      (pToplevel->pAinc = pInfo);
      (pInfo->pTab = pTab);
      (pInfo->iDb = iDb);
      pToplevel->nMem++;
      (pInfo->regCtr = ++pToplevel->nMem);
      pToplevel->nMem++;
    }  
    (memId = pInfo->regCtr);
  }  
  return memId;
}
static  void sqlite3AutoincrementBegin(Parse *pParse )  {
  AutoincInfo *p;
  sqlite3 *db =  pParse->db;
  Db *pDb;
  int memId;
  int addr;
  Vdbe *v =  pParse->pVdbe;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  for ((p = pParse->pAinc); p; (p = p->pNext)) {
    (pDb = (&db->aDb[p->iDb]));
    (memId = p->regCtr);
    ((void ) 0);
    sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, 48);
    sqlite3VdbeAddOp3(v, 24, 0, memId, (memId + 1));
    (addr = sqlite3VdbeCurrentAddr(v));
    sqlite3VdbeAddOp4(v, 94, 0, (memId - 1), 0, p->pTab->zName, 0);
    sqlite3VdbeAddOp2(v, 101, 0, (addr + 9));
    sqlite3VdbeAddOp3(v, 41, 0, 0, memId);
    sqlite3VdbeAddOp3(v, 75, (memId - 1), (addr + 7), memId);
    sqlite3VdbeChangeP5(v, 0x08);
    sqlite3VdbeAddOp2(v, 96, 0, (memId + 1));
    sqlite3VdbeAddOp3(v, 41, 0, 1, memId);
    sqlite3VdbeAddOp2(v, 14, 0, (addr + 9));
    sqlite3VdbeAddOp2(v, 7, 0, (addr + 2));
    sqlite3VdbeAddOp2(v, 21, 0, memId);
    sqlite3VdbeAddOp0(v, 54);
  }
}
static  void autoIncStep(Parse *pParse , int memId , int regRowid )  {
  if ((memId > 0)) {
    sqlite3VdbeAddOp2(pParse->pVdbe, 125, memId, regRowid);
  }  
}
static  void sqlite3AutoincrementEnd(Parse *pParse )  {
  AutoincInfo *p;
  Vdbe *v =  pParse->pVdbe;
  sqlite3 *db =  pParse->db;
  ((void ) 0);
  for ((p = pParse->pAinc); p; (p = p->pNext)) {
    Db *pDb =  (&db->aDb[p->iDb]);
    int j1, j2, j3, j4, j5;
    int iRec;
    int memId =  p->regCtr;
    (iRec = sqlite3GetTempReg(pParse));
    ((void ) 0);
    sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, 49);
    (j1 = sqlite3VdbeAddOp1(v, 74, (memId + 1)));
    (j2 = sqlite3VdbeAddOp0(v, 101));
    (j3 = sqlite3VdbeAddOp3(v, 41, 0, 0, iRec));
    (j4 = sqlite3VdbeAddOp3(v, 76, (memId - 1), 0, iRec));
    sqlite3VdbeAddOp2(v, 7, 0, j3);
    sqlite3VdbeJumpHere(v, j2);
    sqlite3VdbeAddOp2(v, 65, 0, (memId + 1));
    (j5 = sqlite3VdbeAddOp0(v, 14));
    sqlite3VdbeJumpHere(v, j4);
    sqlite3VdbeAddOp2(v, 96, 0, (memId + 1));
    sqlite3VdbeJumpHere(v, j1);
    sqlite3VdbeJumpHere(v, j5);
    sqlite3VdbeAddOp3(v, 43, (memId - 1), 2, iRec);
    sqlite3VdbeAddOp3(v, 66, 0, iRec, (memId + 1));
    sqlite3VdbeChangeP5(v, 0x08);
    sqlite3VdbeAddOp0(v, 54);
    sqlite3ReleaseTempReg(pParse, iRec);
  }
}
static  int sqlite3CodeCoroutine(Parse *pParse , Select *pSelect , SelectDest *pDest )  {
  int regYield;
  int regEof;
  int addrTop;
  int j1;
  int rc;
  Vdbe *v;
  (regYield = ++pParse->nMem);
  (regEof = ++pParse->nMem);
  (v = sqlite3GetVdbe(pParse));
  (addrTop = sqlite3VdbeCurrentAddr(v));
  sqlite3VdbeAddOp2(v, 21, (addrTop + 2), regYield);
  sqlite3VdbeAddOp2(v, 21, 0, regEof);
  sqlite3SelectDestInit(pDest, 10, regYield);
  (j1 = sqlite3VdbeAddOp2(v, 14, 0, 0));
  (rc = sqlite3Select(pParse, pSelect, pDest));
  ((void ) 0);
  if ((pParse->db->mallocFailed && (rc == 0))) {
    (rc = 7);
  }  
  if (rc) {
    return rc;
  }  
  sqlite3VdbeAddOp2(v, 21, 1, regEof);
  sqlite3VdbeAddOp1(v, 17, regYield);
  sqlite3VdbeAddOp2(v, 20, 2, 2);
  sqlite3VdbeJumpHere(v, j1);
  return rc;
}
static int xferOptimization(Parse *pParse , Table *pDest , Select *pSelect , int onError , int iDbDest );
static  void sqlite3Insert(Parse *pParse , SrcList *pTabList , ExprList *pList , Select *pSelect , IdList *pColumn , int onError )  {
  sqlite3 *db;
  Table *pTab;
  char *zTab;
  const char *zDb;
  int i, j, idx;
  Vdbe *v;
  Index *pIdx;
  int nColumn;
  int nHidden =  0;
  int baseCur =  0;
  int keyColumn =  (- 1);
  int endOfLoop;
  int useTempTable =  0;
  int srcTab =  0;
  int addrInsTop =  0;
  int addrCont =  0;
  int addrSelect =  0;
  SelectDest dest;
  int iDb;
  Db *pDb;
  int appendFlag =  0;
  int regFromSelect =  0;
  int regAutoinc =  0;
  int regRowCount =  0;
  int regIns;
  int regRowid;
  int regData;
  int regEof =  0;
  int *aRegIdx =  0;
  int isView;
  Trigger *pTrigger;
  int tmask;
  (db = pParse->db);
  memset((&dest), 0, sizeof(dest));
  if ((pParse->nErr || db->mallocFailed)) {
    goto insert_cleanup;
  }  
  ((void ) 0);
  (zTab = pTabList->a[0].zName);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      goto insert_cleanup;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((zTab == 0)) {
      goto insert_cleanup;
    }  
  }  
  (pTab = sqlite3SrcListLookup(pParse, pTabList));
  if ((pTab == 0)) {
    goto insert_cleanup;
  }  
  (iDb = sqlite3SchemaToIndex(db, pTab->pSchema));
  ((void ) 0);
  (pDb = (&db->aDb[iDb]));
  (zDb = pDb->zName);
  if (sqlite3AuthCheck(pParse, 18, pTab->zName, 0, zDb)) {
    goto insert_cleanup;
  }  
  (pTrigger = sqlite3TriggersExist(pParse, pTab, 105, 0, (&tmask)));
  (isView = (pTab->pSelect != 0));
  ((void ) 0);
  if (sqlite3ViewGetColumnNames(pParse, pTab)) {
    goto insert_cleanup;
  }  
  if (sqlite3IsReadOnly(pParse, pTab, tmask)) {
    goto insert_cleanup;
  }  
  (v = sqlite3GetVdbe(pParse));
  if ((v == 0)) {
    goto insert_cleanup;
  }  
  if ((pParse->nested == 0)) {
    sqlite3VdbeCountChanges(v);
  }  
  sqlite3BeginWriteOperation(pParse, (pSelect || pTrigger), iDb);
  if (((pColumn == 0) && xferOptimization(pParse, pTab, pSelect, onError, iDb))) {
    ((void ) 0);
    ((void ) 0);
    goto insert_end;
  }  
  (regAutoinc = autoIncBegin(pParse, iDb, pTab));
  if (pSelect) {
    int rc =  sqlite3CodeCoroutine(pParse, pSelect, (&dest));
    if (rc) {
      goto insert_cleanup;
    }  
    (regEof = (dest.iSDParm + 1));
    (regFromSelect = dest.iSdst);
    ((void ) 0);
    (nColumn = pSelect->pEList->nExpr);
    ((void ) 0);
    if ((pTrigger || readsTable(pParse, addrSelect, iDb, pTab))) {
      (useTempTable = 1);
    }  
    if (useTempTable) {
      int regRec;
      int regTempRowid;
      int addrTop;
      int addrIf;
      (srcTab = pParse->nTab++);
      (regRec = sqlite3GetTempReg(pParse));
      (regTempRowid = sqlite3GetTempReg(pParse));
      sqlite3VdbeAddOp2(v, 51, srcTab, nColumn);
      (addrTop = sqlite3VdbeAddOp1(v, 17, dest.iSDParm));
      (addrIf = sqlite3VdbeAddOp1(v, 39, regEof));
      sqlite3VdbeAddOp3(v, 43, regFromSelect, nColumn, regRec);
      sqlite3VdbeAddOp2(v, 65, srcTab, regTempRowid);
      sqlite3VdbeAddOp3(v, 66, srcTab, regRec, regTempRowid);
      sqlite3VdbeAddOp2(v, 14, 0, addrTop);
      sqlite3VdbeJumpHere(v, addrIf);
      sqlite3ReleaseTempReg(pParse, regRec);
      sqlite3ReleaseTempReg(pParse, regTempRowid);
    }  
  }  
  else {
    NameContext sNC;
    memset((&sNC), 0, sizeof(sNC));
    (sNC.pParse = pParse);
    (srcTab = (- 1));
    ((void ) 0);
    (nColumn = (pList ? pList->nExpr : 0));
    for ((i = 0); (i < nColumn); i++) {
      if (sqlite3ResolveExprNames((&sNC), pList->a[i].pExpr)) {
        goto insert_cleanup;
      }  
    }
  }
  if (((pTab->tabFlags & 0x10) != 0)) {
    for ((i = 0); (i < pTab->nCol); i++) {
      (nHidden += ((((&pTab->aCol[i])->colFlags & 0x0002) != 0) ? 1 : 0));
    }
  }  
  if (((pColumn == 0) && nColumn && (nColumn != (pTab->nCol - nHidden)))) {
    sqlite3ErrorMsg(pParse, "table %S has %d columns but %d values were supplied", pTabList, 0, (pTab->nCol - nHidden), nColumn);
    goto insert_cleanup;
  }  
  if (((pColumn != 0) && (nColumn != pColumn->nId))) {
    sqlite3ErrorMsg(pParse, "%d values for %d columns", nColumn, pColumn->nId);
    goto insert_cleanup;
  }  
  if (pColumn) {
    for ((i = 0); (i < pColumn->nId); i++) {
      (pColumn->a[i].idx = (- 1));
    }
    for ((i = 0); (i < pColumn->nId); i++) {
      for ((j = 0); (j < pTab->nCol); j++) {
        if ((sqlite3_stricmp(pColumn->a[i].zName, pTab->aCol[j].zName) == 0)) {
          (pColumn->a[i].idx = j);
          if ((j == pTab->iPKey)) {
            (keyColumn = i);
          }  
          break;
        }  
      }
      if ((j >= pTab->nCol)) {
        if (sqlite3IsRowid(pColumn->a[i].zName)) {
          (keyColumn = i);
        }  
        else {
          sqlite3ErrorMsg(pParse, "table %S has no column named %s", pTabList, 0, pColumn->a[i].zName);
          (pParse->checkSchema = 1);
          goto insert_cleanup;
        }
      }  
    }
  }  
  if (((pColumn == 0) && (nColumn > 0))) {
    (keyColumn = pTab->iPKey);
  }  
  if ((db->flags & 0x00000080)) {
    (regRowCount = ++pParse->nMem);
    sqlite3VdbeAddOp2(v, 21, 0, regRowCount);
  }  
  if (((id2i_sqlite_omit_view ) )) {
    if ((! 0)) {
      int nIdx;
      (baseCur = pParse->nTab);
      (nIdx = sqlite3OpenTableAndIndices(pParse, pTab, baseCur, 49));
      (aRegIdx = sqlite3DbMallocRaw(db, (sizeof(int ) * (nIdx + 1))));
      if ((aRegIdx == 0)) {
        goto insert_cleanup;
      }  
      for ((i = 0); (i < nIdx); i++) {
        (aRegIdx[i] = ++pParse->nMem);
      }
    }  
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if ((! isView)) {
      int nIdx;
      (baseCur = pParse->nTab);
      (nIdx = sqlite3OpenTableAndIndices(pParse, pTab, baseCur, 49));
      (aRegIdx = sqlite3DbMallocRaw(db, (sizeof(int ) * (nIdx + 1))));
      if ((aRegIdx == 0)) {
        goto insert_cleanup;
      }  
      for ((i = 0); (i < nIdx); i++) {
        (aRegIdx[i] = ++pParse->nMem);
      }
    }  
  }  
  if (useTempTable) {
    (addrInsTop = sqlite3VdbeAddOp1(v, 101, srcTab));
    (addrCont = sqlite3VdbeCurrentAddr(v));
  } 
  else if (pSelect) {
    (addrCont = sqlite3VdbeAddOp1(v, 17, dest.iSDParm));
    (addrInsTop = sqlite3VdbeAddOp1(v, 39, regEof));
  } 
  (regRowid = (regIns = (pParse->nMem + 1)));
  (pParse->nMem += (pTab->nCol + 1));
  if (((pTab->tabFlags & 0x10) != 0)) {
    regRowid++;
    pParse->nMem++;
  }  
  (regData = (regRowid + 1));
  (endOfLoop = sqlite3VdbeMakeLabel(v));
  if ((tmask & 1)) {
    int regCols =  sqlite3GetTempRange(pParse, (pTab->nCol + 1));
    if ((keyColumn < 0)) {
      sqlite3VdbeAddOp2(v, 21, (- 1), regCols);
    }  
    else {
      int j1;
      if (useTempTable) {
        sqlite3VdbeAddOp3(v, 41, srcTab, keyColumn, regCols);
      }  
      else {
        ((void ) 0);
        sqlite3ExprCode(pParse, pList->a[keyColumn].pExpr, regCols);
      }
      (j1 = sqlite3VdbeAddOp1(v, 74, regCols));
      sqlite3VdbeAddOp2(v, 21, (- 1), regCols);
      sqlite3VdbeJumpHere(v, j1);
      sqlite3VdbeAddOp1(v, 33, regCols);
    }
    ((void ) 0);
    for ((i = 0); (i < pTab->nCol); i++) {
      if ((pColumn == 0)) {
        (j = i);
      }  
      else {
        for ((j = 0); (j < pColumn->nId); j++) {
          if ((pColumn->a[j].idx == i)) {
            break;
          }  
        }
      }
      if ((((! useTempTable) && (! pList)) || (pColumn && (j >= pColumn->nId)))) {
        sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, (regCols + i + 1));
      } 
      else if (useTempTable) {
        sqlite3VdbeAddOp3(v, 41, srcTab, j, (regCols + i + 1));
      } 
      else {
        ((void ) 0);
        sqlite3ExprCodeAndCache(pParse, pList->a[j].pExpr, (regCols + i + 1));
      }
    }
    if (((id2i_sqlite_omit_view ) )) {
      if ((! 0)) {
        sqlite3VdbeAddOp2(v, 42, (regCols + 1), pTab->nCol);
        sqlite3TableAffinityStr(v, pTab);
      }  
    }  
    if ((((! id2i_sqlite_omit_view) ) )) {
      if ((! isView)) {
        sqlite3VdbeAddOp2(v, 42, (regCols + 1), pTab->nCol);
        sqlite3TableAffinityStr(v, pTab);
      }  
    }  
    sqlite3CodeRowTrigger(pParse, pTrigger, 105, 0, 1, pTab, (regCols - pTab->nCol - 1), onError, endOfLoop);
    sqlite3ReleaseTempRange(pParse, regCols, (pTab->nCol + 1));
  }  
  if (((id2i_sqlite_omit_view ) )) {
    if ((! 0)) {
      if (((pTab->tabFlags & 0x10) != 0)) {
        sqlite3VdbeAddOp2(v, 24, 0, regIns);
      }  
      if ((keyColumn >= 0)) {
        if (useTempTable) {
          sqlite3VdbeAddOp3(v, 41, srcTab, keyColumn, regRowid);
        } 
        else if (pSelect) {
          sqlite3VdbeAddOp2(v, 29, (regFromSelect + keyColumn), regRowid);
        } 
        else {
          VdbeOp *pOp;
          sqlite3ExprCode(pParse, pList->a[keyColumn].pExpr, regRowid);
          (pOp = sqlite3VdbeGetOp(v, (- 1)));
          if (((id2i_sqlite_coverage_test ) )) {
            if ((1 && (pOp->opcode == 24) && (! ((pTab->tabFlags & 0x10) != 0)))) {
              (appendFlag = 1);
              (pOp->opcode = 65);
              (pOp->p1 = baseCur);
              (pOp->p2 = regRowid);
              (pOp->p3 = regAutoinc);
            }  
          }  
          if ((((! id2i_sqlite_coverage_test) ) )) {
            if ((pOp && (pOp->opcode == 24) && (! ((pTab->tabFlags & 0x10) != 0)))) {
              (appendFlag = 1);
              (pOp->opcode = 65);
              (pOp->p1 = baseCur);
              (pOp->p2 = regRowid);
              (pOp->p3 = regAutoinc);
            }  
          }  
        }
        if ((! appendFlag)) {
          int j1;
          if ((! ((pTab->tabFlags & 0x10) != 0))) {
            (j1 = sqlite3VdbeAddOp1(v, 74, regRowid));
            sqlite3VdbeAddOp3(v, 65, baseCur, regRowid, regAutoinc);
            sqlite3VdbeJumpHere(v, j1);
          }  
          else {
            (j1 = sqlite3VdbeCurrentAddr(v));
            sqlite3VdbeAddOp2(v, 73, regRowid, (j1 + 2));
          }
          sqlite3VdbeAddOp1(v, 33, regRowid);
        }  
      } 
      else if (((pTab->tabFlags & 0x10) != 0)) {
        sqlite3VdbeAddOp2(v, 24, 0, regRowid);
      } 
      else {
        sqlite3VdbeAddOp3(v, 65, baseCur, regRowid, regAutoinc);
        (appendFlag = 1);
      }
      autoIncStep(pParse, regAutoinc, regRowid);
      (nHidden = 0);
      for ((i = 0); (i < pTab->nCol); i++) {
        int iRegStore =  (regRowid + 1 + i);
        if ((i == pTab->iPKey)) {
          sqlite3VdbeAddOp2(v, 24, 0, iRegStore);
          continue;
        }  
        if ((pColumn == 0)) {
          if ((((&pTab->aCol[i])->colFlags & 0x0002) != 0)) {
            ((void ) 0);
            (j = (- 1));
            nHidden++;
          }  
          else {
            (j = (i - nHidden));
          }
        }  
        else {
          for ((j = 0); (j < pColumn->nId); j++) {
            if ((pColumn->a[j].idx == i)) {
              break;
            }  
          }
        }
        if (((j < 0) || (nColumn == 0) || (pColumn && (j >= pColumn->nId)))) {
          sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, iRegStore);
        } 
        else if (useTempTable) {
          sqlite3VdbeAddOp3(v, 41, srcTab, j, iRegStore);
        }
        
        else if (pSelect) {
          sqlite3VdbeAddOp2(v, 29, (regFromSelect + j), iRegStore);
        } 
        else {
          sqlite3ExprCode(pParse, pList->a[j].pExpr, iRegStore);
        }
      }
      if (((pTab->tabFlags & 0x10) != 0)) {
        const char *pVTab =  ((const  char *) sqlite3GetVTable(db, pTab));
        sqlite3VtabMakeWritable(pParse, pTab);
        sqlite3VdbeAddOp4(v, 13, 1, (pTab->nCol + 2), regIns, pVTab, (- 10));
        sqlite3VdbeChangeP5(v, ((onError == 10) ? 2 : onError));
        sqlite3MayAbort(pParse);
      }  
      else {
        int isReplace;
        sqlite3GenerateConstraintChecks(pParse, pTab, baseCur, regIns, aRegIdx, (keyColumn >= 0), 0, onError, endOfLoop, (&isReplace));
        if ((((! id2i_sqlite_omit_foreign_key) ) )) {
          sqlite3FkCheck(pParse, pTab, 0, regIns, 0, 0);
        }  
        sqlite3CompleteInsertion(pParse, pTab, baseCur, regIns, aRegIdx, 0, appendFlag, (isReplace == 0));
      }
    }  
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if ((! isView)) {
      if (((pTab->tabFlags & 0x10) != 0)) {
        sqlite3VdbeAddOp2(v, 24, 0, regIns);
      }  
      if ((keyColumn >= 0)) {
        if (useTempTable) {
          sqlite3VdbeAddOp3(v, 41, srcTab, keyColumn, regRowid);
        } 
        else if (pSelect) {
          sqlite3VdbeAddOp2(v, 29, (regFromSelect + keyColumn), regRowid);
        } 
        else {
          VdbeOp *pOp;
          sqlite3ExprCode(pParse, pList->a[keyColumn].pExpr, regRowid);
          (pOp = sqlite3VdbeGetOp(v, (- 1)));
          if (((id2i_sqlite_coverage_test ) )) {
            if ((1 && (pOp->opcode == 24) && (! ((pTab->tabFlags & 0x10) != 0)))) {
              (appendFlag = 1);
              (pOp->opcode = 65);
              (pOp->p1 = baseCur);
              (pOp->p2 = regRowid);
              (pOp->p3 = regAutoinc);
            }  
          }  
          if ((((! id2i_sqlite_coverage_test) ) )) {
            if ((pOp && (pOp->opcode == 24) && (! ((pTab->tabFlags & 0x10) != 0)))) {
              (appendFlag = 1);
              (pOp->opcode = 65);
              (pOp->p1 = baseCur);
              (pOp->p2 = regRowid);
              (pOp->p3 = regAutoinc);
            }  
          }  
        }
        if ((! appendFlag)) {
          int j1;
          if ((! ((pTab->tabFlags & 0x10) != 0))) {
            (j1 = sqlite3VdbeAddOp1(v, 74, regRowid));
            sqlite3VdbeAddOp3(v, 65, baseCur, regRowid, regAutoinc);
            sqlite3VdbeJumpHere(v, j1);
          }  
          else {
            (j1 = sqlite3VdbeCurrentAddr(v));
            sqlite3VdbeAddOp2(v, 73, regRowid, (j1 + 2));
          }
          sqlite3VdbeAddOp1(v, 33, regRowid);
        }  
      } 
      else if (((pTab->tabFlags & 0x10) != 0)) {
        sqlite3VdbeAddOp2(v, 24, 0, regRowid);
      } 
      else {
        sqlite3VdbeAddOp3(v, 65, baseCur, regRowid, regAutoinc);
        (appendFlag = 1);
      }
      autoIncStep(pParse, regAutoinc, regRowid);
      (nHidden = 0);
      for ((i = 0); (i < pTab->nCol); i++) {
        int iRegStore =  (regRowid + 1 + i);
        if ((i == pTab->iPKey)) {
          sqlite3VdbeAddOp2(v, 24, 0, iRegStore);
          continue;
        }  
        if ((pColumn == 0)) {
          if ((((&pTab->aCol[i])->colFlags & 0x0002) != 0)) {
            ((void ) 0);
            (j = (- 1));
            nHidden++;
          }  
          else {
            (j = (i - nHidden));
          }
        }  
        else {
          for ((j = 0); (j < pColumn->nId); j++) {
            if ((pColumn->a[j].idx == i)) {
              break;
            }  
          }
        }
        if (((j < 0) || (nColumn == 0) || (pColumn && (j >= pColumn->nId)))) {
          sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, iRegStore);
        } 
        else if (useTempTable) {
          sqlite3VdbeAddOp3(v, 41, srcTab, j, iRegStore);
        }
        
        else if (pSelect) {
          sqlite3VdbeAddOp2(v, 29, (regFromSelect + j), iRegStore);
        } 
        else {
          sqlite3ExprCode(pParse, pList->a[j].pExpr, iRegStore);
        }
      }
      if (((pTab->tabFlags & 0x10) != 0)) {
        const char *pVTab =  ((const  char *) sqlite3GetVTable(db, pTab));
        sqlite3VtabMakeWritable(pParse, pTab);
        sqlite3VdbeAddOp4(v, 13, 1, (pTab->nCol + 2), regIns, pVTab, (- 10));
        sqlite3VdbeChangeP5(v, ((onError == 10) ? 2 : onError));
        sqlite3MayAbort(pParse);
      }  
      else {
        int isReplace;
        sqlite3GenerateConstraintChecks(pParse, pTab, baseCur, regIns, aRegIdx, (keyColumn >= 0), 0, onError, endOfLoop, (&isReplace));
        if ((((! id2i_sqlite_omit_foreign_key) ) )) {
          sqlite3FkCheck(pParse, pTab, 0, regIns, 0, 0);
        }  
        sqlite3CompleteInsertion(pParse, pTab, baseCur, regIns, aRegIdx, 0, appendFlag, (isReplace == 0));
      }
    }  
  }  
  if (((db->flags & 0x00000080) != 0)) {
    sqlite3VdbeAddOp2(v, 32, regRowCount, 1);
  }  
  if (pTrigger) {
    sqlite3CodeRowTrigger(pParse, pTrigger, 105, 0, 2, pTab, (regData - 2 - pTab->nCol), onError, endOfLoop);
  }  
  sqlite3VdbeResolveLabel(v, endOfLoop);
  if (useTempTable) {
    sqlite3VdbeAddOp2(v, 7, srcTab, addrCont);
    sqlite3VdbeJumpHere(v, addrInsTop);
    sqlite3VdbeAddOp1(v, 54, srcTab);
  } 
  else if (pSelect) {
    sqlite3VdbeAddOp2(v, 14, 0, addrCont);
    sqlite3VdbeJumpHere(v, addrInsTop);
  } 
  if ((((! id2i_sqlite_omit_view) ) )) {
    if (((! ((pTab->tabFlags & 0x10) != 0)) && (! isView))) {
      sqlite3VdbeAddOp1(v, 54, baseCur);
      for ((idx = 1), (pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext), idx++) {
        sqlite3VdbeAddOp1(v, 54, (idx + baseCur));
      }
    }  
  }  
  if (((id2i_sqlite_omit_view ) )) {
    if (((! ((pTab->tabFlags & 0x10) != 0)) && (! 0))) {
      sqlite3VdbeAddOp1(v, 54, baseCur);
      for ((idx = 1), (pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext), idx++) {
        sqlite3VdbeAddOp1(v, 54, (idx + baseCur));
      }
    }  
  }  
  insert_end:
  if (((pParse->nested == 0) && (pParse->pTriggerTab == 0))) {
    sqlite3AutoincrementEnd(pParse);
  }  
  if (((db->flags & 0x00000080) && (! pParse->nested) && (! pParse->pTriggerTab))) {
    sqlite3VdbeAddOp2(v, 30, regRowCount, 1);
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "rows inserted", ((sqlite3_destructor_type ) 0));
  }  
  insert_cleanup:
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprListDelete(db, pList);
  sqlite3SelectDelete(db, pSelect);
  sqlite3IdListDelete(db, pColumn);
  sqlite3DbFree(db, aRegIdx);
}
static  void sqlite3GenerateConstraintChecks(Parse *pParse , Table *pTab , int baseCur , int regRowid , int *aRegIdx , int rowidChng , int isUpdate , int overrideError , int ignoreDest , int *pbMayReplace )  {
  int i;
  Vdbe *v;
  int nCol;
  int onError;
  int j1;
  int j2 =  0, j3;
  int regData;
  int iCur;
  Index *pIdx;
  sqlite3 *db;
  int seenReplace =  0;
  int regOldRowid =  ((rowidChng && isUpdate) ? rowidChng : regRowid);
  (db = pParse->db);
  (v = sqlite3GetVdbe(pParse));
  ((void ) 0);
  ((void ) 0);
  (nCol = pTab->nCol);
  (regData = (regRowid + 1));
  for ((i = 0); (i < nCol); i++) {
    if ((i == pTab->iPKey)) {
      continue;
    }  
    (onError = pTab->aCol[i].notNull);
    if ((onError == 0)) {
      continue;
    }  
    if ((overrideError != 10)) {
      (onError = overrideError);
    } 
    else if ((onError == 10)) {
      (onError = 2);
    } 
    if (((onError == 5) && (pTab->aCol[i].pDflt == 0))) {
      (onError = 2);
    }  
    ((void ) 0);
    switch (onError) {
      case 2:
      sqlite3MayAbort(pParse);
      case 1:
      case 3:
      {
        char *zMsg;
        sqlite3VdbeAddOp3(v, 18, (19 | (5 << 8)), onError, (regData + i));
        (zMsg = sqlite3MPrintf(db, "%s.%s may not be NULL", pTab->zName, pTab->aCol[i].zName));
        sqlite3VdbeChangeP4(v, (- 1), zMsg, (- 1));
        break;
      }
      case 4:
      {
        sqlite3VdbeAddOp2(v, 73, (regData + i), ignoreDest);
        break;
      }
      id2i_label_1:
      default:
      {
        ((void ) 0);
        (j1 = sqlite3VdbeAddOp1(v, 74, (regData + i)));
        sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, (regData + i));
        sqlite3VdbeJumpHere(v, j1);
        break;
      }
    }
  }
  if ((pTab->pCheck && ((db->flags & 0x00002000) == 0))) {
    ExprList *pCheck =  pTab->pCheck;
    (pParse->ckBase = regData);
    (onError = ((overrideError != 10) ? overrideError : 2));
    for ((i = 0); (i < pCheck->nExpr); i++) {
      int allOk =  sqlite3VdbeMakeLabel(v);
      sqlite3ExprIfTrue(pParse, pCheck->a[i].pExpr, allOk, 0x08);
      if ((onError == 4)) {
        sqlite3VdbeAddOp2(v, 14, 0, ignoreDest);
      }  
      else {
        char *zConsName =  pCheck->a[i].zName;
        if ((onError == 5)) {
          (onError = 2);
        }  
        if (zConsName) {
          (zConsName = sqlite3MPrintf(db, "constraint %s failed", zConsName));
        }  
        else {
          (zConsName = 0);
        }
        sqlite3HaltConstraint(pParse, (19 | (1 << 8)), onError, zConsName, (- 1));
      }
      sqlite3VdbeResolveLabel(v, allOk);
    }
  }  
  if (rowidChng) {
    (onError = pTab->keyConf);
    if ((overrideError != 10)) {
      (onError = overrideError);
    } 
    else if ((onError == 10)) {
      (onError = 2);
    } 
    if (isUpdate) {
      (j2 = sqlite3VdbeAddOp3(v, 76, regRowid, 0, rowidChng));
    }  
    (j3 = sqlite3VdbeAddOp3(v, 63, baseCur, 0, regRowid));
    switch (onError) {
      id2i_label_2:
      default:
      {
        (onError = 2);
      }
      case 1:
      case 2:
      case 3:
      {
        sqlite3HaltConstraint(pParse, (19 | (6 << 8)), onError, "PRIMARY KEY must be unique", (- 2));
        break;
      }
      case 5:
      {
        Trigger *pTrigger =  0;
        if ((db->flags & 0x00040000)) {
          (pTrigger = sqlite3TriggersExist(pParse, pTab, 106, 0, 0));
        }  
        if ((((! id2i_sqlite_omit_foreign_key) ) )) {
          if ((pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0))) {
            sqlite3MultiWrite(pParse);
            sqlite3GenerateRowDelete(pParse, pTab, baseCur, regRowid, 0, pTrigger, 5);
          } 
          else if (pTab->pIndex) {
            sqlite3MultiWrite(pParse);
            sqlite3GenerateRowIndexDelete(pParse, pTab, baseCur, 0);
          } 
        }  
        if (((id2i_sqlite_omit_foreign_key ) )) {
          if ((pTrigger || 0)) {
            sqlite3MultiWrite(pParse);
            sqlite3GenerateRowDelete(pParse, pTab, baseCur, regRowid, 0, pTrigger, 5);
          } 
          else if (pTab->pIndex) {
            sqlite3MultiWrite(pParse);
            sqlite3GenerateRowIndexDelete(pParse, pTab, baseCur, 0);
          } 
        }  
        (seenReplace = 1);
        break;
      }
      case 4:
      {
        ((void ) 0);
        sqlite3VdbeAddOp2(v, 14, 0, ignoreDest);
        break;
      }
    }
    sqlite3VdbeJumpHere(v, j3);
    if (isUpdate) {
      sqlite3VdbeJumpHere(v, j2);
    }  
  }  
  for ((iCur = 0), (pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext), iCur++) {
    int regIdx;
    int regR;
    int addrSkipRow =  0;
    if ((aRegIdx[iCur] == 0)) {
      continue;
    }  
    if (pIdx->pPartIdxWhere) {
      sqlite3VdbeAddOp2(v, 24, 0, aRegIdx[iCur]);
      (addrSkipRow = sqlite3VdbeMakeLabel(v));
      (pParse->ckBase = regData);
      sqlite3ExprIfFalse(pParse, pIdx->pPartIdxWhere, addrSkipRow, 0x08);
      (pParse->ckBase = 0);
    }  
    (regIdx = sqlite3GetTempRange(pParse, (pIdx->nColumn + 1)));
    for ((i = 0); (i < pIdx->nColumn); i++) {
      int idx =  pIdx->aiColumn[i];
      if ((idx == pTab->iPKey)) {
        sqlite3VdbeAddOp2(v, 29, regRowid, (regIdx + i));
      }  
      else {
        sqlite3VdbeAddOp2(v, 29, (regData + idx), (regIdx + i));
      }
    }
    sqlite3VdbeAddOp2(v, 29, regRowid, (regIdx + i));
    sqlite3VdbeAddOp3(v, 43, regIdx, (pIdx->nColumn + 1), aRegIdx[iCur]);
    sqlite3VdbeChangeP4(v, (- 1), sqlite3IndexAffinityStr(v, pIdx), 0);
    sqlite3ExprCacheAffinityChange(pParse, regIdx, (pIdx->nColumn + 1));
    (onError = pIdx->onError);
    if ((onError == 0)) {
      sqlite3ReleaseTempRange(pParse, regIdx, (pIdx->nColumn + 1));
      sqlite3VdbeResolveLabel(v, addrSkipRow);
      continue;
    }  
    if ((overrideError != 10)) {
      (onError = overrideError);
    } 
    else if ((onError == 10)) {
      (onError = 2);
    } 
    if (seenReplace) {
      if ((onError == 4)) {
        (onError = 5);
      } 
      else if ((onError == 3)) {
        (onError = 2);
      } 
    }  
    (regR = sqlite3GetTempReg(pParse));
    sqlite3VdbeAddOp2(v, 29, regOldRowid, regR);
    (j3 = sqlite3VdbeAddOp4(v, 62, (baseCur + iCur + 1), 0, regR, ((void *) ((long  int ) regIdx)), (- 14)));
    sqlite3ReleaseTempRange(pParse, regIdx, (pIdx->nColumn + 1));
    ((void ) 0);
    switch (onError) {
      case 1:
      case 2:
      case 3:
      {
        int j;
        StrAccum errMsg;
        const char *zSep;
        char *zErr;
        sqlite3StrAccumInit((&errMsg), 0, 0, 200);
        (errMsg.db = db);
        (zSep = ((pIdx->nColumn > 1) ? "columns " : "column "));
        for ((j = 0); (j < pIdx->nColumn); j++) {
          char *zCol =  pTab->aCol[pIdx->aiColumn[j]].zName;
          sqlite3StrAccumAppend((&errMsg), zSep, (- 1));
          (zSep = ", ");
          sqlite3StrAccumAppend((&errMsg), zCol, (- 1));
        }
        sqlite3StrAccumAppend((&errMsg), ((pIdx->nColumn > 1) ? " are not unique" : " is not unique"), (- 1));
        (zErr = sqlite3StrAccumFinish((&errMsg)));
        sqlite3HaltConstraint(pParse, (19 | (8 << 8)), onError, zErr, 0);
        sqlite3DbFree(errMsg.db, zErr);
        break;
      }
      case 4:
      {
        ((void ) 0);
        sqlite3VdbeAddOp2(v, 14, 0, ignoreDest);
        break;
      }
      id2i_label_3:
      default:
      {
        Trigger *pTrigger =  0;
        ((void ) 0);
        sqlite3MultiWrite(pParse);
        if ((db->flags & 0x00040000)) {
          (pTrigger = sqlite3TriggersExist(pParse, pTab, 106, 0, 0));
        }  
        sqlite3GenerateRowDelete(pParse, pTab, baseCur, regR, 0, pTrigger, 5);
        (seenReplace = 1);
        break;
      }
    }
    sqlite3VdbeJumpHere(v, j3);
    sqlite3VdbeResolveLabel(v, addrSkipRow);
    sqlite3ReleaseTempReg(pParse, regR);
  }
  if (pbMayReplace) {
    ((*pbMayReplace) = seenReplace);
  }  
}
static  void sqlite3CompleteInsertion(Parse *pParse , Table *pTab , int baseCur , int regRowid , int *aRegIdx , int isUpdate , int appendBias , int useSeekResult )  {
  int i;
  Vdbe *v;
  Index *pIdx;
  u8 pik_flags;
  int regData;
  int regRec;
  (v = sqlite3GetVdbe(pParse));
  ((void ) 0);
  ((void ) 0);
  for ((i = 0), (pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext), i++) {
    if ((aRegIdx[i] == 0)) {
      continue;
    }  
    if (pIdx->pPartIdxWhere) {
      sqlite3VdbeAddOp2(v, 73, aRegIdx[i], (sqlite3VdbeCurrentAddr(v) + 2));
    }  
    sqlite3VdbeAddOp2(v, 103, (baseCur + i + 1), aRegIdx[i]);
    if (useSeekResult) {
      sqlite3VdbeChangeP5(v, 0x10);
    }  
  }
  (regData = (regRowid + 1));
  (regRec = sqlite3GetTempReg(pParse));
  sqlite3VdbeAddOp3(v, 43, regData, pTab->nCol, regRec);
  sqlite3TableAffinityStr(v, pTab);
  sqlite3ExprCacheAffinityChange(pParse, regData, pTab->nCol);
  if (pParse->nested) {
    (pik_flags = 0);
  }  
  else {
    (pik_flags = 0x01);
    (pik_flags |= (isUpdate ? 0x04 : 0x02));
  }
  if (appendBias) {
    (pik_flags |= 0x08);
  }  
  if (useSeekResult) {
    (pik_flags |= 0x10);
  }  
  sqlite3VdbeAddOp3(v, 66, baseCur, regRec, regRowid);
  if ((! pParse->nested)) {
    sqlite3VdbeChangeP4(v, (- 1), pTab->zName, 0);
  }  
  sqlite3VdbeChangeP5(v, pik_flags);
}
static  int sqlite3OpenTableAndIndices(Parse *pParse , Table *pTab , int baseCur , int op )  {
  int i;
  int iDb;
  Index *pIdx;
  Vdbe *v;
  if (((pTab->tabFlags & 0x10) != 0)) {
    return 0;
  }  
  (iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema));
  (v = sqlite3GetVdbe(pParse));
  ((void ) 0);
  sqlite3OpenTable(pParse, baseCur, iDb, pTab, op);
  for ((i = 1), (pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext), i++) {
    KeyInfo *pKey =  sqlite3IndexKeyinfo(pParse, pIdx);
    ((void ) 0);
    sqlite3VdbeAddOp4(v, op, (i + baseCur), pIdx->tnum, iDb, ((char *) pKey), (- 16));
  }
  if ((pParse->nTab < (baseCur + i))) {
    (pParse->nTab = (baseCur + i));
  }  
  return (i - 1);
}
static  int xferCompatibleCollation(const  char *z1 , const  char *z2 )  {
  if ((z1 == 0)) {
    return (z2 == 0);
  }  
  if ((z2 == 0)) {
    return 0;
  }  
  return (sqlite3_stricmp(z1, z2) == 0);
}
static  int xferCompatibleIndex(Index *pDest , Index *pSrc )  {
  int i;
  ((void ) 0);
  ((void ) 0);
  if ((pDest->nColumn != pSrc->nColumn)) {
    return 0;
  }  
  if ((pDest->onError != pSrc->onError)) {
    return 0;
  }  
  for ((i = 0); (i < pSrc->nColumn); i++) {
    if ((pSrc->aiColumn[i] != pDest->aiColumn[i])) {
      return 0;
    }  
    if ((pSrc->aSortOrder[i] != pDest->aSortOrder[i])) {
      return 0;
    }  
    if ((! xferCompatibleCollation(pSrc->azColl[i], pDest->azColl[i]))) {
      return 0;
    }  
  }
  if (sqlite3ExprCompare(pSrc->pPartIdxWhere, pDest->pPartIdxWhere, (- 1))) {
    return 0;
  }  
  return 1;
}
static  int xferOptimization(Parse *pParse , Table *pDest , Select *pSelect , int onError , int iDbDest )  {
  ExprList *pEList;
  Table *pSrc;
  Index *pSrcIdx, *pDestIdx;
  struct  SrcList_item   *pItem;
  int i;
  int iDbSrc;
  int iSrc, iDest;
  int addr1, addr2;
  int emptyDestTest;
  int emptySrcTest;
  Vdbe *v;
  KeyInfo *pKey;
  int regAutoinc;
  int destHasUniqueIdx =  0;
  int regData, regRowid;
  if ((pSelect == 0)) {
    return 0;
  }  
  if (sqlite3TriggerList(pParse, pDest)) {
    return 0;
  }  
  if ((pDest->tabFlags & 0x10)) {
    return 0;
  }  
  if ((onError == 10)) {
    if ((pDest->iPKey >= 0)) {
      (onError = pDest->keyConf);
    }  
    if ((onError == 10)) {
      (onError = 2);
    }  
  }  
  ((void ) 0);
  if ((pSelect->pSrc->nSrc != 1)) {
    return 0;
  }  
  if (pSelect->pSrc->a[0].pSelect) {
    return 0;
  }  
  if (pSelect->pWhere) {
    return 0;
  }  
  if (pSelect->pOrderBy) {
    return 0;
  }  
  if (pSelect->pGroupBy) {
    return 0;
  }  
  if (pSelect->pLimit) {
    return 0;
  }  
  ((void ) 0);
  if (pSelect->pPrior) {
    return 0;
  }  
  if ((pSelect->selFlags & 0x0001)) {
    return 0;
  }  
  (pEList = pSelect->pEList);
  ((void ) 0);
  if ((pEList->nExpr != 1)) {
    return 0;
  }  
  ((void ) 0);
  if ((pEList->a[0].pExpr->op != 113)) {
    return 0;
  }  
  (pItem = pSelect->pSrc->a);
  (pSrc = sqlite3LocateTableItem(pParse, 0, pItem));
  if ((pSrc == 0)) {
    return 0;
  }  
  if ((pSrc == pDest)) {
    return 0;
  }  
  if ((pSrc->tabFlags & 0x10)) {
    return 0;
  }  
  if (pSrc->pSelect) {
    return 0;
  }  
  if ((pDest->nCol != pSrc->nCol)) {
    return 0;
  }  
  if ((pDest->iPKey != pSrc->iPKey)) {
    return 0;
  }  
  for ((i = 0); (i < pDest->nCol); i++) {
    if ((pDest->aCol[i].affinity != pSrc->aCol[i].affinity)) {
      return 0;
    }  
    if ((! xferCompatibleCollation(pDest->aCol[i].zColl, pSrc->aCol[i].zColl))) {
      return 0;
    }  
    if ((pDest->aCol[i].notNull && (! pSrc->aCol[i].notNull))) {
      return 0;
    }  
  }
  for ((pDestIdx = pDest->pIndex); pDestIdx; (pDestIdx = pDestIdx->pNext)) {
    if ((pDestIdx->onError != 0)) {
      (destHasUniqueIdx = 1);
    }  
    for ((pSrcIdx = pSrc->pIndex); pSrcIdx; (pSrcIdx = pSrcIdx->pNext)) {
      if (xferCompatibleIndex(pDestIdx, pSrcIdx)) {
        break;
      }  
    }
    if ((pSrcIdx == 0)) {
      return 0;
    }  
  }
  if ((pDest->pCheck && sqlite3ExprListCompare(pSrc->pCheck, pDest->pCheck, (- 1)))) {
    return 0;
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    if ((((pParse->db->flags & 0x00080000) != 0) && (pDest->pFKey != 0))) {
      return 0;
    }  
  }  
  if (((pParse->db->flags & 0x00000080) != 0)) {
    return 0;
  }  
  (iDbSrc = sqlite3SchemaToIndex(pParse->db, pSrc->pSchema));
  (v = sqlite3GetVdbe(pParse));
  sqlite3CodeVerifySchema(pParse, iDbSrc);
  (iSrc = pParse->nTab++);
  (iDest = pParse->nTab++);
  (regAutoinc = autoIncBegin(pParse, iDbDest, pDest));
  sqlite3OpenTable(pParse, iDest, iDbDest, pDest, 49);
  if ((((pDest->iPKey < 0) && (pDest->pIndex != 0)) || destHasUniqueIdx || ((onError != 2) && (onError != 1)))) {
    (addr1 = sqlite3VdbeAddOp2(v, 101, iDest, 0));
    (emptyDestTest = sqlite3VdbeAddOp2(v, 14, 0, 0));
    sqlite3VdbeJumpHere(v, addr1);
  }  
  else {
    (emptyDestTest = 0);
  }
  sqlite3OpenTable(pParse, iSrc, iDbSrc, pSrc, 48);
  (emptySrcTest = sqlite3VdbeAddOp2(v, 101, iSrc, 0));
  (regData = sqlite3GetTempReg(pParse));
  (regRowid = sqlite3GetTempReg(pParse));
  if ((pDest->iPKey >= 0)) {
    (addr1 = sqlite3VdbeAddOp2(v, 96, iSrc, regRowid));
    (addr2 = sqlite3VdbeAddOp3(v, 63, iDest, 0, regRowid));
    sqlite3HaltConstraint(pParse, (19 | (6 << 8)), onError, "PRIMARY KEY must be unique", (- 2));
    sqlite3VdbeJumpHere(v, addr2);
    autoIncStep(pParse, regAutoinc, regRowid);
  } 
  else if ((pDest->pIndex == 0)) {
    (addr1 = sqlite3VdbeAddOp2(v, 65, iDest, regRowid));
  } 
  else {
    (addr1 = sqlite3VdbeAddOp2(v, 96, iSrc, regRowid));
    ((void ) 0);
  }
  sqlite3VdbeAddOp2(v, 95, iSrc, regData);
  sqlite3VdbeAddOp3(v, 66, iDest, regData, regRowid);
  sqlite3VdbeChangeP5(v, (0x01 | 0x02 | 0x08));
  sqlite3VdbeChangeP4(v, (- 1), pDest->zName, 0);
  sqlite3VdbeAddOp2(v, 7, iSrc, addr1);
  for ((pDestIdx = pDest->pIndex); pDestIdx; (pDestIdx = pDestIdx->pNext)) {
    if (((id2i_sqlite_coverage_test ) )) {
      for ((pSrcIdx = pSrc->pIndex); 1; (pSrcIdx = pSrcIdx->pNext)) {
        if (xferCompatibleIndex(pDestIdx, pSrcIdx)) {
          break;
        }  
      }
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      for ((pSrcIdx = pSrc->pIndex); pSrcIdx; (pSrcIdx = pSrcIdx->pNext)) {
        if (xferCompatibleIndex(pDestIdx, pSrcIdx)) {
          break;
        }  
      }
    }  
    ((void ) 0);
    sqlite3VdbeAddOp2(v, 54, iSrc, 0);
    sqlite3VdbeAddOp2(v, 54, iDest, 0);
    (pKey = sqlite3IndexKeyinfo(pParse, pSrcIdx));
    sqlite3VdbeAddOp4(v, 48, iSrc, pSrcIdx->tnum, iDbSrc, ((char *) pKey), (- 16));
    (pKey = sqlite3IndexKeyinfo(pParse, pDestIdx));
    sqlite3VdbeAddOp4(v, 49, iDest, pDestIdx->tnum, iDbDest, ((char *) pKey), (- 16));
    sqlite3VdbeChangeP5(v, 0x01);
    (addr1 = sqlite3VdbeAddOp2(v, 101, iSrc, 0));
    sqlite3VdbeAddOp2(v, 92, iSrc, regData);
    sqlite3VdbeAddOp3(v, 103, iDest, regData, 1);
    sqlite3VdbeAddOp2(v, 7, iSrc, (addr1 + 1));
    sqlite3VdbeJumpHere(v, addr1);
  }
  sqlite3VdbeJumpHere(v, emptySrcTest);
  sqlite3ReleaseTempReg(pParse, regRowid);
  sqlite3ReleaseTempReg(pParse, regData);
  sqlite3VdbeAddOp2(v, 54, iSrc, 0);
  sqlite3VdbeAddOp2(v, 54, iDest, 0);
  if (emptyDestTest) {
    sqlite3VdbeAddOp2(v, 20, 0, 0);
    sqlite3VdbeJumpHere(v, emptyDestTest);
    sqlite3VdbeAddOp2(v, 54, iDest, 0);
    return 0;
  }  
  else {
    return 1;
  }
}
int sqlite3_exec(sqlite3 *db , const  char *zSql , sqlite3_callback xCallback , void *pArg , char **pzErrMsg )  {
  int rc =  0;
  const char *zLeftover;
  sqlite3_stmt *pStmt =  0;
  char **azCols =  0;
  int callbackIsInit;
  if ((! sqlite3SafetyCheckOk(db))) {
    return sqlite3MisuseError(93644);
  }  
  if ((zSql == 0)) {
    (zSql = "");
  }  
  sqlite3Error(db, 0, 0);
  while (((rc == 0) && zSql[0])) {
    int nCol;
    char **azVals =  0;
    (pStmt = 0);
    (rc = sqlite3_prepare_v2(db, zSql, (- 1), (&pStmt), (&zLeftover)));
    ((void ) 0);
    if ((rc != 0)) {
      continue;
    }  
    if ((! pStmt)) {
      (zSql = zLeftover);
      continue;
    }  
    (callbackIsInit = 0);
    (nCol = sqlite3_column_count(pStmt));
    while (1) {
      int i;
      (rc = sqlite3_step(pStmt));
      if ((xCallback && ((100 == rc) || ((101 == rc) && (! callbackIsInit) && (db->flags & 0x00000100))))) {
        if ((! callbackIsInit)) {
          (azCols = sqlite3DbMallocZero(db, ((2 * nCol * sizeof(const  char *)) + 1)));
          if ((azCols == 0)) {
            goto exec_out;
          }  
          for ((i = 0); (i < nCol); i++) {
            (azCols[i] = ((char *) sqlite3_column_name(pStmt, i)));
            ((void ) 0);
          }
          (callbackIsInit = 1);
        }  
        if ((rc == 100)) {
          (azVals = (&azCols[nCol]));
          for ((i = 0); (i < nCol); i++) {
            (azVals[i] = ((char *) sqlite3_column_text(pStmt, i)));
            if (((! azVals[i]) && (sqlite3_column_type(pStmt, i) != 5))) {
              (db->mallocFailed = 1);
              goto exec_out;
            }  
          }
        }  
        if (xCallback(pArg, nCol, azVals, azCols)) {
          (rc = 4);
          sqlite3VdbeFinalize(((Vdbe *) pStmt));
          (pStmt = 0);
          sqlite3Error(db, 4, 0);
          goto exec_out;
        }  
      }  
      if ((rc != 100)) {
        (rc = sqlite3VdbeFinalize(((Vdbe *) pStmt)));
        (pStmt = 0);
        (zSql = zLeftover);
        while ((sqlite3CtypeMap[((unsigned  char ) zSql[0])] & 0x01)) {
          zSql++;
        }
        break;
      }  
    }
    sqlite3DbFree(db, azCols);
    (azCols = 0);
  }
  exec_out:
  if (pStmt) {
    sqlite3VdbeFinalize(((Vdbe *) pStmt));
  }  
  sqlite3DbFree(db, azCols);
  (rc = sqlite3ApiExit(db, rc));
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((rc != 0) && (rc == sqlite3_errcode(db)) && pzErrMsg)) {
      int nErrMsg =  (1 + sqlite3Strlen30(sqlite3_errmsg(db)));
      ((*pzErrMsg) = sqlite3Malloc(nErrMsg));
      if ((*pzErrMsg)) {
        memcpy((*pzErrMsg), sqlite3_errmsg(db), nErrMsg);
      }  
      else {
        (rc = 7);
        sqlite3Error(db, 7, 0);
      }
    } 
    else if (pzErrMsg) {
      ((*pzErrMsg) = 0);
    } 
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((rc != 0) && 1 && pzErrMsg)) {
      int nErrMsg =  (1 + sqlite3Strlen30(sqlite3_errmsg(db)));
      ((*pzErrMsg) = sqlite3Malloc(nErrMsg));
      if ((*pzErrMsg)) {
        memcpy((*pzErrMsg), sqlite3_errmsg(db), nErrMsg);
      }  
      else {
        (rc = 7);
        sqlite3Error(db, 7, 0);
      }
    } 
    else if (pzErrMsg) {
      ((*pzErrMsg) = 0);
    } 
  }  
  ((void ) 0);
  return rc;
}
typedef struct  sqlite3_api_routines   sqlite3_api_routines;
struct  sqlite3_api_routines {
  void *( *aggregate_context)(sqlite3_context * , int nBytes ) ;
  int ( *aggregate_count)(sqlite3_context * ) ;
  int ( *bind_blob)(sqlite3_stmt * , int , const  void * , int n , void ( *)(void * ) ) ;
  int ( *bind_double)(sqlite3_stmt * , int , double ) ;
  int ( *bind_int)(sqlite3_stmt * , int , int ) ;
  int ( *bind_int64)(sqlite3_stmt * , int , sqlite_int64 ) ;
  int ( *bind_null)(sqlite3_stmt * , int ) ;
  int ( *bind_parameter_count)(sqlite3_stmt * ) ;
  int ( *bind_parameter_index)(sqlite3_stmt * , const  char *zName ) ;
  const  char *( *bind_parameter_name)(sqlite3_stmt * , int ) ;
  int ( *bind_text)(sqlite3_stmt * , int , const  char * , int n , void ( *)(void * ) ) ;
  int ( *bind_text16)(sqlite3_stmt * , int , const  void * , int , void ( *)(void * ) ) ;
  int ( *bind_value)(sqlite3_stmt * , int , const  sqlite3_value * ) ;
  int ( *busy_handler)(sqlite3 * , int ( *)(void * , int ) , void * ) ;
  int ( *busy_timeout)(sqlite3 * , int ms ) ;
  int ( *changes)(sqlite3 * ) ;
  int ( *close)(sqlite3 * ) ;
  int ( *collation_needed)(sqlite3 * , void * , void ( *)(void * , sqlite3 * , int eTextRep , const  char * ) ) ;
  int ( *collation_needed16)(sqlite3 * , void * , void ( *)(void * , sqlite3 * , int eTextRep , const  void * ) ) ;
  const  void *( *column_blob)(sqlite3_stmt * , int iCol ) ;
  int ( *column_bytes)(sqlite3_stmt * , int iCol ) ;
  int ( *column_bytes16)(sqlite3_stmt * , int iCol ) ;
  int ( *column_count)(sqlite3_stmt *pStmt ) ;
  const  char *( *column_database_name)(sqlite3_stmt * , int ) ;
  const  void *( *column_database_name16)(sqlite3_stmt * , int ) ;
  const  char *( *column_decltype)(sqlite3_stmt * , int i ) ;
  const  void *( *column_decltype16)(sqlite3_stmt * , int ) ;
  double ( *column_double)(sqlite3_stmt * , int iCol ) ;
  int ( *column_int)(sqlite3_stmt * , int iCol ) ;
  sqlite_int64 ( *column_int64)(sqlite3_stmt * , int iCol ) ;
  const  char *( *column_name)(sqlite3_stmt * , int ) ;
  const  void *( *column_name16)(sqlite3_stmt * , int ) ;
  const  char *( *column_origin_name)(sqlite3_stmt * , int ) ;
  const  void *( *column_origin_name16)(sqlite3_stmt * , int ) ;
  const  char *( *column_table_name)(sqlite3_stmt * , int ) ;
  const  void *( *column_table_name16)(sqlite3_stmt * , int ) ;
  const  unsigned  char *( *column_text)(sqlite3_stmt * , int iCol ) ;
  const  void *( *column_text16)(sqlite3_stmt * , int iCol ) ;
  int ( *column_type)(sqlite3_stmt * , int iCol ) ;
  sqlite3_value *( *column_value)(sqlite3_stmt * , int iCol ) ;
  void *( *commit_hook)(sqlite3 * , int ( *)(void * ) , void * ) ;
  int ( *complete)(const  char *sql ) ;
  int ( *complete16)(const  void *sql ) ;
  int ( *create_collation)(sqlite3 * , const  char * , int , void * , int ( *)(void * , int , const  void * , int , const  void * ) ) ;
  int ( *create_collation16)(sqlite3 * , const  void * , int , void * , int ( *)(void * , int , const  void * , int , const  void * ) ) ;
  int ( *create_function)(sqlite3 * , const  char * , int , int , void * , void ( *xFunc)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xStep)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xFinal)(sqlite3_context * ) ) ;
  int ( *create_function16)(sqlite3 * , const  void * , int , int , void * , void ( *xFunc)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xStep)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xFinal)(sqlite3_context * ) ) ;
  int ( *create_module)(sqlite3 * , const  char * , const  sqlite3_module * , void * ) ;
  int ( *data_count)(sqlite3_stmt *pStmt ) ;
  sqlite3 *( *db_handle)(sqlite3_stmt * ) ;
  int ( *declare_vtab)(sqlite3 * , const  char * ) ;
  int ( *enable_shared_cache)(int ) ;
  int ( *errcode)(sqlite3 *db ) ;
  const  char *( *errmsg)(sqlite3 * ) ;
  const  void *( *errmsg16)(sqlite3 * ) ;
  int ( *exec)(sqlite3 * , const  char * , sqlite3_callback , void * , char ** ) ;
  int ( *expired)(sqlite3_stmt * ) ;
  int ( *finalize)(sqlite3_stmt *pStmt ) ;
  void ( *free)(void * ) ;
  void ( *free_table)(char **result ) ;
  int ( *get_autocommit)(sqlite3 * ) ;
  void *( *get_auxdata)(sqlite3_context * , int ) ;
  int ( *get_table)(sqlite3 * , const  char * , char *** , int * , int * , char ** ) ;
  int ( *global_recover)(void ) ;
  void ( *interruptx)(sqlite3 * ) ;
  sqlite_int64 ( *last_insert_rowid)(sqlite3 * ) ;
  const  char *( *libversion)(void ) ;
  int ( *libversion_number)(void ) ;
  void *( *malloc)(int ) ;
  char *( *mprintf)(const  char * , ...) ;
  int ( *open)(const  char * , sqlite3 ** ) ;
  int ( *open16)(const  void * , sqlite3 ** ) ;
  int ( *prepare)(sqlite3 * , const  char * , int , sqlite3_stmt ** , const  char ** ) ;
  int ( *prepare16)(sqlite3 * , const  void * , int , sqlite3_stmt ** , const  void ** ) ;
  void *( *profile)(sqlite3 * , void ( *)(void * , const  char * , sqlite_uint64 ) , void * ) ;
  void ( *progress_handler)(sqlite3 * , int , int ( *)(void * ) , void * ) ;
  void *( *realloc)(void * , int ) ;
  int ( *reset)(sqlite3_stmt *pStmt ) ;
  void ( *result_blob)(sqlite3_context * , const  void * , int , void ( *)(void * ) ) ;
  void ( *result_double)(sqlite3_context * , double ) ;
  void ( *result_error)(sqlite3_context * , const  char * , int ) ;
  void ( *result_error16)(sqlite3_context * , const  void * , int ) ;
  void ( *result_int)(sqlite3_context * , int ) ;
  void ( *result_int64)(sqlite3_context * , sqlite_int64 ) ;
  void ( *result_null)(sqlite3_context * ) ;
  void ( *result_text)(sqlite3_context * , const  char * , int , void ( *)(void * ) ) ;
  void ( *result_text16)(sqlite3_context * , const  void * , int , void ( *)(void * ) ) ;
  void ( *result_text16be)(sqlite3_context * , const  void * , int , void ( *)(void * ) ) ;
  void ( *result_text16le)(sqlite3_context * , const  void * , int , void ( *)(void * ) ) ;
  void ( *result_value)(sqlite3_context * , sqlite3_value * ) ;
  void *( *rollback_hook)(sqlite3 * , void ( *)(void * ) , void * ) ;
  int ( *set_authorizer)(sqlite3 * , int ( *)(void * , int , const  char * , const  char * , const  char * , const  char * ) , void * ) ;
  void ( *set_auxdata)(sqlite3_context * , int , void * , void ( *)(void * ) ) ;
  char *( *snprintf)(int , char * , const  char * , ...) ;
  int ( *step)(sqlite3_stmt * ) ;
  int ( *table_column_metadata)(sqlite3 * , const  char * , const  char * , const  char * , char  const ** , char  const ** , int * , int * , int * ) ;
  void ( *thread_cleanup)(void ) ;
  int ( *total_changes)(sqlite3 * ) ;
  void *( *trace)(sqlite3 * , void ( *xTrace)(void * , const  char * ) , void * ) ;
  int ( *transfer_bindings)(sqlite3_stmt * , sqlite3_stmt * ) ;
  void *( *update_hook)(sqlite3 * , void ( *)(void * , int , char  const * , char  const * , sqlite_int64 ) , void * ) ;
  void *( *user_data)(sqlite3_context * ) ;
  const  void *( *value_blob)(sqlite3_value * ) ;
  int ( *value_bytes)(sqlite3_value * ) ;
  int ( *value_bytes16)(sqlite3_value * ) ;
  double ( *value_double)(sqlite3_value * ) ;
  int ( *value_int)(sqlite3_value * ) ;
  sqlite_int64 ( *value_int64)(sqlite3_value * ) ;
  int ( *value_numeric_type)(sqlite3_value * ) ;
  const  unsigned  char *( *value_text)(sqlite3_value * ) ;
  const  void *( *value_text16)(sqlite3_value * ) ;
  const  void *( *value_text16be)(sqlite3_value * ) ;
  const  void *( *value_text16le)(sqlite3_value * ) ;
  int ( *value_type)(sqlite3_value * ) ;
  char *( *vmprintf)(const  char * , va_list ) ;
  int ( *overload_function)(sqlite3 * , const  char *zFuncName , int nArg ) ;
  int ( *prepare_v2)(sqlite3 * , const  char * , int , sqlite3_stmt ** , const  char ** ) ;
  int ( *prepare16_v2)(sqlite3 * , const  void * , int , sqlite3_stmt ** , const  void ** ) ;
  int ( *clear_bindings)(sqlite3_stmt * ) ;
  int ( *create_module_v2)(sqlite3 * , const  char * , const  sqlite3_module * , void * , void ( *xDestroy)(void * ) ) ;
  int ( *bind_zeroblob)(sqlite3_stmt * , int , int ) ;
  int ( *blob_bytes)(sqlite3_blob * ) ;
  int ( *blob_close)(sqlite3_blob * ) ;
  int ( *blob_open)(sqlite3 * , const  char * , const  char * , const  char * , sqlite3_int64 , int , sqlite3_blob ** ) ;
  int ( *blob_read)(sqlite3_blob * , void * , int , int ) ;
  int ( *blob_write)(sqlite3_blob * , const  void * , int , int ) ;
  int ( *create_collation_v2)(sqlite3 * , const  char * , int , void * , int ( *)(void * , int , const  void * , int , const  void * ) , void ( *)(void * ) ) ;
  int ( *file_control)(sqlite3 * , const  char * , int , void * ) ;
  sqlite3_int64 ( *memory_highwater)(int ) ;
  sqlite3_int64 ( *memory_used)(void ) ;
  sqlite3_mutex *( *mutex_alloc)(int ) ;
  void ( *mutex_enter)(sqlite3_mutex * ) ;
  void ( *mutex_free)(sqlite3_mutex * ) ;
  void ( *mutex_leave)(sqlite3_mutex * ) ;
  int ( *mutex_try)(sqlite3_mutex * ) ;
  int ( *open_v2)(const  char * , sqlite3 ** , int , const  char * ) ;
  int ( *release_memory)(int ) ;
  void ( *result_error_nomem)(sqlite3_context * ) ;
  void ( *result_error_toobig)(sqlite3_context * ) ;
  int ( *sleep)(int ) ;
  void ( *soft_heap_limit)(int ) ;
  sqlite3_vfs *( *vfs_find)(const  char * ) ;
  int ( *vfs_register)(sqlite3_vfs * , int ) ;
  int ( *vfs_unregister)(sqlite3_vfs * ) ;
  int ( *xthreadsafe)(void ) ;
  void ( *result_zeroblob)(sqlite3_context * , int ) ;
  void ( *result_error_code)(sqlite3_context * , int ) ;
  int ( *test_control)(int , ...) ;
  void ( *randomness)(int , void * ) ;
  sqlite3 *( *context_db_handle)(sqlite3_context * ) ;
  int ( *extended_result_codes)(sqlite3 * , int ) ;
  int ( *limit)(sqlite3 * , int , int ) ;
  sqlite3_stmt *( *next_stmt)(sqlite3 * , sqlite3_stmt * ) ;
  const  char *( *sql)(sqlite3_stmt * ) ;
  int ( *status)(int , int * , int * , int ) ;
  int ( *backup_finish)(sqlite3_backup * ) ;
  sqlite3_backup *( *backup_init)(sqlite3 * , const  char * , sqlite3 * , const  char * ) ;
  int ( *backup_pagecount)(sqlite3_backup * ) ;
  int ( *backup_remaining)(sqlite3_backup * ) ;
  int ( *backup_step)(sqlite3_backup * , int ) ;
  const  char *( *compileoption_get)(int ) ;
  int ( *compileoption_used)(const  char * ) ;
  int ( *create_function_v2)(sqlite3 * , const  char * , int , int , void * , void ( *xFunc)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xStep)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xFinal)(sqlite3_context * ) , void ( *xDestroy)(void * ) ) ;
  int ( *db_config)(sqlite3 * , int , ...) ;
  sqlite3_mutex *( *db_mutex)(sqlite3 * ) ;
  int ( *db_status)(sqlite3 * , int , int * , int * , int ) ;
  int ( *extended_errcode)(sqlite3 * ) ;
  void ( *log)(int , const  char * , ...) ;
  sqlite3_int64 ( *soft_heap_limit64)(sqlite3_int64 ) ;
  const  char *( *sourceid)(void ) ;
  int ( *stmt_status)(sqlite3_stmt * , int , int ) ;
  int ( *strnicmp)(const  char * , const  char * , int ) ;
  int ( *unlock_notify)(sqlite3 * , void ( *)(void ** , int ) , void * ) ;
  int ( *wal_autocheckpoint)(sqlite3 * , int ) ;
  int ( *wal_checkpoint)(sqlite3 * , const  char * ) ;
  void *( *wal_hook)(sqlite3 * , int ( *)(void * , sqlite3 * , const  char * , int ) , void * ) ;
  int ( *blob_reopen)(sqlite3_blob * , sqlite3_int64 ) ;
  int ( *vtab_config)(sqlite3 * , int op , ...) ;
  int ( *vtab_on_conflict)(sqlite3 * ) ;
  int ( *close_v2)(sqlite3 * ) ;
  const  char *( *db_filename)(sqlite3 * , const  char * ) ;
  int ( *db_readonly)(sqlite3 * , const  char * ) ;
  int ( *db_release_memory)(sqlite3 * ) ;
  const  char *( *errstr)(int ) ;
  int ( *stmt_busy)(sqlite3_stmt * ) ;
  int ( *stmt_readonly)(sqlite3_stmt * ) ;
  int ( *stricmp)(const  char * , const  char * ) ;
  int ( *uri_boolean)(const  char * , const  char * , int ) ;
  sqlite3_int64 ( *uri_int64)(const  char * , const  char * , sqlite3_int64 ) ;
  const  char *( *uri_parameter)(const  char * , const  char * ) ;
  char *( *vsnprintf)(int , char * , const  char * , va_list ) ;
  int ( *wal_checkpoint_v2)(sqlite3 * , const  char * , int , int * , int * ) ;
}  ;
static const sqlite3_api_routines sqlite3Apis =  { 0};
typedef struct  sqlite3AutoExtList   sqlite3AutoExtList;
static struct  sqlite3AutoExtList {
  int nExt ;
  void ( **aExt)(void ) ;
}  sqlite3Autoext =  { 0,  0};
int sqlite3_auto_extension(void ( *xInit)(void ) )  {
  int rc =  0;
  (rc = sqlite3_initialize());
  if (rc) {
    return rc;
  }  
  else {
    int i;
    for ((i = 0); (i < sqlite3Autoext.nExt); i++) {
      if ((sqlite3Autoext.aExt[i] == xInit)) {
        break;
      }  
    }
    if ((i == sqlite3Autoext.nExt)) {
      int nByte =  ((sqlite3Autoext.nExt + 1) * sizeof(sqlite3Autoext.aExt[0]));
      void ( **aNew)(void );
      (aNew = sqlite3_realloc(sqlite3Autoext.aExt, nByte));
      if ((aNew == 0)) {
        (rc = 7);
      }  
      else {
        (sqlite3Autoext.aExt = aNew);
        (sqlite3Autoext.aExt[sqlite3Autoext.nExt] = xInit);
        sqlite3Autoext.nExt++;
      }
    }  
    ((void ) 0);
    return rc;
  }
}
int sqlite3_cancel_auto_extension(void ( *xInit)(void ) )  {
  int i;
  int n =  0;
  for ((i = (sqlite3Autoext.nExt - 1)); (i >= 0); i--) {
    if ((sqlite3Autoext.aExt[i] == xInit)) {
      sqlite3Autoext.nExt--;
      (sqlite3Autoext.aExt[i] = sqlite3Autoext.aExt[sqlite3Autoext.nExt]);
      n++;
      break;
    }  
  }
  return n;
}
void sqlite3_reset_auto_extension(void )  {
  if ((sqlite3_initialize() == 0)) {
    sqlite3_free(sqlite3Autoext.aExt);
    (sqlite3Autoext.aExt = 0);
    (sqlite3Autoext.nExt = 0);
  }  
}
static  void sqlite3AutoLoadExtensions(sqlite3 *db )  {
  int i;
  int go =  1;
  int rc;
  int ( *xInit)(sqlite3 * , char ** , const  sqlite3_api_routines * );
  if ((sqlite3Autoext.nExt == 0)) {
    return;
  }  
  for ((i = 0); go; i++) {
    char *zErrmsg;
    if ((i >= sqlite3Autoext.nExt)) {
      (xInit = 0);
      (go = 0);
    }  
    else {
      (xInit = ((int ( *)(sqlite3 * , char ** , const  sqlite3_api_routines * )) sqlite3Autoext.aExt[i]));
    }
    (zErrmsg = 0);
    if ((xInit && ((rc = xInit(db, (&zErrmsg), (&sqlite3Apis))) != 0))) {
      sqlite3Error(db, rc, "automatic extension loading failed: %s", zErrmsg);
      (go = 0);
    }  
    sqlite3_free(zErrmsg);
  }
}
static const struct  sPragmaNames {
  const  char *const zName ;
  u8 ePragTyp ;
  u8 mPragFlag ;
  u32 iArg ;
}  ;
static const struct  sPragmaNames   _1334_aPragmaNames[] =  { { "application_id",  0,  0,  0},  { "automatic_index",  2,  0,  0x00100000},  { "busy_timeout",  3,  0,  0},  { "cache_spill",  2,  0,  0x00000010},  { "case_sensitive_like",  5,  0,  0},  { "checkpoint_fullfsync",  2,  0,  0x00000008},  { "collation_list",  6,  0,  0},  { "compile_options",  7,  0,  0},  { "count_changes",  2,  0,  0x00000080},  { "database_list",  9,  0x01,  0},  { "empty_result_callbacks",  2,  0,  0x00000100},  { "encoding",  11,  0,  0},  { "freelist_count",  0,  0,  0},  { "full_column_names",  2,  0,  0x00000020},  { "fullfsync",  2,  0,  0x00000004},  { "ignore_check_constraints",  2,  0,  0x00002000},  { "index_info",  15,  0x01,  0},  { "index_list",  16,  0x01,  0},  { "integrity_check",  17,  0x01,  0},  { "legacy_file_format",  2,  0,  0x00008000},  { "query_only",  2,  0,  0x02000000},  { "quick_check",  17,  0x01,  0},  { "read_uncommitted",  2,  0,  0x0004000},  { "recursive_triggers",  2,  0,  0x00040000},  { "reverse_unordered_selects",  2,  0,  0x00020000},  { "schema_version",  0,  0,  0},  { "short_column_names",  2,  0,  0x00000040},  { "shrink_memory",  26,  0,  0},  { "soft_heap_limit",  27,  0,  0},  { "stats",  28,  0x01,  0},  { "table_info",  30,  0x01,  0},  { "user_version",  0,  0,  0},  { "wal_autocheckpoint",  33,  0,  0},  { "wal_checkpoint",  34,  0x01,  0},  { "writable_schema",  2,  0,  (0x00000800 | 0x00010000)}};
static const struct  sPragmaNames   _1335_aPragmaNames[] =  { { "application_id",  0,  0,  0},  { "automatic_index",  2,  0,  0x00100000},  { "busy_timeout",  3,  0,  0},  { "cache_spill",  2,  0,  0x00000010},  { "case_sensitive_like",  5,  0,  0},  { "checkpoint_fullfsync",  2,  0,  0x00000008},  { "collation_list",  6,  0,  0},  { "compile_options",  7,  0,  0},  { "count_changes",  2,  0,  0x00000080},  { "database_list",  9,  0x01,  0},  { "defer_foreign_keys",  2,  0,  0x01000000},  { "empty_result_callbacks",  2,  0,  0x00000100},  { "encoding",  11,  0,  0},  { "foreign_key_check",  12,  0x01,  0},  { "foreign_key_list",  13,  0x01,  0},  { "foreign_keys",  2,  0,  0x00080000},  { "freelist_count",  0,  0,  0},  { "full_column_names",  2,  0,  0x00000020},  { "fullfsync",  2,  0,  0x00000004},  { "ignore_check_constraints",  2,  0,  0x00002000},  { "index_info",  15,  0x01,  0},  { "index_list",  16,  0x01,  0},  { "integrity_check",  17,  0x01,  0},  { "legacy_file_format",  2,  0,  0x00008000},  { "query_only",  2,  0,  0x02000000},  { "quick_check",  17,  0x01,  0},  { "read_uncommitted",  2,  0,  0x0004000},  { "recursive_triggers",  2,  0,  0x00040000},  { "reverse_unordered_selects",  2,  0,  0x00020000},  { "schema_version",  0,  0,  0},  { "short_column_names",  2,  0,  0x00000040},  { "shrink_memory",  26,  0,  0},  { "soft_heap_limit",  27,  0,  0},  { "stats",  28,  0x01,  0},  { "table_info",  30,  0x01,  0},  { "user_version",  0,  0,  0},  { "wal_autocheckpoint",  33,  0,  0},  { "wal_checkpoint",  34,  0x01,  0},  { "writable_schema",  2,  0,  (0x00000800 | 0x00010000)}};
static const struct  sPragmaNames   _1336_aPragmaNames[] =  { { "application_id",  0,  0,  0},  { "automatic_index",  2,  0,  0x00100000},  { "busy_timeout",  3,  0,  0},  { "cache_size",  4,  0x01,  0},  { "cache_spill",  2,  0,  0x00000010},  { "case_sensitive_like",  5,  0,  0},  { "checkpoint_fullfsync",  2,  0,  0x00000008},  { "collation_list",  6,  0,  0},  { "compile_options",  7,  0,  0},  { "count_changes",  2,  0,  0x00000080},  { "database_list",  9,  0x01,  0},  { "empty_result_callbacks",  2,  0,  0x00000100},  { "encoding",  11,  0,  0},  { "freelist_count",  0,  0,  0},  { "full_column_names",  2,  0,  0x00000020},  { "fullfsync",  2,  0,  0x00000004},  { "ignore_check_constraints",  2,  0,  0x00002000},  { "index_info",  15,  0x01,  0},  { "index_list",  16,  0x01,  0},  { "integrity_check",  17,  0x01,  0},  { "journal_mode",  18,  0x01,  0},  { "journal_size_limit",  19,  0,  0},  { "legacy_file_format",  2,  0,  0x00008000},  { "locking_mode",  21,  0,  0},  { "max_page_count",  22,  0x01,  0},  { "mmap_size",  23,  0,  0},  { "page_count",  22,  0x01,  0},  { "page_size",  24,  0,  0},  { "query_only",  2,  0,  0x02000000},  { "quick_check",  17,  0x01,  0},  { "read_uncommitted",  2,  0,  0x0004000},  { "recursive_triggers",  2,  0,  0x00040000},  { "reverse_unordered_selects",  2,  0,  0x00020000},  { "schema_version",  0,  0,  0},  { "secure_delete",  25,  0,  0},  { "short_column_names",  2,  0,  0x00000040},  { "shrink_memory",  26,  0,  0},  { "soft_heap_limit",  27,  0,  0},  { "stats",  28,  0x01,  0},  { "synchronous",  29,  0x01,  0},  { "table_info",  30,  0x01,  0},  { "temp_store",  31,  0,  0},  { "temp_store_directory",  32,  0,  0},  { "user_version",  0,  0,  0},  { "wal_autocheckpoint",  33,  0,  0},  { "wal_checkpoint",  34,  0x01,  0},  { "writable_schema",  2,  0,  (0x00000800 | 0x00010000)}};
static const struct  sPragmaNames   _1337_aPragmaNames[] =  { { "application_id",  0,  0,  0},  { "automatic_index",  2,  0,  0x00100000},  { "busy_timeout",  3,  0,  0},  { "cache_size",  4,  0x01,  0},  { "cache_spill",  2,  0,  0x00000010},  { "case_sensitive_like",  5,  0,  0},  { "checkpoint_fullfsync",  2,  0,  0x00000008},  { "collation_list",  6,  0,  0},  { "compile_options",  7,  0,  0},  { "count_changes",  2,  0,  0x00000080},  { "database_list",  9,  0x01,  0},  { "defer_foreign_keys",  2,  0,  0x01000000},  { "empty_result_callbacks",  2,  0,  0x00000100},  { "encoding",  11,  0,  0},  { "foreign_key_check",  12,  0x01,  0},  { "foreign_key_list",  13,  0x01,  0},  { "foreign_keys",  2,  0,  0x00080000},  { "freelist_count",  0,  0,  0},  { "full_column_names",  2,  0,  0x00000020},  { "fullfsync",  2,  0,  0x00000004},  { "ignore_check_constraints",  2,  0,  0x00002000},  { "index_info",  15,  0x01,  0},  { "index_list",  16,  0x01,  0},  { "integrity_check",  17,  0x01,  0},  { "journal_mode",  18,  0x01,  0},  { "journal_size_limit",  19,  0,  0},  { "legacy_file_format",  2,  0,  0x00008000},  { "locking_mode",  21,  0,  0},  { "max_page_count",  22,  0x01,  0},  { "mmap_size",  23,  0,  0},  { "page_count",  22,  0x01,  0},  { "page_size",  24,  0,  0},  { "query_only",  2,  0,  0x02000000},  { "quick_check",  17,  0x01,  0},  { "read_uncommitted",  2,  0,  0x0004000},  { "recursive_triggers",  2,  0,  0x00040000},  { "reverse_unordered_selects",  2,  0,  0x00020000},  { "schema_version",  0,  0,  0},  { "secure_delete",  25,  0,  0},  { "short_column_names",  2,  0,  0x00000040},  { "shrink_memory",  26,  0,  0},  { "soft_heap_limit",  27,  0,  0},  { "stats",  28,  0x01,  0},  { "synchronous",  29,  0x01,  0},  { "table_info",  30,  0x01,  0},  { "temp_store",  31,  0,  0},  { "temp_store_directory",  32,  0,  0},  { "user_version",  0,  0,  0},  { "wal_autocheckpoint",  33,  0,  0},  { "wal_checkpoint",  34,  0x01,  0},  { "writable_schema",  2,  0,  (0x00000800 | 0x00010000)}};
static const struct  sPragmaNames   _1338_aPragmaNames[] =  { { "application_id",  0,  0,  0},  { "automatic_index",  2,  0,  0x00100000},  { "busy_timeout",  3,  0,  0},  { "cache_size",  4,  0x01,  0},  { "cache_spill",  2,  0,  0x00000010},  { "case_sensitive_like",  5,  0,  0},  { "checkpoint_fullfsync",  2,  0,  0x00000008},  { "collation_list",  6,  0,  0},  { "compile_options",  7,  0,  0},  { "count_changes",  2,  0,  0x00000080},  { "database_list",  9,  0x01,  0},  { "default_cache_size",  10,  0x01,  0},  { "empty_result_callbacks",  2,  0,  0x00000100},  { "encoding",  11,  0,  0},  { "freelist_count",  0,  0,  0},  { "full_column_names",  2,  0,  0x00000020},  { "fullfsync",  2,  0,  0x00000004},  { "ignore_check_constraints",  2,  0,  0x00002000},  { "index_info",  15,  0x01,  0},  { "index_list",  16,  0x01,  0},  { "integrity_check",  17,  0x01,  0},  { "journal_mode",  18,  0x01,  0},  { "journal_size_limit",  19,  0,  0},  { "legacy_file_format",  2,  0,  0x00008000},  { "locking_mode",  21,  0,  0},  { "max_page_count",  22,  0x01,  0},  { "mmap_size",  23,  0,  0},  { "page_count",  22,  0x01,  0},  { "page_size",  24,  0,  0},  { "query_only",  2,  0,  0x02000000},  { "quick_check",  17,  0x01,  0},  { "read_uncommitted",  2,  0,  0x0004000},  { "recursive_triggers",  2,  0,  0x00040000},  { "reverse_unordered_selects",  2,  0,  0x00020000},  { "schema_version",  0,  0,  0},  { "secure_delete",  25,  0,  0},  { "short_column_names",  2,  0,  0x00000040},  { "shrink_memory",  26,  0,  0},  { "soft_heap_limit",  27,  0,  0},  { "stats",  28,  0x01,  0},  { "synchronous",  29,  0x01,  0},  { "table_info",  30,  0x01,  0},  { "temp_store",  31,  0,  0},  { "temp_store_directory",  32,  0,  0},  { "user_version",  0,  0,  0},  { "wal_autocheckpoint",  33,  0,  0},  { "wal_checkpoint",  34,  0x01,  0},  { "writable_schema",  2,  0,  (0x00000800 | 0x00010000)}};
static const struct  sPragmaNames   _1339_aPragmaNames[] =  { { "application_id",  0,  0,  0},  { "automatic_index",  2,  0,  0x00100000},  { "busy_timeout",  3,  0,  0},  { "cache_size",  4,  0x01,  0},  { "cache_spill",  2,  0,  0x00000010},  { "case_sensitive_like",  5,  0,  0},  { "checkpoint_fullfsync",  2,  0,  0x00000008},  { "collation_list",  6,  0,  0},  { "compile_options",  7,  0,  0},  { "count_changes",  2,  0,  0x00000080},  { "database_list",  9,  0x01,  0},  { "default_cache_size",  10,  0x01,  0},  { "defer_foreign_keys",  2,  0,  0x01000000},  { "empty_result_callbacks",  2,  0,  0x00000100},  { "encoding",  11,  0,  0},  { "foreign_key_check",  12,  0x01,  0},  { "foreign_key_list",  13,  0x01,  0},  { "foreign_keys",  2,  0,  0x00080000},  { "freelist_count",  0,  0,  0},  { "full_column_names",  2,  0,  0x00000020},  { "fullfsync",  2,  0,  0x00000004},  { "ignore_check_constraints",  2,  0,  0x00002000},  { "index_info",  15,  0x01,  0},  { "index_list",  16,  0x01,  0},  { "integrity_check",  17,  0x01,  0},  { "journal_mode",  18,  0x01,  0},  { "journal_size_limit",  19,  0,  0},  { "legacy_file_format",  2,  0,  0x00008000},  { "locking_mode",  21,  0,  0},  { "max_page_count",  22,  0x01,  0},  { "mmap_size",  23,  0,  0},  { "page_count",  22,  0x01,  0},  { "page_size",  24,  0,  0},  { "query_only",  2,  0,  0x02000000},  { "quick_check",  17,  0x01,  0},  { "read_uncommitted",  2,  0,  0x0004000},  { "recursive_triggers",  2,  0,  0x00040000},  { "reverse_unordered_selects",  2,  0,  0x00020000},  { "schema_version",  0,  0,  0},  { "secure_delete",  25,  0,  0},  { "short_column_names",  2,  0,  0x00000040},  { "shrink_memory",  26,  0,  0},  { "soft_heap_limit",  27,  0,  0},  { "stats",  28,  0x01,  0},  { "synchronous",  29,  0x01,  0},  { "table_info",  30,  0x01,  0},  { "temp_store",  31,  0,  0},  { "temp_store_directory",  32,  0,  0},  { "user_version",  0,  0,  0},  { "wal_autocheckpoint",  33,  0,  0},  { "wal_checkpoint",  34,  0x01,  0},  { "writable_schema",  2,  0,  (0x00000800 | 0x00010000)}};
static const struct  sPragmaNames   _1340_aPragmaNames[] =  { { "application_id",  0,  0,  0},  { "auto_vacuum",  1,  0x01,  0},  { "automatic_index",  2,  0,  0x00100000},  { "busy_timeout",  3,  0,  0},  { "cache_spill",  2,  0,  0x00000010},  { "case_sensitive_like",  5,  0,  0},  { "checkpoint_fullfsync",  2,  0,  0x00000008},  { "collation_list",  6,  0,  0},  { "compile_options",  7,  0,  0},  { "count_changes",  2,  0,  0x00000080},  { "database_list",  9,  0x01,  0},  { "empty_result_callbacks",  2,  0,  0x00000100},  { "encoding",  11,  0,  0},  { "freelist_count",  0,  0,  0},  { "full_column_names",  2,  0,  0x00000020},  { "fullfsync",  2,  0,  0x00000004},  { "ignore_check_constraints",  2,  0,  0x00002000},  { "incremental_vacuum",  14,  0x01,  0},  { "index_info",  15,  0x01,  0},  { "index_list",  16,  0x01,  0},  { "integrity_check",  17,  0x01,  0},  { "legacy_file_format",  2,  0,  0x00008000},  { "query_only",  2,  0,  0x02000000},  { "quick_check",  17,  0x01,  0},  { "read_uncommitted",  2,  0,  0x0004000},  { "recursive_triggers",  2,  0,  0x00040000},  { "reverse_unordered_selects",  2,  0,  0x00020000},  { "schema_version",  0,  0,  0},  { "short_column_names",  2,  0,  0x00000040},  { "shrink_memory",  26,  0,  0},  { "soft_heap_limit",  27,  0,  0},  { "stats",  28,  0x01,  0},  { "table_info",  30,  0x01,  0},  { "user_version",  0,  0,  0},  { "wal_autocheckpoint",  33,  0,  0},  { "wal_checkpoint",  34,  0x01,  0},  { "writable_schema",  2,  0,  (0x00000800 | 0x00010000)}};
static const struct  sPragmaNames   _1341_aPragmaNames[] =  { { "application_id",  0,  0,  0},  { "auto_vacuum",  1,  0x01,  0},  { "automatic_index",  2,  0,  0x00100000},  { "busy_timeout",  3,  0,  0},  { "cache_spill",  2,  0,  0x00000010},  { "case_sensitive_like",  5,  0,  0},  { "checkpoint_fullfsync",  2,  0,  0x00000008},  { "collation_list",  6,  0,  0},  { "compile_options",  7,  0,  0},  { "count_changes",  2,  0,  0x00000080},  { "database_list",  9,  0x01,  0},  { "defer_foreign_keys",  2,  0,  0x01000000},  { "empty_result_callbacks",  2,  0,  0x00000100},  { "encoding",  11,  0,  0},  { "foreign_key_check",  12,  0x01,  0},  { "foreign_key_list",  13,  0x01,  0},  { "foreign_keys",  2,  0,  0x00080000},  { "freelist_count",  0,  0,  0},  { "full_column_names",  2,  0,  0x00000020},  { "fullfsync",  2,  0,  0x00000004},  { "ignore_check_constraints",  2,  0,  0x00002000},  { "incremental_vacuum",  14,  0x01,  0},  { "index_info",  15,  0x01,  0},  { "index_list",  16,  0x01,  0},  { "integrity_check",  17,  0x01,  0},  { "legacy_file_format",  2,  0,  0x00008000},  { "query_only",  2,  0,  0x02000000},  { "quick_check",  17,  0x01,  0},  { "read_uncommitted",  2,  0,  0x0004000},  { "recursive_triggers",  2,  0,  0x00040000},  { "reverse_unordered_selects",  2,  0,  0x00020000},  { "schema_version",  0,  0,  0},  { "short_column_names",  2,  0,  0x00000040},  { "shrink_memory",  26,  0,  0},  { "soft_heap_limit",  27,  0,  0},  { "stats",  28,  0x01,  0},  { "table_info",  30,  0x01,  0},  { "user_version",  0,  0,  0},  { "wal_autocheckpoint",  33,  0,  0},  { "wal_checkpoint",  34,  0x01,  0},  { "writable_schema",  2,  0,  (0x00000800 | 0x00010000)}};
static const struct  sPragmaNames   _1342_aPragmaNames[] =  { { "application_id",  0,  0,  0},  { "auto_vacuum",  1,  0x01,  0},  { "automatic_index",  2,  0,  0x00100000},  { "busy_timeout",  3,  0,  0},  { "cache_size",  4,  0x01,  0},  { "cache_spill",  2,  0,  0x00000010},  { "case_sensitive_like",  5,  0,  0},  { "checkpoint_fullfsync",  2,  0,  0x00000008},  { "collation_list",  6,  0,  0},  { "compile_options",  7,  0,  0},  { "count_changes",  2,  0,  0x00000080},  { "database_list",  9,  0x01,  0},  { "empty_result_callbacks",  2,  0,  0x00000100},  { "encoding",  11,  0,  0},  { "freelist_count",  0,  0,  0},  { "full_column_names",  2,  0,  0x00000020},  { "fullfsync",  2,  0,  0x00000004},  { "ignore_check_constraints",  2,  0,  0x00002000},  { "incremental_vacuum",  14,  0x01,  0},  { "index_info",  15,  0x01,  0},  { "index_list",  16,  0x01,  0},  { "integrity_check",  17,  0x01,  0},  { "journal_mode",  18,  0x01,  0},  { "journal_size_limit",  19,  0,  0},  { "legacy_file_format",  2,  0,  0x00008000},  { "locking_mode",  21,  0,  0},  { "max_page_count",  22,  0x01,  0},  { "mmap_size",  23,  0,  0},  { "page_count",  22,  0x01,  0},  { "page_size",  24,  0,  0},  { "query_only",  2,  0,  0x02000000},  { "quick_check",  17,  0x01,  0},  { "read_uncommitted",  2,  0,  0x0004000},  { "recursive_triggers",  2,  0,  0x00040000},  { "reverse_unordered_selects",  2,  0,  0x00020000},  { "schema_version",  0,  0,  0},  { "secure_delete",  25,  0,  0},  { "short_column_names",  2,  0,  0x00000040},  { "shrink_memory",  26,  0,  0},  { "soft_heap_limit",  27,  0,  0},  { "stats",  28,  0x01,  0},  { "synchronous",  29,  0x01,  0},  { "table_info",  30,  0x01,  0},  { "temp_store",  31,  0,  0},  { "temp_store_directory",  32,  0,  0},  { "user_version",  0,  0,  0},  { "wal_autocheckpoint",  33,  0,  0},  { "wal_checkpoint",  34,  0x01,  0},  { "writable_schema",  2,  0,  (0x00000800 | 0x00010000)}};
static const struct  sPragmaNames   _1343_aPragmaNames[] =  { { "application_id",  0,  0,  0},  { "auto_vacuum",  1,  0x01,  0},  { "automatic_index",  2,  0,  0x00100000},  { "busy_timeout",  3,  0,  0},  { "cache_size",  4,  0x01,  0},  { "cache_spill",  2,  0,  0x00000010},  { "case_sensitive_like",  5,  0,  0},  { "checkpoint_fullfsync",  2,  0,  0x00000008},  { "collation_list",  6,  0,  0},  { "compile_options",  7,  0,  0},  { "count_changes",  2,  0,  0x00000080},  { "database_list",  9,  0x01,  0},  { "defer_foreign_keys",  2,  0,  0x01000000},  { "empty_result_callbacks",  2,  0,  0x00000100},  { "encoding",  11,  0,  0},  { "foreign_key_check",  12,  0x01,  0},  { "foreign_key_list",  13,  0x01,  0},  { "foreign_keys",  2,  0,  0x00080000},  { "freelist_count",  0,  0,  0},  { "full_column_names",  2,  0,  0x00000020},  { "fullfsync",  2,  0,  0x00000004},  { "ignore_check_constraints",  2,  0,  0x00002000},  { "incremental_vacuum",  14,  0x01,  0},  { "index_info",  15,  0x01,  0},  { "index_list",  16,  0x01,  0},  { "integrity_check",  17,  0x01,  0},  { "journal_mode",  18,  0x01,  0},  { "journal_size_limit",  19,  0,  0},  { "legacy_file_format",  2,  0,  0x00008000},  { "locking_mode",  21,  0,  0},  { "max_page_count",  22,  0x01,  0},  { "mmap_size",  23,  0,  0},  { "page_count",  22,  0x01,  0},  { "page_size",  24,  0,  0},  { "query_only",  2,  0,  0x02000000},  { "quick_check",  17,  0x01,  0},  { "read_uncommitted",  2,  0,  0x0004000},  { "recursive_triggers",  2,  0,  0x00040000},  { "reverse_unordered_selects",  2,  0,  0x00020000},  { "schema_version",  0,  0,  0},  { "secure_delete",  25,  0,  0},  { "short_column_names",  2,  0,  0x00000040},  { "shrink_memory",  26,  0,  0},  { "soft_heap_limit",  27,  0,  0},  { "stats",  28,  0x01,  0},  { "synchronous",  29,  0x01,  0},  { "table_info",  30,  0x01,  0},  { "temp_store",  31,  0,  0},  { "temp_store_directory",  32,  0,  0},  { "user_version",  0,  0,  0},  { "wal_autocheckpoint",  33,  0,  0},  { "wal_checkpoint",  34,  0x01,  0},  { "writable_schema",  2,  0,  (0x00000800 | 0x00010000)}};
static const struct  sPragmaNames   _1344_aPragmaNames[] =  { { "application_id",  0,  0,  0},  { "auto_vacuum",  1,  0x01,  0},  { "automatic_index",  2,  0,  0x00100000},  { "busy_timeout",  3,  0,  0},  { "cache_size",  4,  0x01,  0},  { "cache_spill",  2,  0,  0x00000010},  { "case_sensitive_like",  5,  0,  0},  { "checkpoint_fullfsync",  2,  0,  0x00000008},  { "collation_list",  6,  0,  0},  { "compile_options",  7,  0,  0},  { "count_changes",  2,  0,  0x00000080},  { "database_list",  9,  0x01,  0},  { "default_cache_size",  10,  0x01,  0},  { "empty_result_callbacks",  2,  0,  0x00000100},  { "encoding",  11,  0,  0},  { "freelist_count",  0,  0,  0},  { "full_column_names",  2,  0,  0x00000020},  { "fullfsync",  2,  0,  0x00000004},  { "ignore_check_constraints",  2,  0,  0x00002000},  { "incremental_vacuum",  14,  0x01,  0},  { "index_info",  15,  0x01,  0},  { "index_list",  16,  0x01,  0},  { "integrity_check",  17,  0x01,  0},  { "journal_mode",  18,  0x01,  0},  { "journal_size_limit",  19,  0,  0},  { "legacy_file_format",  2,  0,  0x00008000},  { "locking_mode",  21,  0,  0},  { "max_page_count",  22,  0x01,  0},  { "mmap_size",  23,  0,  0},  { "page_count",  22,  0x01,  0},  { "page_size",  24,  0,  0},  { "query_only",  2,  0,  0x02000000},  { "quick_check",  17,  0x01,  0},  { "read_uncommitted",  2,  0,  0x0004000},  { "recursive_triggers",  2,  0,  0x00040000},  { "reverse_unordered_selects",  2,  0,  0x00020000},  { "schema_version",  0,  0,  0},  { "secure_delete",  25,  0,  0},  { "short_column_names",  2,  0,  0x00000040},  { "shrink_memory",  26,  0,  0},  { "soft_heap_limit",  27,  0,  0},  { "stats",  28,  0x01,  0},  { "synchronous",  29,  0x01,  0},  { "table_info",  30,  0x01,  0},  { "temp_store",  31,  0,  0},  { "temp_store_directory",  32,  0,  0},  { "user_version",  0,  0,  0},  { "wal_autocheckpoint",  33,  0,  0},  { "wal_checkpoint",  34,  0x01,  0},  { "writable_schema",  2,  0,  (0x00000800 | 0x00010000)}};
static const struct  sPragmaNames   _1345_aPragmaNames[] =  { { "application_id",  0,  0,  0},  { "auto_vacuum",  1,  0x01,  0},  { "automatic_index",  2,  0,  0x00100000},  { "busy_timeout",  3,  0,  0},  { "cache_size",  4,  0x01,  0},  { "cache_spill",  2,  0,  0x00000010},  { "case_sensitive_like",  5,  0,  0},  { "checkpoint_fullfsync",  2,  0,  0x00000008},  { "collation_list",  6,  0,  0},  { "compile_options",  7,  0,  0},  { "count_changes",  2,  0,  0x00000080},  { "database_list",  9,  0x01,  0},  { "default_cache_size",  10,  0x01,  0},  { "defer_foreign_keys",  2,  0,  0x01000000},  { "empty_result_callbacks",  2,  0,  0x00000100},  { "encoding",  11,  0,  0},  { "foreign_key_check",  12,  0x01,  0},  { "foreign_key_list",  13,  0x01,  0},  { "foreign_keys",  2,  0,  0x00080000},  { "freelist_count",  0,  0,  0},  { "full_column_names",  2,  0,  0x00000020},  { "fullfsync",  2,  0,  0x00000004},  { "ignore_check_constraints",  2,  0,  0x00002000},  { "incremental_vacuum",  14,  0x01,  0},  { "index_info",  15,  0x01,  0},  { "index_list",  16,  0x01,  0},  { "integrity_check",  17,  0x01,  0},  { "journal_mode",  18,  0x01,  0},  { "journal_size_limit",  19,  0,  0},  { "legacy_file_format",  2,  0,  0x00008000},  { "locking_mode",  21,  0,  0},  { "max_page_count",  22,  0x01,  0},  { "mmap_size",  23,  0,  0},  { "page_count",  22,  0x01,  0},  { "page_size",  24,  0,  0},  { "query_only",  2,  0,  0x02000000},  { "quick_check",  17,  0x01,  0},  { "read_uncommitted",  2,  0,  0x0004000},  { "recursive_triggers",  2,  0,  0x00040000},  { "reverse_unordered_selects",  2,  0,  0x00020000},  { "schema_version",  0,  0,  0},  { "secure_delete",  25,  0,  0},  { "short_column_names",  2,  0,  0x00000040},  { "shrink_memory",  26,  0,  0},  { "soft_heap_limit",  27,  0,  0},  { "stats",  28,  0x01,  0},  { "synchronous",  29,  0x01,  0},  { "table_info",  30,  0x01,  0},  { "temp_store",  31,  0,  0},  { "temp_store_directory",  32,  0,  0},  { "user_version",  0,  0,  0},  { "wal_autocheckpoint",  33,  0,  0},  { "wal_checkpoint",  34,  0x01,  0},  { "writable_schema",  2,  0,  (0x00000800 | 0x00010000)}};
static  u8 getSafetyLevel(const  char *z , int omitFull , int dflt )  {
  static const char zText[] =  "onoffalseyestruefull";
  static const u8 iOffset[] =  { 0,  1,  2,  4,  9,  12,  16};
  static const u8 iLength[] =  { 2,  2,  3,  5,  3,  4,  4};
  static const u8 iValue[] =  { 1,  0,  0,  0,  1,  1,  2};
  int i, n;
  if ((sqlite3CtypeMap[((unsigned  char ) (*z))] & 0x04)) {
    return ((u8 ) sqlite3Atoi(z));
  }  
  (n = sqlite3Strlen30(z));
  for ((i = 0); (i < (((int ) (sizeof(iLength) / sizeof(iLength[0]))) - omitFull)); i++) {
    if (((iLength[i] == n) && (sqlite3_strnicmp((&zText[iOffset[i]]), z, n) == 0))) {
      return iValue[i];
    }  
  }
  return dflt;
}
static  u8 sqlite3GetBoolean(const  char *z , int dflt )  {
  return (getSafetyLevel(z, 1, dflt) != 0);
}
static  int getLockingMode(const  char *z )  {
  if (z) {
    if ((0 == sqlite3_stricmp(z, "exclusive"))) {
      return 1;
    }  
    if ((0 == sqlite3_stricmp(z, "normal"))) {
      return 0;
    }  
  }  
  return (- 1);
}
static  int getAutoVacuum(const  char *z )  {
  int i;
  if ((0 == sqlite3_stricmp(z, "none"))) {
    return 0;
  }  
  if ((0 == sqlite3_stricmp(z, "full"))) {
    return 1;
  }  
  if ((0 == sqlite3_stricmp(z, "incremental"))) {
    return 2;
  }  
  (i = sqlite3Atoi(z));
  return ((u8 ) (((i >= 0) && (i <= 2)) ? i : 0));
}
static  int getTempStore(const  char *z )  {
  if (((z[0] >= '0') && (z[0] <= '2'))) {
    return (z[0] - '0');
  } 
  else if ((sqlite3_stricmp(z, "file") == 0)) {
    return 1;
  }
  
  else if ((sqlite3_stricmp(z, "memory") == 0)) {
    return 2;
  } 
  else {
    return 0;
  }
}
static  int invalidateTempStorage(Parse *pParse )  {
  sqlite3 *db =  pParse->db;
  if ((db->aDb[1].pBt != 0)) {
    if (((! db->autoCommit) || sqlite3BtreeIsInReadTrans(db->aDb[1].pBt))) {
      sqlite3ErrorMsg(pParse, "temporary storage cannot be changed " "from within a transaction");
      return 1;
    }  
    sqlite3BtreeClose(db->aDb[1].pBt);
    (db->aDb[1].pBt = 0);
    sqlite3ResetAllSchemasOfConnection(db);
  }  
  return 0;
}
static  int changeTempStorage(Parse *pParse , const  char *zStorageType )  {
  int ts =  getTempStore(zStorageType);
  sqlite3 *db =  pParse->db;
  if ((db->temp_store == ts)) {
    return 0;
  }  
  if ((invalidateTempStorage(pParse) != 0)) {
    return 1;
  }  
  (db->temp_store = ((u8 ) ts));
  return 0;
}
static  void returnSingleInt(Parse *pParse , const  char *zLabel , i64 value )  {
  Vdbe *v =  sqlite3GetVdbe(pParse);
  int mem =  ++pParse->nMem;
  i64 *pI64 =  sqlite3DbMallocRaw(pParse->db, sizeof(value));
  if (pI64) {
    memcpy(pI64, (&value), sizeof(value));
  }  
  sqlite3VdbeAddOp4(v, 22, 0, mem, 0, ((char *) pI64), (- 13));
  sqlite3VdbeSetNumCols(v, 1);
  sqlite3VdbeSetColName(v, 0, 0, zLabel, ((sqlite3_destructor_type ) 0));
  sqlite3VdbeAddOp2(v, 30, mem, 1);
}
static  void setAllPagerFlags(sqlite3 *db )  {
  if (db->autoCommit) {
    Db *pDb =  db->aDb;
    int n =  db->nDb;
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    while ((n-- > 0)) {
      if (pDb->pBt) {
        sqlite3BtreeSetPagerFlags(pDb->pBt, (pDb->safety_level | (db->flags & 0x1c)));
      }  
      pDb++;
    }
  }  
}
static  const  char *actionName(u8 action )  {
  const char *zName;
  switch (action) {
    case 7:
    (zName = "SET NULL");
    break;
    case 8:
    (zName = "SET DEFAULT");
    break;
    case 9:
    (zName = "CASCADE");
    break;
    case 6:
    (zName = "RESTRICT");
    break;
    id2i_label_1:
    default:
    (zName = "NO ACTION");
    ((void ) 0);
    break;
  }
  return zName;
}
static  const  char *sqlite3JournalModename(int eMode )  {
  static char *const azModeName[] =  { "delete",  "persist",  "off",  "truncate",  "memory",  "wal"};
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((eMode == ((int ) (sizeof(azModeName) / sizeof(azModeName[0]))))) {
    return 0;
  }  
  return azModeName[eMode];
}
static  void sqlite3Pragma(Parse *pParse , Token *pId1 , Token *pId2 , Token *pValue , int minusFlag )  {
  char *zLeft =  0;
  char *zRight =  0;
  const char *zDb =  0;
  Token *pId;
  char *aFcntl[4];
  int iDb;
  int lwr, upr, mid;
  int rc;
  sqlite3 *db =  pParse->db;
  Db *pDb;
  Vdbe *v =  sqlite3GetVdbe(pParse);
  if ((v == 0)) {
    return;
  }  
  sqlite3VdbeRunOnlyOnce(v);
  (pParse->nMem = 2);
  (iDb = sqlite3TwoPartName(pParse, pId1, pId2, (&pId)));
  if ((iDb < 0)) {
    return;
  }  
  (pDb = (&db->aDb[iDb]));
  if (((iDb == 1) && sqlite3OpenTempDatabase(pParse))) {
    return;
  }  
  (zLeft = sqlite3NameFromToken(db, pId));
  if ((! zLeft)) {
    return;
  }  
  if (minusFlag) {
    (zRight = sqlite3MPrintf(db, "-%T", pValue));
  }  
  else {
    (zRight = sqlite3NameFromToken(db, pValue));
  }
  ((void ) 0);
  (zDb = ((pId2->n > 0) ? pDb->zName : 0));
  if (sqlite3AuthCheck(pParse, 19, zLeft, zRight, zDb)) {
    goto pragma_out;
  }  
  (aFcntl[0] = 0);
  (aFcntl[1] = zLeft);
  (aFcntl[2] = zRight);
  (aFcntl[3] = 0);
  (db->busyHandler.nBusy = 0);
  (rc = sqlite3_file_control(db, zDb, 14, ((void *) aFcntl)));
  if ((rc == 0)) {
    if (aFcntl[0]) {
      int mem =  ++pParse->nMem;
      sqlite3VdbeAddOp4(v, 94, 0, mem, 0, aFcntl[0], 0);
      sqlite3VdbeSetNumCols(v, 1);
      sqlite3VdbeSetColName(v, 0, 0, "result", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeAddOp2(v, 30, mem, 1);
      sqlite3_free(aFcntl[0]);
    }  
    goto pragma_out;
  }  
  if ((rc != 12)) {
    if (aFcntl[0]) {
      sqlite3ErrorMsg(pParse, "%s", aFcntl[0]);
      sqlite3_free(aFcntl[0]);
    }  
    pParse->nErr++;
    (pParse->rc = rc);
    goto pragma_out;
  }  
  (lwr = 0);
  if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
    (upr = (((int ) (sizeof(_1342_aPragmaNames) / sizeof(_1342_aPragmaNames[0]))) - 1));
  }  
  if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
    (upr = (((int ) (sizeof(_1339_aPragmaNames) / sizeof(_1339_aPragmaNames[0]))) - 1));
  }  
  if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
    (upr = (((int ) (sizeof(_1340_aPragmaNames) / sizeof(_1340_aPragmaNames[0]))) - 1));
  }  
  if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
    (upr = (((int ) (sizeof(_1343_aPragmaNames) / sizeof(_1343_aPragmaNames[0]))) - 1));
  }  
  if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
    (upr = (((int ) (sizeof(_1341_aPragmaNames) / sizeof(_1341_aPragmaNames[0]))) - 1));
  }  
  if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
    (upr = (((int ) (sizeof(_1335_aPragmaNames) / sizeof(_1335_aPragmaNames[0]))) - 1));
  }  
  if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
    (upr = (((int ) (sizeof(_1345_aPragmaNames) / sizeof(_1345_aPragmaNames[0]))) - 1));
  }  
  if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
    (upr = (((int ) (sizeof(_1338_aPragmaNames) / sizeof(_1338_aPragmaNames[0]))) - 1));
  }  
  if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
    (upr = (((int ) (sizeof(_1344_aPragmaNames) / sizeof(_1344_aPragmaNames[0]))) - 1));
  }  
  if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
    (upr = (((int ) (sizeof(_1334_aPragmaNames) / sizeof(_1334_aPragmaNames[0]))) - 1));
  }  
  if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
    (upr = (((int ) (sizeof(_1336_aPragmaNames) / sizeof(_1336_aPragmaNames[0]))) - 1));
  }  
  if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
    (upr = (((int ) (sizeof(_1337_aPragmaNames) / sizeof(_1337_aPragmaNames[0]))) - 1));
  }  
  while ((lwr <= upr)) {
    (mid = ((lwr + upr) / 2));
    if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      (rc = sqlite3_stricmp(zLeft, _1342_aPragmaNames[mid].zName));
    }  
    if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
      (rc = sqlite3_stricmp(zLeft, _1339_aPragmaNames[mid].zName));
    }  
    if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
      (rc = sqlite3_stricmp(zLeft, _1340_aPragmaNames[mid].zName));
    }  
    if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      (rc = sqlite3_stricmp(zLeft, _1343_aPragmaNames[mid].zName));
    }  
    if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
      (rc = sqlite3_stricmp(zLeft, _1341_aPragmaNames[mid].zName));
    }  
    if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
      (rc = sqlite3_stricmp(zLeft, _1335_aPragmaNames[mid].zName));
    }  
    if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      (rc = sqlite3_stricmp(zLeft, _1345_aPragmaNames[mid].zName));
    }  
    if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
      (rc = sqlite3_stricmp(zLeft, _1338_aPragmaNames[mid].zName));
    }  
    if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      (rc = sqlite3_stricmp(zLeft, _1344_aPragmaNames[mid].zName));
    }  
    if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
      (rc = sqlite3_stricmp(zLeft, _1334_aPragmaNames[mid].zName));
    }  
    if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
      (rc = sqlite3_stricmp(zLeft, _1336_aPragmaNames[mid].zName));
    }  
    if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
      (rc = sqlite3_stricmp(zLeft, _1337_aPragmaNames[mid].zName));
    }  
    if ((rc == 0)) {
      break;
    }  
    if ((rc < 0)) {
      (upr = (mid - 1));
    }  
    else {
      (lwr = (mid + 1));
    }
  }
  if ((lwr > upr)) {
    goto pragma_out;
  }  
  if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
    if (((_1342_aPragmaNames[mid].mPragFlag & 0x01) != 0)) {
      if (sqlite3ReadSchema(pParse)) {
        goto pragma_out;
      }  
    }  
  }  
  if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
    if (((_1339_aPragmaNames[mid].mPragFlag & 0x01) != 0)) {
      if (sqlite3ReadSchema(pParse)) {
        goto pragma_out;
      }  
    }  
  }  
  if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
    if (((_1340_aPragmaNames[mid].mPragFlag & 0x01) != 0)) {
      if (sqlite3ReadSchema(pParse)) {
        goto pragma_out;
      }  
    }  
  }  
  if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
    if (((_1343_aPragmaNames[mid].mPragFlag & 0x01) != 0)) {
      if (sqlite3ReadSchema(pParse)) {
        goto pragma_out;
      }  
    }  
  }  
  if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
    if (((_1341_aPragmaNames[mid].mPragFlag & 0x01) != 0)) {
      if (sqlite3ReadSchema(pParse)) {
        goto pragma_out;
      }  
    }  
  }  
  if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
    if (((_1335_aPragmaNames[mid].mPragFlag & 0x01) != 0)) {
      if (sqlite3ReadSchema(pParse)) {
        goto pragma_out;
      }  
    }  
  }  
  if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
    if (((_1345_aPragmaNames[mid].mPragFlag & 0x01) != 0)) {
      if (sqlite3ReadSchema(pParse)) {
        goto pragma_out;
      }  
    }  
  }  
  if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
    if (((_1338_aPragmaNames[mid].mPragFlag & 0x01) != 0)) {
      if (sqlite3ReadSchema(pParse)) {
        goto pragma_out;
      }  
    }  
  }  
  if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
    if (((_1344_aPragmaNames[mid].mPragFlag & 0x01) != 0)) {
      if (sqlite3ReadSchema(pParse)) {
        goto pragma_out;
      }  
    }  
  }  
  if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
    if (((_1334_aPragmaNames[mid].mPragFlag & 0x01) != 0)) {
      if (sqlite3ReadSchema(pParse)) {
        goto pragma_out;
      }  
    }  
  }  
  if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
    if (((_1336_aPragmaNames[mid].mPragFlag & 0x01) != 0)) {
      if (sqlite3ReadSchema(pParse)) {
        goto pragma_out;
      }  
    }  
  }  
  if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
    if (((_1337_aPragmaNames[mid].mPragFlag & 0x01) != 0)) {
      if (sqlite3ReadSchema(pParse)) {
        goto pragma_out;
      }  
    }  
  }  
  switch ((((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1337_aPragmaNames[mid].ePragTyp : (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1336_aPragmaNames[mid].ePragTyp : (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) ) ? _1334_aPragmaNames[mid].ePragTyp : ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1344_aPragmaNames[mid].ePragTyp : ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1338_aPragmaNames[mid].ePragTyp : ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1345_aPragmaNames[mid].ePragTyp : ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) ) ? _1335_aPragmaNames[mid].ePragTyp : ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) ) ? _1341_aPragmaNames[mid].ePragTyp : (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1343_aPragmaNames[mid].ePragTyp : (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) ) ? _1340_aPragmaNames[mid].ePragTyp : ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1339_aPragmaNames[mid].ePragTyp : _1342_aPragmaNames[mid].ePragTyp)))))))))))) {
    case 10:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      static const VdbeOpList getCacheSize[] =  { { 4,  0,  0,  0},  { 45,  0,  1,  3},  { 126,  1,  8,  0},  { 21,  0,  2,  0},  { 87,  1,  2,  1},  { 126,  1,  8,  0},  { 21,  0,  1,  0},  { 149,  0,  0,  0},  { 30,  1,  1,  0}};
      int addr;
      sqlite3VdbeUsesBtree(v, iDb);
      if ((! zRight)) {
        sqlite3VdbeSetNumCols(v, 1);
        sqlite3VdbeSetColName(v, 0, 0, "cache_size", ((sqlite3_destructor_type ) 0));
        (pParse->nMem += 2);
        (addr = sqlite3VdbeAddOpList(v, ((int ) (sizeof(getCacheSize) / sizeof(getCacheSize[0]))), getCacheSize));
        sqlite3VdbeChangeP1(v, addr, iDb);
        sqlite3VdbeChangeP1(v, (addr + 1), iDb);
        sqlite3VdbeChangeP1(v, (addr + 6), 2000);
      }  
      else {
        int size =  sqlite3AbsInt32(sqlite3Atoi(zRight));
        sqlite3BeginWriteOperation(pParse, 0, iDb);
        sqlite3VdbeAddOp2(v, 21, size, 1);
        sqlite3VdbeAddOp3(v, 46, iDb, 3, 1);
        ((void ) 0);
        (pDb->pSchema->cache_size = size);
        sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
      }
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_pager_pragmas) || ((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_deprecated) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 10)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 10)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 10)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 10)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 10)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 10)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 10)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 10)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 10)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 10)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 10)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 10)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 24:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      Btree *pBt =  pDb->pBt;
      ((void ) 0);
      if ((! zRight)) {
        int _1349_size =  (pBt ? sqlite3BtreeGetPageSize(pBt) : 0);
        int _1350_size =  (1 ? sqlite3BtreeGetPageSize(pBt) : 0);
        if ((((! id2i_sqlite_coverage_test) ) )) {
          returnSingleInt(pParse, "page_size", _1349_size);
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          returnSingleInt(pParse, "page_size", _1350_size);
        }  
      }  
      else {
        (db->nextPagesize = sqlite3Atoi(zRight));
        if ((7 == sqlite3BtreeSetPageSize(pBt, db->nextPagesize, (- 1), 0))) {
          (db->mallocFailed = 1);
        }  
      }
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_pager_pragmas) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 24)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 24)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 24)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 24)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 24)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 24)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 24)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 24)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 24)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 24)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 24)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 24)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 25:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      Btree *pBt =  pDb->pBt;
      int b =  (- 1);
      ((void ) 0);
      if (zRight) {
        (b = sqlite3GetBoolean(zRight, 0));
      }  
      if (((pId2->n == 0) && (b >= 0))) {
        int ii;
        for ((ii = 0); (ii < db->nDb); ii++) {
          sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);
        }
      }  
      (b = sqlite3BtreeSecureDelete(pBt, b));
      returnSingleInt(pParse, "secure_delete", b);
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_pager_pragmas) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 25)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 25)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 25)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 25)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 25)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 25)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 25)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 25)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 25)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 25)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 25)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 25)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 22:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      int iReg;
      sqlite3CodeVerifySchema(pParse, iDb);
      (iReg = ++pParse->nMem);
      if ((((! id2i_sqlite_ebcdic) ) )) {
        if ((_1281_sqlite3UpperToLower[((unsigned  char ) zLeft[0])] == 'p')) {
          sqlite3VdbeAddOp2(v, 146, iDb, iReg);
        }  
        else {
          sqlite3VdbeAddOp3(v, 147, iDb, iReg, sqlite3AbsInt32(sqlite3Atoi(zRight)));
        }
      }  
      if (((id2i_sqlite_ebcdic ) )) {
        if ((_1282_sqlite3UpperToLower[((unsigned  char ) zLeft[0])] == 'p')) {
          sqlite3VdbeAddOp2(v, 146, iDb, iReg);
        }  
        else {
          sqlite3VdbeAddOp3(v, 147, iDb, iReg, sqlite3AbsInt32(sqlite3Atoi(zRight)));
        }
      }  
      sqlite3VdbeAddOp2(v, 30, iReg, 1);
      sqlite3VdbeSetNumCols(v, 1);
      sqlite3VdbeSetColName(v, 0, 0, zLeft, ((sqlite3_destructor_type ) (- 1)));
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_pager_pragmas) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 22)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 22)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 22)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 22)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 22)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 22)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 22)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 22)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 22)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 22)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 22)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 22)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 21:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      const char *zRet =  "normal";
      int eMode =  getLockingMode(zRight);
      if (((pId2->n == 0) && (eMode == (- 1)))) {
        (eMode = db->dfltLockMode);
      }  
      else {
        Pager *pPager;
        if ((pId2->n == 0)) {
          int ii;
          ((void ) 0);
          for ((ii = 2); (ii < db->nDb); ii++) {
            (pPager = sqlite3BtreePager(db->aDb[ii].pBt));
            sqlite3PagerLockingMode(pPager, eMode);
          }
          (db->dfltLockMode = ((u8 ) eMode));
        }  
        (pPager = sqlite3BtreePager(pDb->pBt));
        (eMode = sqlite3PagerLockingMode(pPager, eMode));
      }
      ((void ) 0);
      if ((eMode == 1)) {
        (zRet = "exclusive");
      }  
      sqlite3VdbeSetNumCols(v, 1);
      sqlite3VdbeSetColName(v, 0, 0, "locking_mode", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeAddOp4(v, 94, 0, 1, 0, zRet, 0);
      sqlite3VdbeAddOp2(v, 30, 1, 1);
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_pager_pragmas) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 21)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 21)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 21)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 21)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 21)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 21)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 21)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 21)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 21)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 21)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 21)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 21)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 18:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      int eMode;
      int ii;
      sqlite3VdbeSetNumCols(v, 1);
      sqlite3VdbeSetColName(v, 0, 0, "journal_mode", ((sqlite3_destructor_type ) 0));
      if ((zRight == 0)) {
        (eMode = (- 1));
      }  
      else {
        const char *zMode;
        int n =  sqlite3Strlen30(zRight);
        for ((eMode = 0); ((zMode = sqlite3JournalModename(eMode)) != 0); eMode++) {
          if ((sqlite3_strnicmp(zRight, zMode, n) == 0)) {
            break;
          }  
        }
        if ((! zMode)) {
          (eMode = (- 1));
        }  
      }
      if (((eMode == (- 1)) && (pId2->n == 0))) {
        (iDb = 0);
        (pId2->n = 1);
      }  
      for ((ii = (db->nDb - 1)); (ii >= 0); ii--) {
        if ((db->aDb[ii].pBt && ((ii == iDb) || (pId2->n == 0)))) {
          sqlite3VdbeUsesBtree(v, ii);
          sqlite3VdbeAddOp3(v, 10, ii, 1, eMode);
        }  
      }
      sqlite3VdbeAddOp2(v, 30, 1, 1);
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_pager_pragmas) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 18)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 18)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 18)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 18)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 18)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 18)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 18)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 18)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 18)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 18)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 18)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 18)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 19:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      Pager *pPager =  sqlite3BtreePager(pDb->pBt);
      i64 iLimit =  (- 2);
      if (zRight) {
        sqlite3Atoi64(zRight, (&iLimit), sqlite3Strlen30(zRight), 1);
        if ((iLimit < (- 1))) {
          (iLimit = (- 1));
        }  
      }  
      (iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit));
      returnSingleInt(pParse, "journal_size_limit", iLimit);
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_pager_pragmas) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 19)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 19)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 19)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 19)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 19)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 19)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 19)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 19)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 19)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 19)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 19)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 19)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 1:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_autovacuum)) )) {
      Btree *pBt =  pDb->pBt;
      ((void ) 0);
      if ((! zRight)) {
        returnSingleInt(pParse, "auto_vacuum", sqlite3BtreeGetAutoVacuum(pBt));
      }  
      else {
        int eAuto =  getAutoVacuum(zRight);
        ((void ) 0);
        (db->nextAutovac = ((u8 ) eAuto));
        (rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto));
        if (((rc == 0) && ((eAuto == 1) || (eAuto == 2)))) {
          static const VdbeOpList setMeta6[] =  { { 4,  0,  1,  0},  { 45,  0,  1,  4},  { 39,  1,  0,  0},  { 20,  0,  2,  0},  { 21,  0,  1,  0},  { 46,  0,  7,  1}};
          int iAddr;
          (iAddr = sqlite3VdbeAddOpList(v, ((int ) (sizeof(setMeta6) / sizeof(setMeta6[0]))), setMeta6));
          sqlite3VdbeChangeP1(v, iAddr, iDb);
          sqlite3VdbeChangeP1(v, (iAddr + 1), iDb);
          sqlite3VdbeChangeP2(v, (iAddr + 2), (iAddr + 4));
          sqlite3VdbeChangeP1(v, (iAddr + 4), (eAuto - 1));
          sqlite3VdbeChangeP1(v, (iAddr + 5), iDb);
          sqlite3VdbeUsesBtree(v, iDb);
        }  
      }
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_autovacuum) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 1)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 1)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 1)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 1)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 1)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 1)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 1)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 1)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 1)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 1)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 1)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 1)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 14:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_autovacuum)) )) {
      int iLimit, addr;
      if (((zRight == 0) || (! sqlite3GetInt32(zRight, (&iLimit))) || (iLimit <= 0))) {
        (iLimit = 0x7fffffff);
      }  
      sqlite3BeginWriteOperation(pParse, 0, iDb);
      sqlite3VdbeAddOp2(v, 21, iLimit, 1);
      (addr = sqlite3VdbeAddOp1(v, 131, iDb));
      sqlite3VdbeAddOp1(v, 30, 1);
      sqlite3VdbeAddOp2(v, 32, 1, (- 1));
      sqlite3VdbeAddOp2(v, 126, 1, addr);
      sqlite3VdbeJumpHere(v, addr);
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_autovacuum) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 14)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 14)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 14)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 14)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 14)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 14)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 14)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 14)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 14)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 14)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 14)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 14)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 4:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      ((void ) 0);
      if ((! zRight)) {
        returnSingleInt(pParse, "cache_size", pDb->pSchema->cache_size);
      }  
      else {
        int size =  sqlite3Atoi(zRight);
        (pDb->pSchema->cache_size = size);
        sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
      }
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_pager_pragmas) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 4)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 4)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 4)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 4)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 4)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 4)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 4)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 4)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 4)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 4)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 4)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 4)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 23:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      sqlite3_int64 sz;
      (sz = 0);
      (rc = 0);
      if ((rc == 0)) {
        returnSingleInt(pParse, "mmap_size", sz);
      } 
      else if ((rc != 12)) {
        pParse->nErr++;
        (pParse->rc = rc);
      } 
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_pager_pragmas) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 23)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 23)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 23)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 23)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 23)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 23)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 23)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 23)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 23)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 23)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 23)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 23)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 31:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      if ((! zRight)) {
        returnSingleInt(pParse, "temp_store", db->temp_store);
      }  
      else {
        changeTempStorage(pParse, zRight);
      }
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_pager_pragmas) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 31)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 31)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 31)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 31)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 31)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 31)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 31)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 31)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 31)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 31)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 31)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 31)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 32:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      if ((! zRight)) {
        if (sqlite3_temp_directory) {
          sqlite3VdbeSetNumCols(v, 1);
          sqlite3VdbeSetColName(v, 0, 0, "temp_store_directory", ((sqlite3_destructor_type ) 0));
          sqlite3VdbeAddOp4(v, 94, 0, 1, 0, sqlite3_temp_directory, 0);
          sqlite3VdbeAddOp2(v, 30, 1, 1);
        }  
      }  
      else {
        if (zRight[0]) {
          int res;
          (rc = sqlite3OsAccess(db->pVfs, zRight, 1, (&res)));
          if (((rc != 0) || (res == 0))) {
            sqlite3ErrorMsg(pParse, "not a writable directory");
            goto pragma_out;
          }  
        }  
        if (((1 == 0) || ((1 == 1) && (db->temp_store <= 1)) || ((1 == 2) && (db->temp_store == 1)))) {
          invalidateTempStorage(pParse);
        }  
        sqlite3_free(sqlite3_temp_directory);
        if (zRight[0]) {
          (sqlite3_temp_directory = sqlite3_mprintf("%s", zRight));
        }  
        else {
          (sqlite3_temp_directory = 0);
        }
      }
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_pager_pragmas) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 32)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 32)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 32)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 32)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 32)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 32)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 32)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 32)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 32)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 32)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 32)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 32)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 29:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_pager_pragmas)) )) {
      if ((! zRight)) {
        returnSingleInt(pParse, "synchronous", (pDb->safety_level - 1));
      }  
      else {
        if ((! db->autoCommit)) {
          sqlite3ErrorMsg(pParse, "Safety level may not be changed inside a transaction");
        }  
        else {
          (pDb->safety_level = (getSafetyLevel(zRight, 0, 1) + 1));
          setAllPagerFlags(db);
        }
      }
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_pager_pragmas) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 29)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 29)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 29)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 29)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 29)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 29)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 29)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 29)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 29)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 29)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 29)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 29)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 2:
    {
      if ((zRight == 0)) {
        if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
          returnSingleInt(pParse, _1342_aPragmaNames[mid].zName, ((db->flags & _1342_aPragmaNames[mid].iArg) != 0));
        }  
        if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
          returnSingleInt(pParse, _1339_aPragmaNames[mid].zName, ((db->flags & _1339_aPragmaNames[mid].iArg) != 0));
        }  
        if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
          returnSingleInt(pParse, _1340_aPragmaNames[mid].zName, ((db->flags & _1340_aPragmaNames[mid].iArg) != 0));
        }  
        if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
          returnSingleInt(pParse, _1343_aPragmaNames[mid].zName, ((db->flags & _1343_aPragmaNames[mid].iArg) != 0));
        }  
        if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
          returnSingleInt(pParse, _1341_aPragmaNames[mid].zName, ((db->flags & _1341_aPragmaNames[mid].iArg) != 0));
        }  
        if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
          returnSingleInt(pParse, _1335_aPragmaNames[mid].zName, ((db->flags & _1335_aPragmaNames[mid].iArg) != 0));
        }  
        if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
          returnSingleInt(pParse, _1345_aPragmaNames[mid].zName, ((db->flags & _1345_aPragmaNames[mid].iArg) != 0));
        }  
        if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
          returnSingleInt(pParse, _1338_aPragmaNames[mid].zName, ((db->flags & _1338_aPragmaNames[mid].iArg) != 0));
        }  
        if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
          returnSingleInt(pParse, _1344_aPragmaNames[mid].zName, ((db->flags & _1344_aPragmaNames[mid].iArg) != 0));
        }  
        if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
          returnSingleInt(pParse, _1334_aPragmaNames[mid].zName, ((db->flags & _1334_aPragmaNames[mid].iArg) != 0));
        }  
        if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
          returnSingleInt(pParse, _1336_aPragmaNames[mid].zName, ((db->flags & _1336_aPragmaNames[mid].iArg) != 0));
        }  
        if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
          returnSingleInt(pParse, _1337_aPragmaNames[mid].zName, ((db->flags & _1337_aPragmaNames[mid].iArg) != 0));
        }  
      }  
      else {
        int mask =  (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1337_aPragmaNames[mid].iArg : (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1336_aPragmaNames[mid].iArg : (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) ) ? _1334_aPragmaNames[mid].iArg : ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1344_aPragmaNames[mid].iArg : ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1338_aPragmaNames[mid].iArg : ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1345_aPragmaNames[mid].iArg : ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) ) ? _1335_aPragmaNames[mid].iArg : ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) ) ? _1341_aPragmaNames[mid].iArg : (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1343_aPragmaNames[mid].iArg : (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) ) ? _1340_aPragmaNames[mid].iArg : ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) ) ? _1339_aPragmaNames[mid].iArg : _1342_aPragmaNames[mid].iArg)))))))))));
        if ((db->autoCommit == 0)) {
          (mask &= (~ 0x00080000));
        }  
        if (sqlite3GetBoolean(zRight, 0)) {
          (db->flags |= mask);
        }  
        else {
          (db->flags &= (~ mask));
          if ((mask == 0x01000000)) {
            (db->nDeferredImmCons = 0);
          }  
        }
        sqlite3VdbeAddOp2(v, 132, 0, 0);
        if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_pager_pragmas)) )) {
          setAllPagerFlags(db);
        }  
      }
      break;
    }
    case 30:
    if (zRight) {
      Table *pTab;
      (pTab = sqlite3FindTable(db, zRight, zDb));
      if (pTab) {
        int i, k;
        int nHidden =  0;
        Column *pCol;
        Index *pPk;
        for ((pPk = pTab->pIndex); (pPk && (pPk->autoIndex != 2)); (pPk = pPk->pNext)) {
          
        }
        sqlite3VdbeSetNumCols(v, 6);
        (pParse->nMem = 6);
        sqlite3CodeVerifySchema(pParse, iDb);
        sqlite3VdbeSetColName(v, 0, 0, "cid", ((sqlite3_destructor_type ) 0));
        sqlite3VdbeSetColName(v, 1, 0, "name", ((sqlite3_destructor_type ) 0));
        sqlite3VdbeSetColName(v, 2, 0, "type", ((sqlite3_destructor_type ) 0));
        sqlite3VdbeSetColName(v, 3, 0, "notnull", ((sqlite3_destructor_type ) 0));
        sqlite3VdbeSetColName(v, 4, 0, "dflt_value", ((sqlite3_destructor_type ) 0));
        sqlite3VdbeSetColName(v, 5, 0, "pk", ((sqlite3_destructor_type ) 0));
        sqlite3ViewGetColumnNames(pParse, pTab);
        for ((i = 0), (pCol = pTab->aCol); (i < pTab->nCol); i++, pCol++) {
          if (((pCol->colFlags & 0x0002) != 0)) {
            nHidden++;
            continue;
          }  
          sqlite3VdbeAddOp2(v, 21, (i - nHidden), 1);
          sqlite3VdbeAddOp4(v, 94, 0, 2, 0, pCol->zName, 0);
          sqlite3VdbeAddOp4(v, 94, 0, 3, 0, (pCol->zType ? pCol->zType : ""), 0);
          sqlite3VdbeAddOp2(v, 21, (pCol->notNull ? 1 : 0), 4);
          if (pCol->zDflt) {
            sqlite3VdbeAddOp4(v, 94, 0, 5, 0, ((char *) pCol->zDflt), 0);
          }  
          else {
            sqlite3VdbeAddOp2(v, 24, 0, 5);
          }
          if (((pCol->colFlags & 0x0001) == 0)) {
            (k = 0);
          } 
          else if ((pPk == 0)) {
            (k = 1);
          } 
          else {
            if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_coverage_test) )) {
              for ((k = 1); (1 && (pPk->aiColumn[(k - 1)] != i)); k++) {
                
              }
            }  
            if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_coverage_test)) || (id2i_sqlite_omit_pragma ))) {
              for ((k = 1); ((k <= pTab->nCol) && (pPk->aiColumn[(k - 1)] != i)); k++) {
                
              }
            }  
          }
          sqlite3VdbeAddOp2(v, 21, k, 6);
          sqlite3VdbeAddOp2(v, 30, 1, 6);
        }
      }  
    }  
    break;
    case 28:
    {
      Index *pIdx;
      HashElem *i;
      (v = sqlite3GetVdbe(pParse));
      sqlite3VdbeSetNumCols(v, 4);
      (pParse->nMem = 4);
      sqlite3CodeVerifySchema(pParse, iDb);
      sqlite3VdbeSetColName(v, 0, 0, "table", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeSetColName(v, 1, 0, "index", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeSetColName(v, 2, 0, "width", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeSetColName(v, 3, 0, "height", ((sqlite3_destructor_type ) 0));
      for ((i = (&pDb->pSchema->tblHash)->first); i; (i = i->next)) {
        Table *pTab =  i->data;
        sqlite3VdbeAddOp4(v, 94, 0, 1, 0, pTab->zName, 0);
        sqlite3VdbeAddOp2(v, 24, 0, 2);
        sqlite3VdbeAddOp2(v, 21, ((int ) sqlite3LogEstToInt(pTab->szTabRow)), 3);
        sqlite3VdbeAddOp2(v, 21, ((int ) pTab->nRowEst), 4);
        sqlite3VdbeAddOp2(v, 30, 1, 4);
        for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
          sqlite3VdbeAddOp4(v, 94, 0, 2, 0, pIdx->zName, 0);
          sqlite3VdbeAddOp2(v, 21, ((int ) sqlite3LogEstToInt(pIdx->szIdxRow)), 3);
          sqlite3VdbeAddOp2(v, 21, ((int ) pIdx->aiRowEst[0]), 4);
          sqlite3VdbeAddOp2(v, 30, 1, 4);
        }
      }
    }
    break;
    case 15:
    if (zRight) {
      Index *pIdx;
      Table *pTab;
      (pIdx = sqlite3FindIndex(db, zRight, zDb));
      if (pIdx) {
        int i;
        (pTab = pIdx->pTable);
        sqlite3VdbeSetNumCols(v, 3);
        (pParse->nMem = 3);
        sqlite3CodeVerifySchema(pParse, iDb);
        sqlite3VdbeSetColName(v, 0, 0, "seqno", ((sqlite3_destructor_type ) 0));
        sqlite3VdbeSetColName(v, 1, 0, "cid", ((sqlite3_destructor_type ) 0));
        sqlite3VdbeSetColName(v, 2, 0, "name", ((sqlite3_destructor_type ) 0));
        for ((i = 0); (i < pIdx->nColumn); i++) {
          int cnum =  pIdx->aiColumn[i];
          sqlite3VdbeAddOp2(v, 21, i, 1);
          sqlite3VdbeAddOp2(v, 21, cnum, 2);
          ((void ) 0);
          sqlite3VdbeAddOp4(v, 94, 0, 3, 0, pTab->aCol[cnum].zName, 0);
          sqlite3VdbeAddOp2(v, 30, 1, 3);
        }
      }  
    }  
    break;
    case 16:
    if (zRight) {
      Index *pIdx;
      Table *pTab;
      int i;
      (pTab = sqlite3FindTable(db, zRight, zDb));
      if (pTab) {
        (v = sqlite3GetVdbe(pParse));
        sqlite3VdbeSetNumCols(v, 3);
        (pParse->nMem = 3);
        sqlite3CodeVerifySchema(pParse, iDb);
        sqlite3VdbeSetColName(v, 0, 0, "seq", ((sqlite3_destructor_type ) 0));
        sqlite3VdbeSetColName(v, 1, 0, "name", ((sqlite3_destructor_type ) 0));
        sqlite3VdbeSetColName(v, 2, 0, "unique", ((sqlite3_destructor_type ) 0));
        for ((pIdx = pTab->pIndex), (i = 0); pIdx; (pIdx = pIdx->pNext), i++) {
          sqlite3VdbeAddOp2(v, 21, i, 1);
          sqlite3VdbeAddOp4(v, 94, 0, 2, 0, pIdx->zName, 0);
          sqlite3VdbeAddOp2(v, 21, (pIdx->onError != 0), 3);
          sqlite3VdbeAddOp2(v, 30, 1, 3);
        }
      }  
    }  
    break;
    case 9:
    {
      int i;
      sqlite3VdbeSetNumCols(v, 3);
      (pParse->nMem = 3);
      sqlite3VdbeSetColName(v, 0, 0, "seq", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeSetColName(v, 1, 0, "name", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeSetColName(v, 2, 0, "file", ((sqlite3_destructor_type ) 0));
      for ((i = 0); (i < db->nDb); i++) {
        if ((db->aDb[i].pBt == 0)) {
          continue;
        }  
        ((void ) 0);
        sqlite3VdbeAddOp2(v, 21, i, 1);
        sqlite3VdbeAddOp4(v, 94, 0, 2, 0, db->aDb[i].zName, 0);
        sqlite3VdbeAddOp4(v, 94, 0, 3, 0, sqlite3BtreeGetFilename(db->aDb[i].pBt), 0);
        sqlite3VdbeAddOp2(v, 30, 1, 3);
      }
    }
    break;
    case 6:
    {
      int i =  0;
      HashElem *p;
      sqlite3VdbeSetNumCols(v, 2);
      (pParse->nMem = 2);
      sqlite3VdbeSetColName(v, 0, 0, "seq", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeSetColName(v, 1, 0, "name", ((sqlite3_destructor_type ) 0));
      for ((p = (&db->aCollSeq)->first); p; (p = p->next)) {
        CollSeq *pColl =  ((CollSeq *) p->data);
        sqlite3VdbeAddOp2(v, 21, i++, 1);
        sqlite3VdbeAddOp4(v, 94, 0, 2, 0, pColl->zName, 0);
        sqlite3VdbeAddOp2(v, 30, 1, 2);
      }
    }
    break;
    case 13:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_foreign_key)) )) {
      if (zRight) {
        FKey *pFK;
        Table *pTab;
        (pTab = sqlite3FindTable(db, zRight, zDb));
        if (pTab) {
          (v = sqlite3GetVdbe(pParse));
          (pFK = pTab->pFKey);
          if (pFK) {
            int i =  0;
            sqlite3VdbeSetNumCols(v, 8);
            (pParse->nMem = 8);
            sqlite3CodeVerifySchema(pParse, iDb);
            sqlite3VdbeSetColName(v, 0, 0, "id", ((sqlite3_destructor_type ) 0));
            sqlite3VdbeSetColName(v, 1, 0, "seq", ((sqlite3_destructor_type ) 0));
            sqlite3VdbeSetColName(v, 2, 0, "table", ((sqlite3_destructor_type ) 0));
            sqlite3VdbeSetColName(v, 3, 0, "from", ((sqlite3_destructor_type ) 0));
            sqlite3VdbeSetColName(v, 4, 0, "to", ((sqlite3_destructor_type ) 0));
            sqlite3VdbeSetColName(v, 5, 0, "on_update", ((sqlite3_destructor_type ) 0));
            sqlite3VdbeSetColName(v, 6, 0, "on_delete", ((sqlite3_destructor_type ) 0));
            sqlite3VdbeSetColName(v, 7, 0, "match", ((sqlite3_destructor_type ) 0));
            while (pFK) {
              int j;
              for ((j = 0); (j < pFK->nCol); j++) {
                char *zCol =  pFK->aCol[j].zCol;
                char *zOnDelete =  ((char *) actionName(pFK->aAction[0]));
                char *zOnUpdate =  ((char *) actionName(pFK->aAction[1]));
                sqlite3VdbeAddOp2(v, 21, i, 1);
                sqlite3VdbeAddOp2(v, 21, j, 2);
                sqlite3VdbeAddOp4(v, 94, 0, 3, 0, pFK->zTo, 0);
                sqlite3VdbeAddOp4(v, 94, 0, 4, 0, pTab->aCol[pFK->aCol[j].iFrom].zName, 0);
                sqlite3VdbeAddOp4(v, (zCol ? 94 : 24), 0, 5, 0, zCol, 0);
                sqlite3VdbeAddOp4(v, 94, 0, 6, 0, zOnUpdate, 0);
                sqlite3VdbeAddOp4(v, 94, 0, 7, 0, zOnDelete, 0);
                sqlite3VdbeAddOp4(v, 94, 0, 8, 0, "NONE", 0);
                sqlite3VdbeAddOp2(v, 30, 1, 8);
              }
              ++i;
              (pFK = pFK->pNextFrom);
            }
          }  
        }  
      }  
    }  
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_foreign_key)) )) {
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_foreign_key) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 13)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 13)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 13)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 13)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 13)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 13)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 13)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 13)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 13)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 13)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 13)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 13)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 12:
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_foreign_key)) )) {
      FKey *pFK;
      Table *pTab;
      Table *pParent;
      Index *pIdx;
      int i;
      int j;
      HashElem *k;
      int x;
      int regResult;
      int regKey;
      int regRow;
      int addrTop;
      int addrOk;
      int *aiCols;
      (regResult = (pParse->nMem + 1));
      (pParse->nMem += 4);
      (regKey = ++pParse->nMem);
      (regRow = ++pParse->nMem);
      (v = sqlite3GetVdbe(pParse));
      sqlite3VdbeSetNumCols(v, 4);
      sqlite3VdbeSetColName(v, 0, 0, "table", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeSetColName(v, 1, 0, "rowid", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeSetColName(v, 2, 0, "parent", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeSetColName(v, 3, 0, "fkid", ((sqlite3_destructor_type ) 0));
      sqlite3CodeVerifySchema(pParse, iDb);
      (k = (&db->aDb[iDb].pSchema->tblHash)->first);
      while (k) {
        if (zRight) {
          (pTab = sqlite3LocateTable(pParse, 0, zRight, zDb));
          (k = 0);
        }  
        else {
          (pTab = ((Table *) k->data));
          (k = k->next);
        }
        if (((pTab == 0) || (pTab->pFKey == 0))) {
          continue;
        }  
        sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
        if (((pTab->nCol + regRow) > pParse->nMem)) {
          (pParse->nMem = (pTab->nCol + regRow));
        }  
        sqlite3OpenTable(pParse, 0, iDb, pTab, 48);
        sqlite3VdbeAddOp4(v, 94, 0, regResult, 0, pTab->zName, 0);
        for ((i = 1), (pFK = pTab->pFKey); pFK; i++, (pFK = pFK->pNextFrom)) {
          (pParent = sqlite3FindTable(db, pFK->zTo, zDb));
          if ((pParent == 0)) {
            continue;
          }  
          (pIdx = 0);
          sqlite3TableLock(pParse, iDb, pParent->tnum, 0, pParent->zName);
          (x = sqlite3FkLocateIndex(pParse, pParent, pFK, (&pIdx), 0));
          if ((x == 0)) {
            if ((pIdx == 0)) {
              sqlite3OpenTable(pParse, i, iDb, pParent, 48);
            }  
            else {
              KeyInfo *pKey =  sqlite3IndexKeyinfo(pParse, pIdx);
              sqlite3VdbeAddOp3(v, 48, i, pIdx->tnum, iDb);
              sqlite3VdbeChangeP4(v, (- 1), ((char *) pKey), (- 16));
            }
          }  
          else {
            (k = 0);
            break;
          }
        }
        ((void ) 0);
        if (pFK) {
          break;
        }  
        if ((pParse->nTab < i)) {
          (pParse->nTab = i);
        }  
        (addrTop = sqlite3VdbeAddOp1(v, 101, 0));
        for ((i = 1), (pFK = pTab->pFKey); pFK; i++, (pFK = pFK->pNextFrom)) {
          (pParent = sqlite3FindTable(db, pFK->zTo, zDb));
          (pIdx = 0);
          (aiCols = 0);
          if (pParent) {
            (x = sqlite3FkLocateIndex(pParse, pParent, pFK, (&pIdx), (&aiCols)));
            ((void ) 0);
          }  
          (addrOk = sqlite3VdbeMakeLabel(v));
          if ((pParent && (pIdx == 0))) {
            int iKey =  pFK->aCol[0].iFrom;
            ((void ) 0);
            if ((iKey != pTab->iPKey)) {
              sqlite3VdbeAddOp3(v, 41, 0, iKey, regRow);
              sqlite3ColumnDefault(v, pTab, iKey, regRow);
              sqlite3VdbeAddOp2(v, 73, regRow, addrOk);
              sqlite3VdbeAddOp2(v, 33, regRow, (sqlite3VdbeCurrentAddr(v) + 3));
            }  
            else {
              sqlite3VdbeAddOp2(v, 96, 0, regRow);
            }
            sqlite3VdbeAddOp3(v, 63, i, 0, regRow);
            sqlite3VdbeAddOp2(v, 14, 0, addrOk);
            sqlite3VdbeJumpHere(v, (sqlite3VdbeCurrentAddr(v) - 2));
          }  
          else {
            for ((j = 0); (j < pFK->nCol); j++) {
              sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, (aiCols ? aiCols[j] : pFK->aCol[j].iFrom), (regRow + j));
              sqlite3VdbeAddOp2(v, 73, (regRow + j), addrOk);
            }
            if (pParent) {
              sqlite3VdbeAddOp3(v, 43, regRow, pFK->nCol, regKey);
              sqlite3VdbeChangeP4(v, (- 1), sqlite3IndexAffinityStr(v, pIdx), 0);
              sqlite3VdbeAddOp4Int(v, 61, i, addrOk, regKey, 0);
            }  
          }
          sqlite3VdbeAddOp2(v, 96, 0, (regResult + 1));
          sqlite3VdbeAddOp4(v, 94, 0, (regResult + 2), 0, pFK->zTo, 0);
          sqlite3VdbeAddOp2(v, 21, (i - 1), (regResult + 3));
          sqlite3VdbeAddOp2(v, 30, regResult, 4);
          sqlite3VdbeResolveLabel(v, addrOk);
          sqlite3DbFree(db, aiCols);
        }
        sqlite3VdbeAddOp2(v, 7, 0, (addrTop + 1));
        sqlite3VdbeJumpHere(v, addrTop);
      }
    }  
    if ((((! id2i_sqlite_omit_pragma) && (! id2i_sqlite_omit_foreign_key)) )) {
      break;
    }  
    if ((((! id2i_sqlite_omit_pragma) && id2i_sqlite_omit_foreign_key) || (id2i_sqlite_omit_pragma ))) {
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1342_aPragmaNames[mid].ePragTyp == 12)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1339_aPragmaNames[mid].ePragTyp == 12)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1340_aPragmaNames[mid].ePragTyp == 12)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1343_aPragmaNames[mid].ePragTyp == 12)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1341_aPragmaNames[mid].ePragTyp == 12)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1335_aPragmaNames[mid].ePragTyp == 12)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && (! id2i_sqlite_omit_foreign_key) && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1345_aPragmaNames[mid].ePragTyp == 12)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1338_aPragmaNames[mid].ePragTyp == 12)) {
          goto id2i_label_1;
        }  
      }  
      if ((((! id2i_sqlite_omit_deprecated) && id2i_sqlite_omit_foreign_key && (! id2i_sqlite_omit_autovacuum) && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1344_aPragmaNames[mid].ePragTyp == 12)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && id2i_sqlite_omit_pager_pragmas) )) {
        if ((_1334_aPragmaNames[mid].ePragTyp == 12)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && id2i_sqlite_omit_foreign_key && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1336_aPragmaNames[mid].ePragTyp == 12)) {
          goto id2i_label_1;
        }  
      }  
      if (((id2i_sqlite_omit_deprecated && (! id2i_sqlite_omit_foreign_key) && id2i_sqlite_omit_autovacuum && (! id2i_sqlite_omit_pager_pragmas)) )) {
        if ((_1337_aPragmaNames[mid].ePragTyp == 12)) {
          goto id2i_label_1;
        }  
      }  
    }  
    case 5:
    {
      if (zRight) {
        sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));
      }  
    }
    break;
    case 17:
    {
      int i, j, addr, mxErr;
      static const VdbeOpList endCode[] =  { { 32,  1,  0,  0},  { 127,  1,  0,  0},  { 94,  0,  3,  0},  { 30,  3,  1,  0}};
      int isQuick =  (((id2i_sqlite_ebcdic ) ) ? (_1282_sqlite3UpperToLower[((unsigned  char ) zLeft[0])] == 'q') : (_1281_sqlite3UpperToLower[((unsigned  char ) zLeft[0])] == 'q'));
      ((void ) 0);
      ((void ) 0);
      if ((pId2->z == 0)) {
        (iDb = (- 1));
      }  
      (pParse->nMem = 6);
      sqlite3VdbeSetNumCols(v, 1);
      sqlite3VdbeSetColName(v, 0, 0, "integrity_check", ((sqlite3_destructor_type ) 0));
      (mxErr = 100);
      if (zRight) {
        sqlite3GetInt32(zRight, (&mxErr));
        if ((mxErr <= 0)) {
          (mxErr = 100);
        }  
      }  
      sqlite3VdbeAddOp2(v, 21, mxErr, 1);
      for ((i = 0); (i < db->nDb); i++) {
        HashElem *x;
        Hash *pTbls;
        int cnt =  0;
        if ((0 && (i == 1))) {
          continue;
        }  
        if (((iDb >= 0) && (i != iDb))) {
          continue;
        }  
        sqlite3CodeVerifySchema(pParse, i);
        (addr = sqlite3VdbeAddOp1(v, 126, 1));
        sqlite3VdbeAddOp2(v, 20, 0, 0);
        sqlite3VdbeJumpHere(v, addr);
        ((void ) 0);
        (pTbls = (&db->aDb[i].pSchema->tblHash));
        for ((x = pTbls->first); x; (x = x->next)) {
          Table *pTab =  x->data;
          Index *pIdx;
          sqlite3VdbeAddOp2(v, 21, pTab->tnum, (2 + cnt));
          cnt++;
          for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
            sqlite3VdbeAddOp2(v, 21, pIdx->tnum, (2 + cnt));
            cnt++;
          }
        }
        (pParse->nMem = ((pParse->nMem > (cnt + 7)) ? pParse->nMem : (cnt + 7)));
        sqlite3VdbeAddOp3(v, 117, 2, cnt, 1);
        sqlite3VdbeChangeP5(v, ((u8 ) i));
        (addr = sqlite3VdbeAddOp1(v, 73, 2));
        sqlite3VdbeAddOp4(v, 94, 0, 3, 0, sqlite3MPrintf(db, "*** in database %s ***\n", db->aDb[i].zName), (- 1));
        sqlite3VdbeAddOp2(v, 27, 2, 4);
        sqlite3VdbeAddOp3(v, 91, 4, 3, 2);
        sqlite3VdbeAddOp2(v, 30, 2, 1);
        sqlite3VdbeJumpHere(v, addr);
        for ((x = pTbls->first); (x && (! isQuick)); (x = x->next)) {
          Table *pTab =  x->data;
          Index *pIdx;
          int loopTop;
          if ((pTab->pIndex == 0)) {
            continue;
          }  
          (addr = sqlite3VdbeAddOp1(v, 126, 1));
          sqlite3VdbeAddOp2(v, 20, 0, 0);
          sqlite3VdbeJumpHere(v, addr);
          sqlite3ExprCacheClear(pParse);
          sqlite3OpenTableAndIndices(pParse, pTab, 1, 48);
          for ((j = 0), (pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext), j++) {
            sqlite3VdbeAddOp2(v, 21, 0, (7 + j));
          }
          (pParse->nMem = ((pParse->nMem > (7 + j)) ? pParse->nMem : (7 + j)));
          (loopTop = (sqlite3VdbeAddOp2(v, 101, 1, 0) + 1));
          for ((j = 0), (pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext), j++) {
            int jmp2, jmp3;
            int r1;
            static const VdbeOpList idxErr[] =  { { 32,  1,  (- 1),  0},  { 94,  0,  3,  0},  { 96,  1,  4,  0},  { 94,  0,  5,  0},  { 94,  0,  6,  0},  { 91,  4,  3,  3},  { 91,  5,  3,  3},  { 91,  6,  3,  3},  { 30,  3,  1,  0},  { 126,  1,  0,  0},  { 20,  0,  0,  0}};
            (r1 = sqlite3GenerateIndexKey(pParse, pIdx, 1, 3, 0, (&jmp3)));
            sqlite3VdbeAddOp2(v, 32, (7 + j), 1);
            (jmp2 = sqlite3VdbeAddOp4Int(v, 61, (j + 2), 0, r1, (pIdx->nColumn + 1)));
            (addr = sqlite3VdbeAddOpList(v, ((int ) (sizeof(idxErr) / sizeof(idxErr[0]))), idxErr));
            sqlite3VdbeChangeP4(v, (addr + 1), "rowid ", (- 2));
            sqlite3VdbeChangeP4(v, (addr + 3), " missing from index ", (- 2));
            sqlite3VdbeChangeP4(v, (addr + 4), pIdx->zName, 0);
            sqlite3VdbeJumpHere(v, (addr + 9));
            sqlite3VdbeJumpHere(v, jmp2);
            sqlite3VdbeResolveLabel(v, jmp3);
          }
          sqlite3VdbeAddOp2(v, 7, 1, loopTop);
          sqlite3VdbeJumpHere(v, (loopTop - 1));
          sqlite3VdbeAddOp4(v, 94, 0, 2, 0, "wrong # of entries in index ", (- 2));
          for ((j = 0), (pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext), j++) {
            (addr = sqlite3VdbeCurrentAddr(v));
            sqlite3VdbeAddOp2(v, 126, 1, (addr + 2));
            sqlite3VdbeAddOp2(v, 20, 0, 0);
            sqlite3VdbeAddOp2(v, 44, (j + 2), 3);
            sqlite3VdbeAddOp3(v, 76, (7 + j), (addr + 8), 3);
            sqlite3VdbeAddOp2(v, 32, 1, (- 1));
            sqlite3VdbeAddOp4(v, 94, 0, 3, 0, pIdx->zName, 0);
            sqlite3VdbeAddOp3(v, 91, 3, 2, 7);
            sqlite3VdbeAddOp2(v, 30, 7, 1);
          }
        }
      }
      (addr = sqlite3VdbeAddOpList(v, ((int ) (sizeof(endCode) / sizeof(endCode[0]))), endCode));
      sqlite3VdbeChangeP2(v, addr, (- mxErr));
      sqlite3VdbeJumpHere(v, (addr + 1));
      sqlite3VdbeChangeP4(v, (addr + 2), "ok", (- 2));
    }
    break;
    case 11:
    {
      static const struct  EncName {
        char *zName ;
        u8 enc ;
      }  encnames[] =  { { "UTF8",  1},  { "UTF-8",  1},  { "UTF-16le",  2},  { "UTF-16be",  3},  { "UTF16le",  2},  { "UTF16be",  3},  { "UTF-16",  0},  { "UTF16",  0},  { 0,  0}};
      const struct  EncName   *pEnc;
      if ((! zRight)) {
        if (sqlite3ReadSchema(pParse)) {
          goto pragma_out;
        }  
        sqlite3VdbeSetNumCols(v, 1);
        sqlite3VdbeSetColName(v, 0, 0, "encoding", ((sqlite3_destructor_type ) 0));
        sqlite3VdbeAddOp2(v, 94, 0, 1);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        sqlite3VdbeChangeP4(v, (- 1), encnames[pParse->db->aDb[0].pSchema->enc].zName, (- 2));
        sqlite3VdbeAddOp2(v, 30, 1, 1);
      }  
      else {
        if (((! ((db->aDb[0].pSchema->flags & 0x0001) == 0x0001)) || ((db->aDb[0].pSchema->flags & 0x0004) == 0x0004))) {
          for ((pEnc = (&encnames[0])); pEnc->zName; pEnc++) {
            if ((0 == sqlite3_stricmp(zRight, pEnc->zName))) {
              (pParse->db->aDb[0].pSchema->enc = (pEnc->enc ? pEnc->enc : 2));
              break;
            }  
          }
          if ((! pEnc->zName)) {
            sqlite3ErrorMsg(pParse, "unsupported encoding: %s", zRight);
          }  
        }  
      }
    }
    break;
    case 0:
    {
      int iCookie;
      sqlite3VdbeUsesBtree(v, iDb);
      switch (zLeft[0]) {
        case 'a':
        case 'A':
        (iCookie = 8);
        break;
        case 'f':
        case 'F':
        (iCookie = 0);
        break;
        case 's':
        case 'S':
        (iCookie = 1);
        break;
        id2i_label_2:
        default:
        (iCookie = 6);
        break;
      }
      if ((zRight && (iCookie != 0))) {
        static const VdbeOpList setCookie[] =  { { 4,  0,  1,  0},  { 21,  0,  1,  0},  { 46,  0,  0,  1}};
        int addr =  sqlite3VdbeAddOpList(v, ((int ) (sizeof(setCookie) / sizeof(setCookie[0]))), setCookie);
        sqlite3VdbeChangeP1(v, addr, iDb);
        sqlite3VdbeChangeP1(v, (addr + 1), sqlite3Atoi(zRight));
        sqlite3VdbeChangeP1(v, (addr + 2), iDb);
        sqlite3VdbeChangeP2(v, (addr + 2), iCookie);
      }  
      else {
        static const VdbeOpList readCookie[] =  { { 4,  0,  0,  0},  { 45,  0,  1,  0},  { 30,  1,  1,  0}};
        int addr =  sqlite3VdbeAddOpList(v, ((int ) (sizeof(readCookie) / sizeof(readCookie[0]))), readCookie);
        sqlite3VdbeChangeP1(v, addr, iDb);
        sqlite3VdbeChangeP1(v, (addr + 1), iDb);
        sqlite3VdbeChangeP3(v, (addr + 1), iCookie);
        sqlite3VdbeSetNumCols(v, 1);
        sqlite3VdbeSetColName(v, 0, 0, zLeft, ((sqlite3_destructor_type ) (- 1)));
      }
    }
    break;
    case 7:
    {
      int i =  0;
      const char *zOpt;
      sqlite3VdbeSetNumCols(v, 1);
      (pParse->nMem = 1);
      sqlite3VdbeSetColName(v, 0, 0, "compile_option", ((sqlite3_destructor_type ) 0));
      while (((zOpt = sqlite3_compileoption_get(i++)) != 0)) {
        sqlite3VdbeAddOp4(v, 94, 0, 1, 0, zOpt, 0);
        sqlite3VdbeAddOp2(v, 30, 1, 1);
      }
    }
    break;
    case 34:
    {
      int iBt =  (pId2->z ? iDb : 10);
      int eMode =  0;
      if (zRight) {
        if ((sqlite3_stricmp(zRight, "full") == 0)) {
          (eMode = 1);
        } 
        else if ((sqlite3_stricmp(zRight, "restart") == 0)) {
          (eMode = 2);
        } 
      }  
      sqlite3VdbeSetNumCols(v, 3);
      (pParse->nMem = 3);
      sqlite3VdbeSetColName(v, 0, 0, "busy", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeSetColName(v, 1, 0, "log", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeSetColName(v, 2, 0, "checkpointed", ((sqlite3_destructor_type ) 0));
      sqlite3VdbeAddOp3(v, 9, iBt, eMode, 1);
      sqlite3VdbeAddOp2(v, 30, 1, 3);
    }
    break;
    case 33:
    {
      if (zRight) {
        sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));
      }  
      returnSingleInt(pParse, "wal_autocheckpoint", ((db->xWalCallback == sqlite3WalDefaultHook) ? ((int ) ((long  int ) db->pWalArg)) : 0));
    }
    break;
    case 26:
    {
      sqlite3_db_release_memory(db);
      break;
    }
    id2i_label_1:
    default:
    {
      ((void ) 0);
      if (zRight) {
        sqlite3_busy_timeout(db, sqlite3Atoi(zRight));
      }  
      returnSingleInt(pParse, "timeout", db->busyTimeout);
      break;
    }
    case 27:
    {
      sqlite3_int64 N;
      if ((zRight && (sqlite3Atoi64(zRight, (&N), 1000000, 1) == 0))) {
        sqlite3_soft_heap_limit64(N);
      }  
      returnSingleInt(pParse, "soft_heap_limit", sqlite3_soft_heap_limit64((- 1)));
      break;
    }
  }
  pragma_out:
  sqlite3DbFree(db, zLeft);
  sqlite3DbFree(db, zRight);
}
static  void corruptSchema(InitData *pData , const  char *zObj , const  char *zExtra )  {
  sqlite3 *db =  pData->db;
  if (((! db->mallocFailed) && ((db->flags & 0x00010000) == 0))) {
    if ((zObj == 0)) {
      (zObj = "?");
    }  
    sqlite3SetString(pData->pzErrMsg, db, "malformed database schema (%s)", zObj);
    if (zExtra) {
      ((*pData->pzErrMsg) = sqlite3MAppendf(db, (*pData->pzErrMsg), "%s - %s", (*pData->pzErrMsg), zExtra));
    }  
  }  
  (pData->rc = (db->mallocFailed ? 7 : sqlite3CorruptError(97292)));
}
static  int sqlite3InitCallback(void *pInit , int argc , char **argv , char **NotUsed )  {
  InitData *pData =  ((InitData *) pInit);
  sqlite3 *db =  pData->db;
  int iDb =  pData->iDb;
  ((void ) 0);
  ((void ) NotUsed), ((void ) argc);
  ((void ) 0);
  (db->aDb[iDb].pSchema->flags &= (~ 0x0004));
  if (db->mallocFailed) {
    corruptSchema(pData, argv[0], 0);
    return 1;
  }  
  ((void ) 0);
  if ((argv == 0)) {
    return 0;
  }  
  if ((argv[1] == 0)) {
    corruptSchema(pData, argv[0], 0);
  } 
  else if ((argv[2] && argv[2][0])) {
    int rc;
    sqlite3_stmt *pStmt;
    int rcp;
    ((void ) 0);
    (db->init.iDb = iDb);
    (db->init.newTnum = sqlite3Atoi(argv[1]));
    (db->init.orphanTrigger = 0);
    if (((id2i_sqlite_coverage_test ) )) {
      (rcp = sqlite3_prepare(db, argv[2], (- 1), (&pStmt), 0));
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      sqlite3_prepare(db, argv[2], (- 1), (&pStmt), 0);
    }  
    (rc = db->errCode);
    ((void ) 0);
    (db->init.iDb = 0);
    if ((0 != rc)) {
      if (db->init.orphanTrigger) {
        ((void ) 0);
      }  
      else {
        (pData->rc = rc);
        if ((rc == 7)) {
          (db->mallocFailed = 1);
        } 
        else if (((rc != 9) && ((rc & 0xFF) != 6))) {
          corruptSchema(pData, argv[0], sqlite3_errmsg(db));
        } 
      }
    }  
    sqlite3_finalize(pStmt);
  }
  
  else if ((argv[0] == 0)) {
    corruptSchema(pData, 0, 0);
  } 
  else {
    Index *pIndex;
    (pIndex = sqlite3FindIndex(db, argv[0], db->aDb[iDb].zName));
    if ((pIndex == 0)) {
      
    } 
    else if ((sqlite3GetInt32(argv[1], (&pIndex->tnum)) == 0)) {
      corruptSchema(pData, argv[0], "invalid rootpage");
    } 
  }
  return 0;
}
static  int sqlite3InitOne(sqlite3 *db , int iDb , char **pzErrMsg )  {
  int rc;
  int i;
  int _1263_size;
  Table *pTab;
  Db *pDb;
  char const *azArg[4];
  int meta[5];
  InitData initData;
  char const *zMasterSchema;
  char const *zMasterName;
  int openedTransaction =  0;
  static const char master_schema[] =  "CREATE TABLE sqlite_master(\n" "  type text,\n" "  name text,\n" "  tbl_name text,\n" "  rootpage integer,\n" "  sql text\n" ")";
  static const char temp_master_schema[] =  "CREATE TEMP TABLE sqlite_temp_master(\n" "  type text,\n" "  name text,\n" "  tbl_name text,\n" "  rootpage integer,\n" "  sql text\n" ")";
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((! 0) && (iDb == 1))) {
    (zMasterSchema = temp_master_schema);
  }  
  else {
    (zMasterSchema = master_schema);
  }
  (zMasterName = (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"));
  (azArg[0] = zMasterName);
  (azArg[1] = "1");
  (azArg[2] = zMasterSchema);
  (azArg[3] = 0);
  (initData.db = db);
  (initData.iDb = iDb);
  (initData.rc = 0);
  (initData.pzErrMsg = pzErrMsg);
  sqlite3InitCallback((&initData), 3, ((char **) azArg), 0);
  if (initData.rc) {
    (rc = initData.rc);
    goto error_out;
  }  
  (pTab = sqlite3FindTable(db, zMasterName, db->aDb[iDb].zName));
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      (pTab->tabFlags |= 0x01);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pTab) {
      (pTab->tabFlags |= 0x01);
    }  
  }  
  (pDb = (&db->aDb[iDb]));
  if ((pDb->pBt == 0)) {
    if ((((! id2i_sqlite_coverage_test) ) )) {
      if (((! 0) && (iDb == 1))) {
        (db->aDb[1].pSchema->flags |= 0x0001);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if (((! 0) && 1)) {
        (db->aDb[1].pSchema->flags |= 0x0001);
      }  
    }  
    return 0;
  }  
  sqlite3BtreeEnter(pDb->pBt);
  if ((! sqlite3BtreeIsInReadTrans(pDb->pBt))) {
    (rc = sqlite3BtreeBeginTrans(pDb->pBt, 0));
    if ((rc != 0)) {
      sqlite3SetString(pzErrMsg, db, "%s", sqlite3ErrStr(rc));
      goto initone_error_out;
    }  
    (openedTransaction = 1);
  }  
  for ((i = 0); (i < ((int ) (sizeof(meta) / sizeof(meta[0])))); i++) {
    sqlite3BtreeGetMeta(pDb->pBt, (i + 1), ((u32 *) (&meta[i])));
  }
  (pDb->pSchema->schema_cookie = meta[(1 - 1)]);
  if (meta[(5 - 1)]) {
    if ((iDb == 0)) {
      u8 encoding;
      (encoding = (((u8 ) meta[(5 - 1)]) & 3));
      if ((encoding == 0)) {
        (encoding = 1);
      }  
      (db->aDb[0].pSchema->enc = encoding);
    }  
    else {
      if ((meta[(5 - 1)] != db->aDb[0].pSchema->enc)) {
        sqlite3SetString(pzErrMsg, db, "attached databases must use the same" " text encoding as main database");
        (rc = 1);
        goto initone_error_out;
      }  
    }
  }  
  else {
    (db->aDb[iDb].pSchema->flags |= 0x0004);
  }
  (pDb->pSchema->enc = db->aDb[0].pSchema->enc);
  if ((pDb->pSchema->cache_size == 0)) {
    if ((((! id2i_sqlite_omit_deprecated) ) )) {
      (_1263_size = sqlite3AbsInt32(meta[(3 - 1)]));
    }  
    if ((((! id2i_sqlite_omit_deprecated) ) )) {
      if ((_1263_size == 0)) {
        (_1263_size = 2000);
      }  
    }  
    if ((((! id2i_sqlite_omit_deprecated) ) )) {
      (pDb->pSchema->cache_size = _1263_size);
    }  
    if (((id2i_sqlite_omit_deprecated ) )) {
      (pDb->pSchema->cache_size = 2000);
    }  
    sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
  }  
  (pDb->pSchema->file_format = ((u8 ) meta[(2 - 1)]));
  if ((pDb->pSchema->file_format == 0)) {
    (pDb->pSchema->file_format = 1);
  }  
  if ((pDb->pSchema->file_format > 4)) {
    sqlite3SetString(pzErrMsg, db, "unsupported file format");
    (rc = 1);
    goto initone_error_out;
  }  
  if (((iDb == 0) && (meta[(2 - 1)] >= 4))) {
    (db->flags &= (~ 0x00008000));
  }  
  ((void ) 0);
  {
    char *zSql;
    (zSql = sqlite3MPrintf(db, "SELECT name, rootpage, sql FROM '%q'.%s ORDER BY rowid", db->aDb[iDb].zName, zMasterName));
    {
      int ( *xAuth)(void * , int , const  char * , const  char * , const  char * , const  char * );
      (xAuth = db->xAuth);
      (db->xAuth = 0);
      (rc = sqlite3_exec(db, zSql, sqlite3InitCallback, (&initData), 0));
      (db->xAuth = xAuth);
    }
    if ((rc == 0)) {
      (rc = initData.rc);
    }  
    sqlite3DbFree(db, zSql);
    if ((((! id2i_sqlite_omit_analyze) ) )) {
      if ((rc == 0)) {
        sqlite3AnalysisLoad(db, iDb);
      }  
    }  
  }
  if (db->mallocFailed) {
    (rc = 7);
    sqlite3ResetAllSchemasOfConnection(db);
  }  
  if (((rc == 0) || (db->flags & 0x00010000))) {
    (db->aDb[iDb].pSchema->flags |= 0x0001);
    (rc = 0);
  }  
  initone_error_out:
  if (openedTransaction) {
    sqlite3BtreeCommit(pDb->pBt);
  }  
  error_out:
  if (((rc == 7) || (rc == (10 | (12 << 8))))) {
    (db->mallocFailed = 1);
  }  
  return rc;
}
static  int sqlite3Init(sqlite3 *db , char **pzErrMsg )  {
  int i, rc;
  int commit_internal =  (! (db->flags & 0x00000002));
  ((void ) 0);
  (rc = 0);
  (db->init.busy = 1);
  for ((i = 0); ((rc == 0) && (i < db->nDb)); i++) {
    if ((((db->aDb[i].pSchema->flags & 0x0001) == 0x0001) || (i == 1))) {
      continue;
    }  
    (rc = sqlite3InitOne(db, i, pzErrMsg));
    if (rc) {
      sqlite3ResetOneSchema(db, i);
    }  
  }
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((rc == 0) && (db->nDb > 1) && (! ((db->aDb[1].pSchema->flags & 0x0001) == 0x0001)))) {
      (rc = sqlite3InitOne(db, 1, pzErrMsg));
      if (rc) {
        sqlite3ResetOneSchema(db, 1);
      }  
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((rc == 0) && 1 && (! ((db->aDb[1].pSchema->flags & 0x0001) == 0x0001)))) {
      (rc = sqlite3InitOne(db, 1, pzErrMsg));
      if (rc) {
        sqlite3ResetOneSchema(db, 1);
      }  
    }  
  }  
  (db->init.busy = 0);
  if (((rc == 0) && commit_internal)) {
    sqlite3CommitInternalChanges(db);
  }  
  return rc;
}
static  int sqlite3ReadSchema(Parse *pParse )  {
  int rc =  0;
  sqlite3 *db =  pParse->db;
  ((void ) 0);
  if ((! db->init.busy)) {
    (rc = sqlite3Init(db, (&pParse->zErrMsg)));
  }  
  if ((rc != 0)) {
    (pParse->rc = rc);
    pParse->nErr++;
  }  
  return rc;
}
static  void schemaIsValid(Parse *pParse )  {
  sqlite3 *db =  pParse->db;
  int iDb;
  int rc;
  int cookie;
  ((void ) 0);
  ((void ) 0);
  for ((iDb = 0); (iDb < db->nDb); iDb++) {
    int openedTransaction =  0;
    Btree *pBt =  db->aDb[iDb].pBt;
    if ((pBt == 0)) {
      continue;
    }  
    if ((! sqlite3BtreeIsInReadTrans(pBt))) {
      (rc = sqlite3BtreeBeginTrans(pBt, 0));
      if (((rc == 7) || (rc == (10 | (12 << 8))))) {
        (db->mallocFailed = 1);
      }  
      if ((rc != 0)) {
        return;
      }  
      (openedTransaction = 1);
    }  
    sqlite3BtreeGetMeta(pBt, 1, ((u32 *) (&cookie)));
    ((void ) 0);
    if ((cookie != db->aDb[iDb].pSchema->schema_cookie)) {
      sqlite3ResetOneSchema(db, iDb);
      (pParse->rc = 17);
    }  
    if (openedTransaction) {
      sqlite3BtreeCommit(pBt);
    }  
  }
}
static  int sqlite3SchemaToIndex(sqlite3 *db , Schema *pSchema )  {
  int i =  (- 1000000);
  ((void ) 0);
  if (pSchema) {
    if (((id2i_sqlite_coverage_test ) )) {
      for ((i = 0); 1; i++) {
        if ((db->aDb[i].pSchema == pSchema)) {
          break;
        }  
      }
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      for ((i = 0); (i < db->nDb); i++) {
        if ((db->aDb[i].pSchema == pSchema)) {
          break;
        }  
      }
    }  
    ((void ) 0);
  }  
  return i;
}
static  int sqlite3Prepare(sqlite3 *db , const  char *zSql , int nBytes , int saveSqlFlag , Vdbe *pReprepare , sqlite3_stmt **ppStmt , const  char **pzTail )  {
  Parse *pParse;
  char *zErrMsg =  0;
  int rc =  0;
  int i;
  (pParse = sqlite3DbMallocZero(db, sizeof((*pParse))));
  if ((pParse == 0)) {
    (rc = 7);
    goto end_prepare;
  }  
  (pParse->pReprepare = pReprepare);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  for ((i = 0); (i < db->nDb); i++) {
    Btree *pBt =  db->aDb[i].pBt;
    if (pBt) {
      ((void ) 0);
      (rc = sqlite3BtreeSchemaLocked(pBt));
      if (rc) {
        const char *zDb =  db->aDb[i].zName;
        sqlite3Error(db, rc, "database schema is locked: %s", zDb);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((db->flags & 0x0004000)) {
            sqlite3Coverage(97841);
          }  
        }  
        goto end_prepare;
      }  
    }  
  }
  sqlite3VtabUnlockList(db);
  (pParse->db = db);
  (pParse->nQueryLoop = 0);
  if (((nBytes >= 0) && ((nBytes == 0) || (zSql[(nBytes - 1)] != 0)))) {
    char *zSqlCopy;
    int mxLen =  db->aLimit[1];
    if (((id2i_sqlite_coverage_test ) )) {
      if ((nBytes == mxLen)) {
        sqlite3Coverage(97854);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((nBytes == (mxLen + 1))) {
        sqlite3Coverage(97855);
      }  
    }  
    if ((nBytes > mxLen)) {
      sqlite3Error(db, 18, "statement too long");
      (rc = sqlite3ApiExit(db, 18));
      goto end_prepare;
    }  
    (zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes));
    if (zSqlCopy) {
      sqlite3RunParser(pParse, zSqlCopy, (&zErrMsg));
      sqlite3DbFree(db, zSqlCopy);
      (pParse->zTail = (&zSql[(pParse->zTail - zSqlCopy)]));
    }  
    else {
      (pParse->zTail = (&zSql[nBytes]));
    }
  }  
  else {
    sqlite3RunParser(pParse, zSql, (&zErrMsg));
  }
  ((void ) 0);
  if (db->mallocFailed) {
    (pParse->rc = 7);
  }  
  if ((pParse->rc == 101)) {
    (pParse->rc = 0);
  }  
  if (pParse->checkSchema) {
    schemaIsValid(pParse);
  }  
  if (db->mallocFailed) {
    (pParse->rc = 7);
  }  
  if (pzTail) {
    ((*pzTail) = pParse->zTail);
  }  
  (rc = pParse->rc);
  if ((((! id2i_sqlite_omit_explain) ) )) {
    if (((rc == 0) && pParse->pVdbe && pParse->explain)) {
      static const char *const azColName[] =  { "addr",  "opcode",  "p1",  "p2",  "p3",  "p4",  "p5",  "comment",  "selectid",  "order",  "from",  "detail"};
      int iFirst, mx;
      if ((pParse->explain == 2)) {
        sqlite3VdbeSetNumCols(pParse->pVdbe, 4);
        (iFirst = 8);
        (mx = 12);
      }  
      else {
        sqlite3VdbeSetNumCols(pParse->pVdbe, 8);
        (iFirst = 0);
        (mx = 8);
      }
      for ((i = iFirst); (i < mx); i++) {
        sqlite3VdbeSetColName(pParse->pVdbe, (i - iFirst), 0, azColName[i], ((sqlite3_destructor_type ) 0));
      }
    }  
  }  
  if ((db->init.busy == 0)) {
    Vdbe *pVdbe =  pParse->pVdbe;
    sqlite3VdbeSetSql(pVdbe, zSql, ((int ) (pParse->zTail - zSql)), saveSqlFlag);
  }  
  if ((pParse->pVdbe && ((rc != 0) || db->mallocFailed))) {
    sqlite3VdbeFinalize(pParse->pVdbe);
    ((void ) 0);
  }  
  else {
    ((*ppStmt) = ((sqlite3_stmt *) pParse->pVdbe));
  }
  if (zErrMsg) {
    sqlite3Error(db, rc, "%s", zErrMsg);
    sqlite3DbFree(db, zErrMsg);
  }  
  else {
    sqlite3Error(db, rc, 0);
  }
  while (pParse->pTriggerPrg) {
    TriggerPrg *pT =  pParse->pTriggerPrg;
    (pParse->pTriggerPrg = pT->pNext);
    sqlite3DbFree(db, pT);
  }
  end_prepare:
  sqlite3DbFree(db, pParse);
  (rc = sqlite3ApiExit(db, rc));
  ((void ) 0);
  return rc;
}
static  int sqlite3LockAndPrepare(sqlite3 *db , const  char *zSql , int nBytes , int saveSqlFlag , Vdbe *pOld , sqlite3_stmt **ppStmt , const  char **pzTail )  {
  int rc;
  ((void ) 0);
  ((*ppStmt) = 0);
  if ((! sqlite3SafetyCheckOk(db))) {
    return sqlite3MisuseError(97957);
  }  
  sqlite3BtreeEnterAll(db);
  (rc = sqlite3Prepare(db, zSql, nBytes, saveSqlFlag, pOld, ppStmt, pzTail));
  if ((rc == 17)) {
    sqlite3_finalize((*ppStmt));
    (rc = sqlite3Prepare(db, zSql, nBytes, saveSqlFlag, pOld, ppStmt, pzTail));
  }  
  ((void ) 0);
  return rc;
}
static  int sqlite3Reprepare(Vdbe *p )  {
  int rc;
  sqlite3_stmt *pNew;
  const char *zSql;
  sqlite3 *db;
  ((void ) 0);
  (zSql = sqlite3_sql(((sqlite3_stmt *) p)));
  ((void ) 0);
  (db = sqlite3VdbeDb(p));
  ((void ) 0);
  (rc = sqlite3LockAndPrepare(db, zSql, (- 1), 0, p, (&pNew), 0));
  if (rc) {
    if ((rc == 7)) {
      (db->mallocFailed = 1);
    }  
    ((void ) 0);
    return rc;
  }  
  else {
    ((void ) 0);
  }
  sqlite3VdbeSwap(((Vdbe *) pNew), p);
  sqlite3TransferBindings(pNew, ((sqlite3_stmt *) p));
  sqlite3VdbeResetStepResult(((Vdbe *) pNew));
  sqlite3VdbeFinalize(((Vdbe *) pNew));
  return 0;
}
int sqlite3_prepare(sqlite3 *db , const  char *zSql , int nBytes , sqlite3_stmt **ppStmt , const  char **pzTail )  {
  int rc;
  (rc = sqlite3LockAndPrepare(db, zSql, nBytes, 0, 0, ppStmt, pzTail));
  ((void ) 0);
  return rc;
}
int sqlite3_prepare_v2(sqlite3 *db , const  char *zSql , int nBytes , sqlite3_stmt **ppStmt , const  char **pzTail )  {
  int rc;
  (rc = sqlite3LockAndPrepare(db, zSql, nBytes, 1, 0, ppStmt, pzTail));
  ((void ) 0);
  return rc;
}
static  int sqlite3Prepare16(sqlite3 *db , const  void *zSql , int nBytes , int saveSqlFlag , sqlite3_stmt **ppStmt , const  void **pzTail )  {
  char *zSql8;
  const char *zTail8 =  0;
  int rc =  0;
  ((void ) 0);
  ((*ppStmt) = 0);
  if ((! sqlite3SafetyCheckOk(db))) {
    return sqlite3MisuseError(98066);
  }  
  if ((nBytes >= 0)) {
    int sz;
    const char *z =  ((const  char *) zSql);
    for ((sz = 0); ((sz < nBytes) && ((z[sz] != 0) || (z[(sz + 1)] != 0))); (sz += 2)) {
      
    }
    (nBytes = sz);
  }  
  (zSql8 = sqlite3Utf16to8(db, zSql, nBytes, 2));
  if (zSql8) {
    (rc = sqlite3LockAndPrepare(db, zSql8, (- 1), saveSqlFlag, 0, ppStmt, (&zTail8)));
  }  
  if ((zTail8 && pzTail)) {
    int chars_parsed =  sqlite3Utf8CharLen(zSql8, ((int ) (zTail8 - zSql8)));
    ((*pzTail) = (((u8 *) zSql) + sqlite3Utf16ByteLen(zSql, chars_parsed)));
  }  
  sqlite3DbFree(db, zSql8);
  (rc = sqlite3ApiExit(db, rc));
  return rc;
}
int sqlite3_prepare16(sqlite3 *db , const  void *zSql , int nBytes , sqlite3_stmt **ppStmt , const  void **pzTail )  {
  int rc;
  (rc = sqlite3Prepare16(db, zSql, nBytes, 0, ppStmt, pzTail));
  ((void ) 0);
  return rc;
}
int sqlite3_prepare16_v2(sqlite3 *db , const  void *zSql , int nBytes , sqlite3_stmt **ppStmt , const  void **pzTail )  {
  int rc;
  (rc = sqlite3Prepare16(db, zSql, nBytes, 1, ppStmt, pzTail));
  ((void ) 0);
  return rc;
}
static  void clearSelect(sqlite3 *db , Select *p )  {
  sqlite3ExprListDelete(db, p->pEList);
  sqlite3SrcListDelete(db, p->pSrc);
  sqlite3ExprDelete(db, p->pWhere);
  sqlite3ExprListDelete(db, p->pGroupBy);
  sqlite3ExprDelete(db, p->pHaving);
  sqlite3ExprListDelete(db, p->pOrderBy);
  sqlite3SelectDelete(db, p->pPrior);
  sqlite3ExprDelete(db, p->pLimit);
  sqlite3ExprDelete(db, p->pOffset);
}
static  void sqlite3SelectDestInit(SelectDest *pDest , int eDest , int iParm )  {
  (pDest->eDest = ((u8 ) eDest));
  (pDest->iSDParm = iParm);
  (pDest->affSdst = 0);
  (pDest->iSdst = 0);
  (pDest->nSdst = 0);
}
static  Select *sqlite3SelectNew(Parse *pParse , ExprList *pEList , SrcList *pSrc , Expr *pWhere , ExprList *pGroupBy , Expr *pHaving , ExprList *pOrderBy , u16 selFlags , Expr *pLimit , Expr *pOffset )  {
  Select *pNew;
  Select standin;
  sqlite3 *db =  pParse->db;
  (pNew = sqlite3DbMallocZero(db, sizeof((*pNew))));
  ((void ) 0);
  if ((pNew == 0)) {
    ((void ) 0);
    (pNew = (&standin));
    memset(pNew, 0, sizeof((*pNew)));
  }  
  if ((pEList == 0)) {
    (pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, 113, 0)));
  }  
  (pNew->pEList = pEList);
  if ((pSrc == 0)) {
    (pSrc = sqlite3DbMallocZero(db, sizeof((*pSrc))));
  }  
  (pNew->pSrc = pSrc);
  (pNew->pWhere = pWhere);
  (pNew->pGroupBy = pGroupBy);
  (pNew->pHaving = pHaving);
  (pNew->pOrderBy = pOrderBy);
  (pNew->selFlags = selFlags);
  (pNew->op = 116);
  (pNew->pLimit = pLimit);
  (pNew->pOffset = pOffset);
  ((void ) 0);
  (pNew->addrOpenEphm[0] = (- 1));
  (pNew->addrOpenEphm[1] = (- 1));
  (pNew->addrOpenEphm[2] = (- 1));
  if (db->mallocFailed) {
    clearSelect(db, pNew);
    if ((pNew != (&standin))) {
      sqlite3DbFree(db, pNew);
    }  
    (pNew = 0);
  }  
  else {
    ((void ) 0);
  }
  ((void ) 0);
  return pNew;
}
static  void sqlite3SelectDelete(sqlite3 *db , Select *p )  {
  if (p) {
    clearSelect(db, p);
    sqlite3DbFree(db, p);
  }  
}
static  int sqlite3JoinType(Parse *pParse , Token *pA , Token *pB , Token *pC )  {
  int jointype =  0;
  Token *apAll[3];
  Token *p;
  static const char zKeyText[] =  "naturaleftouterightfullinnercross";
  static const struct   {
    u8 i ;
    u8 nChar ;
    u8 code ;
  }  aKeyword[] =  { { 0,  7,  0x0004},  { 6,  4,  (0x0008 | 0x0020)},  { 10,  5,  0x0020},  { 14,  5,  (0x0010 | 0x0020)},  { 19,  4,  (0x0008 | 0x0010 | 0x0020)},  { 23,  5,  0x0001},  { 28,  5,  (0x0001 | 0x0002)}};
  int i, j;
  (apAll[0] = pA);
  (apAll[1] = pB);
  (apAll[2] = pC);
  for ((i = 0); ((i < 3) && apAll[i]); i++) {
    (p = apAll[i]);
    for ((j = 0); (j < ((int ) (sizeof(aKeyword) / sizeof(aKeyword[0])))); j++) {
      if (((p->n == aKeyword[j].nChar) && (sqlite3_strnicmp(((char *) p->z), (&zKeyText[aKeyword[j].i]), p->n) == 0))) {
        (jointype |= aKeyword[j].code);
        break;
      }  
    }
    if (((id2i_sqlite_coverage_test ) )) {
      if (((j == 0) || (j == 1) || (j == 2) || (j == 3) || (j == 4) || (j == 5) || (j == 6))) {
        sqlite3Coverage(98290);
      }  
    }  
    if ((j >= ((int ) (sizeof(aKeyword) / sizeof(aKeyword[0]))))) {
      (jointype |= 0x0040);
      break;
    }  
  }
  if ((((jointype & (0x0001 | 0x0020)) == (0x0001 | 0x0020)) || ((jointype & 0x0040) != 0))) {
    const char *zSp =  " ";
    ((void ) 0);
    if ((pC == 0)) {
      zSp++;
    }  
    sqlite3ErrorMsg(pParse, "unknown or unsupported join type: " "%T %T%s%T", pA, pB, zSp, pC);
    (jointype = 0x0001);
  } 
  else if ((((jointype & 0x0020) != 0) && ((jointype & (0x0008 | 0x0010)) != 0x0008))) {
    sqlite3ErrorMsg(pParse, "RIGHT and FULL OUTER JOINs are not currently supported");
    (jointype = 0x0001);
  } 
  return jointype;
}
static  int columnIndex(Table *pTab , const  char *zCol )  {
  int i;
  for ((i = 0); (i < pTab->nCol); i++) {
    if ((sqlite3_stricmp(pTab->aCol[i].zName, zCol) == 0)) {
      return i;
    }  
  }
  return (- 1);
}
static  int tableAndColumnIndex(SrcList *pSrc , int N , const  char *zCol , int *piTab , int *piCol )  {
  int i;
  int iCol;
  ((void ) 0);
  for ((i = 0); (i < N); i++) {
    (iCol = columnIndex(pSrc->a[i].pTab, zCol));
    if ((iCol >= 0)) {
      if (piTab) {
        ((*piTab) = i);
        ((*piCol) = iCol);
      }  
      return 1;
    }  
  }
  return 0;
}
static  void addWhereTerm(Parse *pParse , SrcList *pSrc , int iLeft , int iColLeft , int iRight , int iColRight , int isOuterJoin , Expr **ppWhere )  {
  sqlite3 *db =  pParse->db;
  Expr *pE1;
  Expr *pE2;
  Expr *pEq;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iColLeft));
  (pE2 = sqlite3CreateColumnExpr(db, pSrc, iRight, iColRight));
  (pEq = sqlite3PExpr(pParse, 76, pE1, pE2, 0));
  if ((pEq && isOuterJoin)) {
    (pEq->flags |= 0x000001);
    ((void ) 0);
    (pEq->iRightJoinTable = ((i16 ) pE2->iTable));
  }  
  ((*ppWhere) = sqlite3ExprAnd(db, (*ppWhere), pEq));
}
static  void setJoinExpr(Expr *p , int iTable )  {
  while (p) {
    (p->flags |= 0x000001);
    ((void ) 0);
    (p->iRightJoinTable = ((i16 ) iTable));
    setJoinExpr(p->pLeft, iTable);
    (p = p->pRight);
  }
}
static  int sqliteProcessJoin(Parse *pParse , Select *p )  {
  SrcList *pSrc;
  int i, j;
  struct  SrcList_item   *pLeft;
  struct  SrcList_item   *pRight;
  (pSrc = p->pSrc);
  (pLeft = (&pSrc->a[0]));
  (pRight = (&pLeft[1]));
  for ((i = 0); (i < (pSrc->nSrc - 1)); i++, pRight++, pLeft++) {
    Table *pLeftTab =  pLeft->pTab;
    Table *pRightTab =  pRight->pTab;
    int isOuter;
    if (((id2i_sqlite_coverage_test ) )) {
      if (0) {
        continue;
      }  
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      if (((pLeftTab == 0) || (pRightTab == 0))) {
        continue;
      }  
    }  
    (isOuter = ((pRight->jointype & 0x0020) != 0));
    if ((pRight->jointype & 0x0004)) {
      if ((pRight->pOn || pRight->pUsing)) {
        sqlite3ErrorMsg(pParse, "a NATURAL join may not have " "an ON or USING clause", 0);
        return 1;
      }  
      for ((j = 0); (j < pRightTab->nCol); j++) {
        char *zName;
        int iLeft;
        int iLeftCol;
        (zName = pRightTab->aCol[j].zName);
        if (tableAndColumnIndex(pSrc, (i + 1), zName, (&iLeft), (&iLeftCol))) {
          addWhereTerm(pParse, pSrc, iLeft, iLeftCol, (i + 1), j, isOuter, (&p->pWhere));
        }  
      }
    }  
    if ((pRight->pOn && pRight->pUsing)) {
      sqlite3ErrorMsg(pParse, "cannot have both ON and USING " "clauses in the same join");
      return 1;
    }  
    if (pRight->pOn) {
      if (isOuter) {
        setJoinExpr(pRight->pOn, pRight->iCursor);
      }  
      (p->pWhere = sqlite3ExprAnd(pParse->db, p->pWhere, pRight->pOn));
      (pRight->pOn = 0);
    }  
    if (pRight->pUsing) {
      IdList *pList =  pRight->pUsing;
      for ((j = 0); (j < pList->nId); j++) {
        char *zName;
        int iLeft;
        int iLeftCol;
        int iRightCol;
        (zName = pList->a[j].zName);
        (iRightCol = columnIndex(pRightTab, zName));
        if (((iRightCol < 0) || (! tableAndColumnIndex(pSrc, (i + 1), zName, (&iLeft), (&iLeftCol))))) {
          sqlite3ErrorMsg(pParse, "cannot join using column %s - column " "not present in both tables", zName);
          return 1;
        }  
        addWhereTerm(pParse, pSrc, iLeft, iLeftCol, (i + 1), iRightCol, isOuter, (&p->pWhere));
      }
    }  
  }
  return 0;
}
static  void pushOntoSorter(Parse *pParse , ExprList *pOrderBy , Select *pSelect , int regData )  {
  Vdbe *v =  pParse->pVdbe;
  int nExpr =  pOrderBy->nExpr;
  int regBase =  sqlite3GetTempRange(pParse, (nExpr + 2));
  int regRecord =  sqlite3GetTempReg(pParse);
  int op;
  sqlite3ExprCacheClear(pParse);
  sqlite3ExprCodeExprList(pParse, pOrderBy, regBase, 0);
  sqlite3VdbeAddOp2(v, 64, pOrderBy->iECursor, (regBase + nExpr));
  sqlite3ExprCodeMove(pParse, regData, (regBase + nExpr + 1), 1);
  sqlite3VdbeAddOp3(v, 43, regBase, (nExpr + 2), regRecord);
  if ((pSelect->selFlags & 0x0040)) {
    (op = 102);
  }  
  else {
    (op = 103);
  }
  sqlite3VdbeAddOp2(v, op, pOrderBy->iECursor, regRecord);
  sqlite3ReleaseTempReg(pParse, regRecord);
  sqlite3ReleaseTempRange(pParse, regBase, (nExpr + 2));
  if (pSelect->iLimit) {
    int addr1, addr2;
    int iLimit;
    if (pSelect->iOffset) {
      (iLimit = (pSelect->iOffset + 1));
    }  
    else {
      (iLimit = pSelect->iLimit);
    }
    (addr1 = sqlite3VdbeAddOp1(v, 128, iLimit));
    sqlite3VdbeAddOp2(v, 32, iLimit, (- 1));
    (addr2 = sqlite3VdbeAddOp0(v, 14));
    sqlite3VdbeJumpHere(v, addr1);
    sqlite3VdbeAddOp1(v, 98, pOrderBy->iECursor);
    sqlite3VdbeAddOp1(v, 70, pOrderBy->iECursor);
    sqlite3VdbeJumpHere(v, addr2);
  }  
}
static  void codeOffset(Vdbe *v , Select *p , int iContinue )  {
  if ((p->iOffset && (iContinue != 0))) {
    int addr;
    sqlite3VdbeAddOp2(v, 32, p->iOffset, (- 1));
    (addr = sqlite3VdbeAddOp1(v, 127, p->iOffset));
    sqlite3VdbeAddOp2(v, 14, 0, iContinue);
    sqlite3VdbeJumpHere(v, addr);
  }  
}
static  void codeDistinct(Parse *pParse , int iTab , int addrRepeat , int N , int iMem )  {
  Vdbe *v;
  int r1;
  (v = pParse->pVdbe);
  (r1 = sqlite3GetTempReg(pParse));
  sqlite3VdbeAddOp4Int(v, 61, iTab, addrRepeat, iMem, N);
  sqlite3VdbeAddOp3(v, 43, iMem, N, r1);
  sqlite3VdbeAddOp2(v, 103, iTab, r1);
  sqlite3ReleaseTempReg(pParse, r1);
}
static  int checkForMultiColumnSelectError(Parse *pParse , SelectDest *pDest , int nExpr )  {
  int eDest =  pDest->eDest;
  if (((nExpr > 1) && ((eDest == 6) || (eDest == 7)))) {
    sqlite3ErrorMsg(pParse, "only a single result allowed for " "a SELECT that is part of an expression");
    return 1;
  }  
  else {
    return 0;
  }
}
typedef struct  DistinctCtx   DistinctCtx;
struct  DistinctCtx {
  u8 isTnct ;
  u8 eTnctType ;
  int tabTnct ;
  int addrTnct ;
}  ;
static  void selectInnerLoop(Parse *pParse , Select *p , ExprList *pEList , int srcTab , int nColumn , ExprList *pOrderBy , DistinctCtx *pDistinct , SelectDest *pDest , int iContinue , int iBreak )  {
  Vdbe *v =  pParse->pVdbe;
  int i;
  int hasDistinct;
  int regResult;
  int eDest =  pDest->eDest;
  int iParm =  pDest->iSDParm;
  int nResultCol;
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((v == 0)) {
      return;
    }  
  }  
  ((void ) 0);
  (hasDistinct = (pDistinct ? pDistinct->eTnctType : 0));
  if (((pOrderBy == 0) && (! hasDistinct))) {
    codeOffset(v, p, iContinue);
  }  
  if ((nColumn > 0)) {
    (nResultCol = nColumn);
  }  
  else {
    (nResultCol = pEList->nExpr);
  }
  if ((pDest->iSdst == 0)) {
    (pDest->iSdst = (pParse->nMem + 1));
    (pDest->nSdst = nResultCol);
    (pParse->nMem += nResultCol);
  }  
  else {
    ((void ) 0);
  }
  (regResult = pDest->iSdst);
  if ((nColumn > 0)) {
    for ((i = 0); (i < nColumn); i++) {
      sqlite3VdbeAddOp3(v, 41, srcTab, i, (regResult + i));
    }
  } 
  else if ((eDest != 3)) {
    sqlite3ExprCacheClear(pParse);
    sqlite3ExprCodeExprList(pParse, pEList, regResult, (eDest == 5));
  } 
  (nColumn = nResultCol);
  if (hasDistinct) {
    ((void ) 0);
    ((void ) 0);
    switch (pDistinct->eTnctType) {
      case 2:
      {
        VdbeOp *pOp;
        int iJump;
        int regPrev;
        (regPrev = (pParse->nMem + 1));
        (pParse->nMem += nColumn);
        sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);
        (pOp = sqlite3VdbeGetOp(v, pDistinct->addrTnct));
        (pOp->opcode = 24);
        (pOp->p1 = 1);
        (pOp->p2 = regPrev);
        (iJump = (sqlite3VdbeCurrentAddr(v) + nColumn));
        for ((i = 0); (i < nColumn); i++) {
          CollSeq *pColl =  sqlite3ExprCollSeq(pParse, pEList->a[i].pExpr);
          if ((i < (nColumn - 1))) {
            sqlite3VdbeAddOp3(v, 75, (regResult + i), iJump, (regPrev + i));
          }  
          else {
            sqlite3VdbeAddOp3(v, 76, (regResult + i), iContinue, (regPrev + i));
          }
          sqlite3VdbeChangeP4(v, (- 1), ((const  char *) pColl), (- 4));
          sqlite3VdbeChangeP5(v, 0x80);
        }
        ((void ) 0);
        sqlite3VdbeAddOp3(v, 28, regResult, regPrev, (nColumn - 1));
        break;
      }
      case 1:
      {
        sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);
        break;
      }
      id2i_label_1:
      default:
      {
        ((void ) 0);
        codeDistinct(pParse, pDistinct->tabTnct, iContinue, nColumn, regResult);
        break;
      }
    }
    if ((pOrderBy == 0)) {
      codeOffset(v, p, iContinue);
    }  
  }  
  switch (eDest) {
    case 1:
    {
      int r1;
      (r1 = sqlite3GetTempReg(pParse));
      sqlite3VdbeAddOp3(v, 43, regResult, nColumn, r1);
      sqlite3VdbeAddOp2(v, 103, iParm, r1);
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }
    case 2:
    {
      sqlite3VdbeAddOp3(v, 104, iParm, regResult, nColumn);
      break;
    }
    case 8:
    case 9:
    {
      int r1 =  sqlite3GetTempReg(pParse);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((eDest == 8)) {
          sqlite3Coverage(98826);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((eDest == 9)) {
          sqlite3Coverage(98827);
        }  
      }  
      sqlite3VdbeAddOp3(v, 43, regResult, nColumn, r1);
      if (pOrderBy) {
        pushOntoSorter(pParse, pOrderBy, p, r1);
      }  
      else {
        int r2 =  sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp2(v, 65, iParm, r2);
        sqlite3VdbeAddOp3(v, 66, iParm, r1, r2);
        sqlite3VdbeChangeP5(v, 0x08);
        sqlite3ReleaseTempReg(pParse, r2);
      }
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }
    case 7:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      ((void ) 0);
      (pDest->affSdst = sqlite3CompareAffinity(pEList->a[0].pExpr, pDest->affSdst));
      if (pOrderBy) {
        pushOntoSorter(pParse, pOrderBy, p, regResult);
      }  
      else {
        int r1 =  sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp4(v, 43, regResult, 1, r1, (&pDest->affSdst), 1);
        sqlite3ExprCacheAffinityChange(pParse, regResult, 1);
        sqlite3VdbeAddOp2(v, 103, iParm, r1);
        sqlite3ReleaseTempReg(pParse, r1);
      }
      break;
    }  
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((eDest == 7)) {
        goto id2i_label_2;
      }  
    }  
    case 3:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      sqlite3VdbeAddOp2(v, 21, 1, iParm);
      break;
    }  
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((eDest == 3)) {
        goto id2i_label_2;
      }  
    }  
    case 6:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      ((void ) 0);
      if (pOrderBy) {
        pushOntoSorter(pParse, pOrderBy, p, regResult);
      }  
      else {
        sqlite3ExprCodeMove(pParse, regResult, iParm, 1);
      }
      break;
    }  
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((eDest == 6)) {
        goto id2i_label_2;
      }  
    }  
    case 10:
    case 5:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((eDest == 10)) {
          sqlite3Coverage(98897);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((eDest == 5)) {
          sqlite3Coverage(98898);
        }  
      }  
      if (pOrderBy) {
        int r1 =  sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp3(v, 43, regResult, nColumn, r1);
        pushOntoSorter(pParse, pOrderBy, p, r1);
        sqlite3ReleaseTempReg(pParse, r1);
      } 
      else if ((eDest == 10)) {
        sqlite3VdbeAddOp1(v, 17, pDest->iSDParm);
      } 
      else {
        sqlite3VdbeAddOp2(v, 30, regResult, nColumn);
        sqlite3ExprCacheAffinityChange(pParse, regResult, nColumn);
      }
      break;
    }
    id2i_label_2:
    default:
    {
      ((void ) 0);
      break;
    }
  }
  if (((pOrderBy == 0) && p->iLimit)) {
    sqlite3VdbeAddOp3(v, 128, p->iLimit, iBreak, (- 1));
  }  
}
static  KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db , int N )  {
  KeyInfo *p =  sqlite3DbMallocZero(db, (sizeof(KeyInfo ) + ((N + 1) * (sizeof(CollSeq *) + 1))));
  if (p) {
    (p->aSortOrder = ((u8 *) (&p->aColl[(N + 1)])));
    (p->nField = ((u16 ) N));
    (p->enc = db->aDb[0].pSchema->enc);
    (p->db = db);
  }  
  return p;
}
static  KeyInfo *keyInfoFromExprList(Parse *pParse , ExprList *pList )  {
  int nExpr;
  KeyInfo *pInfo;
  struct  ExprList_item   *pItem;
  sqlite3 *db =  pParse->db;
  int i;
  (nExpr = pList->nExpr);
  (pInfo = sqlite3KeyInfoAlloc(db, nExpr));
  if (pInfo) {
    for ((i = 0), (pItem = pList->a); (i < nExpr); i++, pItem++) {
      CollSeq *pColl;
      (pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr));
      if ((! pColl)) {
        (pColl = db->pDfltColl);
      }  
      (pInfo->aColl[i] = pColl);
      (pInfo->aSortOrder[i] = pItem->sortOrder);
    }
  }  
  return pInfo;
}
static  const  char *selectOpName(int id )  {
  char *z;
  switch (id) {
    case 113:
    (z = "UNION ALL");
    break;
    case 115:
    (z = "INTERSECT");
    break;
    case 114:
    (z = "EXCEPT");
    break;
    id2i_label_1:
    default:
    (z = "UNION");
    break;
  }
  return z;
}
static  void explainTempTable(Parse *pParse , const  char *zUsage )  {
  if ((pParse->explain == 2)) {
    Vdbe *v =  pParse->pVdbe;
    char *zMsg =  sqlite3MPrintf(pParse->db, "USE TEMP B-TREE FOR %s", zUsage);
    sqlite3VdbeAddOp4(v, 150, pParse->_1272_iSelectId, 0, 0, zMsg, (- 1));
  }  
}
static  void explainComposite(Parse *pParse , int op , int iSub1 , int iSub2 , int bUseTmp )  {
  ((void ) 0);
  if ((pParse->explain == 2)) {
    Vdbe *v =  pParse->pVdbe;
    char *zMsg =  sqlite3MPrintf(pParse->db, "COMPOUND SUBQUERIES %d AND %d %s(%s)", iSub1, iSub2, (bUseTmp ? "USING TEMP B-TREE " : ""), selectOpName(op));
    sqlite3VdbeAddOp4(v, 150, pParse->_1272_iSelectId, 0, 0, zMsg, (- 1));
  }  
}
static  void generateSortTail(Parse *pParse , Select *p , Vdbe *v , int nColumn , SelectDest *pDest )  {
  int addrBreak =  sqlite3VdbeMakeLabel(v);
  int addrContinue =  sqlite3VdbeMakeLabel(v);
  int addr;
  int iTab;
  int pseudoTab =  0;
  ExprList *pOrderBy =  p->pOrderBy;
  int eDest =  pDest->eDest;
  int iParm =  pDest->iSDParm;
  int regRow;
  int regRowid;
  (iTab = pOrderBy->iECursor);
  (regRow = sqlite3GetTempReg(pParse));
  if (((eDest == 5) || (eDest == 10))) {
    (pseudoTab = pParse->nTab++);
    sqlite3VdbeAddOp3(v, 53, pseudoTab, regRow, nColumn);
    (regRowid = 0);
  }  
  else {
    (regRowid = sqlite3GetTempReg(pParse));
  }
  if ((p->selFlags & 0x0040)) {
    int regSortOut =  ++pParse->nMem;
    int ptab2 =  pParse->nTab++;
    sqlite3VdbeAddOp3(v, 53, ptab2, regSortOut, (pOrderBy->nExpr + 2));
    (addr = (1 + sqlite3VdbeAddOp2(v, 99, iTab, addrBreak)));
    codeOffset(v, p, addrContinue);
    sqlite3VdbeAddOp2(v, 81, iTab, regSortOut);
    sqlite3VdbeAddOp3(v, 41, ptab2, (pOrderBy->nExpr + 1), regRow);
    sqlite3VdbeChangeP5(v, 0x20);
  }  
  else {
    (addr = (1 + sqlite3VdbeAddOp2(v, 100, iTab, addrBreak)));
    codeOffset(v, p, addrContinue);
    sqlite3VdbeAddOp3(v, 41, iTab, (pOrderBy->nExpr + 1), regRow);
  }
  switch (eDest) {
    case 8:
    case 9:
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((eDest == 8)) {
          sqlite3Coverage(99129);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((eDest == 9)) {
          sqlite3Coverage(99130);
        }  
      }  
      sqlite3VdbeAddOp2(v, 65, iParm, regRowid);
      sqlite3VdbeAddOp3(v, 66, iParm, regRow, regRowid);
      sqlite3VdbeChangeP5(v, 0x08);
      break;
    }
    case 7:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      ((void ) 0);
      sqlite3VdbeAddOp4(v, 43, regRow, 1, regRowid, (&pDest->affSdst), 1);
      sqlite3ExprCacheAffinityChange(pParse, regRow, 1);
      sqlite3VdbeAddOp2(v, 103, iParm, regRowid);
      break;
    }  
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((eDest == 7)) {
        goto id2i_label_1;
      }  
    }  
    case 6:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      ((void ) 0);
      sqlite3ExprCodeMove(pParse, regRow, iParm, 1);
      break;
    }  
    id2i_label_1:
    default:
    {
      int i;
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((eDest == 5)) {
          sqlite3Coverage(99155);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((eDest == 10)) {
          sqlite3Coverage(99156);
        }  
      }  
      for ((i = 0); (i < nColumn); i++) {
        ((void ) 0);
        sqlite3VdbeAddOp3(v, 41, pseudoTab, i, (pDest->iSdst + i));
        if ((i == 0)) {
          sqlite3VdbeChangeP5(v, 0x20);
        }  
      }
      if ((eDest == 5)) {
        sqlite3VdbeAddOp2(v, 30, pDest->iSdst, nColumn);
        sqlite3ExprCacheAffinityChange(pParse, pDest->iSdst, nColumn);
      }  
      else {
        sqlite3VdbeAddOp1(v, 17, pDest->iSDParm);
      }
      break;
    }
  }
  sqlite3ReleaseTempReg(pParse, regRow);
  sqlite3ReleaseTempReg(pParse, regRowid);
  sqlite3VdbeResolveLabel(v, addrContinue);
  if ((p->selFlags & 0x0040)) {
    sqlite3VdbeAddOp2(v, 5, iTab, addr);
  }  
  else {
    sqlite3VdbeAddOp2(v, 7, iTab, addr);
  }
  sqlite3VdbeResolveLabel(v, addrBreak);
  if (((eDest == 5) || (eDest == 10))) {
    sqlite3VdbeAddOp2(v, 54, pseudoTab, 0);
  }  
}
static  const  char *_1316_columnTypeImpl(NameContext *pNC , Expr *pExpr , const  char **pzOrigDb , const  char **pzOrigTab , const  char **pzOrigCol , u8 *pEstWidth )  {
  char const *zOrigDb =  0;
  char const *zOrigTab =  0;
  char const *zOrigCol =  0;
  char const *zType =  0;
  int j;
  u8 estWidth =  1;
  if (((id2i_sqlite_coverage_test ) )) {
    if ((0 || (pNC->pSrcList == 0))) {
      return 0;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((pExpr == 0) || (pNC->pSrcList == 0))) {
      return 0;
    }  
  }  
  switch (pExpr->op) {
    case 154:
    case 152:
    {
      Table *pTab =  0;
      Select *pS =  0;
      int iCol =  pExpr->iColumn;
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pExpr->op == 154)) {
          sqlite3Coverage(99250);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pExpr->op == 152)) {
          sqlite3Coverage(99251);
        }  
      }  
      while ((pNC && (! pTab))) {
        SrcList *pTabList =  pNC->pSrcList;
        for ((j = 0); ((j < pTabList->nSrc) && (pTabList->a[j].iCursor != pExpr->iTable)); j++) {
          
        }
        if ((j < pTabList->nSrc)) {
          (pTab = pTabList->a[j].pTab);
          (pS = pTabList->a[j].pSelect);
        }  
        else {
          (pNC = pNC->pNext);
        }
      }
      if ((pTab == 0)) {
        break;
      }  
      ((void ) 0);
      if (pS) {
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if (((iCol >= 0) && (iCol < pS->pEList->nExpr))) {
            NameContext sNC;
            Expr *p =  pS->pEList->a[iCol].pExpr;
            (sNC.pSrcList = pS->pSrc);
            (sNC.pNext = pNC);
            (sNC.pParse = pNC->pParse);
            (zType = _1316_columnTypeImpl((&sNC), p, (&zOrigDb), (&zOrigTab), (&zOrigCol), (&estWidth)));
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if (((iCol >= 0) && 1)) {
            NameContext sNC;
            Expr *p =  pS->pEList->a[iCol].pExpr;
            (sNC.pSrcList = pS->pSrc);
            (sNC.pNext = pNC);
            (sNC.pParse = pNC->pParse);
            (zType = _1316_columnTypeImpl((&sNC), p, (&zOrigDb), (&zOrigTab), (&zOrigCol), (&estWidth)));
          }  
        }  
      } 
      else if ((((id2i_sqlite_coverage_test ) ) && 1)) {
        ((void ) 0);
        if ((iCol < 0)) {
          (iCol = pTab->iPKey);
        }  
        ((void ) 0);
        if ((iCol < 0)) {
          (zType = "INTEGER");
          (zOrigCol = "rowid");
        }  
        else {
          (zType = pTab->aCol[iCol].zType);
          (zOrigCol = pTab->aCol[iCol].zName);
          (estWidth = pTab->aCol[iCol].szEst);
        }
        (zOrigTab = pTab->zName);
        if (pNC->pParse) {
          int iDb =  sqlite3SchemaToIndex(pNC->pParse->db, pTab->pSchema);
          (zOrigDb = pNC->pParse->db->aDb[iDb].zName);
        }  
      }
      
      else if (((((! id2i_sqlite_coverage_test) ) ) && pTab->pSchema)) {
        ((void ) 0);
        if ((iCol < 0)) {
          (iCol = pTab->iPKey);
        }  
        ((void ) 0);
        if ((iCol < 0)) {
          (zType = "INTEGER");
          (zOrigCol = "rowid");
        }  
        else {
          (zType = pTab->aCol[iCol].zType);
          (zOrigCol = pTab->aCol[iCol].zName);
          (estWidth = pTab->aCol[iCol].szEst);
        }
        (zOrigTab = pTab->zName);
        if (pNC->pParse) {
          int iDb =  sqlite3SchemaToIndex(pNC->pParse->db, pTab->pSchema);
          (zOrigDb = pNC->pParse->db->aDb[iDb].zName);
        }  
      } 
      break;
    }
    case 116:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      NameContext sNC;
      Select *pS =  pExpr->x.pSelect;
      Expr *p =  pS->pEList->a[0].pExpr;
      ((void ) 0);
      (sNC.pSrcList = pS->pSrc);
      (sNC.pNext = pNC);
      (sNC.pParse = pNC->pParse);
      (zType = _1316_columnTypeImpl((&sNC), p, (&zOrigDb), (&zOrigTab), (&zOrigCol), (&estWidth)));
      break;
    }  
  }
  if (pzOrigDb) {
    ((void ) 0);
    ((*pzOrigDb) = zOrigDb);
    ((*pzOrigTab) = zOrigTab);
    ((*pzOrigCol) = zOrigCol);
  }  
  if (pEstWidth) {
    ((*pEstWidth) = estWidth);
  }  
  return zType;
}
static  const  char *_1353_columnTypeImpl(NameContext *pNC , Expr *pExpr , u8 *pEstWidth )  {
  char const *zType =  0;
  int j;
  u8 estWidth =  1;
  if (((id2i_sqlite_coverage_test ) )) {
    if ((0 || (pNC->pSrcList == 0))) {
      return 0;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((pExpr == 0) || (pNC->pSrcList == 0))) {
      return 0;
    }  
  }  
  switch (pExpr->op) {
    case 154:
    case 152:
    {
      Table *pTab =  0;
      Select *pS =  0;
      int iCol =  pExpr->iColumn;
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pExpr->op == 154)) {
          sqlite3Coverage(99250);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pExpr->op == 152)) {
          sqlite3Coverage(99251);
        }  
      }  
      while ((pNC && (! pTab))) {
        SrcList *pTabList =  pNC->pSrcList;
        for ((j = 0); ((j < pTabList->nSrc) && (pTabList->a[j].iCursor != pExpr->iTable)); j++) {
          
        }
        if ((j < pTabList->nSrc)) {
          (pTab = pTabList->a[j].pTab);
          (pS = pTabList->a[j].pSelect);
        }  
        else {
          (pNC = pNC->pNext);
        }
      }
      if ((pTab == 0)) {
        break;
      }  
      ((void ) 0);
      if (pS) {
        if ((((! id2i_sqlite_coverage_test) ) )) {
          if (((iCol >= 0) && (iCol < pS->pEList->nExpr))) {
            NameContext sNC;
            Expr *p =  pS->pEList->a[iCol].pExpr;
            (sNC.pSrcList = pS->pSrc);
            (sNC.pNext = pNC);
            (sNC.pParse = pNC->pParse);
            (zType = _1353_columnTypeImpl((&sNC), p, (&estWidth)));
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if (((iCol >= 0) && 1)) {
            NameContext sNC;
            Expr *p =  pS->pEList->a[iCol].pExpr;
            (sNC.pSrcList = pS->pSrc);
            (sNC.pNext = pNC);
            (sNC.pParse = pNC->pParse);
            (zType = _1353_columnTypeImpl((&sNC), p, (&estWidth)));
          }  
        }  
      } 
      else if ((((id2i_sqlite_coverage_test ) ) && 1)) {
        ((void ) 0);
        if ((iCol < 0)) {
          (iCol = pTab->iPKey);
        }  
        ((void ) 0);
        if ((iCol < 0)) {
          (zType = "INTEGER");
        }  
        else {
          (zType = pTab->aCol[iCol].zType);
          (estWidth = pTab->aCol[iCol].szEst);
        }
      }
      
      else if (((((! id2i_sqlite_coverage_test) ) ) && pTab->pSchema)) {
        ((void ) 0);
        if ((iCol < 0)) {
          (iCol = pTab->iPKey);
        }  
        ((void ) 0);
        if ((iCol < 0)) {
          (zType = "INTEGER");
        }  
        else {
          (zType = pTab->aCol[iCol].zType);
          (estWidth = pTab->aCol[iCol].szEst);
        }
      } 
      break;
    }
    case 116:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      NameContext sNC;
      Select *pS =  pExpr->x.pSelect;
      Expr *p =  pS->pEList->a[0].pExpr;
      ((void ) 0);
      (sNC.pSrcList = pS->pSrc);
      (sNC.pNext = pNC);
      (sNC.pParse = pNC->pParse);
      (zType = _1353_columnTypeImpl((&sNC), p, (&estWidth)));
      break;
    }  
  }
  if (pEstWidth) {
    ((*pEstWidth) = estWidth);
  }  
  return zType;
}
static  void generateColumnTypes(Parse *pParse , SrcList *pTabList , ExprList *pEList )  {
  Vdbe *_1315_v =  pParse->pVdbe;
  int _1315_i;
  NameContext _1315_sNC;
  if ((((! id2i_sqlite_omit_decltype) ) )) {
    (_1315_sNC.pSrcList = pTabList);
  }  
  if ((((! id2i_sqlite_omit_decltype) ) )) {
    (_1315_sNC.pParse = pParse);
  }  
  if ((((! id2i_sqlite_omit_decltype) ) )) {
    for ((_1315_i = 0); (_1315_i < pEList->nExpr); _1315_i++) {
      Expr *p =  pEList->a[_1315_i].pExpr;
      const char *zType;
      const char *_1354_zOrigDb =  0;
      const char *_1354_zOrigTab =  0;
      const char *_1354_zOrigCol =  0;
      if (((id2i_sqlite_enable_column_metadata ) )) {
        (zType = _1316_columnTypeImpl((&_1315_sNC), p, (&_1354_zOrigDb), (&_1354_zOrigTab), (&_1354_zOrigCol), 0));
      }  
      if (((id2i_sqlite_enable_column_metadata ) )) {
        sqlite3VdbeSetColName(_1315_v, _1315_i, 2, _1354_zOrigDb, ((sqlite3_destructor_type ) (- 1)));
      }  
      if (((id2i_sqlite_enable_column_metadata ) )) {
        sqlite3VdbeSetColName(_1315_v, _1315_i, 3, _1354_zOrigTab, ((sqlite3_destructor_type ) (- 1)));
      }  
      if (((id2i_sqlite_enable_column_metadata ) )) {
        sqlite3VdbeSetColName(_1315_v, _1315_i, 4, _1354_zOrigCol, ((sqlite3_destructor_type ) (- 1)));
      }  
      if ((((! id2i_sqlite_enable_column_metadata) ) )) {
        (zType = _1353_columnTypeImpl((&_1315_sNC), p, 0));
      }  
      sqlite3VdbeSetColName(_1315_v, _1315_i, 1, zType, ((sqlite3_destructor_type ) (- 1)));
    }
  }  
}
static  void generateColumnNames(Parse *pParse , SrcList *pTabList , ExprList *pEList )  {
  Vdbe *v =  pParse->pVdbe;
  int i, j;
  sqlite3 *db =  pParse->db;
  int fullNames, shortNames;
  if ((((! id2i_sqlite_omit_explain) ) )) {
    if (pParse->explain) {
      return;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pParse->colNamesSet || (v == 0) || db->mallocFailed)) {
      return;
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pParse->colNamesSet || 0 || db->mallocFailed)) {
      return;
    }  
  }  
  (pParse->colNamesSet = 1);
  (fullNames = ((db->flags & 0x00000020) != 0));
  (shortNames = ((db->flags & 0x00000040) != 0));
  sqlite3VdbeSetNumCols(v, pEList->nExpr);
  for ((i = 0); (i < pEList->nExpr); i++) {
    Expr *p;
    (p = pEList->a[i].pExpr);
    if (((id2i_sqlite_coverage_test ) )) {
      if (0) {
        continue;
      }  
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      if ((p == 0)) {
        continue;
      }  
    }  
    if (pEList->a[i].zName) {
      char *zName =  pEList->a[i].zName;
      sqlite3VdbeSetColName(v, i, 0, zName, ((sqlite3_destructor_type ) (- 1)));
    } 
    else if ((((p->op == 152) || (p->op == 154)) && pTabList)) {
      Table *pTab;
      char *zCol;
      int iCol =  p->iColumn;
      if (((id2i_sqlite_coverage_test ) )) {
        for ((j = 0); 1; j++) {
          if ((pTabList->a[j].iCursor == p->iTable)) {
            break;
          }  
        }
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        for ((j = 0); (j < pTabList->nSrc); j++) {
          if ((pTabList->a[j].iCursor == p->iTable)) {
            break;
          }  
        }
      }  
      ((void ) 0);
      (pTab = pTabList->a[j].pTab);
      if ((iCol < 0)) {
        (iCol = pTab->iPKey);
      }  
      ((void ) 0);
      if ((iCol < 0)) {
        (zCol = "rowid");
      }  
      else {
        (zCol = pTab->aCol[iCol].zName);
      }
      if (((! shortNames) && (! fullNames))) {
        sqlite3VdbeSetColName(v, i, 0, sqlite3DbStrDup(db, pEList->a[i].zSpan), ((sqlite3_destructor_type ) sqlite3MallocSize));
      } 
      else if (fullNames) {
        char *zName =  0;
        (zName = sqlite3MPrintf(db, "%s.%s", pTab->zName, zCol));
        sqlite3VdbeSetColName(v, i, 0, zName, ((sqlite3_destructor_type ) sqlite3MallocSize));
      } 
      else {
        sqlite3VdbeSetColName(v, i, 0, zCol, ((sqlite3_destructor_type ) (- 1)));
      }
    } 
    else {
      sqlite3VdbeSetColName(v, i, 0, sqlite3DbStrDup(db, pEList->a[i].zSpan), ((sqlite3_destructor_type ) sqlite3MallocSize));
    }
  }
  generateColumnTypes(pParse, pTabList, pEList);
}
static  int selectColumnsFromExprList(Parse *pParse , ExprList *pEList , i16 *pnCol , Column **paCol )  {
  sqlite3 *db =  pParse->db;
  int i, j;
  int cnt;
  Column *aCol, *pCol;
  int nCol;
  Expr *p;
  char *zName;
  int nName;
  if (pEList) {
    (nCol = pEList->nExpr);
    (aCol = sqlite3DbMallocZero(db, (sizeof(aCol[0]) * nCol)));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((aCol == 0)) {
        sqlite3Coverage(99501);
      }  
    }  
  }  
  else {
    (nCol = 0);
    (aCol = 0);
  }
  ((*pnCol) = nCol);
  ((*paCol) = aCol);
  for ((i = 0), (pCol = aCol); (i < nCol); i++, pCol++) {
    (p = sqlite3ExprSkipCollate(pEList->a[i].pExpr));
    if (((zName = pEList->a[i].zName) != 0)) {
      (zName = sqlite3DbStrDup(db, zName));
    }  
    else {
      Expr *pColExpr =  p;
      Table *pTab;
      while ((pColExpr->op == 118)) {
        (pColExpr = pColExpr->pRight);
        ((void ) 0);
      }
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if (((pColExpr->op == 152) && (pColExpr->pTab != 0))) {
          int iCol =  pColExpr->iColumn;
          (pTab = pColExpr->pTab);
          if ((iCol < 0)) {
            (iCol = pTab->iPKey);
          }  
          (zName = sqlite3MPrintf(db, "%s", ((iCol >= 0) ? pTab->aCol[iCol].zName : "rowid")));
        } 
        else if ((pColExpr->op == 26)) {
          ((void ) 0);
          (zName = sqlite3MPrintf(db, "%s", pColExpr->u.zToken));
        } 
        else {
          (zName = sqlite3MPrintf(db, "%s", pEList->a[i].zSpan));
        }
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if (((pColExpr->op == 152) && 1)) {
          int iCol =  pColExpr->iColumn;
          (pTab = pColExpr->pTab);
          if ((iCol < 0)) {
            (iCol = pTab->iPKey);
          }  
          (zName = sqlite3MPrintf(db, "%s", ((iCol >= 0) ? pTab->aCol[iCol].zName : "rowid")));
        } 
        else if ((pColExpr->op == 26)) {
          ((void ) 0);
          (zName = sqlite3MPrintf(db, "%s", pColExpr->u.zToken));
        } 
        else {
          (zName = sqlite3MPrintf(db, "%s", pEList->a[i].zSpan));
        }
      }  
    }
    if (db->mallocFailed) {
      sqlite3DbFree(db, zName);
      break;
    }  
    (nName = sqlite3Strlen30(zName));
    for ((j = (cnt = 0)); (j < i); j++) {
      if ((sqlite3_stricmp(aCol[j].zName, zName) == 0)) {
        char *zNewName;
        int k;
        for ((k = (nName - 1)); ((k > 1) && (sqlite3CtypeMap[((unsigned  char ) zName[k])] & 0x04)); k--) {
          
        }
        if ((zName[k] == ':')) {
          (nName = k);
        }  
        (zName[nName] = 0);
        (zNewName = sqlite3MPrintf(db, "%s:%d", zName, ++cnt));
        sqlite3DbFree(db, zName);
        (zName = zNewName);
        (j = (- 1));
        if ((zName == 0)) {
          break;
        }  
      }  
    }
    (pCol->zName = zName);
  }
  if (db->mallocFailed) {
    for ((j = 0); (j < i); j++) {
      sqlite3DbFree(db, aCol[j].zName);
    }
    sqlite3DbFree(db, aCol);
    ((*paCol) = 0);
    ((*pnCol) = 0);
    return 7;
  }  
  return 0;
}
static  void selectAddColumnTypeAndCollation(Parse *pParse , Table *pTab , Select *pSelect )  {
  sqlite3 *db =  pParse->db;
  NameContext sNC;
  Column *pCol;
  CollSeq *pColl;
  int i;
  Expr *p;
  struct  ExprList_item   *a;
  u64 szAll =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (db->mallocFailed) {
    return;
  }  
  memset((&sNC), 0, sizeof(sNC));
  (sNC.pSrcList = pSelect->pSrc);
  (a = pSelect->pEList->a);
  for ((i = 0), (pCol = pTab->aCol); (i < pTab->nCol); i++, pCol++) {
    (p = a[i].pExpr);
    if ((((! id2i_sqlite_enable_column_metadata) ) )) {
      (pCol->zType = sqlite3DbStrDup(db, _1353_columnTypeImpl((&sNC), p, (&pCol->szEst))));
    }  
    if (((id2i_sqlite_enable_column_metadata ) )) {
      (pCol->zType = sqlite3DbStrDup(db, _1316_columnTypeImpl((&sNC), p, 0, 0, 0, (&pCol->szEst))));
    }  
    (szAll += pCol->szEst);
    (pCol->affinity = sqlite3ExprAffinity(p));
    if ((pCol->affinity == 0)) {
      (pCol->affinity = 'b');
    }  
    (pColl = sqlite3ExprCollSeq(pParse, p));
    if (pColl) {
      (pCol->zColl = sqlite3DbStrDup(db, pColl->zName));
    }  
  }
  (pTab->szTabRow = sqlite3LogEst((szAll * 4)));
}
static  Table *sqlite3ResultSetOfSelect(Parse *pParse , Select *pSelect )  {
  Table *pTab;
  sqlite3 *db =  pParse->db;
  int savedFlags;
  (savedFlags = db->flags);
  (db->flags &= (~ 0x00000020));
  (db->flags |= 0x00000040);
  sqlite3SelectPrep(pParse, pSelect, 0);
  if (pParse->nErr) {
    return 0;
  }  
  while (pSelect->pPrior) {
    (pSelect = pSelect->pPrior);
  }
  (db->flags = savedFlags);
  (pTab = sqlite3DbMallocZero(db, sizeof(Table )));
  if ((pTab == 0)) {
    return 0;
  }  
  ((void ) 0);
  (pTab->nRef = 1);
  (pTab->zName = 0);
  (pTab->nRowEst = 1048576);
  selectColumnsFromExprList(pParse, pSelect->pEList, (&pTab->nCol), (&pTab->aCol));
  selectAddColumnTypeAndCollation(pParse, pTab, pSelect);
  (pTab->iPKey = (- 1));
  if (db->mallocFailed) {
    sqlite3DeleteTable(db, pTab);
    return 0;
  }  
  return pTab;
}
static  Vdbe *sqlite3GetVdbe(Parse *pParse )  {
  Vdbe *v =  pParse->pVdbe;
  if ((v == 0)) {
    (v = (pParse->pVdbe = sqlite3VdbeCreate(pParse->db)));
    if (v) {
      sqlite3VdbeAddOp0(v, 148);
    }  
  }  
  return v;
}
static  void computeLimitRegisters(Parse *pParse , Select *p , int iBreak )  {
  Vdbe *v =  0;
  int iLimit =  0;
  int iOffset;
  int addr1, n;
  if (p->iLimit) {
    return;
  }  
  sqlite3ExprCacheClear(pParse);
  ((void ) 0);
  if (p->pLimit) {
    (p->iLimit = (iLimit = ++pParse->nMem));
    (v = sqlite3GetVdbe(pParse));
    if (((id2i_sqlite_coverage_test ) )) {
      if (0) {
        return;
      }  
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      if ((v == 0)) {
        return;
      }  
    }  
    if (sqlite3ExprIsInteger(p->pLimit, (&n))) {
      sqlite3VdbeAddOp2(v, 21, n, iLimit);
      if ((n == 0)) {
        sqlite3VdbeAddOp2(v, 14, 0, iBreak);
      } 
      else if (((n >= 0) && (p->nSelectRow > ((u64 ) n)))) {
        (p->nSelectRow = n);
      } 
    }  
    else {
      sqlite3ExprCode(pParse, p->pLimit, iLimit);
      sqlite3VdbeAddOp1(v, 33, iLimit);
      sqlite3VdbeAddOp2(v, 128, iLimit, iBreak);
    }
    if (p->pOffset) {
      (p->iOffset = (iOffset = ++pParse->nMem));
      pParse->nMem++;
      sqlite3ExprCode(pParse, p->pOffset, iOffset);
      sqlite3VdbeAddOp1(v, 33, iOffset);
      (addr1 = sqlite3VdbeAddOp1(v, 126, iOffset));
      sqlite3VdbeAddOp2(v, 21, 0, iOffset);
      sqlite3VdbeJumpHere(v, addr1);
      sqlite3VdbeAddOp3(v, 86, iLimit, iOffset, (iOffset + 1));
      (addr1 = sqlite3VdbeAddOp1(v, 126, iLimit));
      sqlite3VdbeAddOp2(v, 21, (- 1), (iOffset + 1));
      sqlite3VdbeJumpHere(v, addr1);
    }  
  }  
}
static  CollSeq *multiSelectCollSeq(Parse *pParse , Select *p , int iCol )  {
  CollSeq *pRet;
  if (p->pPrior) {
    (pRet = multiSelectCollSeq(pParse, p->pPrior, iCol));
  }  
  else {
    (pRet = 0);
  }
  ((void ) 0);
  if (((pRet == 0) && (iCol < p->pEList->nExpr))) {
    (pRet = sqlite3ExprCollSeq(pParse, p->pEList->a[iCol].pExpr));
  }  
  return pRet;
}
static int multiSelectOrderBy(Parse *pParse , Select *p , SelectDest *pDest );
static  int multiSelect(Parse *pParse , Select *p , SelectDest *pDest )  {
  int rc =  0;
  Select *pPrior;
  Vdbe *v;
  SelectDest dest;
  Select *pDelete =  0;
  sqlite3 *db;
  int _1272_iSub1;
  int _1272_iSub2;
  ((void ) 0);
  (db = pParse->db);
  (pPrior = p->pPrior);
  ((void ) 0);
  ((void ) 0);
  (dest = (*pDest));
  if (pPrior->pOrderBy) {
    sqlite3ErrorMsg(pParse, "ORDER BY clause should come after %s not before", selectOpName(p->op));
    (rc = 1);
    goto multi_select_end;
  }  
  if (pPrior->pLimit) {
    sqlite3ErrorMsg(pParse, "LIMIT clause should come after %s not before", selectOpName(p->op));
    (rc = 1);
    goto multi_select_end;
  }  
  (v = sqlite3GetVdbe(pParse));
  ((void ) 0);
  if ((dest.eDest == 9)) {
    ((void ) 0);
    sqlite3VdbeAddOp2(v, 51, dest.iSDParm, p->pEList->nExpr);
    sqlite3VdbeChangeP5(v, 8);
    (dest.eDest = 8);
  }  
  ((void ) 0);
  if ((p->pEList->nExpr != pPrior->pEList->nExpr)) {
    if ((p->selFlags & 0x0080)) {
      sqlite3ErrorMsg(pParse, "all VALUES must have the same number of terms");
    }  
    else {
      sqlite3ErrorMsg(pParse, "SELECTs to the left and right of %s" " do not have the same number of result columns", selectOpName(p->op));
    }
    (rc = 1);
    goto multi_select_end;
  }  
  if (p->pOrderBy) {
    return multiSelectOrderBy(pParse, p, pDest);
  }  
  switch (p->op) {
    case 113:
    {
      int addr =  0;
      int nLimit;
      ((void ) 0);
      (pPrior->iLimit = p->iLimit);
      (pPrior->iOffset = p->iOffset);
      (pPrior->pLimit = p->pLimit);
      (pPrior->pOffset = p->pOffset);
      if ((((! id2i_sqlite_omit_explain) ) )) {
        (_1272_iSub1 = pParse->_1272_iNextSelectId);
      }  
      (rc = sqlite3Select(pParse, pPrior, (&dest)));
      (p->pLimit = 0);
      (p->pOffset = 0);
      if (rc) {
        goto multi_select_end;
      }  
      (p->pPrior = 0);
      (p->iLimit = pPrior->iLimit);
      (p->iOffset = pPrior->iOffset);
      if (p->iLimit) {
        (addr = sqlite3VdbeAddOp1(v, 128, p->iLimit));
      }  
      if ((((! id2i_sqlite_omit_explain) ) )) {
        (_1272_iSub2 = pParse->_1272_iNextSelectId);
      }  
      (rc = sqlite3Select(pParse, p, (&dest)));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((rc != 0)) {
          sqlite3Coverage(99906);
        }  
      }  
      (pDelete = p->pPrior);
      (p->pPrior = pPrior);
      (p->nSelectRow += pPrior->nSelectRow);
      if ((pPrior->pLimit && sqlite3ExprIsInteger(pPrior->pLimit, (&nLimit)) && (nLimit > 0) && (p->nSelectRow > ((u64 ) nLimit)))) {
        (p->nSelectRow = nLimit);
      }  
      if (addr) {
        sqlite3VdbeJumpHere(v, addr);
      }  
      break;
    }
    case 114:
    case 112:
    {
      int unionTab;
      u8 op =  0;
      int priorOp;
      Expr *pLimit, *pOffset;
      int addr;
      SelectDest uniondest;
      if (((id2i_sqlite_coverage_test ) )) {
        if ((p->op == 114)) {
          sqlite3Coverage(99930);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((p->op == 112)) {
          sqlite3Coverage(99931);
        }  
      }  
      (priorOp = 1);
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if (((dest.eDest == priorOp) && ((! p->pLimit) && (! p->pOffset)))) {
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (unionTab = dest.iSDParm);
        }  
        else {
          (unionTab = pParse->nTab++);
          ((void ) 0);
          (addr = sqlite3VdbeAddOp2(v, 51, unionTab, 0));
          ((void ) 0);
          (p->addrOpenEphm[0] = addr);
          (p->pRightmost->selFlags |= 0x0008);
          ((void ) 0);
        }
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if (((dest.eDest == priorOp) && 1)) {
          ((void ) 0);
          ((void ) 0);
          ((void ) 0);
          (unionTab = dest.iSDParm);
        }  
        else {
          (unionTab = pParse->nTab++);
          ((void ) 0);
          (addr = sqlite3VdbeAddOp2(v, 51, unionTab, 0));
          ((void ) 0);
          (p->addrOpenEphm[0] = addr);
          (p->pRightmost->selFlags |= 0x0008);
          ((void ) 0);
        }
      }  
      ((void ) 0);
      sqlite3SelectDestInit((&uniondest), priorOp, unionTab);
      if ((((! id2i_sqlite_omit_explain) ) )) {
        (_1272_iSub1 = pParse->_1272_iNextSelectId);
      }  
      (rc = sqlite3Select(pParse, pPrior, (&uniondest)));
      if (rc) {
        goto multi_select_end;
      }  
      if ((p->op == 114)) {
        (op = 2);
      }  
      else {
        ((void ) 0);
        (op = 1);
      }
      (p->pPrior = 0);
      (pLimit = p->pLimit);
      (p->pLimit = 0);
      (pOffset = p->pOffset);
      (p->pOffset = 0);
      (uniondest.eDest = op);
      if ((((! id2i_sqlite_omit_explain) ) )) {
        (_1272_iSub2 = pParse->_1272_iNextSelectId);
      }  
      (rc = sqlite3Select(pParse, p, (&uniondest)));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((rc != 0)) {
          sqlite3Coverage(99981);
        }  
      }  
      sqlite3ExprListDelete(db, p->pOrderBy);
      (pDelete = p->pPrior);
      (p->pPrior = pPrior);
      (p->pOrderBy = 0);
      if ((p->op == 112)) {
        (p->nSelectRow += pPrior->nSelectRow);
      }  
      sqlite3ExprDelete(db, p->pLimit);
      (p->pLimit = pLimit);
      (p->pOffset = pOffset);
      (p->iLimit = 0);
      (p->iOffset = 0);
      ((void ) 0);
      if ((dest.eDest != priorOp)) {
        int iCont, iBreak, iStart;
        ((void ) 0);
        if ((dest.eDest == 5)) {
          Select *pFirst =  p;
          while (pFirst->pPrior) {
            (pFirst = pFirst->pPrior);
          }
          generateColumnNames(pParse, 0, pFirst->pEList);
        }  
        (iBreak = sqlite3VdbeMakeLabel(v));
        (iCont = sqlite3VdbeMakeLabel(v));
        computeLimitRegisters(pParse, p, iBreak);
        sqlite3VdbeAddOp2(v, 101, unionTab, iBreak);
        (iStart = sqlite3VdbeCurrentAddr(v));
        selectInnerLoop(pParse, p, p->pEList, unionTab, p->pEList->nExpr, 0, 0, (&dest), iCont, iBreak);
        sqlite3VdbeResolveLabel(v, iCont);
        sqlite3VdbeAddOp2(v, 7, unionTab, iStart);
        sqlite3VdbeResolveLabel(v, iBreak);
        sqlite3VdbeAddOp2(v, 54, unionTab, 0);
      }  
      break;
    }
    id2i_label_1:
    default:
    ((void ) 0);
    {
      int tab1, tab2;
      int iCont, iBreak, iStart;
      Expr *pLimit, *pOffset;
      int addr;
      SelectDest intersectdest;
      int r1;
      (tab1 = pParse->nTab++);
      (tab2 = pParse->nTab++);
      ((void ) 0);
      (addr = sqlite3VdbeAddOp2(v, 51, tab1, 0));
      ((void ) 0);
      (p->addrOpenEphm[0] = addr);
      (p->pRightmost->selFlags |= 0x0008);
      ((void ) 0);
      sqlite3SelectDestInit((&intersectdest), 1, tab1);
      if ((((! id2i_sqlite_omit_explain) ) )) {
        (_1272_iSub1 = pParse->_1272_iNextSelectId);
      }  
      (rc = sqlite3Select(pParse, pPrior, (&intersectdest)));
      if (rc) {
        goto multi_select_end;
      }  
      (addr = sqlite3VdbeAddOp2(v, 51, tab2, 0));
      ((void ) 0);
      (p->addrOpenEphm[1] = addr);
      (p->pPrior = 0);
      (pLimit = p->pLimit);
      (p->pLimit = 0);
      (pOffset = p->pOffset);
      (p->pOffset = 0);
      (intersectdest.iSDParm = tab2);
      if ((((! id2i_sqlite_omit_explain) ) )) {
        (_1272_iSub2 = pParse->_1272_iNextSelectId);
      }  
      (rc = sqlite3Select(pParse, p, (&intersectdest)));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((rc != 0)) {
          sqlite3Coverage(100065);
        }  
      }  
      (pDelete = p->pPrior);
      (p->pPrior = pPrior);
      if ((p->nSelectRow > pPrior->nSelectRow)) {
        (p->nSelectRow = pPrior->nSelectRow);
      }  
      sqlite3ExprDelete(db, p->pLimit);
      (p->pLimit = pLimit);
      (p->pOffset = pOffset);
      ((void ) 0);
      if ((dest.eDest == 5)) {
        Select *pFirst =  p;
        while (pFirst->pPrior) {
          (pFirst = pFirst->pPrior);
        }
        generateColumnNames(pParse, 0, pFirst->pEList);
      }  
      (iBreak = sqlite3VdbeMakeLabel(v));
      (iCont = sqlite3VdbeMakeLabel(v));
      computeLimitRegisters(pParse, p, iBreak);
      sqlite3VdbeAddOp2(v, 101, tab1, iBreak);
      (r1 = sqlite3GetTempReg(pParse));
      (iStart = sqlite3VdbeAddOp2(v, 92, tab1, r1));
      sqlite3VdbeAddOp4Int(v, 60, tab2, iCont, r1, 0);
      sqlite3ReleaseTempReg(pParse, r1);
      selectInnerLoop(pParse, p, p->pEList, tab1, p->pEList->nExpr, 0, 0, (&dest), iCont, iBreak);
      sqlite3VdbeResolveLabel(v, iCont);
      sqlite3VdbeAddOp2(v, 7, tab1, iStart);
      sqlite3VdbeResolveLabel(v, iBreak);
      sqlite3VdbeAddOp2(v, 54, tab2, 0);
      sqlite3VdbeAddOp2(v, 54, tab1, 0);
      break;
    }
  }
  if ((((! id2i_sqlite_omit_explain) ) )) {
    explainComposite(pParse, p->op, _1272_iSub1, _1272_iSub2, (p->op != 113));
  }  
  if ((p->selFlags & 0x0008)) {
    int i;
    KeyInfo *pKeyInfo;
    Select *pLoop;
    CollSeq **apColl;
    int nCol;
    ((void ) 0);
    (nCol = p->pEList->nExpr);
    (pKeyInfo = sqlite3KeyInfoAlloc(db, nCol));
    if ((! pKeyInfo)) {
      (rc = 7);
      goto multi_select_end;
    }  
    for ((i = 0), (apColl = pKeyInfo->aColl); (i < nCol); i++, apColl++) {
      ((*apColl) = multiSelectCollSeq(pParse, p, i));
      if ((0 == (*apColl))) {
        ((*apColl) = db->pDfltColl);
      }  
    }
    for ((pLoop = p); pLoop; (pLoop = pLoop->pPrior)) {
      for ((i = 0); (i < 2); i++) {
        int addr =  pLoop->addrOpenEphm[i];
        if ((addr < 0)) {
          ((void ) 0);
          break;
        }  
        sqlite3VdbeChangeP2(v, addr, nCol);
        sqlite3VdbeChangeP4(v, addr, ((char *) pKeyInfo), (- 6));
        (pLoop->addrOpenEphm[i] = (- 1));
      }
    }
    sqlite3DbFree(db, pKeyInfo);
  }  
  multi_select_end:
  (pDest->iSdst = dest.iSdst);
  (pDest->nSdst = dest.nSdst);
  sqlite3SelectDelete(db, pDelete);
  return rc;
}
static  int generateOutputSubroutine(Parse *pParse , Select *p , SelectDest *pIn , SelectDest *pDest , int regReturn , int regPrev , KeyInfo *pKeyInfo , int p4type , int iBreak )  {
  Vdbe *v =  pParse->pVdbe;
  int iContinue;
  int addr;
  (addr = sqlite3VdbeCurrentAddr(v));
  (iContinue = sqlite3VdbeMakeLabel(v));
  if (regPrev) {
    int j1, j2;
    (j1 = sqlite3VdbeAddOp1(v, 40, regPrev));
    (j2 = sqlite3VdbeAddOp4(v, 36, pIn->iSdst, (regPrev + 1), pIn->nSdst, ((char *) pKeyInfo), p4type));
    sqlite3VdbeAddOp3(v, 37, (j2 + 2), iContinue, (j2 + 2));
    sqlite3VdbeJumpHere(v, j1);
    sqlite3VdbeAddOp3(v, 28, pIn->iSdst, (regPrev + 1), (pIn->nSdst - 1));
    sqlite3VdbeAddOp2(v, 21, 1, regPrev);
  }  
  if (pParse->db->mallocFailed) {
    return 0;
  }  
  codeOffset(v, p, iContinue);
  switch (pDest->eDest) {
    case 8:
    case 9:
    {
      int r1 =  sqlite3GetTempReg(pParse);
      int r2 =  sqlite3GetTempReg(pParse);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pDest->eDest == 8)) {
          sqlite3Coverage(100221);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pDest->eDest == 9)) {
          sqlite3Coverage(100222);
        }  
      }  
      sqlite3VdbeAddOp3(v, 43, pIn->iSdst, pIn->nSdst, r1);
      sqlite3VdbeAddOp2(v, 65, pDest->iSDParm, r2);
      sqlite3VdbeAddOp3(v, 66, pDest->iSDParm, r1, r2);
      sqlite3VdbeChangeP5(v, 0x08);
      sqlite3ReleaseTempReg(pParse, r2);
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }
    case 7:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      int r1;
      ((void ) 0);
      (pDest->affSdst = sqlite3CompareAffinity(p->pEList->a[0].pExpr, pDest->affSdst));
      (r1 = sqlite3GetTempReg(pParse));
      sqlite3VdbeAddOp4(v, 43, pIn->iSdst, 1, r1, (&pDest->affSdst), 1);
      sqlite3ExprCacheAffinityChange(pParse, pIn->iSdst, 1);
      sqlite3VdbeAddOp2(v, 103, pDest->iSDParm, r1);
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }  
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((pDest->eDest == 7)) {
        goto id2i_label_1;
      }  
    }  
    case 6:
    if ((((! id2i_sqlite_omit_subquery) ) )) {
      ((void ) 0);
      sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, 1);
      break;
    }  
    if (((id2i_sqlite_omit_subquery ) )) {
      if ((pDest->eDest == 6)) {
        goto id2i_label_1;
      }  
    }  
    case 10:
    {
      if ((pDest->iSdst == 0)) {
        (pDest->iSdst = sqlite3GetTempRange(pParse, pIn->nSdst));
        (pDest->nSdst = pIn->nSdst);
      }  
      sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSdst, pDest->nSdst);
      sqlite3VdbeAddOp1(v, 17, pDest->iSDParm);
      break;
    }
    id2i_label_1:
    default:
    {
      ((void ) 0);
      sqlite3VdbeAddOp2(v, 30, pIn->iSdst, pIn->nSdst);
      sqlite3ExprCacheAffinityChange(pParse, pIn->iSdst, pIn->nSdst);
      break;
    }
  }
  if (p->iLimit) {
    sqlite3VdbeAddOp3(v, 128, p->iLimit, iBreak, (- 1));
  }  
  sqlite3VdbeResolveLabel(v, iContinue);
  sqlite3VdbeAddOp1(v, 16, regReturn);
  return addr;
}
static  int multiSelectOrderBy(Parse *pParse , Select *p , SelectDest *pDest )  {
  int i, j;
  Select *pPrior;
  Vdbe *v;
  SelectDest destA;
  SelectDest destB;
  int regAddrA;
  int regEofA;
  int regAddrB;
  int regEofB;
  int addrSelectA;
  int addrSelectB;
  int regOutA;
  int regOutB;
  int addrOutA;
  int addrOutB =  0;
  int addrEofA;
  int addrEofB;
  int addrAltB;
  int addrAeqB;
  int addrAgtB;
  int regLimitA;
  int regLimitB;
  int regPrev;
  int savedLimit;
  int savedOffset;
  int labelCmpr;
  int labelEnd;
  int j1;
  int op;
  KeyInfo *pKeyDup =  0;
  KeyInfo *pKeyMerge;
  sqlite3 *db;
  ExprList *pOrderBy;
  int nOrderBy;
  int *aPermute;
  int _1272_iSub1;
  int _1272_iSub2;
  ((void ) 0);
  ((void ) 0);
  (db = pParse->db);
  (v = pParse->pVdbe);
  ((void ) 0);
  (labelEnd = sqlite3VdbeMakeLabel(v));
  (labelCmpr = sqlite3VdbeMakeLabel(v));
  (op = p->op);
  (pPrior = p->pPrior);
  ((void ) 0);
  (pOrderBy = p->pOrderBy);
  ((void ) 0);
  (nOrderBy = pOrderBy->nExpr);
  if ((op != 113)) {
    for ((i = 1); ((db->mallocFailed == 0) && (i <= p->pEList->nExpr)); i++) {
      struct  ExprList_item   *pItem;
      for ((j = 0), (pItem = pOrderBy->a); (j < nOrderBy); j++, pItem++) {
        ((void ) 0);
        if ((pItem->iOrderByCol == i)) {
          break;
        }  
      }
      if ((j == nOrderBy)) {
        Expr *pNew =  sqlite3Expr(db, 129, 0);
        if ((pNew == 0)) {
          return 7;
        }  
        (pNew->flags |= 0x000400);
        (pNew->u.iValue = i);
        (pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew));
        if (pOrderBy) {
          (pOrderBy->a[nOrderBy++].iOrderByCol = ((u16 ) i));
        }  
      }  
    }
  }  
  (aPermute = sqlite3DbMallocRaw(db, (sizeof(int ) * nOrderBy)));
  if (aPermute) {
    struct  ExprList_item   *pItem;
    for ((i = 0), (pItem = pOrderBy->a); (i < nOrderBy); i++, pItem++) {
      ((void ) 0);
      (aPermute[i] = (pItem->iOrderByCol - 1));
    }
    (pKeyMerge = sqlite3KeyInfoAlloc(db, nOrderBy));
    if (pKeyMerge) {
      for ((i = 0); (i < nOrderBy); i++) {
        CollSeq *pColl;
        Expr *pTerm =  pOrderBy->a[i].pExpr;
        if ((pTerm->flags & 0x000100)) {
          (pColl = sqlite3ExprCollSeq(pParse, pTerm));
        }  
        else {
          (pColl = multiSelectCollSeq(pParse, p, aPermute[i]));
          if ((pColl == 0)) {
            (pColl = db->pDfltColl);
          }  
          (pOrderBy->a[i].pExpr = sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName));
        }
        (pKeyMerge->aColl[i] = pColl);
        (pKeyMerge->aSortOrder[i] = pOrderBy->a[i].sortOrder);
      }
    }  
  }  
  else {
    (pKeyMerge = 0);
  }
  (p->pOrderBy = pOrderBy);
  (pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy, 0));
  if ((op == 113)) {
    (regPrev = 0);
  }  
  else {
    int nExpr =  p->pEList->nExpr;
    ((void ) 0);
    (regPrev = (pParse->nMem + 1));
    (pParse->nMem += (nExpr + 1));
    sqlite3VdbeAddOp2(v, 21, 0, regPrev);
    (pKeyDup = sqlite3KeyInfoAlloc(db, nExpr));
    if (pKeyDup) {
      for ((i = 0); (i < nExpr); i++) {
        (pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i));
        (pKeyDup->aSortOrder[i] = 0);
      }
    }  
  }
  (p->pPrior = 0);
  sqlite3ResolveOrderGroupBy(pParse, p, p->pOrderBy, "ORDER");
  if ((pPrior->pPrior == 0)) {
    sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, "ORDER");
  }  
  computeLimitRegisters(pParse, p, labelEnd);
  if ((p->iLimit && (op == 113))) {
    (regLimitA = ++pParse->nMem);
    (regLimitB = ++pParse->nMem);
    sqlite3VdbeAddOp2(v, 28, (p->iOffset ? (p->iOffset + 1) : p->iLimit), regLimitA);
    sqlite3VdbeAddOp2(v, 28, regLimitA, regLimitB);
  }  
  else {
    (regLimitA = (regLimitB = 0));
  }
  sqlite3ExprDelete(db, p->pLimit);
  (p->pLimit = 0);
  sqlite3ExprDelete(db, p->pOffset);
  (p->pOffset = 0);
  (regAddrA = ++pParse->nMem);
  (regEofA = ++pParse->nMem);
  (regAddrB = ++pParse->nMem);
  (regEofB = ++pParse->nMem);
  (regOutA = ++pParse->nMem);
  (regOutB = ++pParse->nMem);
  sqlite3SelectDestInit((&destA), 10, regAddrA);
  sqlite3SelectDestInit((&destB), 10, regAddrB);
  (j1 = sqlite3VdbeAddOp0(v, 14));
  (addrSelectA = sqlite3VdbeCurrentAddr(v));
  (pPrior->iLimit = regLimitA);
  if ((((! id2i_sqlite_omit_explain) ) )) {
    (_1272_iSub1 = pParse->_1272_iNextSelectId);
  }  
  sqlite3Select(pParse, pPrior, (&destA));
  sqlite3VdbeAddOp2(v, 21, 1, regEofA);
  sqlite3VdbeAddOp1(v, 17, regAddrA);
  (addrSelectB = sqlite3VdbeCurrentAddr(v));
  (savedLimit = p->iLimit);
  (savedOffset = p->iOffset);
  (p->iLimit = regLimitB);
  (p->iOffset = 0);
  if ((((! id2i_sqlite_omit_explain) ) )) {
    (_1272_iSub2 = pParse->_1272_iNextSelectId);
  }  
  sqlite3Select(pParse, p, (&destB));
  (p->iLimit = savedLimit);
  (p->iOffset = savedOffset);
  sqlite3VdbeAddOp2(v, 21, 1, regEofB);
  sqlite3VdbeAddOp1(v, 17, regAddrB);
  (addrOutA = generateOutputSubroutine(pParse, p, (&destA), pDest, regOutA, regPrev, pKeyDup, (- 16), labelEnd));
  if (((op == 113) || (op == 112))) {
    (addrOutB = generateOutputSubroutine(pParse, p, (&destB), pDest, regOutB, regPrev, pKeyDup, (- 17), labelEnd));
  }  
  if (((op == 114) || (op == 115))) {
    (addrEofA = sqlite3VdbeAddOp2(v, 14, 0, labelEnd));
  }  
  else {
    (addrEofA = sqlite3VdbeAddOp2(v, 39, regEofB, labelEnd));
    sqlite3VdbeAddOp2(v, 15, regOutB, addrOutB);
    sqlite3VdbeAddOp1(v, 17, regAddrB);
    sqlite3VdbeAddOp2(v, 14, 0, addrEofA);
    (p->nSelectRow += pPrior->nSelectRow);
  }
  if ((op == 115)) {
    (addrEofB = addrEofA);
    if ((p->nSelectRow > pPrior->nSelectRow)) {
      (p->nSelectRow = pPrior->nSelectRow);
    }  
  }  
  else {
    (addrEofB = sqlite3VdbeAddOp2(v, 39, regEofA, labelEnd));
    sqlite3VdbeAddOp2(v, 15, regOutA, addrOutA);
    sqlite3VdbeAddOp1(v, 17, regAddrA);
    sqlite3VdbeAddOp2(v, 14, 0, addrEofB);
  }
  (addrAltB = sqlite3VdbeAddOp2(v, 15, regOutA, addrOutA));
  sqlite3VdbeAddOp1(v, 17, regAddrA);
  sqlite3VdbeAddOp2(v, 39, regEofA, addrEofA);
  sqlite3VdbeAddOp2(v, 14, 0, labelCmpr);
  if ((op == 113)) {
    (addrAeqB = addrAltB);
  } 
  else if ((op == 115)) {
    (addrAeqB = addrAltB);
    addrAltB++;
  } 
  else {
    (addrAeqB = sqlite3VdbeAddOp1(v, 17, regAddrA));
    sqlite3VdbeAddOp2(v, 39, regEofA, addrEofA);
    sqlite3VdbeAddOp2(v, 14, 0, labelCmpr);
  }
  (addrAgtB = sqlite3VdbeCurrentAddr(v));
  if (((op == 113) || (op == 112))) {
    sqlite3VdbeAddOp2(v, 15, regOutB, addrOutB);
  }  
  sqlite3VdbeAddOp1(v, 17, regAddrB);
  sqlite3VdbeAddOp2(v, 39, regEofB, addrEofB);
  sqlite3VdbeAddOp2(v, 14, 0, labelCmpr);
  sqlite3VdbeJumpHere(v, j1);
  sqlite3VdbeAddOp2(v, 21, 0, regEofA);
  sqlite3VdbeAddOp2(v, 21, 0, regEofB);
  sqlite3VdbeAddOp2(v, 15, regAddrA, addrSelectA);
  sqlite3VdbeAddOp2(v, 15, regAddrB, addrSelectB);
  sqlite3VdbeAddOp2(v, 39, regEofA, addrEofA);
  sqlite3VdbeAddOp2(v, 39, regEofB, addrEofB);
  sqlite3VdbeResolveLabel(v, labelCmpr);
  sqlite3VdbeAddOp4(v, 35, 0, 0, 0, ((char *) aPermute), (- 15));
  sqlite3VdbeAddOp4(v, 36, destA.iSdst, destB.iSdst, nOrderBy, ((char *) pKeyMerge), (- 16));
  sqlite3VdbeChangeP5(v, 0x01);
  sqlite3VdbeAddOp3(v, 37, addrAltB, addrAeqB, addrAgtB);
  sqlite3VdbeResolveLabel(v, labelEnd);
  if ((pDest->eDest == 5)) {
    Select *pFirst =  pPrior;
    while (pFirst->pPrior) {
      (pFirst = pFirst->pPrior);
    }
    generateColumnNames(pParse, 0, pFirst->pEList);
  }  
  if (p->pPrior) {
    sqlite3SelectDelete(db, p->pPrior);
  }  
  (p->pPrior = pPrior);
  if ((((! id2i_sqlite_omit_explain) ) )) {
    explainComposite(pParse, p->op, _1272_iSub1, _1272_iSub2, 0);
  }  
  return 0;
}
static void substExprList(sqlite3 * , ExprList * , int , ExprList * );
static void substSelect(sqlite3 * , Select * , int , ExprList * );
static  Expr *substExpr(sqlite3 *db , Expr *pExpr , int iTable , ExprList *pEList )  {
  if ((pExpr == 0)) {
    return 0;
  }  
  if (((pExpr->op == 152) && (pExpr->iTable == iTable))) {
    if ((pExpr->iColumn < 0)) {
      (pExpr->op = 98);
    }  
    else {
      Expr *pNew;
      ((void ) 0);
      ((void ) 0);
      (pNew = sqlite3ExprDup(db, pEList->a[pExpr->iColumn].pExpr, 0));
      sqlite3ExprDelete(db, pExpr);
      (pExpr = pNew);
    }
  }  
  else {
    (pExpr->pLeft = substExpr(db, pExpr->pLeft, iTable, pEList));
    (pExpr->pRight = substExpr(db, pExpr->pRight, iTable, pEList));
    if (((pExpr->flags & 0x000800) != 0)) {
      substSelect(db, pExpr->x.pSelect, iTable, pEList);
    }  
    else {
      substExprList(db, pExpr->x.pList, iTable, pEList);
    }
  }
  return pExpr;
}
static  void substExprList(sqlite3 *db , ExprList *pList , int iTable , ExprList *pEList )  {
  int i;
  if ((pList == 0)) {
    return;
  }  
  for ((i = 0); (i < pList->nExpr); i++) {
    (pList->a[i].pExpr = substExpr(db, pList->a[i].pExpr, iTable, pEList));
  }
}
static  void substSelect(sqlite3 *db , Select *p , int iTable , ExprList *pEList )  {
  SrcList *pSrc;
  struct  SrcList_item   *pItem;
  int i;
  if ((! p)) {
    return;
  }  
  substExprList(db, p->pEList, iTable, pEList);
  substExprList(db, p->pGroupBy, iTable, pEList);
  substExprList(db, p->pOrderBy, iTable, pEList);
  (p->pHaving = substExpr(db, p->pHaving, iTable, pEList));
  (p->pWhere = substExpr(db, p->pWhere, iTable, pEList));
  substSelect(db, p->pPrior, iTable, pEList);
  (pSrc = p->pSrc);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      for ((i = pSrc->nSrc), (pItem = pSrc->a); (i > 0); i--, pItem++) {
        substSelect(db, pItem->pSelect, iTable, pEList);
      }
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pSrc) {
      for ((i = pSrc->nSrc), (pItem = pSrc->a); (i > 0); i--, pItem++) {
        substSelect(db, pItem->pSelect, iTable, pEList);
      }
    }  
  }  
}
static  int flattenSubquery(Parse *pParse , Select *p , int iFrom , int isAgg , int subqueryIsAgg )  {
  const char *zSavedAuthContext =  pParse->zAuthContext;
  Select *pParent;
  Select *pSub;
  Select *pSub1;
  SrcList *pSrc;
  SrcList *pSubSrc;
  ExprList *pList;
  int iParent;
  int i;
  Expr *pWhere;
  struct  SrcList_item   *pSubitem;
  sqlite3 *db =  pParse->db;
  ((void ) 0);
  ((void ) 0);
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    if (((db->dbOptFlags & 0x0001) != 0)) {
      return 0;
    }  
  }  
  if (((id2i_sqlite_omit_builtin_test ) )) {
    if (0) {
      return 0;
    }  
  }  
  (pSrc = p->pSrc);
  ((void ) 0);
  (pSubitem = (&pSrc->a[iFrom]));
  (iParent = pSubitem->iCursor);
  (pSub = pSubitem->pSelect);
  ((void ) 0);
  if ((isAgg && subqueryIsAgg)) {
    return 0;
  }  
  if ((subqueryIsAgg && (pSrc->nSrc > 1))) {
    return 0;
  }  
  (pSubSrc = pSub->pSrc);
  ((void ) 0);
  if ((pSub->pLimit && p->pLimit)) {
    return 0;
  }  
  if (pSub->pOffset) {
    return 0;
  }  
  if ((p->pRightmost && pSub->pLimit)) {
    return 0;
  }  
  if ((pSubSrc->nSrc == 0)) {
    return 0;
  }  
  if ((pSub->selFlags & 0x0001)) {
    return 0;
  }  
  if ((pSub->pLimit && ((pSrc->nSrc > 1) || isAgg))) {
    return 0;
  }  
  if ((((p->selFlags & 0x0001) != 0) && subqueryIsAgg)) {
    return 0;
  }  
  if ((p->pOrderBy && pSub->pOrderBy)) {
    return 0;
  }  
  if ((isAgg && pSub->pOrderBy)) {
    return 0;
  }  
  if ((pSub->pLimit && p->pWhere)) {
    return 0;
  }  
  if ((pSub->pLimit && ((p->selFlags & 0x0001) != 0))) {
    return 0;
  }  
  if (((pSubitem->jointype & 0x0020) != 0)) {
    return 0;
  }  
  if (pSub->pPrior) {
    if (pSub->pOrderBy) {
      return 0;
    }  
    if ((isAgg || ((p->selFlags & 0x0001) != 0) || (pSrc->nSrc != 1))) {
      return 0;
    }  
    for ((pSub1 = pSub); pSub1; (pSub1 = pSub1->pPrior)) {
      if (((id2i_sqlite_coverage_test ) )) {
        if (((pSub1->selFlags & (0x0001 | 0x0004)) == 0x0001)) {
          sqlite3Coverage(101058);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if (((pSub1->selFlags & (0x0001 | 0x0004)) == 0x0004)) {
          sqlite3Coverage(101059);
        }  
      }  
      ((void ) 0);
      if ((((pSub1->selFlags & (0x0001 | 0x0004)) != 0) || (pSub1->pPrior && (pSub1->op != 113)) || (pSub1->pSrc->nSrc < 1) || (pSub->pEList->nExpr != pSub1->pEList->nExpr))) {
        return 0;
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pSub1->pSrc->nSrc > 1)) {
          sqlite3Coverage(101068);
        }  
      }  
    }
    if (p->pOrderBy) {
      int ii;
      for ((ii = 0); (ii < p->pOrderBy->nExpr); ii++) {
        if ((p->pOrderBy->a[ii].iOrderByCol == 0)) {
          return 0;
        }  
      }
    }  
  }  
  (pParse->zAuthContext = pSubitem->zName);
  if (((id2i_sqlite_coverage_test ) )) {
    (i = sqlite3AuthCheck(pParse, 21, 0, 0, 0));
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    sqlite3AuthCheck(pParse, 21, 0, 0, 0);
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((i == 1)) {
      sqlite3Coverage(101085);
    }  
  }  
  (pParse->zAuthContext = zSavedAuthContext);
  for ((pSub = pSub->pPrior); pSub; (pSub = pSub->pPrior)) {
    Select *pNew;
    ExprList *pOrderBy =  p->pOrderBy;
    Expr *pLimit =  p->pLimit;
    Expr *pOffset =  p->pOffset;
    Select *pPrior =  p->pPrior;
    (p->pOrderBy = 0);
    (p->pSrc = 0);
    (p->pPrior = 0);
    (p->pLimit = 0);
    (p->pOffset = 0);
    (pNew = sqlite3SelectDup(db, p, 0));
    (p->pOffset = pOffset);
    (p->pLimit = pLimit);
    (p->pOrderBy = pOrderBy);
    (p->pSrc = pSrc);
    (p->op = 113);
    (p->pRightmost = 0);
    if ((pNew == 0)) {
      (pNew = pPrior);
    }  
    else {
      (pNew->pPrior = pPrior);
      (pNew->pRightmost = 0);
    }
    (p->pPrior = pNew);
    if (db->mallocFailed) {
      return 1;
    }  
  }
  (pSub = (pSub1 = pSubitem->pSelect));
  sqlite3DbFree(db, pSubitem->zDatabase);
  sqlite3DbFree(db, pSubitem->zName);
  sqlite3DbFree(db, pSubitem->zAlias);
  (pSubitem->zDatabase = 0);
  (pSubitem->zName = 0);
  (pSubitem->zAlias = 0);
  (pSubitem->pSelect = 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      Table *pTabToDel =  pSubitem->pTab;
      if ((pTabToDel->nRef == 1)) {
        Parse *pToplevel =  (pParse->pToplevel ? pParse->pToplevel : pParse);
        (pTabToDel->pNextZombie = pToplevel->pZombieTab);
        (pToplevel->pZombieTab = pTabToDel);
      }  
      else {
        pTabToDel->nRef--;
      }
      (pSubitem->pTab = 0);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pSubitem->pTab != 0)) {
      Table *pTabToDel =  pSubitem->pTab;
      if ((pTabToDel->nRef == 1)) {
        Parse *pToplevel =  (pParse->pToplevel ? pParse->pToplevel : pParse);
        (pTabToDel->pNextZombie = pToplevel->pZombieTab);
        (pToplevel->pZombieTab = pTabToDel);
      }  
      else {
        pTabToDel->nRef--;
      }
      (pSubitem->pTab = 0);
    }  
  }  
  for ((pParent = p); pParent; (pParent = pParent->pPrior), (pSub = pSub->pPrior)) {
    int nSubSrc;
    u8 jointype =  0;
    (pSubSrc = pSub->pSrc);
    (nSubSrc = pSubSrc->nSrc);
    (pSrc = pParent->pSrc);
    if (pSrc) {
      ((void ) 0);
      (jointype = pSubitem->jointype);
    }  
    else {
      ((void ) 0);
      (pSrc = (pParent->pSrc = sqlite3SrcListAppend(db, 0, 0, 0)));
      if ((pSrc == 0)) {
        ((void ) 0);
        break;
      }  
    }
    if ((nSubSrc > 1)) {
      (pParent->pSrc = (pSrc = sqlite3SrcListEnlarge(db, pSrc, (nSubSrc - 1), (iFrom + 1))));
      if (db->mallocFailed) {
        break;
      }  
    }  
    for ((i = 0); (i < nSubSrc); i++) {
      sqlite3IdListDelete(db, pSrc->a[(i + iFrom)].pUsing);
      (pSrc->a[(i + iFrom)] = pSubSrc->a[i]);
      memset((&pSubSrc->a[i]), 0, sizeof(pSubSrc->a[i]));
    }
    (pSrc->a[iFrom].jointype = jointype);
    (pList = pParent->pEList);
    for ((i = 0); (i < pList->nExpr); i++) {
      if ((pList->a[i].zName == 0)) {
        char *zName =  sqlite3DbStrDup(db, pList->a[i].zSpan);
        sqlite3Dequote(zName);
        (pList->a[i].zName = zName);
      }  
    }
    substExprList(db, pParent->pEList, iParent, pSub->pEList);
    if (isAgg) {
      substExprList(db, pParent->pGroupBy, iParent, pSub->pEList);
      (pParent->pHaving = substExpr(db, pParent->pHaving, iParent, pSub->pEList));
    }  
    if (pSub->pOrderBy) {
      ((void ) 0);
      (pParent->pOrderBy = pSub->pOrderBy);
      (pSub->pOrderBy = 0);
    } 
    else if (pParent->pOrderBy) {
      substExprList(db, pParent->pOrderBy, iParent, pSub->pEList);
    } 
    if (pSub->pWhere) {
      (pWhere = sqlite3ExprDup(db, pSub->pWhere, 0));
    }  
    else {
      (pWhere = 0);
    }
    if (subqueryIsAgg) {
      ((void ) 0);
      (pParent->pHaving = pParent->pWhere);
      (pParent->pWhere = pWhere);
      (pParent->pHaving = substExpr(db, pParent->pHaving, iParent, pSub->pEList));
      (pParent->pHaving = sqlite3ExprAnd(db, pParent->pHaving, sqlite3ExprDup(db, pSub->pHaving, 0)));
      ((void ) 0);
      (pParent->pGroupBy = sqlite3ExprListDup(db, pSub->pGroupBy, 0));
    }  
    else {
      (pParent->pWhere = substExpr(db, pParent->pWhere, iParent, pSub->pEList));
      (pParent->pWhere = sqlite3ExprAnd(db, pParent->pWhere, pWhere));
    }
    (pParent->selFlags |= (pSub->selFlags & 0x0001));
    if (pSub->pLimit) {
      (pParent->pLimit = pSub->pLimit);
      (pSub->pLimit = 0);
    }  
  }
  sqlite3SelectDelete(db, pSub1);
  return 1;
}
static  u8 minMaxQuery(AggInfo *pAggInfo , ExprList **ppMinMax )  {
  int eRet =  0x0000;
  ((*ppMinMax) = 0);
  if ((pAggInfo->nFunc == 1)) {
    Expr *pExpr =  pAggInfo->aFunc[0].pExpr;
    ExprList *pEList =  pExpr->x.pList;
    ((void ) 0);
    if ((pEList && (pEList->nExpr == 1) && (pEList->a[0].pExpr->op == 154))) {
      const char *zFunc =  pExpr->u.zToken;
      if ((sqlite3_stricmp(zFunc, "min") == 0)) {
        (eRet = 0x0001);
        ((*ppMinMax) = pEList);
      } 
      else if ((sqlite3_stricmp(zFunc, "max") == 0)) {
        (eRet = 0x0002);
        ((*ppMinMax) = pEList);
      } 
    }  
  }  
  ((void ) 0);
  return eRet;
}
static  Table *isSimpleCount(Select *p , AggInfo *pAggInfo )  {
  Table *pTab;
  Expr *pExpr;
  ((void ) 0);
  if ((p->pWhere || (p->pEList->nExpr != 1) || (p->pSrc->nSrc != 1) || p->pSrc->a[0].pSelect)) {
    return 0;
  }  
  (pTab = p->pSrc->a[0].pTab);
  (pExpr = p->pEList->a[0].pExpr);
  ((void ) 0);
  if (((pTab->tabFlags & 0x10) != 0)) {
    return 0;
  }  
  if ((pExpr->op != 153)) {
    return 0;
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return 0;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pAggInfo->nFunc == 0)) {
      return 0;
    }  
  }  
  if (((pAggInfo->aFunc[0].pFunc->funcFlags & 0x100) == 0)) {
    return 0;
  }  
  if ((pExpr->flags & 0x000010)) {
    return 0;
  }  
  return pTab;
}
static  int sqlite3IndexedByLookup(Parse *pParse , struct  SrcList_item   *pFrom )  {
  if ((pFrom->pTab && pFrom->zIndex)) {
    Table *pTab =  pFrom->pTab;
    char *zIndex =  pFrom->zIndex;
    Index *pIdx;
    for ((pIdx = pTab->pIndex); (pIdx && sqlite3_stricmp(pIdx->zName, zIndex)); (pIdx = pIdx->pNext)) {
      
    }
    if ((! pIdx)) {
      sqlite3ErrorMsg(pParse, "no such index: %s", zIndex, 0);
      (pParse->checkSchema = 1);
      return 1;
    }  
    (pFrom->pIndex = pIdx);
  }  
  return 0;
}
static  int convertCompoundSelectToSubquery(Walker *pWalker , Select *p )  {
  int i;
  Select *pNew;
  Select *pX;
  sqlite3 *db;
  struct  ExprList_item   *a;
  SrcList *pNewSrc;
  Parse *pParse;
  Token dummy;
  if ((p->pPrior == 0)) {
    return 0;
  }  
  if ((p->pOrderBy == 0)) {
    return 0;
  }  
  for ((pX = p); (pX && ((pX->op == 113) || (pX->op == 116))); (pX = pX->pPrior)) {
    
  }
  if ((pX == 0)) {
    return 0;
  }  
  (a = p->pOrderBy->a);
  for ((i = (p->pOrderBy->nExpr - 1)); (i >= 0); i--) {
    if ((a[i].pExpr->flags & 0x000100)) {
      break;
    }  
  }
  if ((i < 0)) {
    return 0;
  }  
  (pParse = pWalker->pParse);
  (db = pParse->db);
  (pNew = sqlite3DbMallocZero(db, sizeof((*pNew))));
  if ((pNew == 0)) {
    return 2;
  }  
  memset((&dummy), 0, sizeof(dummy));
  (pNewSrc = sqlite3SrcListAppendFromTerm(pParse, 0, 0, 0, (&dummy), pNew, 0, 0));
  if ((pNewSrc == 0)) {
    return 2;
  }  
  ((*pNew) = (*p));
  (p->pSrc = pNewSrc);
  (p->pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, 113, 0)));
  (p->op = 116);
  (p->pWhere = 0);
  (pNew->pGroupBy = 0);
  (pNew->pHaving = 0);
  (pNew->pOrderBy = 0);
  (p->pPrior = 0);
  (pNew->pLimit = 0);
  (pNew->pOffset = 0);
  return 0;
}
static  int selectExpander(Walker *pWalker , Select *p )  {
  Parse *pParse =  pWalker->pParse;
  int i, j, k;
  SrcList *pTabList;
  ExprList *pEList;
  struct  SrcList_item   *pFrom;
  sqlite3 *db =  pParse->db;
  Expr *pE, *pRight, *pExpr;
  u16 selFlags =  p->selFlags;
  (p->selFlags |= 0x0010);
  if (db->mallocFailed) {
    return 2;
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((0 || ((selFlags & 0x0010) != 0))) {
      return 1;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((p->pSrc == 0) || ((selFlags & 0x0010) != 0))) {
      return 1;
    }  
  }  
  (pTabList = p->pSrc);
  (pEList = p->pEList);
  sqlite3SrcListAssignCursors(pParse, pTabList);
  for ((i = 0), (pFrom = pTabList->a); (i < pTabList->nSrc); i++, pFrom++) {
    Table *pTab;
    if ((pFrom->pTab != 0)) {
      ((void ) 0);
      return 1;
    }  
    if ((pFrom->zName == 0)) {
      Select *_1327_pSel =  pFrom->pSelect;
      if ((((! id2i_sqlite_omit_subquery) ) )) {
        ((void ) 0);
      }  
      if ((((! id2i_sqlite_omit_subquery) ) )) {
        ((void ) 0);
      }  
      if ((((! id2i_sqlite_omit_subquery) ) )) {
        sqlite3WalkSelect(pWalker, _1327_pSel);
      }  
      if ((((! id2i_sqlite_omit_subquery) ) )) {
        (pFrom->pTab = (pTab = sqlite3DbMallocZero(db, sizeof(Table ))));
      }  
      if ((((! id2i_sqlite_omit_subquery) ) )) {
        if ((pTab == 0)) {
          return 2;
        }  
      }  
      if ((((! id2i_sqlite_omit_subquery) ) )) {
        (pTab->nRef = 1);
      }  
      if ((((! id2i_sqlite_omit_subquery) ) )) {
        (pTab->zName = sqlite3MPrintf(db, "sqlite_sq_%p", ((void *) pTab)));
      }  
      if ((((! id2i_sqlite_omit_subquery) ) )) {
        while (_1327_pSel->pPrior) {
          (_1327_pSel = _1327_pSel->pPrior);
        }
      }  
      if ((((! id2i_sqlite_omit_subquery) ) )) {
        selectColumnsFromExprList(pParse, _1327_pSel->pEList, (&pTab->nCol), (&pTab->aCol));
      }  
      if ((((! id2i_sqlite_omit_subquery) ) )) {
        (pTab->iPKey = (- 1));
      }  
      if ((((! id2i_sqlite_omit_subquery) ) )) {
        (pTab->nRowEst = 1048576);
      }  
      if ((((! id2i_sqlite_omit_subquery) ) )) {
        (pTab->tabFlags |= 0x02);
      }  
    }  
    else {
      ((void ) 0);
      (pFrom->pTab = (pTab = sqlite3LocateTableItem(pParse, 0, pFrom)));
      if ((pTab == 0)) {
        return 2;
      }  
      if ((pTab->nRef == 0xffff)) {
        sqlite3ErrorMsg(pParse, "too many references to \"%s\": max 65535", pTab->zName);
        (pFrom->pTab = 0);
        return 2;
      }  
      pTab->nRef++;
      if ((pTab->pSelect || ((pTab->tabFlags & 0x10) != 0))) {
        if (sqlite3ViewGetColumnNames(pParse, pTab)) {
          return 2;
        }  
        ((void ) 0);
        (pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0));
        sqlite3WalkSelect(pWalker, pFrom->pSelect);
      }  
    }
    if (sqlite3IndexedByLookup(pParse, pFrom)) {
      return 2;
    }  
  }
  if ((db->mallocFailed || sqliteProcessJoin(pParse, p))) {
    return 2;
  }  
  for ((k = 0); (k < pEList->nExpr); k++) {
    (pE = pEList->a[k].pExpr);
    if ((pE->op == 113)) {
      break;
    }  
    ((void ) 0);
    ((void ) 0);
    if (((pE->op == 118) && (pE->pRight->op == 113))) {
      break;
    }  
  }
  if ((k < pEList->nExpr)) {
    struct  ExprList_item   *a =  pEList->a;
    ExprList *pNew =  0;
    int flags =  pParse->db->flags;
    int longNames =  (((flags & 0x00000020) != 0) && ((flags & 0x00000040) == 0));
    ((void ) 0);
    for ((k = 0); (k < pEList->nExpr); k++) {
      (pE = a[k].pExpr);
      (pRight = pE->pRight);
      ((void ) 0);
      if (((pE->op != 113) && ((pE->op != 118) || (pRight->op != 113)))) {
        (pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr));
        if (pNew) {
          (pNew->a[(pNew->nExpr - 1)].zName = a[k].zName);
          (pNew->a[(pNew->nExpr - 1)].zSpan = a[k].zSpan);
          (a[k].zName = 0);
          (a[k].zSpan = 0);
        }  
        (a[k].pExpr = 0);
      }  
      else {
        int tableSeen =  0;
        char *zTName =  0;
        if ((pE->op == 118)) {
          ((void ) 0);
          ((void ) 0);
          (zTName = pE->pLeft->u.zToken);
        }  
        for ((i = 0), (pFrom = pTabList->a); (i < pTabList->nSrc); i++, pFrom++) {
          Table *pTab =  pFrom->pTab;
          Select *pSub =  pFrom->pSelect;
          char *zTabName =  pFrom->zAlias;
          const char *zSchemaName =  0;
          int iDb;
          if ((zTabName == 0)) {
            (zTabName = pTab->zName);
          }  
          if (db->mallocFailed) {
            break;
          }  
          if (((pSub == 0) || ((pSub->selFlags & 0x0200) == 0))) {
            (pSub = 0);
            if ((zTName && (sqlite3_stricmp(zTName, zTabName) != 0))) {
              continue;
            }  
            (iDb = sqlite3SchemaToIndex(db, pTab->pSchema));
            (zSchemaName = ((iDb >= 0) ? db->aDb[iDb].zName : "*"));
          }  
          for ((j = 0); (j < pTab->nCol); j++) {
            char *zName =  pTab->aCol[j].zName;
            char *zColname;
            char *zToFree;
            Token sColname;
            ((void ) 0);
            if ((zTName && pSub && (sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0) == 0))) {
              continue;
            }  
            if ((((&pTab->aCol[j])->colFlags & 0x0002) != 0)) {
              ((void ) 0);
              continue;
            }  
            (tableSeen = 1);
            if (((i > 0) && (zTName == 0))) {
              if ((((pFrom->jointype & 0x0004) != 0) && tableAndColumnIndex(pTabList, i, zName, 0, 0))) {
                continue;
              }  
              if ((sqlite3IdListIndex(pFrom->pUsing, zName) >= 0)) {
                continue;
              }  
            }  
            (pRight = sqlite3Expr(db, 26, zName));
            (zColname = zName);
            (zToFree = 0);
            if ((longNames || (pTabList->nSrc > 1))) {
              Expr *pLeft;
              (pLeft = sqlite3Expr(db, 26, zTabName));
              (pExpr = sqlite3PExpr(pParse, 118, pLeft, pRight, 0));
              if (zSchemaName) {
                (pLeft = sqlite3Expr(db, 26, zSchemaName));
                (pExpr = sqlite3PExpr(pParse, 118, pLeft, pExpr, 0));
              }  
              if (longNames) {
                (zColname = sqlite3MPrintf(db, "%s.%s", zTabName, zName));
                (zToFree = zColname);
              }  
            }  
            else {
              (pExpr = pRight);
            }
            (pNew = sqlite3ExprListAppend(pParse, pNew, pExpr));
            (sColname.z = zColname);
            (sColname.n = sqlite3Strlen30(zColname));
            sqlite3ExprListSetName(pParse, pNew, (&sColname), 0);
            if ((pNew && ((p->selFlags & 0x0200) != 0))) {
              struct  ExprList_item   *pX =  (&pNew->a[(pNew->nExpr - 1)]);
              if (pSub) {
                (pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan));
                if (((id2i_sqlite_coverage_test ) )) {
                  if ((pX->zSpan == 0)) {
                    sqlite3Coverage(101744);
                  }  
                }  
              }  
              else {
                (pX->zSpan = sqlite3MPrintf(db, "%s.%s.%s", zSchemaName, zTabName, zColname));
                if (((id2i_sqlite_coverage_test ) )) {
                  if ((pX->zSpan == 0)) {
                    sqlite3Coverage(101748);
                  }  
                }  
              }
              (pX->bSpanIsTab = 1);
            }  
            sqlite3DbFree(db, zToFree);
          }
        }
        if ((! tableSeen)) {
          if (zTName) {
            sqlite3ErrorMsg(pParse, "no such table: %s", zTName);
          }  
          else {
            sqlite3ErrorMsg(pParse, "no tables specified");
          }
        }  
      }
    }
    sqlite3ExprListDelete(db, pEList);
    (p->pEList = pNew);
  }  
  if ((p->pEList && (p->pEList->nExpr > db->aLimit[2]))) {
    sqlite3ErrorMsg(pParse, "too many columns in result set");
  }  
  return 0;
}
static  int exprWalkNoop(Walker *NotUsed , Expr *NotUsed2 )  {
  ((void ) NotUsed), ((void ) NotUsed2);
  return 0;
}
static  void sqlite3SelectExpand(Parse *pParse , Select *pSelect )  {
  Walker w;
  memset((&w), 0, sizeof(w));
  (w.xExprCallback = exprWalkNoop);
  (w.pParse = pParse);
  if (pParse->hasCompound) {
    (w.xSelectCallback = convertCompoundSelectToSubquery);
    sqlite3WalkSelect((&w), pSelect);
  }  
  (w.xSelectCallback = selectExpander);
  sqlite3WalkSelect((&w), pSelect);
}
static  int selectAddSubqueryTypeInfo(Walker *pWalker , Select *p )  {
  Parse *pParse;
  int i;
  SrcList *pTabList;
  struct  SrcList_item   *pFrom;
  ((void ) 0);
  if (((p->selFlags & 0x0020) == 0)) {
    (p->selFlags |= 0x0020);
    (pParse = pWalker->pParse);
    (pTabList = p->pSrc);
    for ((i = 0), (pFrom = pTabList->a); (i < pTabList->nSrc); i++, pFrom++) {
      Table *pTab =  pFrom->pTab;
      if (((id2i_sqlite_coverage_test ) )) {
        if ((1 && ((pTab->tabFlags & 0x02) != 0))) {
          Select *pSel =  pFrom->pSelect;
          ((void ) 0);
          while (pSel->pPrior) {
            (pSel = pSel->pPrior);
          }
          selectAddColumnTypeAndCollation(pParse, pTab, pSel);
        }  
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if (((pTab != 0) && ((pTab->tabFlags & 0x02) != 0))) {
          Select *pSel =  pFrom->pSelect;
          ((void ) 0);
          while (pSel->pPrior) {
            (pSel = pSel->pPrior);
          }
          selectAddColumnTypeAndCollation(pParse, pTab, pSel);
        }  
      }  
    }
  }  
  return 0;
}
static  void sqlite3SelectAddTypeInfo(Parse *pParse , Select *pSelect )  {
  Walker _1327_w;
  if ((((! id2i_sqlite_omit_subquery) ) )) {
    memset((&_1327_w), 0, sizeof(_1327_w));
  }  
  if ((((! id2i_sqlite_omit_subquery) ) )) {
    (_1327_w.xSelectCallback = selectAddSubqueryTypeInfo);
  }  
  if ((((! id2i_sqlite_omit_subquery) ) )) {
    (_1327_w.xExprCallback = exprWalkNoop);
  }  
  if ((((! id2i_sqlite_omit_subquery) ) )) {
    (_1327_w.pParse = pParse);
  }  
  if ((((! id2i_sqlite_omit_subquery) ) )) {
    (_1327_w.bSelectDepthFirst = 1);
  }  
  if ((((! id2i_sqlite_omit_subquery) ) )) {
    sqlite3WalkSelect((&_1327_w), pSelect);
  }  
}
static  void sqlite3SelectPrep(Parse *pParse , Select *p , NameContext *pOuterNC )  {
  sqlite3 *db;
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((p == 0)) {
      return;
    }  
  }  
  (db = pParse->db);
  if (db->mallocFailed) {
    return;
  }  
  if ((p->selFlags & 0x0020)) {
    return;
  }  
  sqlite3SelectExpand(pParse, p);
  if ((pParse->nErr || db->mallocFailed)) {
    return;
  }  
  sqlite3ResolveSelectNames(pParse, p, pOuterNC);
  if ((pParse->nErr || db->mallocFailed)) {
    return;
  }  
  sqlite3SelectAddTypeInfo(pParse, p);
}
static  void resetAccumulator(Parse *pParse , AggInfo *pAggInfo )  {
  Vdbe *v =  pParse->pVdbe;
  int i;
  struct  AggInfo_func   *pFunc;
  if (((pAggInfo->nFunc + pAggInfo->nColumn) == 0)) {
    return;
  }  
  for ((i = 0); (i < pAggInfo->nColumn); i++) {
    sqlite3VdbeAddOp2(v, 24, 0, pAggInfo->aCol[i].iMem);
  }
  for ((pFunc = pAggInfo->aFunc), (i = 0); (i < pAggInfo->nFunc); i++, pFunc++) {
    sqlite3VdbeAddOp2(v, 24, 0, pFunc->iMem);
    if ((pFunc->iDistinct >= 0)) {
      Expr *pE =  pFunc->pExpr;
      ((void ) 0);
      if (((pE->x.pList == 0) || (pE->x.pList->nExpr != 1))) {
        sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one " "argument");
        (pFunc->iDistinct = (- 1));
      }  
      else {
        KeyInfo *pKeyInfo =  keyInfoFromExprList(pParse, pE->x.pList);
        sqlite3VdbeAddOp4(v, 51, pFunc->iDistinct, 0, 0, ((char *) pKeyInfo), (- 16));
      }
    }  
  }
}
static  void finalizeAggFunctions(Parse *pParse , AggInfo *pAggInfo )  {
  Vdbe *v =  pParse->pVdbe;
  int i;
  struct  AggInfo_func   *pF;
  for ((i = 0), (pF = pAggInfo->aFunc); (i < pAggInfo->nFunc); i++, pF++) {
    ExprList *pList =  pF->pExpr->x.pList;
    ((void ) 0);
    sqlite3VdbeAddOp4(v, 129, pF->iMem, (pList ? pList->nExpr : 0), 0, ((void *) pF->pFunc), (- 5));
  }
}
static  void updateAccumulator(Parse *pParse , AggInfo *pAggInfo )  {
  Vdbe *v =  pParse->pVdbe;
  int i;
  int regHit =  0;
  int addrHitTest =  0;
  struct  AggInfo_func   *pF;
  struct  AggInfo_col   *pC;
  (pAggInfo->directMode = 1);
  sqlite3ExprCacheClear(pParse);
  for ((i = 0), (pF = pAggInfo->aFunc); (i < pAggInfo->nFunc); i++, pF++) {
    int nArg;
    int addrNext =  0;
    int regAgg;
    ExprList *pList =  pF->pExpr->x.pList;
    ((void ) 0);
    if (pList) {
      (nArg = pList->nExpr);
      (regAgg = sqlite3GetTempRange(pParse, nArg));
      sqlite3ExprCodeExprList(pParse, pList, regAgg, 1);
    }  
    else {
      (nArg = 0);
      (regAgg = 0);
    }
    if ((pF->iDistinct >= 0)) {
      (addrNext = sqlite3VdbeMakeLabel(v));
      ((void ) 0);
      codeDistinct(pParse, pF->iDistinct, addrNext, 1, regAgg);
    }  
    if ((pF->pFunc->funcFlags & 0x020)) {
      CollSeq *pColl =  0;
      struct  ExprList_item   *pItem;
      int j;
      ((void ) 0);
      for ((j = 0), (pItem = pList->a); ((! pColl) && (j < nArg)); j++, pItem++) {
        (pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr));
      }
      if ((! pColl)) {
        (pColl = pParse->db->pDfltColl);
      }  
      if (((regHit == 0) && pAggInfo->nAccumulator)) {
        (regHit = ++pParse->nMem);
      }  
      sqlite3VdbeAddOp4(v, 31, regHit, 0, 0, ((char *) pColl), (- 4));
    }  
    sqlite3VdbeAddOp4(v, 8, 0, regAgg, pF->iMem, ((void *) pF->pFunc), (- 5));
    sqlite3VdbeChangeP5(v, ((u8 ) nArg));
    sqlite3ExprCacheAffinityChange(pParse, regAgg, nArg);
    sqlite3ReleaseTempRange(pParse, regAgg, nArg);
    if (addrNext) {
      sqlite3VdbeResolveLabel(v, addrNext);
      sqlite3ExprCacheClear(pParse);
    }  
  }
  if (regHit) {
    (addrHitTest = sqlite3VdbeAddOp1(v, 39, regHit));
  }  
  sqlite3ExprCacheClear(pParse);
  for ((i = 0), (pC = pAggInfo->aCol); (i < pAggInfo->nAccumulator); i++, pC++) {
    sqlite3ExprCode(pParse, pC->pExpr, pC->iMem);
  }
  (pAggInfo->directMode = 0);
  sqlite3ExprCacheClear(pParse);
  if (addrHitTest) {
    sqlite3VdbeJumpHere(v, addrHitTest);
  }  
}
static  void explainSimpleCount(Parse *pParse , Table *pTab , Index *pIdx )  {
  if ((pParse->explain == 2)) {
    char *zEqp =  sqlite3MPrintf(pParse->db, "SCAN TABLE %s%s%s", pTab->zName, (pIdx ? " USING COVERING INDEX " : ""), (pIdx ? pIdx->zName : ""));
    sqlite3VdbeAddOp4(pParse->pVdbe, 150, pParse->_1272_iSelectId, 0, 0, zEqp, (- 1));
  }  
}
static  int sqlite3Select(Parse *pParse , Select *p , SelectDest *pDest )  {
  int i, j;
  WhereInfo *pWInfo;
  Vdbe *v;
  int isAgg;
  ExprList *pEList;
  SrcList *pTabList;
  Expr *pWhere;
  ExprList *pOrderBy;
  ExprList *pGroupBy;
  Expr *pHaving;
  int rc =  1;
  int addrSortIndex;
  DistinctCtx sDistinct;
  AggInfo sAggInfo;
  int iEnd;
  sqlite3 *db;
  int iRestoreSelectId =  pParse->_1272_iSelectId;
  if ((((! id2i_sqlite_omit_explain) ) )) {
    (pParse->_1272_iSelectId = pParse->_1272_iNextSelectId++);
  }  
  (db = pParse->db);
  if (((p == 0) || db->mallocFailed || pParse->nErr)) {
    return 1;
  }  
  if (sqlite3AuthCheck(pParse, 21, 0, 0, 0)) {
    return 1;
  }  
  memset((&sAggInfo), 0, sizeof(sAggInfo));
  if ((pDest->eDest <= 4)) {
    ((void ) 0);
    sqlite3ExprListDelete(db, p->pOrderBy);
    (p->pOrderBy = 0);
    (p->selFlags &= (~ 0x0001));
  }  
  sqlite3SelectPrep(pParse, p, 0);
  (pOrderBy = p->pOrderBy);
  (pTabList = p->pSrc);
  (pEList = p->pEList);
  if ((pParse->nErr || db->mallocFailed)) {
    goto select_end;
  }  
  (isAgg = ((p->selFlags & 0x0004) != 0));
  ((void ) 0);
  (v = sqlite3GetVdbe(pParse));
  if ((v == 0)) {
    goto select_end;
  }  
  if ((((! id2i_sqlite_omit_subquery) ) )) {
    if (checkForMultiColumnSelectError(pParse, pDest, pEList->nExpr)) {
      goto select_end;
    }  
  }  
  if ((((! id2i_sqlite_omit_view) ) || (id2i_sqlite_omit_view && (! id2i_sqlite_omit_subquery)))) {
    for ((i = 0); ((! p->pPrior) && (i < pTabList->nSrc)); i++) {
      struct  SrcList_item   *pItem =  (&pTabList->a[i]);
      SelectDest dest;
      Select *pSub =  pItem->pSelect;
      int isAggSub;
      if ((pSub == 0)) {
        continue;
      }  
      if (pItem->addrFillSub) {
        if ((pItem->viaCoroutine == 0)) {
          sqlite3VdbeAddOp2(v, 15, pItem->regReturn, pItem->addrFillSub);
        }  
        continue;
      }  
      (pParse->nHeight += sqlite3SelectExprHeight(p));
      (isAggSub = ((pSub->selFlags & 0x0004) != 0));
      if (flattenSubquery(pParse, p, i, isAgg, isAggSub)) {
        if (isAggSub) {
          (isAgg = 1);
          (p->selFlags |= 0x0004);
        }  
        (i = (- 1));
      } 
      else if ((((id2i_sqlite_omit_builtin_test ) ) && ((pTabList->nSrc == 1) && ((p->selFlags & 0x0100) == 0) && 1))) {
        int addrTop;
        int addrEof;
        (pItem->regReturn = ++pParse->nMem);
        (addrEof = ++pParse->nMem);
        sqlite3CodeVerifySchema(pParse, (- 1));
        sqlite3VdbeAddOp0(v, 14);
        (addrTop = sqlite3VdbeAddOp1(v, 53, pItem->iCursor));
        sqlite3VdbeChangeP5(v, 1);
        (pItem->addrFillSub = addrTop);
        sqlite3VdbeAddOp2(v, 21, 0, addrEof);
        sqlite3VdbeChangeP5(v, 1);
        sqlite3SelectDestInit((&dest), 10, pItem->regReturn);
        if ((((! id2i_sqlite_omit_explain) ) )) {
          (pItem->_1272_iSelectId = ((u8 ) pParse->_1272_iNextSelectId));
        }  
        sqlite3Select(pParse, pSub, (&dest));
        (pItem->pTab->nRowEst = ((unsigned ) pSub->nSelectRow));
        (pItem->viaCoroutine = 1);
        sqlite3VdbeChangeP2(v, addrTop, dest.iSdst);
        sqlite3VdbeChangeP3(v, addrTop, dest.nSdst);
        sqlite3VdbeAddOp2(v, 21, 1, addrEof);
        sqlite3VdbeAddOp1(v, 17, pItem->regReturn);
        sqlite3VdbeJumpHere(v, (addrTop - 1));
        sqlite3ClearTempRegCache(pParse);
      }
      
      else if (((((! id2i_sqlite_omit_builtin_test) ) ) && ((pTabList->nSrc == 1) && ((p->selFlags & 0x0100) == 0) && ((db->dbOptFlags & 0x0100) == 0)))) {
        int addrTop;
        int addrEof;
        (pItem->regReturn = ++pParse->nMem);
        (addrEof = ++pParse->nMem);
        sqlite3CodeVerifySchema(pParse, (- 1));
        sqlite3VdbeAddOp0(v, 14);
        (addrTop = sqlite3VdbeAddOp1(v, 53, pItem->iCursor));
        sqlite3VdbeChangeP5(v, 1);
        (pItem->addrFillSub = addrTop);
        sqlite3VdbeAddOp2(v, 21, 0, addrEof);
        sqlite3VdbeChangeP5(v, 1);
        sqlite3SelectDestInit((&dest), 10, pItem->regReturn);
        if ((((! id2i_sqlite_omit_explain) ) )) {
          (pItem->_1272_iSelectId = ((u8 ) pParse->_1272_iNextSelectId));
        }  
        sqlite3Select(pParse, pSub, (&dest));
        (pItem->pTab->nRowEst = ((unsigned ) pSub->nSelectRow));
        (pItem->viaCoroutine = 1);
        sqlite3VdbeChangeP2(v, addrTop, dest.iSdst);
        sqlite3VdbeChangeP3(v, addrTop, dest.nSdst);
        sqlite3VdbeAddOp2(v, 21, 1, addrEof);
        sqlite3VdbeAddOp1(v, 17, pItem->regReturn);
        sqlite3VdbeJumpHere(v, (addrTop - 1));
        sqlite3ClearTempRegCache(pParse);
      } 
      else {
        int topAddr;
        int onceAddr =  0;
        int retAddr;
        ((void ) 0);
        (pItem->regReturn = ++pParse->nMem);
        (topAddr = sqlite3VdbeAddOp2(v, 21, 0, pItem->regReturn));
        (pItem->addrFillSub = (topAddr + 1));
        if ((pItem->isCorrelated == 0)) {
          (onceAddr = sqlite3CodeOnce(pParse));
        }  
        sqlite3SelectDestInit((&dest), 9, pItem->iCursor);
        if ((((! id2i_sqlite_omit_explain) ) )) {
          (pItem->_1272_iSelectId = ((u8 ) pParse->_1272_iNextSelectId));
        }  
        sqlite3Select(pParse, pSub, (&dest));
        (pItem->pTab->nRowEst = ((unsigned ) pSub->nSelectRow));
        if (onceAddr) {
          sqlite3VdbeJumpHere(v, onceAddr);
        }  
        (retAddr = sqlite3VdbeAddOp1(v, 16, pItem->regReturn));
        sqlite3VdbeChangeP1(v, topAddr, retAddr);
        sqlite3ClearTempRegCache(pParse);
      }
      if (db->mallocFailed) {
        goto select_end;
      }  
      (pParse->nHeight -= sqlite3SelectExprHeight(p));
      (pTabList = p->pSrc);
      if ((! (pDest->eDest <= 4))) {
        (pOrderBy = p->pOrderBy);
      }  
    }
  }  
  if ((((! id2i_sqlite_omit_view) ) || (id2i_sqlite_omit_view && (! id2i_sqlite_omit_subquery)))) {
    (pEList = p->pEList);
  }  
  (pWhere = p->pWhere);
  (pGroupBy = p->pGroupBy);
  (pHaving = p->pHaving);
  (sDistinct.isTnct = ((p->selFlags & 0x0001) != 0));
  if (p->pPrior) {
    if ((p->pRightmost == 0)) {
      Select *pLoop, *pRight =  0;
      int cnt =  0;
      int mxSelect;
      for ((pLoop = p); pLoop; (pLoop = pLoop->pPrior), cnt++) {
        (pLoop->pRightmost = p);
        (pLoop->pNext = pRight);
        (pRight = pLoop);
      }
      (mxSelect = db->aLimit[4]);
      if ((mxSelect && (cnt > mxSelect))) {
        sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");
        goto select_end;
      }  
    }  
    (rc = multiSelect(pParse, p, pDest));
    if ((((! id2i_sqlite_omit_explain) ) )) {
      (pParse->_1272_iSelectId = iRestoreSelectId);
    }  
    return rc;
  }  
  if (((id2i_sqlite_omit_builtin_test ) )) {
    if (((sqlite3ExprListCompare(p->pGroupBy, pOrderBy, (- 1)) == 0) && 1)) {
      (pOrderBy = 0);
    }  
  }  
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    if (((sqlite3ExprListCompare(p->pGroupBy, pOrderBy, (- 1)) == 0) && ((db->dbOptFlags & 0x0004) == 0))) {
      (pOrderBy = 0);
    }  
  }  
  if ((((p->selFlags & (0x0001 | 0x0004)) == 0x0001) && (sqlite3ExprListCompare(pOrderBy, p->pEList, (- 1)) == 0))) {
    (p->selFlags &= (~ 0x0001));
    (p->pGroupBy = sqlite3ExprListDup(db, p->pEList, 0));
    (pGroupBy = p->pGroupBy);
    (pOrderBy = 0);
    ((void ) 0);
  }  
  if (pOrderBy) {
    KeyInfo *pKeyInfo;
    (pKeyInfo = keyInfoFromExprList(pParse, pOrderBy));
    (pOrderBy->iECursor = pParse->nTab++);
    (p->addrOpenEphm[2] = (addrSortIndex = sqlite3VdbeAddOp4(v, 51, pOrderBy->iECursor, (pOrderBy->nExpr + 2), 0, ((char *) pKeyInfo), (- 16))));
  }  
  else {
    (addrSortIndex = (- 1));
  }
  if ((pDest->eDest == 9)) {
    sqlite3VdbeAddOp2(v, 51, pDest->iSDParm, pEList->nExpr);
  }  
  (iEnd = sqlite3VdbeMakeLabel(v));
  (p->nSelectRow = (0xffffffff | (((i64 ) 0x7fffffff) << 32)));
  computeLimitRegisters(pParse, p, iEnd);
  if (((p->iLimit == 0) && (addrSortIndex >= 0))) {
    (sqlite3VdbeGetOp(v, addrSortIndex)->opcode = 52);
    (p->selFlags |= 0x0040);
  }  
  if ((p->selFlags & 0x0001)) {
    (sDistinct.tabTnct = pParse->nTab++);
    (sDistinct.addrTnct = sqlite3VdbeAddOp4(v, 51, sDistinct.tabTnct, 0, 0, ((char *) keyInfoFromExprList(pParse, p->pEList)), (- 16)));
    sqlite3VdbeChangeP5(v, 8);
    (sDistinct.eTnctType = 3);
  }  
  else {
    (sDistinct.eTnctType = 0);
  }
  if (((! isAgg) && (pGroupBy == 0))) {
    u16 wctrlFlags =  (sDistinct.isTnct ? 0x0400 : 0);
    (pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pOrderBy, p->pEList, wctrlFlags, 0));
    if ((pWInfo == 0)) {
      goto select_end;
    }  
    if ((sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow)) {
      (p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo));
    }  
    if ((sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo))) {
      (sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo));
    }  
    if ((pOrderBy && sqlite3WhereIsOrdered(pWInfo))) {
      (pOrderBy = 0);
    }  
    if (((addrSortIndex >= 0) && (pOrderBy == 0))) {
      sqlite3VdbeChangeToNoop(v, addrSortIndex);
      (p->addrOpenEphm[2] = (- 1));
    }  
    selectInnerLoop(pParse, p, pEList, 0, 0, pOrderBy, (&sDistinct), pDest, sqlite3WhereContinueLabel(pWInfo), sqlite3WhereBreakLabel(pWInfo));
    sqlite3WhereEnd(pWInfo);
  }  
  else {
    NameContext sNC;
    int iAMem;
    int iBMem;
    int iUseFlag;
    int iAbortFlag;
    int groupBySort;
    int addrEnd;
    int sortPTab =  0;
    int sortOut =  0;
    if (pGroupBy) {
      int k;
      struct  ExprList_item   *pItem;
      for ((k = p->pEList->nExpr), (pItem = p->pEList->a); (k > 0); k--, pItem++) {
        (pItem->iAlias = 0);
      }
      for ((k = pGroupBy->nExpr), (pItem = pGroupBy->a); (k > 0); k--, pItem++) {
        (pItem->iAlias = 0);
      }
      if ((p->nSelectRow > 100)) {
        (p->nSelectRow = 100);
      }  
    }  
    else {
      (p->nSelectRow = 1);
    }
    (addrEnd = sqlite3VdbeMakeLabel(v));
    memset((&sNC), 0, sizeof(sNC));
    (sNC.pParse = pParse);
    (sNC.pSrcList = pTabList);
    (sNC.pAggInfo = (&sAggInfo));
    (sAggInfo.nSortingColumn = (pGroupBy ? (pGroupBy->nExpr + 1) : 0));
    (sAggInfo.pGroupBy = pGroupBy);
    sqlite3ExprAnalyzeAggList((&sNC), pEList);
    sqlite3ExprAnalyzeAggList((&sNC), pOrderBy);
    if (pHaving) {
      sqlite3ExprAnalyzeAggregates((&sNC), pHaving);
    }  
    (sAggInfo.nAccumulator = sAggInfo.nColumn);
    for ((i = 0); (i < sAggInfo.nFunc); i++) {
      ((void ) 0);
      (sNC.ncFlags |= 0x08);
      sqlite3ExprAnalyzeAggList((&sNC), sAggInfo.aFunc[i].pExpr->x.pList);
      (sNC.ncFlags &= (~ 0x08));
    }
    if (db->mallocFailed) {
      goto select_end;
    }  
    if (pGroupBy) {
      KeyInfo *pKeyInfo;
      int j1;
      int addrOutputRow;
      int regOutputRow;
      int addrSetAbort;
      int addrTopOfLoop;
      int addrSortingIdx;
      int addrReset;
      int regReset;
      (sAggInfo.sortingIdx = pParse->nTab++);
      (pKeyInfo = keyInfoFromExprList(pParse, pGroupBy));
      (addrSortingIdx = sqlite3VdbeAddOp4(v, 52, sAggInfo.sortingIdx, sAggInfo.nSortingColumn, 0, ((char *) pKeyInfo), (- 16)));
      (iUseFlag = ++pParse->nMem);
      (iAbortFlag = ++pParse->nMem);
      (regOutputRow = ++pParse->nMem);
      (addrOutputRow = sqlite3VdbeMakeLabel(v));
      (regReset = ++pParse->nMem);
      (addrReset = sqlite3VdbeMakeLabel(v));
      (iAMem = (pParse->nMem + 1));
      (pParse->nMem += pGroupBy->nExpr);
      (iBMem = (pParse->nMem + 1));
      (pParse->nMem += pGroupBy->nExpr);
      sqlite3VdbeAddOp2(v, 21, 0, iAbortFlag);
      sqlite3VdbeAddOp2(v, 21, 0, iUseFlag);
      sqlite3VdbeAddOp3(v, 24, 0, iAMem, (iAMem + pGroupBy->nExpr - 1));
      sqlite3VdbeAddOp2(v, 15, regReset, addrReset);
      (pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0, 0x0100, 0));
      if ((pWInfo == 0)) {
        goto select_end;
      }  
      if (sqlite3WhereIsOrdered(pWInfo)) {
        (groupBySort = 0);
      }  
      else {
        int regBase;
        int regRecord;
        int nCol;
        int nGroupBy;
        if ((((! id2i_sqlite_omit_explain) ) )) {
          explainTempTable(pParse, ((sDistinct.isTnct && ((p->selFlags & 0x0001) == 0)) ? "DISTINCT" : "GROUP BY"));
        }  
        (groupBySort = 1);
        (nGroupBy = pGroupBy->nExpr);
        (nCol = (nGroupBy + 1));
        (j = (nGroupBy + 1));
        for ((i = 0); (i < sAggInfo.nColumn); i++) {
          if ((sAggInfo.aCol[i].iSorterColumn >= j)) {
            nCol++;
            j++;
          }  
        }
        (regBase = sqlite3GetTempRange(pParse, nCol));
        sqlite3ExprCacheClear(pParse);
        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0);
        sqlite3VdbeAddOp2(v, 64, sAggInfo.sortingIdx, (regBase + nGroupBy));
        (j = (nGroupBy + 1));
        for ((i = 0); (i < sAggInfo.nColumn); i++) {
          struct  AggInfo_col   *pCol =  (&sAggInfo.aCol[i]);
          if ((pCol->iSorterColumn >= j)) {
            int r1 =  (j + regBase);
            int r2;
            (r2 = sqlite3ExprCodeGetColumn(pParse, pCol->pTab, pCol->iColumn, pCol->iTable, r1, 0));
            if ((r1 != r2)) {
              sqlite3VdbeAddOp2(v, 29, r2, r1);
            }  
            j++;
          }  
        }
        (regRecord = sqlite3GetTempReg(pParse));
        sqlite3VdbeAddOp3(v, 43, regBase, nCol, regRecord);
        sqlite3VdbeAddOp2(v, 102, sAggInfo.sortingIdx, regRecord);
        sqlite3ReleaseTempReg(pParse, regRecord);
        sqlite3ReleaseTempRange(pParse, regBase, nCol);
        sqlite3WhereEnd(pWInfo);
        (sAggInfo.sortingIdxPTab = (sortPTab = pParse->nTab++));
        (sortOut = sqlite3GetTempReg(pParse));
        sqlite3VdbeAddOp3(v, 53, sortPTab, sortOut, nCol);
        sqlite3VdbeAddOp2(v, 99, sAggInfo.sortingIdx, addrEnd);
        (sAggInfo.useSortingIdx = 1);
        sqlite3ExprCacheClear(pParse);
      }
      (addrTopOfLoop = sqlite3VdbeCurrentAddr(v));
      sqlite3ExprCacheClear(pParse);
      if (groupBySort) {
        sqlite3VdbeAddOp2(v, 81, sAggInfo.sortingIdx, sortOut);
      }  
      for ((j = 0); (j < pGroupBy->nExpr); j++) {
        if (groupBySort) {
          sqlite3VdbeAddOp3(v, 41, sortPTab, j, (iBMem + j));
          if ((j == 0)) {
            sqlite3VdbeChangeP5(v, 0x20);
          }  
        }  
        else {
          (sAggInfo.directMode = 1);
          sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, (iBMem + j));
        }
      }
      sqlite3VdbeAddOp4(v, 36, iAMem, iBMem, pGroupBy->nExpr, ((char *) pKeyInfo), (- 6));
      (j1 = sqlite3VdbeCurrentAddr(v));
      sqlite3VdbeAddOp3(v, 37, (j1 + 1), 0, (j1 + 1));
      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);
      sqlite3VdbeAddOp2(v, 15, regOutputRow, addrOutputRow);
      sqlite3VdbeAddOp2(v, 126, iAbortFlag, addrEnd);
      sqlite3VdbeAddOp2(v, 15, regReset, addrReset);
      sqlite3VdbeJumpHere(v, j1);
      updateAccumulator(pParse, (&sAggInfo));
      sqlite3VdbeAddOp2(v, 21, 1, iUseFlag);
      if (groupBySort) {
        sqlite3VdbeAddOp2(v, 5, sAggInfo.sortingIdx, addrTopOfLoop);
      }  
      else {
        sqlite3WhereEnd(pWInfo);
        sqlite3VdbeChangeToNoop(v, addrSortingIdx);
      }
      sqlite3VdbeAddOp2(v, 15, regOutputRow, addrOutputRow);
      sqlite3VdbeAddOp2(v, 14, 0, addrEnd);
      (addrSetAbort = sqlite3VdbeCurrentAddr(v));
      sqlite3VdbeAddOp2(v, 21, 1, iAbortFlag);
      sqlite3VdbeAddOp1(v, 16, regOutputRow);
      sqlite3VdbeResolveLabel(v, addrOutputRow);
      (addrOutputRow = sqlite3VdbeCurrentAddr(v));
      sqlite3VdbeAddOp2(v, 126, iUseFlag, (addrOutputRow + 2));
      sqlite3VdbeAddOp1(v, 16, regOutputRow);
      finalizeAggFunctions(pParse, (&sAggInfo));
      sqlite3ExprIfFalse(pParse, pHaving, (addrOutputRow + 1), 0x08);
      selectInnerLoop(pParse, p, p->pEList, 0, 0, pOrderBy, (&sDistinct), pDest, (addrOutputRow + 1), addrSetAbort);
      sqlite3VdbeAddOp1(v, 16, regOutputRow);
      sqlite3VdbeResolveLabel(v, addrReset);
      resetAccumulator(pParse, (&sAggInfo));
      sqlite3VdbeAddOp1(v, 16, regReset);
    }  
    else {
      ExprList *pDel =  0;
      Table *pTab;
      if (((pTab = isSimpleCount(p, (&sAggInfo))) != 0)) {
        const int iDb =  sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
        const int iCsr =  pParse->nTab++;
        Index *pIdx;
        KeyInfo *pKeyInfo =  0;
        Index *pBest =  0;
        int iRoot =  pTab->tnum;
        sqlite3CodeVerifySchema(pParse, iDb);
        sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
        for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
          if (((pIdx->bUnordered == 0) && (pIdx->szIdxRow < pTab->szTabRow) && (pIdx->pPartIdxWhere == 0) && ((! pBest) || (pIdx->szIdxRow < pBest->szIdxRow)))) {
            (pBest = pIdx);
          }  
        }
        if (pBest) {
          (iRoot = pBest->tnum);
          (pKeyInfo = sqlite3IndexKeyinfo(pParse, pBest));
        }  
        sqlite3VdbeAddOp3(v, 48, iCsr, iRoot, iDb);
        if (pKeyInfo) {
          sqlite3VdbeChangeP4(v, (- 1), ((char *) pKeyInfo), (- 16));
        }  
        sqlite3VdbeAddOp2(v, 44, iCsr, sAggInfo.aFunc[0].iMem);
        sqlite3VdbeAddOp1(v, 54, iCsr);
        if ((((! id2i_sqlite_omit_explain) ) )) {
          explainSimpleCount(pParse, pTab, pBest);
        }  
      }  
      else {
        ExprList *pMinMax =  0;
        u8 flag =  0x0000;
        ((void ) 0);
        ((void ) 0);
        if ((p->pHaving == 0)) {
          (flag = minMaxQuery((&sAggInfo), (&pMinMax)));
        }  
        ((void ) 0);
        if (flag) {
          (pMinMax = sqlite3ExprListDup(db, pMinMax, 0));
          (pDel = pMinMax);
          if ((pMinMax && (! db->mallocFailed))) {
            (pMinMax->a[0].sortOrder = ((flag != 0x0001) ? 1 : 0));
            (pMinMax->a[0].pExpr->op = 152);
          }  
        }  
        resetAccumulator(pParse, (&sAggInfo));
        (pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMax, 0, flag, 0));
        if ((pWInfo == 0)) {
          sqlite3ExprListDelete(db, pDel);
          goto select_end;
        }  
        updateAccumulator(pParse, (&sAggInfo));
        ((void ) 0);
        if (sqlite3WhereIsOrdered(pWInfo)) {
          sqlite3VdbeAddOp2(v, 14, 0, sqlite3WhereBreakLabel(pWInfo));
        }  
        sqlite3WhereEnd(pWInfo);
        finalizeAggFunctions(pParse, (&sAggInfo));
      }
      (pOrderBy = 0);
      sqlite3ExprIfFalse(pParse, pHaving, addrEnd, 0x08);
      selectInnerLoop(pParse, p, p->pEList, 0, 0, 0, 0, pDest, addrEnd, addrEnd);
      sqlite3ExprListDelete(db, pDel);
    }
    sqlite3VdbeResolveLabel(v, addrEnd);
  }
  if ((sDistinct.eTnctType == 3)) {
    if ((((! id2i_sqlite_omit_explain) ) )) {
      explainTempTable(pParse, "DISTINCT");
    }  
  }  
  if (pOrderBy) {
    if ((((! id2i_sqlite_omit_explain) ) )) {
      explainTempTable(pParse, "ORDER BY");
    }  
    generateSortTail(pParse, p, v, pEList->nExpr, pDest);
  }  
  sqlite3VdbeResolveLabel(v, iEnd);
  (rc = 0);
  select_end:
  if ((((! id2i_sqlite_omit_explain) ) )) {
    (pParse->_1272_iSelectId = iRestoreSelectId);
  }  
  if (((rc == 0) && (pDest->eDest == 5))) {
    generateColumnNames(pParse, pTabList, pEList);
  }  
  sqlite3DbFree(db, sAggInfo.aCol);
  sqlite3DbFree(db, sAggInfo.aFunc);
  return rc;
}
static  void explainOneSelect(Vdbe *pVdbe , Select *p )  {
  sqlite3ExplainPrintf(pVdbe, "SELECT ");
  if ((p->selFlags & (0x0001 | 0x0004))) {
    if ((p->selFlags & 0x0001)) {
      sqlite3ExplainPrintf(pVdbe, "DISTINCT ");
    }  
    if ((p->selFlags & 0x0004)) {
      sqlite3ExplainPrintf(pVdbe, "agg_flag ");
    }  
    sqlite3ExplainNL(pVdbe);
    sqlite3ExplainPrintf(pVdbe, "   ");
  }  
  sqlite3ExplainExprList(pVdbe, p->pEList);
  sqlite3ExplainNL(pVdbe);
  if ((p->pSrc && p->pSrc->nSrc)) {
    int i;
    sqlite3ExplainPrintf(pVdbe, "FROM ");
    sqlite3ExplainPush(pVdbe);
    for ((i = 0); (i < p->pSrc->nSrc); i++) {
      struct  SrcList_item   *pItem =  (&p->pSrc->a[i]);
      sqlite3ExplainPrintf(pVdbe, "{%d,*} = ", pItem->iCursor);
      if (pItem->pSelect) {
        sqlite3ExplainSelect(pVdbe, pItem->pSelect);
        if (pItem->pTab) {
          sqlite3ExplainPrintf(pVdbe, " (tabname=%s)", pItem->pTab->zName);
        }  
      } 
      else if (pItem->zName) {
        sqlite3ExplainPrintf(pVdbe, "%s", pItem->zName);
      } 
      if (pItem->zAlias) {
        sqlite3ExplainPrintf(pVdbe, " (AS %s)", pItem->zAlias);
      }  
      if ((pItem->jointype & 0x0008)) {
        sqlite3ExplainPrintf(pVdbe, " LEFT-JOIN");
      }  
      sqlite3ExplainNL(pVdbe);
    }
    sqlite3ExplainPop(pVdbe);
  }  
  if (p->pWhere) {
    sqlite3ExplainPrintf(pVdbe, "WHERE ");
    sqlite3ExplainExpr(pVdbe, p->pWhere);
    sqlite3ExplainNL(pVdbe);
  }  
  if (p->pGroupBy) {
    sqlite3ExplainPrintf(pVdbe, "GROUPBY ");
    sqlite3ExplainExprList(pVdbe, p->pGroupBy);
    sqlite3ExplainNL(pVdbe);
  }  
  if (p->pHaving) {
    sqlite3ExplainPrintf(pVdbe, "HAVING ");
    sqlite3ExplainExpr(pVdbe, p->pHaving);
    sqlite3ExplainNL(pVdbe);
  }  
  if (p->pOrderBy) {
    sqlite3ExplainPrintf(pVdbe, "ORDERBY ");
    sqlite3ExplainExprList(pVdbe, p->pOrderBy);
    sqlite3ExplainNL(pVdbe);
  }  
  if (p->pLimit) {
    sqlite3ExplainPrintf(pVdbe, "LIMIT ");
    sqlite3ExplainExpr(pVdbe, p->pLimit);
    sqlite3ExplainNL(pVdbe);
  }  
  if (p->pOffset) {
    sqlite3ExplainPrintf(pVdbe, "OFFSET ");
    sqlite3ExplainExpr(pVdbe, p->pOffset);
    sqlite3ExplainNL(pVdbe);
  }  
}
static  void sqlite3ExplainSelect(Vdbe *pVdbe , Select *p )  {
  if ((p == 0)) {
    sqlite3ExplainPrintf(pVdbe, "(null-select)");
    return;
  }  
  while (p->pPrior) {
    (p->pPrior->pNext = p);
    (p = p->pPrior);
  }
  sqlite3ExplainPush(pVdbe);
  while (p) {
    explainOneSelect(pVdbe, p);
    (p = p->pNext);
    if ((p == 0)) {
      break;
    }  
    sqlite3ExplainNL(pVdbe);
    sqlite3ExplainPrintf(pVdbe, "%s\n", selectOpName(p->op));
  }
  sqlite3ExplainPrintf(pVdbe, "END");
  sqlite3ExplainPop(pVdbe);
}
typedef struct  TabResult {
  char **azResult ;
  char *zErrMsg ;
  int nAlloc ;
  int nRow ;
  int nColumn ;
  int nData ;
  int rc ;
}  TabResult;
static  int sqlite3_get_table_cb(void *pArg , int nCol , char **argv , char **colv )  {
  TabResult *p =  ((TabResult *) pArg);
  int need;
  int i;
  char *z;
  if (((p->nRow == 0) && (argv != 0))) {
    (need = (nCol * 2));
  }  
  else {
    (need = nCol);
  }
  if (((p->nData + need) > p->nAlloc)) {
    char **azNew;
    (p->nAlloc = ((p->nAlloc * 2) + need));
    (azNew = sqlite3_realloc(p->azResult, (sizeof(char *) * p->nAlloc)));
    if ((azNew == 0)) {
      goto malloc_failed;
    }  
    (p->azResult = azNew);
  }  
  if ((p->nRow == 0)) {
    (p->nColumn = nCol);
    for ((i = 0); (i < nCol); i++) {
      (z = sqlite3_mprintf("%s", colv[i]));
      if ((z == 0)) {
        goto malloc_failed;
      }  
      (p->azResult[p->nData++] = z);
    }
  } 
  else if ((p->nColumn != nCol)) {
    sqlite3_free(p->zErrMsg);
    (p->zErrMsg = sqlite3_mprintf("sqlite3_get_table() called with two or more incompatible queries"));
    (p->rc = 1);
    return 1;
  } 
  if ((argv != 0)) {
    for ((i = 0); (i < nCol); i++) {
      if ((argv[i] == 0)) {
        (z = 0);
      }  
      else {
        int n =  (sqlite3Strlen30(argv[i]) + 1);
        (z = sqlite3_malloc(n));
        if ((z == 0)) {
          goto malloc_failed;
        }  
        memcpy(z, argv[i], n);
      }
      (p->azResult[p->nData++] = z);
    }
    p->nRow++;
  }  
  return 0;
  malloc_failed:
  (p->rc = 7);
  return 1;
}
int sqlite3_get_table(sqlite3 *db , const  char *zSql , char ***pazResult , int *pnRow , int *pnColumn , char **pzErrMsg )  {
  int rc;
  TabResult res;
  ((*pazResult) = 0);
  if (pnColumn) {
    ((*pnColumn) = 0);
  }  
  if (pnRow) {
    ((*pnRow) = 0);
  }  
  if (pzErrMsg) {
    ((*pzErrMsg) = 0);
  }  
  (res.zErrMsg = 0);
  (res.nRow = 0);
  (res.nColumn = 0);
  (res.nData = 1);
  (res.nAlloc = 20);
  (res.rc = 0);
  (res.azResult = sqlite3_malloc((sizeof(char *) * res.nAlloc)));
  if ((res.azResult == 0)) {
    (db->errCode = 7);
    return 7;
  }  
  (res.azResult[0] = 0);
  (rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, (&res), pzErrMsg));
  ((void ) 0);
  (res.azResult[0] = ((void *) ((long  int ) res.nData)));
  if (((rc & 0xff) == 4)) {
    sqlite3_free_table((&res.azResult[1]));
    if (res.zErrMsg) {
      if (pzErrMsg) {
        sqlite3_free((*pzErrMsg));
        ((*pzErrMsg) = sqlite3_mprintf("%s", res.zErrMsg));
      }  
      sqlite3_free(res.zErrMsg);
    }  
    (db->errCode = res.rc);
    return res.rc;
  }  
  sqlite3_free(res.zErrMsg);
  if ((rc != 0)) {
    sqlite3_free_table((&res.azResult[1]));
    return rc;
  }  
  if ((res.nAlloc > res.nData)) {
    char **azNew;
    (azNew = sqlite3_realloc(res.azResult, (sizeof(char *) * res.nData)));
    if ((azNew == 0)) {
      sqlite3_free_table((&res.azResult[1]));
      (db->errCode = 7);
      return 7;
    }  
    (res.azResult = azNew);
  }  
  ((*pazResult) = (&res.azResult[1]));
  if (pnColumn) {
    ((*pnColumn) = res.nColumn);
  }  
  if (pnRow) {
    ((*pnRow) = res.nRow);
  }  
  return rc;
}
void sqlite3_free_table(char **azResult )  {
  if (azResult) {
    int i, n;
    azResult--;
    ((void ) 0);
    (n = ((int ) ((long  int ) azResult[0])));
    for ((i = 1); (i < n); i++) {
      if (azResult[i]) {
        sqlite3_free(azResult[i]);
      }  
    }
    sqlite3_free(azResult);
  }  
}
static  void sqlite3DeleteTriggerStep(sqlite3 *db , TriggerStep *pTriggerStep )  {
  while (pTriggerStep) {
    TriggerStep *pTmp =  pTriggerStep;
    (pTriggerStep = pTriggerStep->pNext);
    sqlite3ExprDelete(db, pTmp->pWhere);
    sqlite3ExprListDelete(db, pTmp->pExprList);
    sqlite3SelectDelete(db, pTmp->pSelect);
    sqlite3IdListDelete(db, pTmp->pIdList);
    sqlite3DbFree(db, pTmp);
  }
}
static  Trigger *sqlite3TriggerList(Parse *pParse , Table *pTab )  {
  Schema *const pTmpSchema =  pParse->db->aDb[1].pSchema;
  Trigger *pList =  0;
  if (pParse->disableTriggers) {
    return 0;
  }  
  if ((pTmpSchema != pTab->pSchema)) {
    HashElem *p;
    ((void ) 0);
    for ((p = (&pTmpSchema->trigHash)->first); p; (p = p->next)) {
      Trigger *pTrig =  ((Trigger *) p->data);
      if (((pTrig->pTabSchema == pTab->pSchema) && (0 == sqlite3_stricmp(pTrig->table, pTab->zName)))) {
        (pTrig->pNext = (pList ? pList : pTab->pTrigger));
        (pList = pTrig);
      }  
    }
  }  
  return (pList ? pList : pTab->pTrigger);
}
static  void sqlite3BeginTrigger(Parse *pParse , Token *pName1 , Token *pName2 , int tr_tm , int op , IdList *pColumns , SrcList *pTableName , Expr *pWhen , int isTemp , int noErr )  {
  Trigger *pTrigger =  0;
  Table *pTab;
  char *zName =  0;
  sqlite3 *db =  pParse->db;
  int iDb;
  Token *pName;
  DbFixer sFix;
  int iTabDb;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (isTemp) {
    if ((pName2->n > 0)) {
      sqlite3ErrorMsg(pParse, "temporary trigger may not have qualified name");
      goto trigger_cleanup;
    }  
    (iDb = 1);
    (pName = pName1);
  }  
  else {
    (iDb = sqlite3TwoPartName(pParse, pName1, pName2, (&pName)));
    if ((iDb < 0)) {
      goto trigger_cleanup;
    }  
  }
  if (((! pTableName) || db->mallocFailed)) {
    goto trigger_cleanup;
  }  
  if ((db->init.busy && (iDb != 1))) {
    sqlite3DbFree(db, pTableName->a[0].zDatabase);
    (pTableName->a[0].zDatabase = 0);
  }  
  (pTab = sqlite3SrcListLookup(pParse, pTableName));
  if (((db->init.busy == 0) && (pName2->n == 0) && pTab && (pTab->pSchema == db->aDb[1].pSchema))) {
    (iDb = 1);
  }  
  if (db->mallocFailed) {
    goto trigger_cleanup;
  }  
  ((void ) 0);
  sqlite3FixInit((&sFix), pParse, iDb, "trigger", pName);
  if (sqlite3FixSrcList((&sFix), pTableName)) {
    goto trigger_cleanup;
  }  
  (pTab = sqlite3SrcListLookup(pParse, pTableName));
  if ((! pTab)) {
    if ((db->init.iDb == 1)) {
      (db->init.orphanTrigger = 1);
    }  
    goto trigger_cleanup;
  }  
  if (((pTab->tabFlags & 0x10) != 0)) {
    sqlite3ErrorMsg(pParse, "cannot create triggers on virtual tables");
    goto trigger_cleanup;
  }  
  (zName = sqlite3NameFromToken(db, pName));
  if (((! zName) || (0 != sqlite3CheckObjectName(pParse, zName)))) {
    goto trigger_cleanup;
  }  
  ((void ) 0);
  if (sqlite3HashFind((&db->aDb[iDb].pSchema->trigHash), zName, sqlite3Strlen30(zName))) {
    if ((! noErr)) {
      sqlite3ErrorMsg(pParse, "trigger %T already exists", pName);
    }  
    else {
      ((void ) 0);
      sqlite3CodeVerifySchema(pParse, iDb);
    }
    goto trigger_cleanup;
  }  
  if ((sqlite3_strnicmp(pTab->zName, "sqlite_", 7) == 0)) {
    sqlite3ErrorMsg(pParse, "cannot create trigger on system table");
    pParse->nErr++;
    goto trigger_cleanup;
  }  
  if ((pTab->pSelect && (tr_tm != 48))) {
    sqlite3ErrorMsg(pParse, "cannot create %s trigger on view: %S", ((tr_tm == 34) ? "BEFORE" : "AFTER"), pTableName, 0);
    goto trigger_cleanup;
  }  
  if (((! pTab->pSelect) && (tr_tm == 48))) {
    sqlite3ErrorMsg(pParse, "cannot create INSTEAD OF" " trigger on table: %S", pTableName, 0);
    goto trigger_cleanup;
  }  
  (iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema));
  {
    int code =  7;
    const char *zDb =  db->aDb[iTabDb].zName;
    const char *zDbTrig =  (isTemp ? db->aDb[1].zName : zDb);
    if (((iTabDb == 1) || isTemp)) {
      (code = 5);
    }  
    if (sqlite3AuthCheck(pParse, code, zName, pTab->zName, zDbTrig)) {
      goto trigger_cleanup;
    }  
    if (sqlite3AuthCheck(pParse, 18, (((! 0) && (iTabDb == 1)) ? "sqlite_temp_master" : "sqlite_master"), 0, zDb)) {
      goto trigger_cleanup;
    }  
  }
  if ((tr_tm == 48)) {
    (tr_tm = 34);
  }  
  (pTrigger = ((Trigger *) sqlite3DbMallocZero(db, sizeof(Trigger ))));
  if ((pTrigger == 0)) {
    goto trigger_cleanup;
  }  
  (pTrigger->zName = zName);
  (zName = 0);
  (pTrigger->table = sqlite3DbStrDup(db, pTableName->a[0].zName));
  (pTrigger->pSchema = db->aDb[iDb].pSchema);
  (pTrigger->pTabSchema = pTab->pSchema);
  (pTrigger->op = ((u8 ) op));
  (pTrigger->tr_tm = ((tr_tm == 34) ? 1 : 2));
  (pTrigger->pWhen = sqlite3ExprDup(db, pWhen, 0x0001));
  (pTrigger->pColumns = sqlite3IdListDup(db, pColumns));
  ((void ) 0);
  (pParse->pNewTrigger = pTrigger);
  trigger_cleanup:
  sqlite3DbFree(db, zName);
  sqlite3SrcListDelete(db, pTableName);
  sqlite3IdListDelete(db, pColumns);
  sqlite3ExprDelete(db, pWhen);
  if ((! pParse->pNewTrigger)) {
    sqlite3DeleteTrigger(db, pTrigger);
  }  
  else {
    ((void ) 0);
  }
}
static  void sqlite3FinishTrigger(Parse *pParse , TriggerStep *pStepList , Token *pAll )  {
  Trigger *pTrig =  pParse->pNewTrigger;
  char *zName;
  sqlite3 *db =  pParse->db;
  DbFixer sFix;
  int iDb;
  Token nameToken;
  (pParse->pNewTrigger = 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((0 || (! pTrig))) {
      goto triggerfinish_cleanup;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pParse->nErr || (! pTrig))) {
      goto triggerfinish_cleanup;
    }  
  }  
  (zName = pTrig->zName);
  (iDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema));
  (pTrig->step_list = pStepList);
  while (pStepList) {
    (pStepList->pTrig = pTrig);
    (pStepList = pStepList->pNext);
  }
  (nameToken.z = pTrig->zName);
  (nameToken.n = sqlite3Strlen30(nameToken.z));
  sqlite3FixInit((&sFix), pParse, iDb, "trigger", (&nameToken));
  if ((sqlite3FixTriggerStep((&sFix), pTrig->step_list) || sqlite3FixExpr((&sFix), pTrig->pWhen))) {
    goto triggerfinish_cleanup;
  }  
  if ((! db->init.busy)) {
    Vdbe *v;
    char *z;
    (v = sqlite3GetVdbe(pParse));
    if ((v == 0)) {
      goto triggerfinish_cleanup;
    }  
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    (z = sqlite3DbStrNDup(db, ((char *) pAll->z), pAll->n));
    sqlite3NestedParse(pParse, "INSERT INTO %Q.%s VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')", db->aDb[iDb].zName, (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"), zName, pTrig->table, z);
    sqlite3DbFree(db, z);
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddParseSchemaOp(v, iDb, sqlite3MPrintf(db, "type='trigger' AND name='%q'", zName));
  }  
  if (db->init.busy) {
    Trigger *pLink =  pTrig;
    Hash *pHash =  (&db->aDb[iDb].pSchema->trigHash);
    ((void ) 0);
    (pTrig = sqlite3HashInsert(pHash, zName, sqlite3Strlen30(zName), pTrig));
    if (pTrig) {
      (db->mallocFailed = 1);
    } 
    else if ((pLink->pSchema == pLink->pTabSchema)) {
      Table *pTab;
      int n =  sqlite3Strlen30(pLink->table);
      (pTab = sqlite3HashFind((&pLink->pTabSchema->tblHash), pLink->table, n));
      ((void ) 0);
      (pLink->pNext = pTab->pTrigger);
      (pTab->pTrigger = pLink);
    } 
  }  
  triggerfinish_cleanup:
  sqlite3DeleteTrigger(db, pTrig);
  ((void ) 0);
  sqlite3DeleteTriggerStep(db, pStepList);
}
static  TriggerStep *sqlite3TriggerSelectStep(sqlite3 *db , Select *pSelect )  {
  TriggerStep *pTriggerStep =  sqlite3DbMallocZero(db, sizeof(TriggerStep ));
  if ((pTriggerStep == 0)) {
    sqlite3SelectDelete(db, pSelect);
    return 0;
  }  
  (pTriggerStep->op = 116);
  (pTriggerStep->pSelect = pSelect);
  (pTriggerStep->orconf = 10);
  return pTriggerStep;
}
static  TriggerStep *triggerStepAllocate(sqlite3 *db , u8 op , Token *pName )  {
  TriggerStep *pTriggerStep;
  (pTriggerStep = sqlite3DbMallocZero(db, (sizeof(TriggerStep ) + pName->n)));
  if (pTriggerStep) {
    char *z =  ((char *) (&pTriggerStep[1]));
    memcpy(z, pName->z, pName->n);
    (pTriggerStep->target.z = z);
    (pTriggerStep->target.n = pName->n);
    (pTriggerStep->op = op);
  }  
  return pTriggerStep;
}
static  TriggerStep *sqlite3TriggerInsertStep(sqlite3 *db , Token *pTableName , IdList *pColumn , ExprList *pEList , Select *pSelect , u8 orconf )  {
  TriggerStep *pTriggerStep;
  ((void ) 0);
  ((void ) 0);
  (pTriggerStep = triggerStepAllocate(db, 105, pTableName));
  if (pTriggerStep) {
    (pTriggerStep->pSelect = sqlite3SelectDup(db, pSelect, 0x0001));
    (pTriggerStep->pIdList = pColumn);
    (pTriggerStep->pExprList = sqlite3ExprListDup(db, pEList, 0x0001));
    (pTriggerStep->orconf = orconf);
  }  
  else {
    sqlite3IdListDelete(db, pColumn);
  }
  sqlite3ExprListDelete(db, pEList);
  sqlite3SelectDelete(db, pSelect);
  return pTriggerStep;
}
static  TriggerStep *sqlite3TriggerUpdateStep(sqlite3 *db , Token *pTableName , ExprList *pEList , Expr *pWhere , u8 orconf )  {
  TriggerStep *pTriggerStep;
  (pTriggerStep = triggerStepAllocate(db, 107, pTableName));
  if (pTriggerStep) {
    (pTriggerStep->pExprList = sqlite3ExprListDup(db, pEList, 0x0001));
    (pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, 0x0001));
    (pTriggerStep->orconf = orconf);
  }  
  sqlite3ExprListDelete(db, pEList);
  sqlite3ExprDelete(db, pWhere);
  return pTriggerStep;
}
static  TriggerStep *sqlite3TriggerDeleteStep(sqlite3 *db , Token *pTableName , Expr *pWhere )  {
  TriggerStep *pTriggerStep;
  (pTriggerStep = triggerStepAllocate(db, 106, pTableName));
  if (pTriggerStep) {
    (pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, 0x0001));
    (pTriggerStep->orconf = 10);
  }  
  sqlite3ExprDelete(db, pWhere);
  return pTriggerStep;
}
static  void sqlite3DeleteTrigger(sqlite3 *db , Trigger *pTrigger )  {
  if ((pTrigger == 0)) {
    return;
  }  
  sqlite3DeleteTriggerStep(db, pTrigger->step_list);
  sqlite3DbFree(db, pTrigger->zName);
  sqlite3DbFree(db, pTrigger->table);
  sqlite3ExprDelete(db, pTrigger->pWhen);
  sqlite3IdListDelete(db, pTrigger->pColumns);
  sqlite3DbFree(db, pTrigger);
}
static  void sqlite3DropTrigger(Parse *pParse , SrcList *pName , int noErr )  {
  Trigger *pTrigger =  0;
  int i;
  const char *zDb;
  const char *zName;
  int nName;
  sqlite3 *db =  pParse->db;
  if (db->mallocFailed) {
    goto drop_trigger_cleanup;
  }  
  if ((0 != sqlite3ReadSchema(pParse))) {
    goto drop_trigger_cleanup;
  }  
  ((void ) 0);
  (zDb = pName->a[0].zDatabase);
  (zName = pName->a[0].zName);
  (nName = sqlite3Strlen30(zName));
  ((void ) 0);
  for ((i = 0); (i < db->nDb); i++) {
    int j =  ((i < 2) ? (i ^ 1) : i);
    if ((zDb && sqlite3_stricmp(db->aDb[j].zName, zDb))) {
      continue;
    }  
    ((void ) 0);
    (pTrigger = sqlite3HashFind((&db->aDb[j].pSchema->trigHash), zName, nName));
    if (pTrigger) {
      break;
    }  
  }
  if ((! pTrigger)) {
    if ((! noErr)) {
      sqlite3ErrorMsg(pParse, "no such trigger: %S", pName, 0);
    }  
    else {
      sqlite3CodeVerifyNamedSchema(pParse, zDb);
    }
    (pParse->checkSchema = 1);
    goto drop_trigger_cleanup;
  }  
  sqlite3DropTriggerPtr(pParse, pTrigger);
  drop_trigger_cleanup:
  sqlite3SrcListDelete(db, pName);
}
static  Table *tableOfTrigger(Trigger *pTrigger )  {
  int n =  sqlite3Strlen30(pTrigger->table);
  return sqlite3HashFind((&pTrigger->pTabSchema->tblHash), pTrigger->table, n);
}
static  void sqlite3DropTriggerPtr(Parse *pParse , Trigger *pTrigger )  {
  Table *pTable;
  Vdbe *v;
  sqlite3 *db =  pParse->db;
  int iDb;
  (iDb = sqlite3SchemaToIndex(pParse->db, pTrigger->pSchema));
  ((void ) 0);
  (pTable = tableOfTrigger(pTrigger));
  ((void ) 0);
  ((void ) 0);
  {
    int code =  16;
    const char *zDb =  db->aDb[iDb].zName;
    const char *zTab =  (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master");
    if ((iDb == 1)) {
      (code = 14);
    }  
    if ((sqlite3AuthCheck(pParse, code, pTrigger->zName, pTable->zName, zDb) || sqlite3AuthCheck(pParse, 9, zTab, 0, zDb))) {
      return;
    }  
  }
  ((void ) 0);
  if (((v = sqlite3GetVdbe(pParse)) != 0)) {
    int base;
    static const VdbeOpList dropTrigger[] =  { { 101,  0,  ((- 1) - 9),  0},  { 94,  0,  1,  0},  { 41,  0,  1,  2},  { 75,  2,  ((- 1) - 8),  1},  { 94,  0,  1,  0},  { 41,  0,  0,  2},  { 75,  2,  ((- 1) - 8),  1},  { 70,  0,  0,  0},  { 7,  0,  ((- 1) - 1),  0}};
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    sqlite3OpenMasterTable(pParse, iDb);
    (base = sqlite3VdbeAddOpList(v, ((int ) (sizeof(dropTrigger) / sizeof(dropTrigger[0]))), dropTrigger));
    sqlite3VdbeChangeP4(v, (base + 1), pTrigger->zName, 0);
    sqlite3VdbeChangeP4(v, (base + 4), "trigger", (- 2));
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddOp2(v, 54, 0, 0);
    sqlite3VdbeAddOp4(v, 116, iDb, 0, 0, pTrigger->zName, 0);
    if ((pParse->nMem < 3)) {
      (pParse->nMem = 3);
    }  
  }  
}
static  void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db , int iDb , const  char *zName )  {
  Trigger *pTrigger;
  Hash *pHash;
  ((void ) 0);
  (pHash = (&db->aDb[iDb].pSchema->trigHash));
  (pTrigger = sqlite3HashInsert(pHash, zName, sqlite3Strlen30(zName), 0));
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      if ((pTrigger->pSchema == pTrigger->pTabSchema)) {
        Table *pTab =  tableOfTrigger(pTrigger);
        Trigger **pp;
        for ((pp = (&pTab->pTrigger)); ((*pp) != pTrigger); (pp = (&(*pp)->pNext))) {
          
        }
        ((*pp) = (*pp)->pNext);
      }  
      sqlite3DeleteTrigger(db, pTrigger);
      (db->flags |= 0x00000002);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pTrigger) {
      if ((pTrigger->pSchema == pTrigger->pTabSchema)) {
        Table *pTab =  tableOfTrigger(pTrigger);
        Trigger **pp;
        for ((pp = (&pTab->pTrigger)); ((*pp) != pTrigger); (pp = (&(*pp)->pNext))) {
          
        }
        ((*pp) = (*pp)->pNext);
      }  
      sqlite3DeleteTrigger(db, pTrigger);
      (db->flags |= 0x00000002);
    }  
  }  
}
static  int checkColumnOverlap(IdList *pIdList , ExprList *pEList )  {
  int e;
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((pIdList == 0) || (pEList == 0))) {
      return 1;
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((pIdList == 0) || 0)) {
      return 1;
    }  
  }  
  for ((e = 0); (e < pEList->nExpr); e++) {
    if ((sqlite3IdListIndex(pIdList, pEList->a[e].zName) >= 0)) {
      return 1;
    }  
  }
  return 0;
}
static  Trigger *sqlite3TriggersExist(Parse *pParse , Table *pTab , int op , ExprList *pChanges , int *pMask )  {
  int mask =  0;
  Trigger *pList =  0;
  Trigger *p;
  if (((pParse->db->flags & 0x00800000) != 0)) {
    (pList = sqlite3TriggerList(pParse, pTab));
  }  
  ((void ) 0);
  for ((p = pList); p; (p = p->pNext)) {
    if (((p->op == op) && checkColumnOverlap(p->pColumns, pChanges))) {
      (mask |= p->tr_tm);
    }  
  }
  if (pMask) {
    ((*pMask) = mask);
  }  
  return (mask ? pList : 0);
}
static  SrcList *targetSrcList(Parse *pParse , TriggerStep *pStep )  {
  int iDb;
  SrcList *pSrc;
  (pSrc = sqlite3SrcListAppend(pParse->db, 0, (&pStep->target), 0));
  if (pSrc) {
    ((void ) 0);
    ((void ) 0);
    (iDb = sqlite3SchemaToIndex(pParse->db, pStep->pTrig->pSchema));
    if (((iDb == 0) || (iDb >= 2))) {
      sqlite3 *db =  pParse->db;
      ((void ) 0);
      (pSrc->a[(pSrc->nSrc - 1)].zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zName));
    }  
  }  
  return pSrc;
}
static  int codeTriggerProgram(Parse *pParse , TriggerStep *pStepList , int orconf )  {
  TriggerStep *pStep;
  Vdbe *v =  pParse->pVdbe;
  sqlite3 *db =  pParse->db;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  for ((pStep = pStepList); pStep; (pStep = pStep->pNext)) {
    (pParse->eOrconf = ((orconf == 10) ? pStep->orconf : ((u8 ) orconf)));
    ((void ) 0);
    (pParse->cookieGoto = 0);
    switch (pStep->op) {
      case 107:
      {
        sqlite3Update(pParse, targetSrcList(pParse, pStep), sqlite3ExprListDup(db, pStep->pExprList, 0), sqlite3ExprDup(db, pStep->pWhere, 0), pParse->eOrconf);
        break;
      }
      case 105:
      {
        sqlite3Insert(pParse, targetSrcList(pParse, pStep), sqlite3ExprListDup(db, pStep->pExprList, 0), sqlite3SelectDup(db, pStep->pSelect, 0), sqlite3IdListDup(db, pStep->pIdList), pParse->eOrconf);
        break;
      }
      case 106:
      {
        sqlite3DeleteFrom(pParse, targetSrcList(pParse, pStep), sqlite3ExprDup(db, pStep->pWhere, 0));
        break;
      }
      id2i_label_1:
      default:
      ((void ) 0);
      {
        SelectDest sDest;
        Select *pSelect =  sqlite3SelectDup(db, pStep->pSelect, 0);
        sqlite3SelectDestInit((&sDest), 4, 0);
        sqlite3Select(pParse, pSelect, (&sDest));
        sqlite3SelectDelete(db, pSelect);
        break;
      }
    }
    if ((pStep->op != 116)) {
      sqlite3VdbeAddOp0(v, 71);
    }  
  }
  return 0;
}
static  void transferParseError(Parse *pTo , Parse *pFrom )  {
  ((void ) 0);
  ((void ) 0);
  if ((pTo->nErr == 0)) {
    (pTo->zErrMsg = pFrom->zErrMsg);
    (pTo->nErr = pFrom->nErr);
  }  
  else {
    sqlite3DbFree(pFrom->db, pFrom->zErrMsg);
  }
}
static  TriggerPrg *codeRowTrigger(Parse *pParse , Trigger *pTrigger , Table *pTab , int orconf )  {
  Parse *pTop =  (pParse->pToplevel ? pParse->pToplevel : pParse);
  sqlite3 *db =  pParse->db;
  TriggerPrg *pPrg;
  Expr *pWhen =  0;
  Vdbe *v;
  NameContext sNC;
  SubProgram *pProgram =  0;
  Parse *pSubParse;
  int iEndTrigger =  0;
  ((void ) 0);
  ((void ) 0);
  (pPrg = sqlite3DbMallocZero(db, sizeof(TriggerPrg )));
  if ((! pPrg)) {
    return 0;
  }  
  (pPrg->pNext = pTop->pTriggerPrg);
  (pTop->pTriggerPrg = pPrg);
  (pPrg->pProgram = (pProgram = sqlite3DbMallocZero(db, sizeof(SubProgram ))));
  if ((! pProgram)) {
    return 0;
  }  
  sqlite3VdbeLinkSubProgram(pTop->pVdbe, pProgram);
  (pPrg->pTrigger = pTrigger);
  (pPrg->orconf = orconf);
  (pPrg->aColmask[0] = 0xffffffff);
  (pPrg->aColmask[1] = 0xffffffff);
  (pSubParse = sqlite3DbMallocZero(db, sizeof(Parse )));
  if ((! pSubParse)) {
    return 0;
  }  
  memset((&sNC), 0, sizeof(sNC));
  (sNC.pParse = pSubParse);
  (pSubParse->db = db);
  (pSubParse->pTriggerTab = pTab);
  (pSubParse->pToplevel = pTop);
  (pSubParse->zAuthContext = pTrigger->zName);
  (pSubParse->eTriggerOp = pTrigger->op);
  (pSubParse->nQueryLoop = pParse->nQueryLoop);
  (v = sqlite3GetVdbe(pSubParse));
  if (v) {
    sqlite3VdbeChangeP4(v, (- 1), sqlite3MPrintf(db, "-- TRIGGER %s", pTrigger->zName), (- 1));
    if (pTrigger->pWhen) {
      (pWhen = sqlite3ExprDup(db, pTrigger->pWhen, 0));
      if (((0 == sqlite3ResolveExprNames((&sNC), pWhen)) && (db->mallocFailed == 0))) {
        (iEndTrigger = sqlite3VdbeMakeLabel(v));
        sqlite3ExprIfFalse(pSubParse, pWhen, iEndTrigger, 0x08);
      }  
      sqlite3ExprDelete(db, pWhen);
    }  
    codeTriggerProgram(pSubParse, pTrigger->step_list, orconf);
    if (iEndTrigger) {
      sqlite3VdbeResolveLabel(v, iEndTrigger);
    }  
    sqlite3VdbeAddOp0(v, 20);
    transferParseError(pParse, pSubParse);
    if ((db->mallocFailed == 0)) {
      (pProgram->aOp = sqlite3VdbeTakeOpArray(v, (&pProgram->nOp), (&pTop->nMaxArg)));
    }  
    (pProgram->nMem = pSubParse->nMem);
    (pProgram->nCsr = pSubParse->nTab);
    (pProgram->nOnce = pSubParse->nOnce);
    (pProgram->token = ((void *) pTrigger));
    (pPrg->aColmask[0] = pSubParse->oldmask);
    (pPrg->aColmask[1] = pSubParse->newmask);
    sqlite3VdbeDelete(v);
  }  
  ((void ) 0);
  ((void ) 0);
  sqlite3DbFree(db, pSubParse);
  return pPrg;
}
static  TriggerPrg *getRowTrigger(Parse *pParse , Trigger *pTrigger , Table *pTab , int orconf )  {
  Parse *pRoot =  (pParse->pToplevel ? pParse->pToplevel : pParse);
  TriggerPrg *pPrg;
  ((void ) 0);
  for ((pPrg = pRoot->pTriggerPrg); (pPrg && ((pPrg->pTrigger != pTrigger) || (pPrg->orconf != orconf))); (pPrg = pPrg->pNext)) {
    
  }
  if ((! pPrg)) {
    (pPrg = codeRowTrigger(pParse, pTrigger, pTab, orconf));
  }  
  return pPrg;
}
static  void sqlite3CodeRowTriggerDirect(Parse *pParse , Trigger *p , Table *pTab , int reg , int orconf , int ignoreJump )  {
  Vdbe *v =  sqlite3GetVdbe(pParse);
  TriggerPrg *pPrg;
  (pPrg = getRowTrigger(pParse, p, pTab, orconf));
  ((void ) 0);
  if (pPrg) {
    int bRecursive =  (p->zName && (0 == (pParse->db->flags & 0x00040000)));
    sqlite3VdbeAddOp3(v, 121, reg, ignoreJump, ++pParse->nMem);
    sqlite3VdbeChangeP4(v, (- 1), ((const  char *) pPrg->pProgram), (- 18));
    sqlite3VdbeChangeP5(v, ((u8 ) bRecursive));
  }  
}
static  void sqlite3CodeRowTrigger(Parse *pParse , Trigger *pTrigger , int op , ExprList *pChanges , int tr_tm , Table *pTab , int reg , int orconf , int ignoreJump )  {
  Trigger *p;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  for ((p = pTrigger); p; (p = p->pNext)) {
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    if (((p->op == op) && (p->tr_tm == tr_tm) && checkColumnOverlap(p->pColumns, pChanges))) {
      sqlite3CodeRowTriggerDirect(pParse, p, pTab, reg, orconf, ignoreJump);
    }  
  }
}
static  u32 sqlite3TriggerColmask(Parse *pParse , Trigger *pTrigger , ExprList *pChanges , int isNew , int tr_tm , Table *pTab , int orconf )  {
  const int op =  (pChanges ? 107 : 106);
  u32 mask =  0;
  Trigger *p;
  ((void ) 0);
  for ((p = pTrigger); p; (p = p->pNext)) {
    if (((p->op == op) && (tr_tm & p->tr_tm) && checkColumnOverlap(p->pColumns, pChanges))) {
      TriggerPrg *pPrg;
      (pPrg = getRowTrigger(pParse, p, pTab, orconf));
      if (pPrg) {
        (mask |= pPrg->aColmask[isNew]);
      }  
    }  
  }
  return mask;
}
static void updateVirtualTable(Parse *pParse , SrcList *pSrc , Table *pTab , ExprList *pChanges , Expr *pRowidExpr , int *aXRef , Expr *pWhere , int onError );
static  void sqlite3ColumnDefault(Vdbe *v , Table *pTab , int i , int iReg )  {
  ((void ) 0);
  if ((! pTab->pSelect)) {
    sqlite3_value *pValue =  0;
    u8 enc =  sqlite3VdbeDb(v)->aDb[0].pSchema->enc;
    Column *pCol =  (&pTab->aCol[i]);
    ((void ) 0);
    sqlite3ValueFromExpr(sqlite3VdbeDb(v), pCol->pDflt, enc, pCol->affinity, (&pValue));
    if (pValue) {
      sqlite3VdbeChangeP4(v, (- 1), ((const  char *) pValue), (- 8));
    }  
    if (((iReg >= 0) && (pTab->aCol[i].affinity == 'e'))) {
      sqlite3VdbeAddOp1(v, 34, iReg);
    }  
  }  
}
static  void sqlite3Update(Parse *pParse , SrcList *pTabList , ExprList *pChanges , Expr *pWhere , int onError )  {
  int i, j;
  Table *pTab;
  int addr =  0;
  WhereInfo *pWInfo;
  Vdbe *v;
  Index *pIdx;
  int nIdx;
  int iCur;
  sqlite3 *db;
  int *aRegIdx =  0;
  int *aXRef =  0;
  int chngRowid;
  Expr *pRowidExpr =  0;
  int openAll =  0;
  AuthContext sContext;
  NameContext sNC;
  int iDb;
  int okOnePass;
  int hasFK;
  int isView;
  Trigger *pTrigger;
  int tmask;
  int newmask;
  int regRowCount =  0;
  int regOldRowid;
  int regNewRowid;
  int regNew;
  int regOld =  0;
  int regRowSet =  0;
  memset((&sContext), 0, sizeof(sContext));
  (db = pParse->db);
  if ((pParse->nErr || db->mallocFailed)) {
    goto update_cleanup;
  }  
  ((void ) 0);
  (pTab = sqlite3SrcListLookup(pParse, pTabList));
  if ((pTab == 0)) {
    goto update_cleanup;
  }  
  (iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema));
  (pTrigger = sqlite3TriggersExist(pParse, pTab, 107, pChanges, (&tmask)));
  (isView = (pTab->pSelect != 0));
  ((void ) 0);
  if (sqlite3ViewGetColumnNames(pParse, pTab)) {
    goto update_cleanup;
  }  
  if (sqlite3IsReadOnly(pParse, pTab, tmask)) {
    goto update_cleanup;
  }  
  (aXRef = sqlite3DbMallocRaw(db, (sizeof(int ) * pTab->nCol)));
  if ((aXRef == 0)) {
    goto update_cleanup;
  }  
  for ((i = 0); (i < pTab->nCol); i++) {
    (aXRef[i] = (- 1));
  }
  (pTabList->a[0].iCursor = (iCur = pParse->nTab++));
  for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
    pParse->nTab++;
  }
  memset((&sNC), 0, sizeof(sNC));
  (sNC.pParse = pParse);
  (sNC.pSrcList = pTabList);
  (chngRowid = 0);
  for ((i = 0); (i < pChanges->nExpr); i++) {
    if (sqlite3ResolveExprNames((&sNC), pChanges->a[i].pExpr)) {
      goto update_cleanup;
    }  
    for ((j = 0); (j < pTab->nCol); j++) {
      if ((sqlite3_stricmp(pTab->aCol[j].zName, pChanges->a[i].zName) == 0)) {
        if ((j == pTab->iPKey)) {
          (chngRowid = 1);
          (pRowidExpr = pChanges->a[i].pExpr);
        }  
        (aXRef[j] = i);
        break;
      }  
    }
    if ((j >= pTab->nCol)) {
      if (sqlite3IsRowid(pChanges->a[i].zName)) {
        (j = (- 1));
        (chngRowid = 1);
        (pRowidExpr = pChanges->a[i].pExpr);
      }  
      else {
        sqlite3ErrorMsg(pParse, "no such column: %s", pChanges->a[i].zName);
        (pParse->checkSchema = 1);
        goto update_cleanup;
      }
    }  
    {
      int rc;
      (rc = sqlite3AuthCheck(pParse, 23, pTab->zName, ((j < 0) ? "ROWID" : pTab->aCol[j].zName), db->aDb[iDb].zName));
      if ((rc == 1)) {
        goto update_cleanup;
      } 
      else if ((rc == 2)) {
        (aXRef[j] = (- 1));
      } 
    }
  }
  if (((id2i_sqlite_omit_foreign_key ) )) {
    (hasFK = 0);
  }  
  if ((((! id2i_sqlite_omit_foreign_key) ) )) {
    (hasFK = sqlite3FkRequired(pParse, pTab, aXRef, chngRowid));
  }  
  for ((nIdx = 0), (pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext), nIdx++) {
    
  }
  if ((nIdx > 0)) {
    (aRegIdx = sqlite3DbMallocRaw(db, (sizeof(Index *) * nIdx)));
    if ((aRegIdx == 0)) {
      goto update_cleanup;
    }  
  }  
  for ((j = 0), (pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext), j++) {
    int reg;
    if ((hasFK || chngRowid || pIdx->pPartIdxWhere)) {
      (reg = ++pParse->nMem);
    }  
    else {
      (reg = 0);
      for ((i = 0); (i < pIdx->nColumn); i++) {
        if ((aXRef[pIdx->aiColumn[i]] >= 0)) {
          (reg = ++pParse->nMem);
          break;
        }  
      }
    }
    (aRegIdx[j] = reg);
  }
  (v = sqlite3GetVdbe(pParse));
  if ((v == 0)) {
    goto update_cleanup;
  }  
  if ((pParse->nested == 0)) {
    sqlite3VdbeCountChanges(v);
  }  
  sqlite3BeginWriteOperation(pParse, 1, iDb);
  if (((pTab->tabFlags & 0x10) != 0)) {
    updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef, pWhere, onError);
    (pWhere = 0);
    (pTabList = 0);
    goto update_cleanup;
  }  
  (regRowSet = ++pParse->nMem);
  (regOldRowid = (regNewRowid = ++pParse->nMem));
  if ((pTrigger || hasFK)) {
    (regOld = (pParse->nMem + 1));
    (pParse->nMem += pTab->nCol);
  }  
  if ((chngRowid || pTrigger || hasFK)) {
    (regNewRowid = ++pParse->nMem);
  }  
  (regNew = (pParse->nMem + 1));
  (pParse->nMem += pTab->nCol);
  if (((id2i_sqlite_omit_view ) )) {
    if (0) {
      sqlite3AuthContextPush(pParse, (&sContext), pTab->zName);
    }  
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if (isView) {
      sqlite3AuthContextPush(pParse, (&sContext), pTab->zName);
    }  
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if (isView) {
      sqlite3MaterializeView(pParse, pTab, pWhere, iCur);
    }  
  }  
  if (sqlite3ResolveExprNames((&sNC), pWhere)) {
    goto update_cleanup;
  }  
  sqlite3VdbeAddOp3(v, 24, 0, regRowSet, regOldRowid);
  (pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, 0x0004, 0));
  if ((pWInfo == 0)) {
    goto update_cleanup;
  }  
  (okOnePass = sqlite3WhereOkOnePass(pWInfo));
  sqlite3VdbeAddOp2(v, 96, iCur, regOldRowid);
  if ((! okOnePass)) {
    sqlite3VdbeAddOp2(v, 118, regRowSet, regOldRowid);
  }  
  sqlite3WhereEnd(pWInfo);
  if (((db->flags & 0x00000080) && (! pParse->pTriggerTab))) {
    (regRowCount = ++pParse->nMem);
    sqlite3VdbeAddOp2(v, 21, 0, regRowCount);
  }  
  if (((id2i_sqlite_omit_view ) )) {
    if ((! 0)) {
      if ((! okOnePass)) {
        sqlite3OpenTable(pParse, iCur, iDb, pTab, 49);
      }  
      if ((onError == 5)) {
        (openAll = 1);
      }  
      else {
        (openAll = 0);
        for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
          if ((pIdx->onError == 5)) {
            (openAll = 1);
            break;
          }  
        }
      }
      for ((i = 0), (pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext), i++) {
        ((void ) 0);
        if ((openAll || (aRegIdx[i] > 0))) {
          KeyInfo *pKey =  sqlite3IndexKeyinfo(pParse, pIdx);
          sqlite3VdbeAddOp4(v, 49, (iCur + i + 1), pIdx->tnum, iDb, ((char *) pKey), (- 16));
          ((void ) 0);
        }  
      }
    }  
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if ((! isView)) {
      if ((! okOnePass)) {
        sqlite3OpenTable(pParse, iCur, iDb, pTab, 49);
      }  
      if ((onError == 5)) {
        (openAll = 1);
      }  
      else {
        (openAll = 0);
        for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
          if ((pIdx->onError == 5)) {
            (openAll = 1);
            break;
          }  
        }
      }
      for ((i = 0), (pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext), i++) {
        ((void ) 0);
        if ((openAll || (aRegIdx[i] > 0))) {
          KeyInfo *pKey =  sqlite3IndexKeyinfo(pParse, pIdx);
          sqlite3VdbeAddOp4(v, 49, (iCur + i + 1), pIdx->tnum, iDb, ((char *) pKey), (- 16));
          ((void ) 0);
        }  
      }
    }  
  }  
  if (okOnePass) {
    int a1 =  sqlite3VdbeAddOp1(v, 74, regOldRowid);
    (addr = sqlite3VdbeAddOp0(v, 14));
    sqlite3VdbeJumpHere(v, a1);
  }  
  else {
    (addr = sqlite3VdbeAddOp3(v, 119, regRowSet, 0, regOldRowid));
  }
  sqlite3VdbeAddOp3(v, 63, iCur, addr, regOldRowid);
  ((void ) 0);
  if (chngRowid) {
    sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);
    sqlite3VdbeAddOp1(v, 33, regNewRowid);
  }  
  if ((hasFK || pTrigger)) {
    u32 _1278_oldmask =  (hasFK ? sqlite3FkOldmask(pParse, pTab) : 0);
    u32 _1329_oldmask =  (hasFK ? 0 : 0);
    if ((((! id2i_sqlite_omit_foreign_key) ) )) {
      (_1278_oldmask |= sqlite3TriggerColmask(pParse, pTrigger, pChanges, 0, (1 | 2), pTab, onError));
    }  
    if (((id2i_sqlite_omit_foreign_key ) )) {
      (_1329_oldmask |= sqlite3TriggerColmask(pParse, pTrigger, pChanges, 0, (1 | 2), pTab, onError));
    }  
    for ((i = 0); (i < pTab->nCol); i++) {
      if ((((! id2i_sqlite_omit_foreign_key) ) )) {
        if (((aXRef[i] < 0) || (_1278_oldmask == 0xffffffff) || ((i < 32) && (_1278_oldmask & (1 << i))))) {
          sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, i, (regOld + i));
        }  
        else {
          sqlite3VdbeAddOp2(v, 24, 0, (regOld + i));
        }
      }  
      if (((id2i_sqlite_omit_foreign_key ) )) {
        if (((aXRef[i] < 0) || (_1329_oldmask == 0xffffffff) || ((i < 32) && (_1329_oldmask & (1 << i))))) {
          sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, i, (regOld + i));
        }  
        else {
          sqlite3VdbeAddOp2(v, 24, 0, (regOld + i));
        }
      }  
    }
    if ((chngRowid == 0)) {
      sqlite3VdbeAddOp2(v, 28, regOldRowid, regNewRowid);
    }  
  }  
  (newmask = sqlite3TriggerColmask(pParse, pTrigger, pChanges, 1, 1, pTab, onError));
  sqlite3VdbeAddOp3(v, 24, 0, regNew, (regNew + pTab->nCol - 1));
  for ((i = 0); (i < pTab->nCol); i++) {
    if ((i == pTab->iPKey)) {
      
    }  
    else {
      (j = aXRef[i]);
      if ((j >= 0)) {
        sqlite3ExprCode(pParse, pChanges->a[j].pExpr, (regNew + i));
      } 
      else if (((0 == (tmask & 1)) || (i > 31) || (newmask & (1 << i)))) {
        if (((id2i_sqlite_coverage_test ) )) {
          if ((i == 31)) {
            sqlite3Coverage(104789);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((i == 32)) {
            sqlite3Coverage(104790);
          }  
        }  
        sqlite3VdbeAddOp3(v, 41, iCur, i, (regNew + i));
        sqlite3ColumnDefault(v, pTab, i, (regNew + i));
      } 
    }
  }
  if ((tmask & 1)) {
    sqlite3VdbeAddOp2(v, 42, regNew, pTab->nCol);
    sqlite3TableAffinityStr(v, pTab);
    sqlite3CodeRowTrigger(pParse, pTrigger, 107, pChanges, 1, pTab, regOldRowid, onError, addr);
    sqlite3VdbeAddOp3(v, 63, iCur, addr, regOldRowid);
    for ((i = 0); (i < pTab->nCol); i++) {
      if (((aXRef[i] < 0) && (i != pTab->iPKey))) {
        sqlite3VdbeAddOp3(v, 41, iCur, i, (regNew + i));
        sqlite3ColumnDefault(v, pTab, i, (regNew + i));
      }  
    }
  }  
  if (((id2i_sqlite_omit_view ) )) {
    if ((! 0)) {
      int j1;
      sqlite3GenerateConstraintChecks(pParse, pTab, iCur, regNewRowid, aRegIdx, (chngRowid ? regOldRowid : 0), 1, onError, addr, 0);
      if (hasFK) {
        if ((((! id2i_sqlite_omit_foreign_key) ) )) {
          sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, chngRowid);
        }  
      }  
      (j1 = sqlite3VdbeAddOp3(v, 63, iCur, 0, regOldRowid));
      sqlite3GenerateRowIndexDelete(pParse, pTab, iCur, aRegIdx);
      if ((hasFK || chngRowid)) {
        sqlite3VdbeAddOp2(v, 70, iCur, 0);
      }  
      sqlite3VdbeJumpHere(v, j1);
      if (hasFK) {
        if ((((! id2i_sqlite_omit_foreign_key) ) )) {
          sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, chngRowid);
        }  
      }  
      sqlite3CompleteInsertion(pParse, pTab, iCur, regNewRowid, aRegIdx, 1, 0, 0);
      if (hasFK) {
        if ((((! id2i_sqlite_omit_foreign_key) ) )) {
          sqlite3FkActions(pParse, pTab, pChanges, regOldRowid, aXRef, chngRowid);
        }  
      }  
    }  
  }  
  if ((((! id2i_sqlite_omit_view) ) )) {
    if ((! isView)) {
      int j1;
      sqlite3GenerateConstraintChecks(pParse, pTab, iCur, regNewRowid, aRegIdx, (chngRowid ? regOldRowid : 0), 1, onError, addr, 0);
      if (hasFK) {
        if ((((! id2i_sqlite_omit_foreign_key) ) )) {
          sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, chngRowid);
        }  
      }  
      (j1 = sqlite3VdbeAddOp3(v, 63, iCur, 0, regOldRowid));
      sqlite3GenerateRowIndexDelete(pParse, pTab, iCur, aRegIdx);
      if ((hasFK || chngRowid)) {
        sqlite3VdbeAddOp2(v, 70, iCur, 0);
      }  
      sqlite3VdbeJumpHere(v, j1);
      if (hasFK) {
        if ((((! id2i_sqlite_omit_foreign_key) ) )) {
          sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, chngRowid);
        }  
      }  
      sqlite3CompleteInsertion(pParse, pTab, iCur, regNewRowid, aRegIdx, 1, 0, 0);
      if (hasFK) {
        if ((((! id2i_sqlite_omit_foreign_key) ) )) {
          sqlite3FkActions(pParse, pTab, pChanges, regOldRowid, aXRef, chngRowid);
        }  
      }  
    }  
  }  
  if (((db->flags & 0x00000080) && (! pParse->pTriggerTab))) {
    sqlite3VdbeAddOp2(v, 32, regRowCount, 1);
  }  
  sqlite3CodeRowTrigger(pParse, pTrigger, 107, pChanges, 2, pTab, regOldRowid, onError, addr);
  sqlite3VdbeAddOp2(v, 14, 0, addr);
  sqlite3VdbeJumpHere(v, addr);
  for ((i = 0), (pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext), i++) {
    ((void ) 0);
    if ((openAll || (aRegIdx[i] > 0))) {
      sqlite3VdbeAddOp2(v, 54, (iCur + i + 1), 0);
    }  
  }
  sqlite3VdbeAddOp2(v, 54, iCur, 0);
  if (((pParse->nested == 0) && (pParse->pTriggerTab == 0))) {
    sqlite3AutoincrementEnd(pParse);
  }  
  if (((db->flags & 0x00000080) && (! pParse->pTriggerTab) && (! pParse->nested))) {
    sqlite3VdbeAddOp2(v, 30, regRowCount, 1);
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "rows updated", ((sqlite3_destructor_type ) 0));
  }  
  update_cleanup:
  sqlite3AuthContextPop((&sContext));
  sqlite3DbFree(db, aRegIdx);
  sqlite3DbFree(db, aXRef);
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprListDelete(db, pChanges);
  sqlite3ExprDelete(db, pWhere);
  return;
}
static  void updateVirtualTable(Parse *pParse , SrcList *pSrc , Table *pTab , ExprList *pChanges , Expr *pRowid , int *aXRef , Expr *pWhere , int onError )  {
  Vdbe *v =  pParse->pVdbe;
  ExprList *pEList =  0;
  Select *pSelect =  0;
  Expr *pExpr;
  int ephemTab;
  int i;
  int addr;
  int iReg;
  sqlite3 *db =  pParse->db;
  const char *pVTab =  ((const  char *) sqlite3GetVTable(db, pTab));
  SelectDest dest;
  (pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, 26, "_rowid_")));
  if (pRowid) {
    (pEList = sqlite3ExprListAppend(pParse, pEList, sqlite3ExprDup(db, pRowid, 0)));
  }  
  ((void ) 0);
  for ((i = 0); (i < pTab->nCol); i++) {
    if ((aXRef[i] >= 0)) {
      (pExpr = sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr, 0));
    }  
    else {
      (pExpr = sqlite3Expr(db, 26, pTab->aCol[i].zName));
    }
    (pEList = sqlite3ExprListAppend(pParse, pEList, pExpr));
  }
  (pSelect = sqlite3SelectNew(pParse, pEList, pSrc, pWhere, 0, 0, 0, 0, 0, 0));
  ((void ) 0);
  (ephemTab = pParse->nTab++);
  sqlite3VdbeAddOp2(v, 51, ephemTab, (pTab->nCol + 1 + (pRowid != 0)));
  sqlite3VdbeChangeP5(v, 8);
  sqlite3SelectDestInit((&dest), 8, ephemTab);
  sqlite3Select(pParse, pSelect, (&dest));
  (iReg = ++pParse->nMem);
  (pParse->nMem += (pTab->nCol + 1));
  (addr = sqlite3VdbeAddOp2(v, 101, ephemTab, 0));
  sqlite3VdbeAddOp3(v, 41, ephemTab, 0, iReg);
  sqlite3VdbeAddOp3(v, 41, ephemTab, (pRowid ? 1 : 0), (iReg + 1));
  for ((i = 0); (i < pTab->nCol); i++) {
    sqlite3VdbeAddOp3(v, 41, ephemTab, (i + 1 + (pRowid != 0)), (iReg + 2 + i));
  }
  sqlite3VtabMakeWritable(pParse, pTab);
  sqlite3VdbeAddOp4(v, 13, 0, (pTab->nCol + 2), iReg, pVTab, (- 10));
  sqlite3VdbeChangeP5(v, ((onError == 10) ? 2 : onError));
  sqlite3MayAbort(pParse);
  sqlite3VdbeAddOp2(v, 7, ephemTab, (addr + 1));
  sqlite3VdbeJumpHere(v, addr);
  sqlite3VdbeAddOp2(v, 54, ephemTab, 0);
  sqlite3SelectDelete(db, pSelect);
}
static  int vacuumFinalize(sqlite3 *db , sqlite3_stmt *pStmt , char **pzErrMsg )  {
  int rc;
  (rc = sqlite3VdbeFinalize(((Vdbe *) pStmt)));
  if (rc) {
    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));
  }  
  return rc;
}
static  int execSql(sqlite3 *db , char **pzErrMsg , const  char *zSql )  {
  sqlite3_stmt *pStmt;
  if ((! zSql)) {
    return 7;
  }  
  if ((0 != sqlite3_prepare(db, zSql, (- 1), (&pStmt), 0))) {
    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));
    return sqlite3_errcode(db);
  }  
  sqlite3_step(pStmt);
  ((void ) 0);
  return vacuumFinalize(db, pStmt, pzErrMsg);
}
static  int execExecSql(sqlite3 *db , char **pzErrMsg , const  char *zSql )  {
  sqlite3_stmt *pStmt;
  int rc;
  (rc = sqlite3_prepare(db, zSql, (- 1), (&pStmt), 0));
  if ((rc != 0)) {
    return rc;
  }  
  while ((100 == sqlite3_step(pStmt))) {
    (rc = execSql(db, pzErrMsg, ((char *) sqlite3_column_text(pStmt, 0))));
    if ((rc != 0)) {
      vacuumFinalize(db, pStmt, pzErrMsg);
      return rc;
    }  
  }
  return vacuumFinalize(db, pStmt, pzErrMsg);
}
static  void sqlite3Vacuum(Parse *pParse )  {
  Vdbe *v =  sqlite3GetVdbe(pParse);
  if (v) {
    sqlite3VdbeAddOp2(v, 11, 0, 0);
    sqlite3VdbeUsesBtree(v, 0);
  }  
  return;
}
static  int sqlite3RunVacuum(char **pzErrMsg , sqlite3 *db )  {
  int rc =  0;
  Btree *pMain;
  Btree *pTemp;
  char *zSql =  0;
  int saved_flags;
  int saved_nChange;
  int saved_nTotalChange;
  void ( *saved_xTrace)(void * , const  char * );
  Db *pDb =  0;
  int isMemDb;
  int nRes;
  int nDb;
  if ((! db->autoCommit)) {
    sqlite3SetString(pzErrMsg, db, "cannot VACUUM from within a transaction");
    return 1;
  }  
  if ((db->nVdbeActive > 1)) {
    sqlite3SetString(pzErrMsg, db, "cannot VACUUM - SQL statements in progress");
    return 1;
  }  
  (saved_flags = db->flags);
  (saved_nChange = db->nChange);
  (saved_nTotalChange = db->nTotalChange);
  (saved_xTrace = db->xTrace);
  (db->flags |= (0x00000800 | 0x00002000 | 0x00200000));
  (db->flags &= (~ (0x00080000 | 0x00020000)));
  (db->xTrace = 0);
  (pMain = db->aDb[0].pBt);
  (isMemDb = sqlite3PagerIsMemdb(sqlite3BtreePager(pMain)));
  (nDb = db->nDb);
  if (sqlite3TempInMemory(db)) {
    (zSql = "ATTACH ':memory:' AS vacuum_db;");
  }  
  else {
    (zSql = "ATTACH '' AS vacuum_db;");
  }
  (rc = execSql(db, pzErrMsg, zSql));
  if ((db->nDb > nDb)) {
    (pDb = (&db->aDb[(db->nDb - 1)]));
    ((void ) 0);
  }  
  if ((rc != 0)) {
    goto end_of_vacuum;
  }  
  (pTemp = db->aDb[(db->nDb - 1)].pBt);
  sqlite3BtreeCommit(pTemp);
  (nRes = sqlite3BtreeGetReserve(pMain));
  (rc = execSql(db, pzErrMsg, "PRAGMA vacuum_db.synchronous=OFF"));
  if ((rc != 0)) {
    goto end_of_vacuum;
  }  
  (rc = execSql(db, pzErrMsg, "BEGIN;"));
  if ((rc != 0)) {
    goto end_of_vacuum;
  }  
  (rc = sqlite3BtreeBeginTrans(pMain, 2));
  if ((rc != 0)) {
    goto end_of_vacuum;
  }  
  if ((sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain)) == 5)) {
    (db->nextPagesize = 0);
  }  
  if ((((! id2i_sqlite_omit_attach) && (! id2i_sqlite_omit_vacuum) && (! id2i_sqlite_coverage_test)) || ((! id2i_sqlite_omit_attach) && id2i_sqlite_omit_vacuum) || (id2i_sqlite_omit_attach ))) {
    if ((sqlite3BtreeSetPageSize(pTemp, sqlite3BtreeGetPageSize(pMain), nRes, 0) || ((! isMemDb) && sqlite3BtreeSetPageSize(pTemp, db->nextPagesize, nRes, 0)) || db->mallocFailed)) {
      (rc = 7);
      goto end_of_vacuum;
    }  
  }  
  if ((((! id2i_sqlite_omit_attach) && (! id2i_sqlite_omit_vacuum) && id2i_sqlite_coverage_test) )) {
    if ((sqlite3BtreeSetPageSize(pTemp, sqlite3BtreeGetPageSize(pMain), nRes, 0) || ((! isMemDb) && sqlite3BtreeSetPageSize(pTemp, db->nextPagesize, nRes, 0)) || 0)) {
      (rc = 7);
      goto end_of_vacuum;
    }  
  }  
  if ((((! id2i_sqlite_omit_attach) && (! id2i_sqlite_omit_vacuum) && (! id2i_sqlite_omit_autovacuum)) )) {
    sqlite3BtreeSetAutoVacuum(pTemp, ((db->nextAutovac >= 0) ? db->nextAutovac : sqlite3BtreeGetAutoVacuum(pMain)));
  }  
  (rc = execExecSql(db, pzErrMsg, "SELECT 'CREATE TABLE vacuum_db.' || substr(sql,14) " "  FROM sqlite_master WHERE type='table' AND name!='sqlite_sequence'" "   AND rootpage>0"));
  if ((rc != 0)) {
    goto end_of_vacuum;
  }  
  (rc = execExecSql(db, pzErrMsg, "SELECT 'CREATE INDEX vacuum_db.' || substr(sql,14)" "  FROM sqlite_master WHERE sql LIKE 'CREATE INDEX %' "));
  if ((rc != 0)) {
    goto end_of_vacuum;
  }  
  (rc = execExecSql(db, pzErrMsg, "SELECT 'CREATE UNIQUE INDEX vacuum_db.' || substr(sql,21) " "  FROM sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %'"));
  if ((rc != 0)) {
    goto end_of_vacuum;
  }  
  (rc = execExecSql(db, pzErrMsg, "SELECT 'INSERT INTO vacuum_db.' || quote(name) " "|| ' SELECT * FROM main.' || quote(name) || ';'" "FROM main.sqlite_master " "WHERE type = 'table' AND name!='sqlite_sequence' " "  AND rootpage>0"));
  if ((rc != 0)) {
    goto end_of_vacuum;
  }  
  (rc = execExecSql(db, pzErrMsg, "SELECT 'DELETE FROM vacuum_db.' || quote(name) || ';' " "FROM vacuum_db.sqlite_master WHERE name='sqlite_sequence' "));
  if ((rc != 0)) {
    goto end_of_vacuum;
  }  
  (rc = execExecSql(db, pzErrMsg, "SELECT 'INSERT INTO vacuum_db.' || quote(name) " "|| ' SELECT * FROM main.' || quote(name) || ';' " "FROM vacuum_db.sqlite_master WHERE name=='sqlite_sequence';"));
  if ((rc != 0)) {
    goto end_of_vacuum;
  }  
  (rc = execSql(db, pzErrMsg, "INSERT INTO vacuum_db.sqlite_master " "  SELECT type, name, tbl_name, rootpage, sql" "    FROM main.sqlite_master" "   WHERE type='view' OR type='trigger'" "      OR (type='table' AND rootpage=0)"));
  if (rc) {
    goto end_of_vacuum;
  }  
  {
    u32 meta;
    int i;
    static const unsigned char aCopy[] =  { 1,  1,  3,  0,  5,  0,  6,  0,  8,  0};
    ((void ) 0);
    ((void ) 0);
    for ((i = 0); (i < ((int ) (sizeof(aCopy) / sizeof(aCopy[0])))); (i += 2)) {
      sqlite3BtreeGetMeta(pMain, aCopy[i], (&meta));
      (rc = sqlite3BtreeUpdateMeta(pTemp, aCopy[i], (meta + aCopy[(i + 1)])));
      if ((((! id2i_sqlite_omit_attach) && (! id2i_sqlite_omit_vacuum) && id2i_sqlite_coverage_test) )) {
        if (0) {
          goto end_of_vacuum;
        }  
      }  
      if ((((! id2i_sqlite_omit_attach) && (! id2i_sqlite_omit_vacuum) && (! id2i_sqlite_coverage_test)) || ((! id2i_sqlite_omit_attach) && id2i_sqlite_omit_vacuum) || (id2i_sqlite_omit_attach ))) {
        if ((rc != 0)) {
          goto end_of_vacuum;
        }  
      }  
    }
    (rc = sqlite3BtreeCopyFile(pMain, pTemp));
    if ((rc != 0)) {
      goto end_of_vacuum;
    }  
    (rc = sqlite3BtreeCommit(pTemp));
    if ((rc != 0)) {
      goto end_of_vacuum;
    }  
    if ((((! id2i_sqlite_omit_attach) && (! id2i_sqlite_omit_vacuum) && (! id2i_sqlite_omit_autovacuum)) )) {
      sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp));
    }  
  }
  ((void ) 0);
  (rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes, 1));
  end_of_vacuum:
  (db->flags = saved_flags);
  (db->nChange = saved_nChange);
  (db->nTotalChange = saved_nTotalChange);
  (db->xTrace = saved_xTrace);
  sqlite3BtreeSetPageSize(pMain, (- 1), (- 1), 1);
  (db->autoCommit = 1);
  if (pDb) {
    sqlite3BtreeClose(pDb->pBt);
    (pDb->pBt = 0);
    (pDb->pSchema = 0);
  }  
  sqlite3ResetAllSchemasOfConnection(db);
  return rc;
}
struct  VtabCtx {
  VTable *pVTable ;
  Table *pTab ;
}  ;
static  int createModule(sqlite3 *db , const  char *zName , const  sqlite3_module *pModule , void *pAux , void ( *xDestroy)(void * ) )  {
  int rc =  0;
  int nName;
  (nName = sqlite3Strlen30(zName));
  if (sqlite3HashFind((&db->aModule), zName, nName)) {
    (rc = sqlite3MisuseError(105439));
  }  
  else {
    Module *pMod;
    (pMod = ((Module *) sqlite3DbMallocRaw(db, (sizeof(Module ) + nName + 1))));
    if (pMod) {
      Module *pDel;
      char *zCopy =  ((char *) (&pMod[1]));
      memcpy(zCopy, zName, (nName + 1));
      (pMod->zName = zCopy);
      (pMod->pModule = pModule);
      (pMod->pAux = pAux);
      (pMod->xDestroy = xDestroy);
      (pDel = ((Module *) sqlite3HashInsert((&db->aModule), zCopy, nName, ((void *) pMod))));
      ((void ) 0);
      if (pDel) {
        (db->mallocFailed = 1);
        sqlite3DbFree(db, pDel);
      }  
    }  
  }
  (rc = sqlite3ApiExit(db, rc));
  if (((rc != 0) && xDestroy)) {
    xDestroy(pAux);
  }  
  return rc;
}
int sqlite3_create_module(sqlite3 *db , const  char *zName , const  sqlite3_module *pModule , void *pAux )  {
  return createModule(db, zName, pModule, pAux, 0);
}
int sqlite3_create_module_v2(sqlite3 *db , const  char *zName , const  sqlite3_module *pModule , void *pAux , void ( *xDestroy)(void * ) )  {
  return createModule(db, zName, pModule, pAux, xDestroy);
}
static  void sqlite3VtabLock(VTable *pVTab )  {
  pVTab->nRef++;
}
static  VTable *sqlite3GetVTable(sqlite3 *db , Table *pTab )  {
  VTable *pVtab;
  ((void ) 0);
  for ((pVtab = pTab->pVTable); (pVtab && (pVtab->db != db)); (pVtab = pVtab->pNext)) {
    
  }
  return pVtab;
}
static  void sqlite3VtabUnlock(VTable *pVTab )  {
  sqlite3 *db =  pVTab->db;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  pVTab->nRef--;
  if ((pVTab->nRef == 0)) {
    sqlite3_vtab *p =  pVTab->pVtab;
    if (p) {
      p->pModule->xDisconnect(p);
    }  
    sqlite3DbFree(db, pVTab);
  }  
}
static  VTable *vtabDisconnectAll(sqlite3 *db , Table *p )  {
  VTable *pRet =  0;
  VTable *pVTable =  p->pVTable;
  (p->pVTable = 0);
  ((void ) 0);
  while (pVTable) {
    sqlite3 *db2 =  pVTable->db;
    VTable *pNext =  pVTable->pNext;
    ((void ) 0);
    if ((db2 == db)) {
      (pRet = pVTable);
      (p->pVTable = pRet);
      (pRet->pNext = 0);
    }  
    else {
      (pVTable->pNext = db2->pDisconnect);
      (db2->pDisconnect = pVTable);
    }
    (pVTable = pNext);
  }
  ((void ) 0);
  return pRet;
}
static  void sqlite3VtabDisconnect(sqlite3 *db , Table *p )  {
  VTable **ppVTab;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  for ((ppVTab = (&p->pVTable)); (*ppVTab); (ppVTab = (&(*ppVTab)->pNext))) {
    if (((*ppVTab)->db == db)) {
      VTable *pVTab =  (*ppVTab);
      ((*ppVTab) = pVTab->pNext);
      sqlite3VtabUnlock(pVTab);
      break;
    }  
  }
}
static  void sqlite3VtabUnlockList(sqlite3 *db )  {
  VTable *p =  db->pDisconnect;
  (db->pDisconnect = 0);
  ((void ) 0);
  ((void ) 0);
  if (p) {
    sqlite3ExpirePreparedStatements(db);
    do {
      VTable *pNext =  p->pNext;
      sqlite3VtabUnlock(p);
      (p = pNext);
    } while (p);
  }  
}
static  void sqlite3VtabClear(sqlite3 *db , Table *p )  {
  if (((! db) || (db->pnBytesFreed == 0))) {
    vtabDisconnectAll(0, p);
  }  
  if (p->azModuleArg) {
    int i;
    for ((i = 0); (i < p->nModuleArg); i++) {
      if ((i != 1)) {
        sqlite3DbFree(db, p->azModuleArg[i]);
      }  
    }
    sqlite3DbFree(db, p->azModuleArg);
  }  
}
static  void addModuleArgument(sqlite3 *db , Table *pTable , char *zArg )  {
  int i =  pTable->nModuleArg++;
  int nBytes =  (sizeof(char *) * (1 + pTable->nModuleArg));
  char **azModuleArg;
  (azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes));
  if ((azModuleArg == 0)) {
    int j;
    for ((j = 0); (j < i); j++) {
      sqlite3DbFree(db, pTable->azModuleArg[j]);
    }
    sqlite3DbFree(db, zArg);
    sqlite3DbFree(db, pTable->azModuleArg);
    (pTable->nModuleArg = 0);
  }  
  else {
    (azModuleArg[i] = zArg);
    (azModuleArg[(i + 1)] = 0);
  }
  (pTable->azModuleArg = azModuleArg);
}
static  void sqlite3VtabBeginParse(Parse *pParse , Token *pName1 , Token *pName2 , Token *pModuleName , int ifNotExists )  {
  int iDb;
  Table *pTable;
  sqlite3 *db;
  sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, ifNotExists);
  (pTable = pParse->pNewTable);
  if ((pTable == 0)) {
    return;
  }  
  ((void ) 0);
  (db = pParse->db);
  (iDb = sqlite3SchemaToIndex(db, pTable->pSchema));
  ((void ) 0);
  (pTable->tabFlags |= 0x10);
  (pTable->nModuleArg = 0);
  addModuleArgument(db, pTable, sqlite3NameFromToken(db, pModuleName));
  addModuleArgument(db, pTable, 0);
  addModuleArgument(db, pTable, sqlite3DbStrDup(db, pTable->zName));
  (pParse->sNameToken.n = ((int ) ((&pModuleName->z[pModuleName->n]) - pName1->z)));
  if (pTable->azModuleArg) {
    sqlite3AuthCheck(pParse, 29, pTable->zName, pTable->azModuleArg[0], pParse->db->aDb[iDb].zName);
  }  
}
static  void addArgumentToVtab(Parse *pParse )  {
  if ((pParse->sArg.z && pParse->pNewTable)) {
    const char *z =  ((const  char *) pParse->sArg.z);
    int n =  pParse->sArg.n;
    sqlite3 *db =  pParse->db;
    addModuleArgument(db, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));
  }  
}
static  void sqlite3VtabFinishParse(Parse *pParse , Token *pEnd )  {
  Table *pTab =  pParse->pNewTable;
  sqlite3 *db =  pParse->db;
  if ((pTab == 0)) {
    return;
  }  
  addArgumentToVtab(pParse);
  (pParse->sArg.z = 0);
  if ((pTab->nModuleArg < 1)) {
    return;
  }  
  if ((! db->init.busy)) {
    char *zStmt;
    char *zWhere;
    int iDb;
    Vdbe *v;
    if (pEnd) {
      (pParse->sNameToken.n = (((int ) (pEnd->z - pParse->sNameToken.z)) + pEnd->n));
    }  
    (zStmt = sqlite3MPrintf(db, "CREATE VIRTUAL TABLE %T", (&pParse->sNameToken)));
    (iDb = sqlite3SchemaToIndex(db, pTab->pSchema));
    sqlite3NestedParse(pParse, "UPDATE %Q.%s " "SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q " "WHERE rowid=#%d", db->aDb[iDb].zName, (((! 0) && (iDb == 1)) ? "sqlite_temp_master" : "sqlite_master"), pTab->zName, pTab->zName, zStmt, pParse->regRowid);
    sqlite3DbFree(db, zStmt);
    (v = sqlite3GetVdbe(pParse));
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddOp2(v, 132, 0, 0);
    (zWhere = sqlite3MPrintf(db, "name='%q' AND type='table'", pTab->zName));
    sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere);
    sqlite3VdbeAddOp4(v, 135, iDb, 0, 0, pTab->zName, (sqlite3Strlen30(pTab->zName) + 1));
  }  
  else {
    Table *pOld;
    Schema *pSchema =  pTab->pSchema;
    const char *zName =  pTab->zName;
    int nName =  sqlite3Strlen30(zName);
    ((void ) 0);
    (pOld = sqlite3HashInsert((&pSchema->tblHash), zName, nName, pTab));
    if (pOld) {
      (db->mallocFailed = 1);
      ((void ) 0);
      return;
    }  
    (pParse->pNewTable = 0);
  }
}
static  void sqlite3VtabArgInit(Parse *pParse )  {
  addArgumentToVtab(pParse);
  (pParse->sArg.z = 0);
  (pParse->sArg.n = 0);
}
static  void sqlite3VtabArgExtend(Parse *pParse , Token *p )  {
  Token *pArg =  (&pParse->sArg);
  if ((pArg->z == 0)) {
    (pArg->z = p->z);
    (pArg->n = p->n);
  }  
  else {
    ((void ) 0);
    (pArg->n = ((int ) ((&p->z[p->n]) - pArg->z)));
  }
}
static  int vtabCallConstructor(sqlite3 *db , Table *pTab , Module *pMod , int ( *xConstruct)(sqlite3 * , void * , int , const  char *const * , sqlite3_vtab ** , char ** ) , char **pzErr )  {
  VtabCtx sCtx, *pPriorCtx;
  VTable *pVTable;
  int rc;
  const char *const *azArg =  ((const  char *const *) pTab->azModuleArg);
  int nArg =  pTab->nModuleArg;
  char *zErr =  0;
  char *zModuleName =  sqlite3MPrintf(db, "%s", pTab->zName);
  int iDb;
  if ((! zModuleName)) {
    return 7;
  }  
  (pVTable = sqlite3DbMallocZero(db, sizeof(VTable )));
  if ((! pVTable)) {
    sqlite3DbFree(db, zModuleName);
    return 7;
  }  
  (pVTable->db = db);
  (pVTable->pMod = pMod);
  (iDb = sqlite3SchemaToIndex(db, pTab->pSchema));
  (pTab->azModuleArg[1] = db->aDb[iDb].zName);
  ((void ) 0);
  ((void ) 0);
  (sCtx.pTab = pTab);
  (sCtx.pVTable = pVTable);
  (pPriorCtx = db->pVtabCtx);
  (db->pVtabCtx = (&sCtx));
  (rc = xConstruct(db, pMod->pAux, nArg, azArg, (&pVTable->pVtab), (&zErr)));
  (db->pVtabCtx = pPriorCtx);
  if ((rc == 7)) {
    (db->mallocFailed = 1);
  }  
  if ((0 != rc)) {
    if ((zErr == 0)) {
      ((*pzErr) = sqlite3MPrintf(db, "vtable constructor failed: %s", zModuleName));
    }  
    else {
      ((*pzErr) = sqlite3MPrintf(db, "%s", zErr));
      sqlite3_free(zErr);
    }
    sqlite3DbFree(db, pVTable);
  } 
  else if ((((id2i_sqlite_coverage_test ) ) && 1)) {
    (pVTable->pVtab->pModule = pMod->pModule);
    (pVTable->nRef = 1);
    if (sCtx.pTab) {
      const char *zFormat =  "vtable constructor did not declare schema: %s";
      ((*pzErr) = sqlite3MPrintf(db, zFormat, pTab->zName));
      sqlite3VtabUnlock(pVTable);
      (rc = 1);
    }  
    else {
      int iCol;
      (pVTable->pNext = pTab->pVTable);
      (pTab->pVTable = pVTable);
      for ((iCol = 0); (iCol < pTab->nCol); iCol++) {
        char *zType =  pTab->aCol[iCol].zType;
        int nType;
        int i =  0;
        if ((! zType)) {
          continue;
        }  
        (nType = sqlite3Strlen30(zType));
        if ((sqlite3_strnicmp("hidden", zType, 6) || (zType[6] && (zType[6] != ' ')))) {
          for ((i = 0); (i < nType); i++) {
            if (((0 == sqlite3_strnicmp(" hidden", (&zType[i]), 7)) && ((zType[(i + 7)] == '\0') || (zType[(i + 7)] == ' ')))) {
              i++;
              break;
            }  
          }
        }  
        if ((i < nType)) {
          int j;
          int nDel =  (6 + (zType[(i + 6)] ? 1 : 0));
          for ((j = i); ((j + nDel) <= nType); j++) {
            (zType[j] = zType[(j + nDel)]);
          }
          if (((zType[i] == '\0') && (i > 0))) {
            ((void ) 0);
            (zType[(i - 1)] = '\0');
          }  
          (pTab->aCol[iCol].colFlags |= 0x0002);
        }  
      }
    }
  }
  
  else if (((((! id2i_sqlite_coverage_test) ) ) && pVTable->pVtab)) {
    (pVTable->pVtab->pModule = pMod->pModule);
    (pVTable->nRef = 1);
    if (sCtx.pTab) {
      const char *zFormat =  "vtable constructor did not declare schema: %s";
      ((*pzErr) = sqlite3MPrintf(db, zFormat, pTab->zName));
      sqlite3VtabUnlock(pVTable);
      (rc = 1);
    }  
    else {
      int iCol;
      (pVTable->pNext = pTab->pVTable);
      (pTab->pVTable = pVTable);
      for ((iCol = 0); (iCol < pTab->nCol); iCol++) {
        char *zType =  pTab->aCol[iCol].zType;
        int nType;
        int i =  0;
        if ((! zType)) {
          continue;
        }  
        (nType = sqlite3Strlen30(zType));
        if ((sqlite3_strnicmp("hidden", zType, 6) || (zType[6] && (zType[6] != ' ')))) {
          for ((i = 0); (i < nType); i++) {
            if (((0 == sqlite3_strnicmp(" hidden", (&zType[i]), 7)) && ((zType[(i + 7)] == '\0') || (zType[(i + 7)] == ' ')))) {
              i++;
              break;
            }  
          }
        }  
        if ((i < nType)) {
          int j;
          int nDel =  (6 + (zType[(i + 6)] ? 1 : 0));
          for ((j = i); ((j + nDel) <= nType); j++) {
            (zType[j] = zType[(j + nDel)]);
          }
          if (((zType[i] == '\0') && (i > 0))) {
            ((void ) 0);
            (zType[(i - 1)] = '\0');
          }  
          (pTab->aCol[iCol].colFlags |= 0x0002);
        }  
      }
    }
  } 
  sqlite3DbFree(db, zModuleName);
  return rc;
}
static  int sqlite3VtabCallConnect(Parse *pParse , Table *pTab )  {
  sqlite3 *db =  pParse->db;
  const char *zMod;
  Module *pMod;
  int rc;
  ((void ) 0);
  if ((((pTab->tabFlags & 0x10) == 0) || sqlite3GetVTable(db, pTab))) {
    return 0;
  }  
  (zMod = pTab->azModuleArg[0]);
  (pMod = ((Module *) sqlite3HashFind((&db->aModule), zMod, sqlite3Strlen30(zMod))));
  if ((! pMod)) {
    const char *zModule =  pTab->azModuleArg[0];
    sqlite3ErrorMsg(pParse, "no such module: %s", zModule);
    (rc = 1);
  }  
  else {
    char *zErr =  0;
    (rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xConnect, (&zErr)));
    if ((rc != 0)) {
      sqlite3ErrorMsg(pParse, "%s", zErr);
    }  
    sqlite3DbFree(db, zErr);
  }
  return rc;
}
static  int growVTrans(sqlite3 *db )  {
  const int ARRAY_INCR =  5;
  if (((db->nVTrans % ARRAY_INCR) == 0)) {
    VTable **aVTrans;
    int nBytes =  (sizeof(sqlite3_vtab *) * (db->nVTrans + ARRAY_INCR));
    (aVTrans = sqlite3DbRealloc(db, ((void *) db->aVTrans), nBytes));
    if ((! aVTrans)) {
      return 7;
    }  
    memset((&aVTrans[db->nVTrans]), 0, (sizeof(sqlite3_vtab *) * ARRAY_INCR));
    (db->aVTrans = aVTrans);
  }  
  return 0;
}
static  void addToVTrans(sqlite3 *db , VTable *pVTab )  {
  (db->aVTrans[db->nVTrans++] = pVTab);
  sqlite3VtabLock(pVTab);
}
static  int sqlite3VtabCallCreate(sqlite3 *db , int iDb , const  char *zTab , char **pzErr )  {
  int rc =  0;
  Table *pTab;
  Module *pMod;
  const char *zMod;
  (pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName));
  ((void ) 0);
  (zMod = pTab->azModuleArg[0]);
  (pMod = ((Module *) sqlite3HashFind((&db->aModule), zMod, sqlite3Strlen30(zMod))));
  if ((! pMod)) {
    ((*pzErr) = sqlite3MPrintf(db, "no such module: %s", zMod));
    (rc = 1);
  }  
  else {
    (rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xCreate, pzErr));
  }
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((rc == 0) && sqlite3GetVTable(db, pTab))) {
      (rc = growVTrans(db));
      if ((rc == 0)) {
        addToVTrans(db, sqlite3GetVTable(db, pTab));
      }  
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((rc == 0) && 1)) {
      (rc = growVTrans(db));
      if ((rc == 0)) {
        addToVTrans(db, sqlite3GetVTable(db, pTab));
      }  
    }  
  }  
  return rc;
}
int sqlite3_declare_vtab(sqlite3 *db , const  char *zCreateTable )  {
  Parse *pParse;
  int rc =  0;
  Table *pTab;
  char *zErr =  0;
  if (((! db->pVtabCtx) || (! (pTab = db->pVtabCtx->pTab)))) {
    sqlite3Error(db, 21, 0);
    return sqlite3MisuseError(106097);
  }  
  ((void ) 0);
  (pParse = sqlite3DbMallocZero(db, sizeof((*pParse))));
  if ((pParse == 0)) {
    (rc = 7);
  }  
  else {
    (pParse->declareVtab = 1);
    (pParse->db = db);
    (pParse->nQueryLoop = 1);
    if (((0 == sqlite3RunParser(pParse, zCreateTable, (&zErr))) && pParse->pNewTable && (! db->mallocFailed) && (! pParse->pNewTable->pSelect) && ((pParse->pNewTable->tabFlags & 0x10) == 0))) {
      if ((! pTab->aCol)) {
        (pTab->aCol = pParse->pNewTable->aCol);
        (pTab->nCol = pParse->pNewTable->nCol);
        (pParse->pNewTable->nCol = 0);
        (pParse->pNewTable->aCol = 0);
      }  
      (db->pVtabCtx->pTab = 0);
    }  
    else {
      sqlite3Error(db, 1, (zErr ? "%s" : 0), zErr);
      sqlite3DbFree(db, zErr);
      (rc = 1);
    }
    (pParse->declareVtab = 0);
    if (pParse->pVdbe) {
      sqlite3VdbeFinalize(pParse->pVdbe);
    }  
    sqlite3DeleteTable(db, pParse->pNewTable);
    sqlite3DbFree(db, pParse);
  }
  ((void ) 0);
  (rc = sqlite3ApiExit(db, rc));
  return rc;
}
static  int sqlite3VtabCallDestroy(sqlite3 *db , int iDb , const  char *zTab )  {
  int rc =  0;
  Table *pTab;
  (pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName));
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      VTable *p =  vtabDisconnectAll(db, pTab);
      ((void ) 0);
      (rc = p->pMod->pModule->xDestroy(p->pVtab));
      if ((rc == 0)) {
        ((void ) 0);
        (p->pVtab = 0);
        (pTab->pVTable = 0);
        sqlite3VtabUnlock(p);
      }  
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((pTab != 0) && (pTab->pVTable != 0))) {
      VTable *p =  vtabDisconnectAll(db, pTab);
      ((void ) 0);
      (rc = p->pMod->pModule->xDestroy(p->pVtab));
      if ((rc == 0)) {
        ((void ) 0);
        (p->pVtab = 0);
        (pTab->pVTable = 0);
        sqlite3VtabUnlock(p);
      }  
    }  
  }  
  return rc;
}
static  void callFinaliser(sqlite3 *db , int offset )  {
  int i;
  if (db->aVTrans) {
    for ((i = 0); (i < db->nVTrans); i++) {
      VTable *pVTab =  db->aVTrans[i];
      sqlite3_vtab *p =  pVTab->pVtab;
      if (p) {
        int ( *x)(sqlite3_vtab * );
        (x = (*((int ( **)(sqlite3_vtab * )) (((char *) p->pModule) + offset))));
        if (x) {
          x(p);
        }  
      }  
      (pVTab->iSavepoint = 0);
      sqlite3VtabUnlock(pVTab);
    }
    sqlite3DbFree(db, db->aVTrans);
    (db->nVTrans = 0);
    (db->aVTrans = 0);
  }  
}
static  int sqlite3VtabSync(sqlite3 *db , Vdbe *p )  {
  int i;
  int rc =  0;
  VTable **aVTrans =  db->aVTrans;
  (db->aVTrans = 0);
  for ((i = 0); ((rc == 0) && (i < db->nVTrans)); i++) {
    int ( *x)(sqlite3_vtab * );
    sqlite3_vtab *pVtab =  aVTrans[i]->pVtab;
    if ((pVtab && ((x = pVtab->pModule->xSync) != 0))) {
      (rc = x(pVtab));
      sqlite3VtabImportErrmsg(p, pVtab);
    }  
  }
  (db->aVTrans = aVTrans);
  return rc;
}
static  int sqlite3VtabRollback(sqlite3 *db )  {
  callFinaliser(db, __builtin_offsetof(sqlite3_module , xRollback));
  return 0;
}
static  int sqlite3VtabCommit(sqlite3 *db )  {
  callFinaliser(db, __builtin_offsetof(sqlite3_module , xCommit));
  return 0;
}
static  int sqlite3VtabBegin(sqlite3 *db , VTable *pVTab )  {
  int rc =  0;
  const sqlite3_module *pModule;
  if (((db->nVTrans > 0) && (db->aVTrans == 0))) {
    return 6;
  }  
  if ((! pVTab)) {
    return 0;
  }  
  (pModule = pVTab->pVtab->pModule);
  if (pModule->xBegin) {
    int i;
    for ((i = 0); (i < db->nVTrans); i++) {
      if ((db->aVTrans[i] == pVTab)) {
        return 0;
      }  
    }
    (rc = growVTrans(db));
    if ((rc == 0)) {
      (rc = pModule->xBegin(pVTab->pVtab));
      if ((rc == 0)) {
        addToVTrans(db, pVTab);
      }  
    }  
  }  
  return rc;
}
static  int sqlite3VtabSavepoint(sqlite3 *db , int op , int iSavepoint )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  if (db->aVTrans) {
    int i;
    for ((i = 0); ((rc == 0) && (i < db->nVTrans)); i++) {
      VTable *pVTab =  db->aVTrans[i];
      const sqlite3_module *pMod =  pVTab->pMod->pModule;
      if ((pVTab->pVtab && (pMod->iVersion >= 2))) {
        int ( *xMethod)(sqlite3_vtab * , int );
        switch (op) {
          case 0:
          (xMethod = pMod->xSavepoint);
          (pVTab->iSavepoint = (iSavepoint + 1));
          break;
          case 2:
          (xMethod = pMod->xRollbackTo);
          break;
          id2i_label_1:
          default:
          (xMethod = pMod->xRelease);
          break;
        }
        if ((xMethod && (pVTab->iSavepoint > iSavepoint))) {
          (rc = xMethod(pVTab->pVtab, iSavepoint));
        }  
      }  
    }
  }  
  return rc;
}
static  FuncDef *sqlite3VtabOverloadFunction(sqlite3 *db , FuncDef *pDef , int nArg , Expr *pExpr )  {
  Table *pTab;
  sqlite3_vtab *pVtab;
  sqlite3_module *pMod;
  void ( *xFunc)(sqlite3_context * , int , sqlite3_value ** ) =  0;
  void *pArg =  0;
  FuncDef *pNew;
  int rc =  0;
  char *zLowerName;
  unsigned char *z;
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return pDef;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pExpr == 0)) {
      return pDef;
    }  
  }  
  if ((pExpr->op != 152)) {
    return pDef;
  }  
  (pTab = pExpr->pTab);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return pDef;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pTab == 0)) {
      return pDef;
    }  
  }  
  if (((pTab->tabFlags & 0x10) == 0)) {
    return pDef;
  }  
  (pVtab = sqlite3GetVTable(db, pTab)->pVtab);
  ((void ) 0);
  ((void ) 0);
  (pMod = ((sqlite3_module *) pVtab->pModule));
  if ((pMod->xFindFunction == 0)) {
    return pDef;
  }  
  (zLowerName = sqlite3DbStrDup(db, pDef->zName));
  if (zLowerName) {
    for ((z = ((unsigned  char *) zLowerName)); (*z); z++) {
      if ((((! id2i_sqlite_ebcdic) ) )) {
        ((*z) = _1281_sqlite3UpperToLower[(*z)]);
      }  
      if (((id2i_sqlite_ebcdic ) )) {
        ((*z) = _1282_sqlite3UpperToLower[(*z)]);
      }  
    }
    (rc = pMod->xFindFunction(pVtab, nArg, zLowerName, (&xFunc), (&pArg)));
    sqlite3DbFree(db, zLowerName);
  }  
  if ((rc == 0)) {
    return pDef;
  }  
  (pNew = sqlite3DbMallocZero(db, (sizeof((*pNew)) + sqlite3Strlen30(pDef->zName) + 1)));
  if ((pNew == 0)) {
    return pDef;
  }  
  ((*pNew) = (*pDef));
  (pNew->zName = ((char *) (&pNew[1])));
  memcpy(pNew->zName, pDef->zName, (sqlite3Strlen30(pDef->zName) + 1));
  (pNew->xFunc = xFunc);
  (pNew->pUserData = pArg);
  (pNew->funcFlags |= 0x010);
  return pNew;
}
static  void sqlite3VtabMakeWritable(Parse *pParse , Table *pTab )  {
  Parse *pToplevel =  (pParse->pToplevel ? pParse->pToplevel : pParse);
  int i, n;
  Table **apVtabLock;
  ((void ) 0);
  for ((i = 0); (i < pToplevel->nVtabLock); i++) {
    if ((pTab == pToplevel->apVtabLock[i])) {
      return;
    }  
  }
  (n = ((pToplevel->nVtabLock + 1) * sizeof(pToplevel->apVtabLock[0])));
  (apVtabLock = sqlite3_realloc(pToplevel->apVtabLock, n));
  if (apVtabLock) {
    (pToplevel->apVtabLock = apVtabLock);
    (pToplevel->apVtabLock[pToplevel->nVtabLock++] = pTab);
  }  
  else {
    (pToplevel->db->mallocFailed = 1);
  }
}
int sqlite3_vtab_on_conflict(sqlite3 *db )  {
  static const unsigned char aMap[] =  { 1,  4,  3,  2,  5};
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  return ((int ) aMap[(db->vtabOnConflict - 1)]);
}
int sqlite3_vtab_config(sqlite3 *db , int op , ...)  {
  va_list ap;
  int rc =  0;
  __builtin_va_start(ap, op);
  switch (op) {
    case 1:
    {
      VtabCtx *p =  db->pVtabCtx;
      if ((! p)) {
        (rc = sqlite3MisuseError(106470));
      }  
      else {
        ((void ) 0);
        (p->pVTable->bConstraint = ((u8 ) __builtin_va_arg(ap, int )));
      }
      break;
    }
    id2i_label_1:
    default:
    (rc = sqlite3MisuseError(106478));
    break;
  }
  __builtin_va_end(ap);
  if ((rc != 0)) {
    sqlite3Error(db, rc, 0);
  }  
  return rc;
}
typedef struct  WhereClause   WhereClause;
typedef struct  WhereMaskSet   WhereMaskSet;
typedef struct  WhereOrInfo   WhereOrInfo;
typedef struct  WhereAndInfo   WhereAndInfo;
typedef struct  WhereLevel   WhereLevel;
typedef struct  WhereLoop   WhereLoop;
typedef struct  WherePath   WherePath;
typedef struct  WhereTerm   WhereTerm;
typedef struct  WhereLoopBuilder   WhereLoopBuilder;
typedef struct  WhereScan   WhereScan;
typedef struct  WhereOrCost   WhereOrCost;
typedef struct  WhereOrSet   WhereOrSet;
struct  WhereLevel {
  int iLeftJoin ;
  int iTabCur ;
  int iIdxCur ;
  int addrBrk ;
  int addrNxt ;
  int addrCont ;
  int addrFirst ;
  int addrBody ;
  u8 iFrom ;
  u8 op , p5 ;
  int p1 , p2 ;
  union   {
    struct   {
      int nIn ;
      struct  InLoop {
        int iCur ;
        int addrInTop ;
        u8 eEndLoopOp ;
      }  *aInLoop ;
    }  in ;
    Index *pCovidx ;
  }  u ;
  struct  WhereLoop   *pWLoop ;
  Bitmask notReady ;
}  ;
struct  WhereLoop {
  Bitmask prereq ;
  Bitmask maskSelf ;
  u8 iTab ;
  u8 iSortIdx ;
  LogEst rSetup ;
  LogEst rRun ;
  LogEst nOut ;
  union   {
    struct   {
      int nEq ;
      Index *pIndex ;
    }  btree ;
    struct   {
      int idxNum ;
      u8 needFree ;
      u8 isOrdered ;
      u16 omitMask ;
      char *idxStr ;
    }  vtab ;
  }  u ;
  u32 wsFlags ;
  u16 nLTerm ;
  u16 nLSlot ;
  WhereTerm **aLTerm ;
  WhereLoop *pNextLoop ;
  WhereTerm *aLTermSpace[4] ;
}  ;
struct  WhereOrCost {
  Bitmask prereq ;
  LogEst rRun ;
  LogEst nOut ;
}  ;
struct  WhereOrSet {
  u16 n ;
  WhereOrCost a[3] ;
}  ;
static int whereLoopResize(sqlite3 * , WhereLoop * , int );
struct  WherePath {
  Bitmask maskLoop ;
  Bitmask revLoop ;
  LogEst nRow ;
  LogEst rCost ;
  u8 isOrdered ;
  u8 isOrderedValid ;
  WhereLoop **aLoop ;
}  ;
struct  WhereTerm {
  Expr *pExpr ;
  int iParent ;
  int leftCursor ;
  union   {
    int leftColumn ;
    WhereOrInfo *pOrInfo ;
    WhereAndInfo *pAndInfo ;
  }  u ;
  LogEst truthProb ;
  u16 eOperator ;
  u8 wtFlags ;
  u8 nChild ;
  WhereClause *pWC ;
  Bitmask prereqRight ;
  Bitmask prereqAll ;
}  ;
struct  WhereScan {
  WhereClause *pOrigWC ;
  WhereClause *pWC ;
  char *zCollName ;
  char idxaff ;
  unsigned  char nEquiv ;
  unsigned  char iEquiv ;
  u32 opMask ;
  int k ;
  int aEquiv[22] ;
}  ;
struct  WhereClause {
  WhereInfo *pWInfo ;
  WhereClause *pOuter ;
  u8 op ;
  int nTerm ;
  int nSlot ;
  WhereTerm *a ;
  WhereTerm _1356_aStatic[1] ;
  WhereTerm _1357_aStatic[8] ;
}  ;
struct  WhereOrInfo {
  WhereClause wc ;
  Bitmask indexable ;
}  ;
struct  WhereAndInfo {
  WhereClause wc ;
}  ;
struct  WhereMaskSet {
  int n ;
  int ix[((int ) (sizeof(Bitmask ) * 8))] ;
}  ;
struct  WhereLoopBuilder {
  WhereInfo *pWInfo ;
  WhereClause *pWC ;
  ExprList *pOrderBy ;
  WhereLoop *pNew ;
  WhereOrSet *pOrSet ;
}  ;
struct  WhereInfo {
  Parse *pParse ;
  SrcList *pTabList ;
  ExprList *pOrderBy ;
  ExprList *pResultSet ;
  WhereLoop *pLoops ;
  Bitmask revMask ;
  LogEst nRowOut ;
  u16 wctrlFlags ;
  u8 bOBSat ;
  u8 okOnePass ;
  u8 untestedTerms ;
  u8 eDistinct ;
  u8 nLevel ;
  int iTop ;
  int iContinue ;
  int iBreak ;
  int savedNQueryLoop ;
  WhereMaskSet sMaskSet ;
  WhereClause sWC ;
  WhereLevel a[1] ;
}  ;
static  u64 sqlite3WhereOutputRowCount(WhereInfo *pWInfo )  {
  return sqlite3LogEstToInt(pWInfo->nRowOut);
}
static  int sqlite3WhereIsDistinct(WhereInfo *pWInfo )  {
  return pWInfo->eDistinct;
}
static  int sqlite3WhereIsOrdered(WhereInfo *pWInfo )  {
  return (pWInfo->bOBSat != 0);
}
static  int sqlite3WhereContinueLabel(WhereInfo *pWInfo )  {
  return pWInfo->iContinue;
}
static  int sqlite3WhereBreakLabel(WhereInfo *pWInfo )  {
  return pWInfo->iBreak;
}
static  int sqlite3WhereOkOnePass(WhereInfo *pWInfo )  {
  return pWInfo->okOnePass;
}
static  void whereOrMove(WhereOrSet *pDest , WhereOrSet *pSrc )  {
  (pDest->n = pSrc->n);
  memcpy(pDest->a, pSrc->a, (pDest->n * sizeof(pDest->a[0])));
}
static  int whereOrInsert(WhereOrSet *pSet , Bitmask prereq , LogEst rRun , LogEst nOut )  {
  u16 i;
  WhereOrCost *p;
  for ((i = pSet->n), (p = pSet->a); (i > 0); i--, p++) {
    if (((rRun <= p->rRun) && ((prereq & p->prereq) == prereq))) {
      goto whereOrInsert_done;
    }  
    if (((p->rRun <= rRun) && ((p->prereq & prereq) == p->prereq))) {
      return 0;
    }  
  }
  if ((pSet->n < 3)) {
    (p = (&pSet->a[pSet->n++]));
    (p->nOut = nOut);
  }  
  else {
    (p = pSet->a);
    for ((i = 1); (i < pSet->n); i++) {
      if ((p->rRun > pSet->a[i].rRun)) {
        (p = (pSet->a + i));
      }  
    }
    if ((p->rRun <= rRun)) {
      return 0;
    }  
  }
  whereOrInsert_done:
  (p->prereq = prereq);
  (p->rRun = rRun);
  if ((p->nOut > nOut)) {
    (p->nOut = nOut);
  }  
  return 1;
}
static  void whereClauseInit(WhereClause *pWC , WhereInfo *pWInfo )  {
  (pWC->pWInfo = pWInfo);
  (pWC->pOuter = 0);
  (pWC->nTerm = 0);
  if (((id2i_sqlite_small_stack ) )) {
    (pWC->nSlot = ((int ) (sizeof(pWC->_1356_aStatic) / sizeof(pWC->_1356_aStatic[0]))));
  }  
  if ((((! id2i_sqlite_small_stack) ) )) {
    (pWC->nSlot = ((int ) (sizeof(pWC->_1357_aStatic) / sizeof(pWC->_1357_aStatic[0]))));
  }  
  if (((id2i_sqlite_small_stack ) )) {
    (pWC->a = pWC->_1356_aStatic);
  }  
  if ((((! id2i_sqlite_small_stack) ) )) {
    (pWC->a = pWC->_1357_aStatic);
  }  
}
static void whereClauseClear(WhereClause * );
static  void whereOrInfoDelete(sqlite3 *db , WhereOrInfo *p )  {
  whereClauseClear((&p->wc));
  sqlite3DbFree(db, p);
}
static  void whereAndInfoDelete(sqlite3 *db , WhereAndInfo *p )  {
  whereClauseClear((&p->wc));
  sqlite3DbFree(db, p);
}
static  void whereClauseClear(WhereClause *pWC )  {
  int i;
  WhereTerm *a;
  sqlite3 *db =  pWC->pWInfo->pParse->db;
  for ((i = (pWC->nTerm - 1)), (a = pWC->a); (i >= 0); i--, a++) {
    if ((a->wtFlags & 0x01)) {
      sqlite3ExprDelete(db, a->pExpr);
    }  
    if ((a->wtFlags & 0x10)) {
      whereOrInfoDelete(db, a->u.pOrInfo);
    } 
    else if ((a->wtFlags & 0x20)) {
      whereAndInfoDelete(db, a->u.pAndInfo);
    } 
  }
  if (((id2i_sqlite_small_stack ) )) {
    if ((pWC->a != pWC->_1356_aStatic)) {
      sqlite3DbFree(db, pWC->a);
    }  
  }  
  if ((((! id2i_sqlite_small_stack) ) )) {
    if ((pWC->a != pWC->_1357_aStatic)) {
      sqlite3DbFree(db, pWC->a);
    }  
  }  
}
static  int whereClauseInsert(WhereClause *pWC , Expr *p , u8 wtFlags )  {
  WhereTerm *pTerm;
  int idx;
  if (((id2i_sqlite_coverage_test ) )) {
    if ((wtFlags & 0x02)) {
      sqlite3Coverage(107125);
    }  
  }  
  if ((pWC->nTerm >= pWC->nSlot)) {
    WhereTerm *pOld =  pWC->a;
    sqlite3 *db =  pWC->pWInfo->pParse->db;
    (pWC->a = sqlite3DbMallocRaw(db, (sizeof(pWC->a[0]) * pWC->nSlot * 2)));
    if ((pWC->a == 0)) {
      if ((wtFlags & 0x01)) {
        sqlite3ExprDelete(db, p);
      }  
      (pWC->a = pOld);
      return 0;
    }  
    memcpy(pWC->a, pOld, (sizeof(pWC->a[0]) * pWC->nTerm));
    if (((id2i_sqlite_small_stack ) )) {
      if ((pOld != pWC->_1356_aStatic)) {
        sqlite3DbFree(db, pOld);
      }  
    }  
    if ((((! id2i_sqlite_small_stack) ) )) {
      if ((pOld != pWC->_1357_aStatic)) {
        sqlite3DbFree(db, pOld);
      }  
    }  
    (pWC->nSlot = (sqlite3DbMallocSize(db, pWC->a) / sizeof(pWC->a[0])));
  }  
  (pTerm = (&pWC->a[(idx = pWC->nTerm++)]));
  if ((p && ((p->flags & 0x040000) != 0))) {
    (pTerm->truthProb = (sqlite3LogEst(p->iTable) - 99));
  }  
  else {
    (pTerm->truthProb = (- 1));
  }
  (pTerm->pExpr = sqlite3ExprSkipCollate(p));
  (pTerm->wtFlags = wtFlags);
  (pTerm->pWC = pWC);
  (pTerm->iParent = (- 1));
  return idx;
}
static  void whereSplit(WhereClause *pWC , Expr *pExpr , u8 op )  {
  (pWC->op = op);
  if ((pExpr == 0)) {
    return;
  }  
  if ((pExpr->op != op)) {
    whereClauseInsert(pWC, pExpr, 0);
  }  
  else {
    whereSplit(pWC, pExpr->pLeft, op);
    whereSplit(pWC, pExpr->pRight, op);
  }
}
static  Bitmask getMask(WhereMaskSet *pMaskSet , int iCursor )  {
  int i;
  ((void ) 0);
  for ((i = 0); (i < pMaskSet->n); i++) {
    if ((pMaskSet->ix[i] == iCursor)) {
      return (((Bitmask ) 1) << i);
    }  
  }
  return 0;
}
static  void createMask(WhereMaskSet *pMaskSet , int iCursor )  {
  ((void ) 0);
  (pMaskSet->ix[pMaskSet->n++] = iCursor);
}
static Bitmask exprListTableUsage(WhereMaskSet * , ExprList * );
static Bitmask exprSelectTableUsage(WhereMaskSet * , Select * );
static  Bitmask exprTableUsage(WhereMaskSet *pMaskSet , Expr *p )  {
  Bitmask mask =  0;
  if ((p == 0)) {
    return 0;
  }  
  if ((p->op == 152)) {
    (mask = getMask(pMaskSet, p->iTable));
    return mask;
  }  
  (mask = exprTableUsage(pMaskSet, p->pRight));
  (mask |= exprTableUsage(pMaskSet, p->pLeft));
  if (((p->flags & 0x000800) != 0)) {
    (mask |= exprSelectTableUsage(pMaskSet, p->x.pSelect));
  }  
  else {
    (mask |= exprListTableUsage(pMaskSet, p->x.pList));
  }
  return mask;
}
static  Bitmask exprListTableUsage(WhereMaskSet *pMaskSet , ExprList *pList )  {
  int i;
  Bitmask mask =  0;
  if (pList) {
    for ((i = 0); (i < pList->nExpr); i++) {
      (mask |= exprTableUsage(pMaskSet, pList->a[i].pExpr));
    }
  }  
  return mask;
}
static  Bitmask exprSelectTableUsage(WhereMaskSet *pMaskSet , Select *pS )  {
  Bitmask mask =  0;
  while (pS) {
    SrcList *pSrc =  pS->pSrc;
    (mask |= exprListTableUsage(pMaskSet, pS->pEList));
    (mask |= exprListTableUsage(pMaskSet, pS->pGroupBy));
    (mask |= exprListTableUsage(pMaskSet, pS->pOrderBy));
    (mask |= exprTableUsage(pMaskSet, pS->pWhere));
    (mask |= exprTableUsage(pMaskSet, pS->pHaving));
    if (((id2i_sqlite_coverage_test ) )) {
      if (1) {
        int i;
        for ((i = 0); (i < pSrc->nSrc); i++) {
          (mask |= exprSelectTableUsage(pMaskSet, pSrc->a[i].pSelect));
          (mask |= exprTableUsage(pMaskSet, pSrc->a[i].pOn));
        }
      }  
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      if ((pSrc != 0)) {
        int i;
        for ((i = 0); (i < pSrc->nSrc); i++) {
          (mask |= exprSelectTableUsage(pMaskSet, pSrc->a[i].pSelect));
          (mask |= exprTableUsage(pMaskSet, pSrc->a[i].pOn));
        }
      }  
    }  
    (pS = pS->pPrior);
  }
  return mask;
}
static  int allowedOp(int op )  {
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  return ((op == 72) || ((op >= 76) && (op <= 80)) || (op == 73));
}
static  void exprCommute(Parse *pParse , Expr *pExpr )  {
  u16 expRight =  (pExpr->pRight->flags & 0x000100);
  u16 expLeft =  (pExpr->pLeft->flags & 0x000100);
  ((void ) 0);
  if ((expRight == expLeft)) {
    if (expRight) {
      (pExpr->pRight->flags &= (~ 0x000100));
    } 
    else if ((sqlite3ExprCollSeq(pParse, pExpr->pLeft) != 0)) {
      (pExpr->pLeft->flags |= 0x000100);
    } 
  }  
  {
    Expr *t =  pExpr->pRight;
    (pExpr->pRight = pExpr->pLeft);
    (pExpr->pLeft = t);
  }
  if ((pExpr->op >= 77)) {
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    (pExpr->op = (((pExpr->op - 77) ^ 2) + 77));
  }  
}
static  u16 operatorMask(int op )  {
  u16 c;
  ((void ) 0);
  if ((op == 72)) {
    (c = 0x001);
  } 
  else if ((op == 73)) {
    (c = 0x080);
  } 
  else {
    ((void ) 0);
    (c = ((u16 ) (0x002 << (op - 76))));
  }
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  return c;
}
static  WhereTerm *whereScanNext(WhereScan *pScan )  {
  int iCur;
  int iColumn;
  Expr *pX;
  WhereClause *pWC;
  WhereTerm *pTerm;
  int k =  pScan->k;
  while ((pScan->iEquiv <= pScan->nEquiv)) {
    (iCur = pScan->aEquiv[(pScan->iEquiv - 2)]);
    (iColumn = pScan->aEquiv[(pScan->iEquiv - 1)]);
    while (((pWC = pScan->pWC) != 0)) {
      for ((pTerm = (pWC->a + k)); (k < pWC->nTerm); k++, pTerm++) {
        if (((pTerm->leftCursor == iCur) && (pTerm->u.leftColumn == iColumn))) {
          if ((((pTerm->eOperator & 0x400) != 0) && (pScan->nEquiv < ((int ) (sizeof(pScan->aEquiv) / sizeof(pScan->aEquiv[0])))))) {
            int j;
            (pX = sqlite3ExprSkipCollate(pTerm->pExpr->pRight));
            ((void ) 0);
            for ((j = 0); (j < pScan->nEquiv); (j += 2)) {
              if (((pScan->aEquiv[j] == pX->iTable) && (pScan->aEquiv[(j + 1)] == pX->iColumn))) {
                break;
              }  
            }
            if ((j == pScan->nEquiv)) {
              (pScan->aEquiv[j] = pX->iTable);
              (pScan->aEquiv[(j + 1)] = pX->iColumn);
              (pScan->nEquiv += 2);
            }  
          }  
          if (((pTerm->eOperator & pScan->opMask) != 0)) {
            if ((pScan->zCollName && ((pTerm->eOperator & 0x080) == 0))) {
              CollSeq *pColl;
              Parse *pParse =  pWC->pWInfo->pParse;
              (pX = pTerm->pExpr);
              if ((! sqlite3IndexAffinityOk(pX, pScan->idxaff))) {
                continue;
              }  
              ((void ) 0);
              (pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight));
              if ((pColl == 0)) {
                (pColl = pParse->db->pDfltColl);
              }  
              if (sqlite3_stricmp(pColl->zName, pScan->zCollName)) {
                continue;
              }  
            }  
            if ((((pTerm->eOperator & 0x002) != 0) && ((pX = pTerm->pExpr->pRight)->op == 152) && (pX->iTable == pScan->aEquiv[0]) && (pX->iColumn == pScan->aEquiv[1]))) {
              continue;
            }  
            (pScan->k = (k + 1));
            return pTerm;
          }  
        }  
      }
      (pScan->pWC = pScan->pWC->pOuter);
      (k = 0);
    }
    (pScan->pWC = pScan->pOrigWC);
    (k = 0);
    (pScan->iEquiv += 2);
  }
  return 0;
}
static  WhereTerm *whereScanInit(WhereScan *pScan , WhereClause *pWC , int iCur , int iColumn , u32 opMask , Index *pIdx )  {
  int j;
  (pScan->pOrigWC = pWC);
  (pScan->pWC = pWC);
  if ((pIdx && (iColumn >= 0))) {
    (pScan->idxaff = pIdx->pTable->aCol[iColumn].affinity);
    for ((j = 0); (pIdx->aiColumn[j] != iColumn); j++) {
      if (((id2i_sqlite_coverage_test ) )) {
        if (0) {
          return 0;
        }  
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if ((j >= pIdx->nColumn)) {
          return 0;
        }  
      }  
    }
    (pScan->zCollName = pIdx->azColl[j]);
  }  
  else {
    (pScan->idxaff = 0);
    (pScan->zCollName = 0);
  }
  (pScan->opMask = opMask);
  (pScan->k = 0);
  (pScan->aEquiv[0] = iCur);
  (pScan->aEquiv[1] = iColumn);
  (pScan->nEquiv = 2);
  (pScan->iEquiv = 2);
  return whereScanNext(pScan);
}
static  WhereTerm *findTerm(WhereClause *pWC , int iCur , int iColumn , Bitmask notReady , u32 op , Index *pIdx )  {
  WhereTerm *pResult =  0;
  WhereTerm *p;
  WhereScan scan;
  (p = whereScanInit((&scan), pWC, iCur, iColumn, op, pIdx));
  while (p) {
    if (((p->prereqRight & notReady) == 0)) {
      if (((p->prereqRight == 0) && ((p->eOperator & 0x002) != 0))) {
        return p;
      }  
      if ((pResult == 0)) {
        (pResult = p);
      }  
    }  
    (p = whereScanNext((&scan)));
  }
  return pResult;
}
static void exprAnalyze(SrcList * , WhereClause * , int );
static  void exprAnalyzeAll(SrcList *pTabList , WhereClause *pWC )  {
  int i;
  for ((i = (pWC->nTerm - 1)); (i >= 0); i--) {
    exprAnalyze(pTabList, pWC, i);
  }
}
static  int isLikeOrGlob(Parse *pParse , Expr *pExpr , Expr **ppPrefix , int *pisComplete , int *pnoCase )  {
  const char *z =  0;
  Expr *pRight, *pLeft;
  ExprList *pList;
  int c;
  int cnt;
  char wc[3];
  sqlite3 *db =  pParse->db;
  sqlite3_value *pVal =  0;
  int op;
  if ((! sqlite3IsLikeFunction(db, pExpr, pnoCase, wc))) {
    return 0;
  }  
  if (((id2i_sqlite_ebcdic ) )) {
    if ((*pnoCase)) {
      return 0;
    }  
  }  
  (pList = pExpr->x.pList);
  (pLeft = pList->a[1].pExpr);
  if (((pLeft->op != 152) || (sqlite3ExprAffinity(pLeft) != 'a') || ((pLeft->pTab->tabFlags & 0x10) != 0))) {
    return 0;
  }  
  ((void ) 0);
  (pRight = pList->a[0].pExpr);
  (op = pRight->op);
  if ((op == 132)) {
    (op = pRight->op2);
  }  
  if ((op == 133)) {
    Vdbe *pReprepare =  pParse->pReprepare;
    int iCol =  pRight->iColumn;
    (pVal = sqlite3VdbeGetBoundValue(pReprepare, iCol, 'b'));
    if ((pVal && (sqlite3_value_type(pVal) == 3))) {
      (z = ((char *) sqlite3_value_text(pVal)));
    }  
    sqlite3VdbeSetVarmask(pParse->pVdbe, iCol);
    ((void ) 0);
  } 
  else if ((op == 94)) {
    (z = pRight->u.zToken);
  } 
  if (z) {
    (cnt = 0);
    while ((((c = z[cnt]) != 0) && (c != wc[0]) && (c != wc[1]) && (c != wc[2]))) {
      cnt++;
    }
    if (((cnt != 0) && (255 != ((u8 ) z[(cnt - 1)])))) {
      Expr *pPrefix;
      ((*pisComplete) = ((c == wc[0]) && (z[(cnt + 1)] == 0)));
      (pPrefix = sqlite3Expr(db, 94, z));
      if (pPrefix) {
        (pPrefix->u.zToken[cnt] = 0);
      }  
      ((*ppPrefix) = pPrefix);
      if ((op == 133)) {
        Vdbe *v =  pParse->pVdbe;
        sqlite3VdbeSetVarmask(v, pRight->iColumn);
        if (((*pisComplete) && pRight->u.zToken[1])) {
          int r1 =  sqlite3GetTempReg(pParse);
          sqlite3ExprCodeTarget(pParse, pRight, r1);
          sqlite3VdbeChangeP3(v, (sqlite3VdbeCurrentAddr(v) - 1), 0);
          sqlite3ReleaseTempReg(pParse, r1);
        }  
      }  
    }  
    else {
      (z = 0);
    }
  }  
  sqlite3ValueFree(pVal);
  return (z != 0);
}
static  int isMatchOfColumn(Expr *pExpr )  {
  ExprList *pList;
  if ((pExpr->op != 151)) {
    return 0;
  }  
  if ((sqlite3_stricmp(pExpr->u.zToken, "match") != 0)) {
    return 0;
  }  
  (pList = pExpr->x.pList);
  if ((pList->nExpr != 2)) {
    return 0;
  }  
  if ((pList->a[1].pExpr->op != 152)) {
    return 0;
  }  
  return 1;
}
static  void transferJoinMarkings(Expr *pDerived , Expr *pBase )  {
  if (pDerived) {
    (pDerived->flags |= (pBase->flags & 0x000001));
    (pDerived->iRightJoinTable = pBase->iRightJoinTable);
  }  
}
static  void exprAnalyzeOrTerm(SrcList *pSrc , WhereClause *pWC , int idxTerm )  {
  WhereInfo *pWInfo =  pWC->pWInfo;
  Parse *pParse =  pWInfo->pParse;
  sqlite3 *db =  pParse->db;
  WhereTerm *pTerm =  (&pWC->a[idxTerm]);
  Expr *pExpr =  pTerm->pExpr;
  int i;
  WhereClause *pOrWc;
  WhereTerm *pOrTerm;
  WhereOrInfo *pOrInfo;
  Bitmask chngToIN;
  Bitmask indexable;
  ((void ) 0);
  ((void ) 0);
  (pTerm->u.pOrInfo = (pOrInfo = sqlite3DbMallocZero(db, sizeof((*pOrInfo)))));
  if ((pOrInfo == 0)) {
    return;
  }  
  (pTerm->wtFlags |= 0x10);
  (pOrWc = (&pOrInfo->wc));
  whereClauseInit(pOrWc, pWInfo);
  whereSplit(pOrWc, pExpr, 68);
  exprAnalyzeAll(pSrc, pOrWc);
  if (db->mallocFailed) {
    return;
  }  
  ((void ) 0);
  (indexable = (~ ((Bitmask ) 0)));
  (chngToIN = (~ ((Bitmask ) 0)));
  for ((i = (pOrWc->nTerm - 1)), (pOrTerm = pOrWc->a); ((i >= 0) && indexable); i--, pOrTerm++) {
    if (((pOrTerm->eOperator & 0x0ff) == 0)) {
      WhereAndInfo *pAndInfo;
      ((void ) 0);
      (chngToIN = 0);
      (pAndInfo = sqlite3DbMallocRaw(db, sizeof((*pAndInfo))));
      if (pAndInfo) {
        WhereClause *pAndWC;
        WhereTerm *pAndTerm;
        int j;
        Bitmask b =  0;
        (pOrTerm->u.pAndInfo = pAndInfo);
        (pOrTerm->wtFlags |= 0x20);
        (pOrTerm->eOperator = 0x200);
        (pAndWC = (&pAndInfo->wc));
        whereClauseInit(pAndWC, pWC->pWInfo);
        whereSplit(pAndWC, pOrTerm->pExpr, 69);
        exprAnalyzeAll(pSrc, pAndWC);
        (pAndWC->pOuter = pWC);
        if (((id2i_sqlite_coverage_test ) )) {
          if (db->mallocFailed) {
            sqlite3Coverage(107816);
          }  
        }  
        if ((! db->mallocFailed)) {
          for ((j = 0), (pAndTerm = pAndWC->a); (j < pAndWC->nTerm); j++, pAndTerm++) {
            ((void ) 0);
            if (allowedOp(pAndTerm->pExpr->op)) {
              (b |= getMask((&pWInfo->sMaskSet), pAndTerm->leftCursor));
            }  
          }
        }  
        (indexable &= b);
      }  
    } 
    else if ((pOrTerm->wtFlags & 0x08)) {
      
    } 
    else {
      Bitmask b;
      (b = getMask((&pWInfo->sMaskSet), pOrTerm->leftCursor));
      if ((pOrTerm->wtFlags & 0x02)) {
        WhereTerm *pOther =  (&pOrWc->a[pOrTerm->iParent]);
        (b |= getMask((&pWInfo->sMaskSet), pOther->leftCursor));
      }  
      (indexable &= b);
      if (((pOrTerm->eOperator & 0x002) == 0)) {
        (chngToIN = 0);
      }  
      else {
        (chngToIN &= b);
      }
    }
  }
  (pOrInfo->indexable = indexable);
  (pTerm->eOperator = ((indexable == 0) ? 0 : 0x100));
  if (chngToIN) {
    int okToChngToIN =  0;
    int iColumn =  (- 1);
    int iCursor =  (- 1);
    int j =  0;
    for ((j = 0); ((j < 2) && (! okToChngToIN)); j++) {
      (pOrTerm = pOrWc->a);
      for ((i = (pOrWc->nTerm - 1)); (i >= 0); i--, pOrTerm++) {
        ((void ) 0);
        (pOrTerm->wtFlags &= (~ 0x40));
        if ((pOrTerm->leftCursor == iCursor)) {
          ((void ) 0);
          continue;
        }  
        if (((chngToIN & getMask((&pWInfo->sMaskSet), pOrTerm->leftCursor)) == 0)) {
          if (((id2i_sqlite_coverage_test ) )) {
            if ((pOrTerm->wtFlags & 0x08)) {
              sqlite3Coverage(107902);
            }  
          }  
          if (((id2i_sqlite_coverage_test ) )) {
            if ((pOrTerm->wtFlags & 0x02)) {
              sqlite3Coverage(107903);
            }  
          }  
          ((void ) 0);
          continue;
        }  
        (iColumn = pOrTerm->u.leftColumn);
        (iCursor = pOrTerm->leftCursor);
        break;
      }
      if ((i < 0)) {
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        break;
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((j == 1)) {
          sqlite3Coverage(107919);
        }  
      }  
      (okToChngToIN = 1);
      for (; ((i >= 0) && okToChngToIN); i--, pOrTerm++) {
        ((void ) 0);
        if ((pOrTerm->leftCursor != iCursor)) {
          (pOrTerm->wtFlags &= (~ 0x40));
        } 
        else if ((pOrTerm->u.leftColumn != iColumn)) {
          (okToChngToIN = 0);
        } 
        else {
          int affLeft, affRight;
          (affRight = sqlite3ExprAffinity(pOrTerm->pExpr->pRight));
          (affLeft = sqlite3ExprAffinity(pOrTerm->pExpr->pLeft));
          if (((affRight != 0) && (affRight != affLeft))) {
            (okToChngToIN = 0);
          }  
          else {
            (pOrTerm->wtFlags |= 0x40);
          }
        }
      }
    }
    if (okToChngToIN) {
      Expr *pDup;
      ExprList *pList =  0;
      Expr *pLeft =  0;
      Expr *pNew;
      for ((i = (pOrWc->nTerm - 1)), (pOrTerm = pOrWc->a); (i >= 0); i--, pOrTerm++) {
        if (((pOrTerm->wtFlags & 0x40) == 0)) {
          continue;
        }  
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        (pDup = sqlite3ExprDup(db, pOrTerm->pExpr->pRight, 0));
        (pList = sqlite3ExprListAppend(pWInfo->pParse, pList, pDup));
        (pLeft = pOrTerm->pExpr->pLeft);
      }
      ((void ) 0);
      (pDup = sqlite3ExprDup(db, pLeft, 0));
      (pNew = sqlite3PExpr(pParse, 72, pDup, 0, 0));
      if (pNew) {
        int idxNew;
        transferJoinMarkings(pNew, pExpr);
        ((void ) 0);
        (pNew->x.pList = pList);
        (idxNew = whereClauseInsert(pWC, pNew, (0x02 | 0x01)));
        if (((id2i_sqlite_coverage_test ) )) {
          if ((idxNew == 0)) {
            sqlite3Coverage(107975);
          }  
        }  
        exprAnalyze(pSrc, pWC, idxNew);
        (pTerm = (&pWC->a[idxTerm]));
        (pWC->a[idxNew].iParent = idxTerm);
        (pTerm->nChild = 1);
      }  
      else {
        sqlite3ExprListDelete(db, pList);
      }
      (pTerm->eOperator = 0x800);
    }  
  }  
}
static  void exprAnalyze(SrcList *pSrc , WhereClause *pWC , int idxTerm )  {
  WhereInfo *pWInfo =  pWC->pWInfo;
  WhereTerm *pTerm;
  WhereMaskSet *pMaskSet;
  Expr *pExpr;
  Bitmask prereqLeft;
  Bitmask prereqAll;
  Bitmask extraRight =  0;
  Expr *pStr1 =  0;
  int isComplete =  0;
  int noCase =  0;
  int op;
  Parse *pParse =  pWInfo->pParse;
  sqlite3 *db =  pParse->db;
  if (db->mallocFailed) {
    return;
  }  
  (pTerm = (&pWC->a[idxTerm]));
  (pMaskSet = (&pWInfo->sMaskSet));
  (pExpr = pTerm->pExpr);
  ((void ) 0);
  (prereqLeft = exprTableUsage(pMaskSet, pExpr->pLeft));
  (op = pExpr->op);
  if ((op == 72)) {
    ((void ) 0);
    if (((pExpr->flags & 0x000800) != 0)) {
      (pTerm->prereqRight = exprSelectTableUsage(pMaskSet, pExpr->x.pSelect));
    }  
    else {
      (pTerm->prereqRight = exprListTableUsage(pMaskSet, pExpr->x.pList));
    }
  } 
  else if ((op == 73)) {
    (pTerm->prereqRight = 0);
  } 
  else {
    (pTerm->prereqRight = exprTableUsage(pMaskSet, pExpr->pRight));
  }
  (prereqAll = exprTableUsage(pMaskSet, pExpr));
  if (((pExpr->flags & 0x000001) != 0)) {
    Bitmask x =  getMask(pMaskSet, pExpr->iRightJoinTable);
    (prereqAll |= x);
    (extraRight = (x - 1));
  }  
  (pTerm->prereqAll = prereqAll);
  (pTerm->leftCursor = (- 1));
  (pTerm->iParent = (- 1));
  (pTerm->eOperator = 0);
  if (allowedOp(op)) {
    Expr *pLeft =  sqlite3ExprSkipCollate(pExpr->pLeft);
    Expr *pRight =  sqlite3ExprSkipCollate(pExpr->pRight);
    u16 opMask =  (((pTerm->prereqRight & prereqLeft) == 0) ? 0xfff : 0x400);
    if ((pLeft->op == 152)) {
      (pTerm->leftCursor = pLeft->iTable);
      (pTerm->u.leftColumn = pLeft->iColumn);
      (pTerm->eOperator = (operatorMask(op) & opMask));
    }  
    if ((pRight && (pRight->op == 152))) {
      WhereTerm *pNew;
      Expr *pDup;
      u16 eExtraOp =  0;
      if ((pTerm->leftCursor >= 0)) {
        int idxNew;
        (pDup = sqlite3ExprDup(db, pExpr, 0));
        if (db->mallocFailed) {
          sqlite3ExprDelete(db, pDup);
          return;
        }  
        (idxNew = whereClauseInsert(pWC, pDup, (0x02 | 0x01)));
        if ((idxNew == 0)) {
          return;
        }  
        (pNew = (&pWC->a[idxNew]));
        (pNew->iParent = idxTerm);
        (pTerm = (&pWC->a[idxTerm]));
        (pTerm->nChild = 1);
        (pTerm->wtFlags |= 0x08);
        if (((id2i_sqlite_omit_builtin_test ) )) {
          if (((pExpr->op == 76) && (! ((pExpr->flags & 0x000001) != 0)) && 1)) {
            (pTerm->eOperator |= 0x400);
            (eExtraOp = 0x400);
          }  
        }  
        if ((((! id2i_sqlite_omit_builtin_test) ) )) {
          if (((pExpr->op == 76) && (! ((pExpr->flags & 0x000001) != 0)) && ((db->dbOptFlags & 0x0200) == 0))) {
            (pTerm->eOperator |= 0x400);
            (eExtraOp = 0x400);
          }  
        }  
      }  
      else {
        (pDup = pExpr);
        (pNew = pTerm);
      }
      exprCommute(pParse, pDup);
      (pLeft = sqlite3ExprSkipCollate(pDup->pLeft));
      (pNew->leftCursor = pLeft->iTable);
      (pNew->u.leftColumn = pLeft->iColumn);
      if (((id2i_sqlite_coverage_test ) )) {
        if (((prereqLeft | extraRight) != prereqLeft)) {
          sqlite3Coverage(108100);
        }  
      }  
      (pNew->prereqRight = (prereqLeft | extraRight));
      (pNew->prereqAll = prereqAll);
      (pNew->eOperator = ((operatorMask(pDup->op) + eExtraOp) & opMask));
    }  
  } 
  else if (((pExpr->op == 71) && (pWC->op == 69))) {
    ExprList *pList =  pExpr->x.pList;
    int i;
    static const u8 ops[] =  { 80,  78};
    ((void ) 0);
    ((void ) 0);
    for ((i = 0); (i < 2); i++) {
      Expr *pNewExpr;
      int idxNew;
      (pNewExpr = sqlite3PExpr(pParse, ops[i], sqlite3ExprDup(db, pExpr->pLeft, 0), sqlite3ExprDup(db, pList->a[i].pExpr, 0), 0));
      transferJoinMarkings(pNewExpr, pExpr);
      (idxNew = whereClauseInsert(pWC, pNewExpr, (0x02 | 0x01)));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((idxNew == 0)) {
          sqlite3Coverage(108137);
        }  
      }  
      exprAnalyze(pSrc, pWC, idxNew);
      (pTerm = (&pWC->a[idxTerm]));
      (pWC->a[idxNew].iParent = idxTerm);
    }
    (pTerm->nChild = 2);
  }
  
  else if (((((! id2i_sqlite_omit_subquery) && (! id2i_sqlite_omit_or_optimization)) ) && (pExpr->op == 68))) {
    ((void ) 0);
    exprAnalyzeOrTerm(pSrc, pWC, idxTerm);
    (pTerm = (&pWC->a[idxTerm]));
  } 
  if (((pWC->op == 69) && isLikeOrGlob(pParse, pExpr, (&pStr1), (&isComplete), (&noCase)))) {
    Expr *pLeft;
    Expr *pStr2;
    Expr *pNewExpr1;
    Expr *pNewExpr2;
    int idxNew1;
    int idxNew2;
    Token sCollSeqName;
    (pLeft = pExpr->x.pList->a[1].pExpr);
    (pStr2 = sqlite3ExprDup(db, pStr1, 0));
    if ((! db->mallocFailed)) {
      u8 c, *pC;
      (pC = ((u8 *) (&pStr2->u.zToken[(sqlite3Strlen30(pStr2->u.zToken) - 1)])));
      (c = (*pC));
      if (noCase) {
        if ((c == ('A' - 1))) {
          (isComplete = 0);
        }  
        if ((((! id2i_sqlite_ebcdic) ) )) {
          (c = _1281_sqlite3UpperToLower[c]);
        }  
        if (((id2i_sqlite_ebcdic ) )) {
          (c = _1282_sqlite3UpperToLower[c]);
        }  
      }  
      ((*pC) = (c + 1));
    }  
    (sCollSeqName.z = (noCase ? "NOCASE" : "BINARY"));
    (sCollSeqName.n = 6);
    (pNewExpr1 = sqlite3ExprDup(db, pLeft, 0));
    (pNewExpr1 = sqlite3PExpr(pParse, 80, sqlite3ExprAddCollateToken(pParse, pNewExpr1, (&sCollSeqName)), pStr1, 0));
    transferJoinMarkings(pNewExpr1, pExpr);
    (idxNew1 = whereClauseInsert(pWC, pNewExpr1, (0x02 | 0x01)));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((idxNew1 == 0)) {
        sqlite3Coverage(108205);
      }  
    }  
    exprAnalyze(pSrc, pWC, idxNew1);
    (pNewExpr2 = sqlite3ExprDup(db, pLeft, 0));
    (pNewExpr2 = sqlite3PExpr(pParse, 79, sqlite3ExprAddCollateToken(pParse, pNewExpr2, (&sCollSeqName)), pStr2, 0));
    transferJoinMarkings(pNewExpr2, pExpr);
    (idxNew2 = whereClauseInsert(pWC, pNewExpr2, (0x02 | 0x01)));
    if (((id2i_sqlite_coverage_test ) )) {
      if ((idxNew2 == 0)) {
        sqlite3Coverage(108213);
      }  
    }  
    exprAnalyze(pSrc, pWC, idxNew2);
    (pTerm = (&pWC->a[idxTerm]));
    if (isComplete) {
      (pWC->a[idxNew1].iParent = idxTerm);
      (pWC->a[idxNew2].iParent = idxTerm);
      (pTerm->nChild = 2);
    }  
  }  
  if (isMatchOfColumn(pExpr)) {
    int idxNew;
    Expr *pRight, *pLeft;
    WhereTerm *pNewTerm;
    Bitmask prereqColumn, prereqExpr;
    (pRight = pExpr->x.pList->a[0].pExpr);
    (pLeft = pExpr->x.pList->a[1].pExpr);
    (prereqExpr = exprTableUsage(pMaskSet, pRight));
    (prereqColumn = exprTableUsage(pMaskSet, pLeft));
    if (((prereqExpr & prereqColumn) == 0)) {
      Expr *pNewExpr;
      (pNewExpr = sqlite3PExpr(pParse, 50, 0, sqlite3ExprDup(db, pRight, 0), 0));
      (idxNew = whereClauseInsert(pWC, pNewExpr, (0x02 | 0x01)));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((idxNew == 0)) {
          sqlite3Coverage(108246);
        }  
      }  
      (pNewTerm = (&pWC->a[idxNew]));
      (pNewTerm->prereqRight = prereqExpr);
      (pNewTerm->leftCursor = pLeft->iTable);
      (pNewTerm->u.leftColumn = pLeft->iColumn);
      (pNewTerm->eOperator = 0x040);
      (pNewTerm->iParent = idxTerm);
      (pTerm = (&pWC->a[idxTerm]));
      (pTerm->nChild = 1);
      (pTerm->wtFlags |= 0x08);
      (pNewTerm->prereqAll = pTerm->prereqAll);
    }  
  }  
  (pTerm->prereqRight |= extraRight);
}
static  int findIndexCol(Parse *pParse , ExprList *pList , int iBase , Index *pIdx , int iCol )  {
  int i;
  const char *zColl =  pIdx->azColl[iCol];
  for ((i = 0); (i < pList->nExpr); i++) {
    Expr *p =  sqlite3ExprSkipCollate(pList->a[i].pExpr);
    if (((p->op == 152) && (p->iColumn == pIdx->aiColumn[iCol]) && (p->iTable == iBase))) {
      CollSeq *pColl =  sqlite3ExprCollSeq(pParse, pList->a[i].pExpr);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((1 && (0 == sqlite3_stricmp(pColl->zName, zColl)))) {
          return i;
        }  
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if ((pColl && (0 == sqlite3_stricmp(pColl->zName, zColl)))) {
          return i;
        }  
      }  
    }  
  }
  return (- 1);
}
static  int isDistinctRedundant(Parse *pParse , SrcList *pTabList , WhereClause *pWC , ExprList *pDistinct )  {
  Table *pTab;
  Index *pIdx;
  int i;
  int iBase;
  if ((pTabList->nSrc != 1)) {
    return 0;
  }  
  (iBase = pTabList->a[0].iCursor);
  (pTab = pTabList->a[0].pTab);
  for ((i = 0); (i < pDistinct->nExpr); i++) {
    Expr *p =  sqlite3ExprSkipCollate(pDistinct->a[i].pExpr);
    if (((p->op == 152) && (p->iTable == iBase) && (p->iColumn < 0))) {
      return 1;
    }  
  }
  for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
    if ((pIdx->onError == 0)) {
      continue;
    }  
    for ((i = 0); (i < pIdx->nColumn); i++) {
      int iCol =  pIdx->aiColumn[i];
      if ((0 == findTerm(pWC, iBase, iCol, (~ ((Bitmask ) 0)), 0x002, pIdx))) {
        int iIdxCol =  findIndexCol(pParse, pDistinct, iBase, pIdx, i);
        if (((iIdxCol < 0) || (pTab->aCol[pIdx->aiColumn[i]].notNull == 0))) {
          break;
        }  
      }  
    }
    if ((i == pIdx->nColumn)) {
      return 1;
    }  
  }
  return 0;
}
static  LogEst estLog(LogEst N )  {
  LogEst x =  sqlite3LogEst(N);
  return ((x > 33) ? (x - 33) : 0);
}
static  int termCanDriveIndex(WhereTerm *pTerm , struct  SrcList_item   *pSrc , Bitmask notReady )  {
  char aff;
  if ((pTerm->leftCursor != pSrc->iCursor)) {
    return 0;
  }  
  if (((pTerm->eOperator & 0x002) == 0)) {
    return 0;
  }  
  if (((pTerm->prereqRight & notReady) != 0)) {
    return 0;
  }  
  if ((pTerm->u.leftColumn < 0)) {
    return 0;
  }  
  (aff = pSrc->pTab->aCol[pTerm->u.leftColumn].affinity);
  if ((! sqlite3IndexAffinityOk(pTerm->pExpr, aff))) {
    return 0;
  }  
  return 1;
}
static  void constructAutomaticIndex(Parse *pParse , WhereClause *pWC , struct  SrcList_item   *pSrc , Bitmask notReady , WhereLevel *pLevel )  {
  int nColumn;
  WhereTerm *pTerm;
  WhereTerm *pWCEnd;
  int nByte;
  Index *pIdx;
  Vdbe *v;
  int addrInit;
  Table *pTable;
  KeyInfo *pKeyinfo;
  int addrTop;
  int regRecord;
  int n;
  int i;
  int mxBitCol;
  CollSeq *pColl;
  WhereLoop *pLoop;
  Bitmask idxCols;
  Bitmask extraCols;
  u8 sentWarning =  0;
  (v = pParse->pVdbe);
  ((void ) 0);
  (addrInit = sqlite3CodeOnce(pParse));
  (nColumn = 0);
  (pTable = pSrc->pTab);
  (pWCEnd = (&pWC->a[pWC->nTerm]));
  (pLoop = pLevel->pWLoop);
  (idxCols = 0);
  for ((pTerm = pWC->a); (pTerm < pWCEnd); pTerm++) {
    if (termCanDriveIndex(pTerm, pSrc, notReady)) {
      int iCol =  pTerm->u.leftColumn;
      Bitmask cMask =  ((iCol >= ((int ) (sizeof(Bitmask ) * 8))) ? (((Bitmask ) 1) << (((int ) (sizeof(Bitmask ) * 8)) - 1)) : (((Bitmask ) 1) << iCol));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((iCol == ((int ) (sizeof(Bitmask ) * 8)))) {
          sqlite3Coverage(108535);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((iCol == (((int ) (sizeof(Bitmask ) * 8)) - 1))) {
          sqlite3Coverage(108536);
        }  
      }  
      if ((! sentWarning)) {
        sqlite3_log((28 | (1 << 8)), "automatic index on %s(%s)", pTable->zName, pTable->aCol[iCol].zName);
        (sentWarning = 1);
      }  
      if (((idxCols & cMask) == 0)) {
        if (whereLoopResize(pParse->db, pLoop, (nColumn + 1))) {
          return;
        }  
        (pLoop->aLTerm[nColumn++] = pTerm);
        (idxCols |= cMask);
      }  
    }  
  }
  ((void ) 0);
  (pLoop->u.btree.nEq = (pLoop->nLTerm = nColumn));
  (pLoop->wsFlags = (0x00000001 | 0x00000040 | 0x00000200 | 0x00004000));
  (extraCols = (pSrc->colUsed & ((~ idxCols) | (((Bitmask ) 1) << (((int ) (sizeof(Bitmask ) * 8)) - 1)))));
  (mxBitCol = ((pTable->nCol >= (((int ) (sizeof(Bitmask ) * 8)) - 1)) ? (((int ) (sizeof(Bitmask ) * 8)) - 1) : pTable->nCol));
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pTable->nCol == (((int ) (sizeof(Bitmask ) * 8)) - 1))) {
      sqlite3Coverage(108565);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pTable->nCol == (((int ) (sizeof(Bitmask ) * 8)) - 2))) {
      sqlite3Coverage(108566);
    }  
  }  
  for ((i = 0); (i < mxBitCol); i++) {
    if ((extraCols & (((Bitmask ) 1) << i))) {
      nColumn++;
    }  
  }
  if ((pSrc->colUsed & (((Bitmask ) 1) << (((int ) (sizeof(Bitmask ) * 8)) - 1)))) {
    (nColumn += (pTable->nCol - ((int ) (sizeof(Bitmask ) * 8)) + 1));
  }  
  (pLoop->wsFlags |= (0x00000001 | 0x00000040));
  (nByte = sizeof(Index ));
  (nByte += (nColumn * sizeof(int )));
  (nByte += (nColumn * sizeof(char *)));
  (nByte += nColumn);
  (pIdx = sqlite3DbMallocZero(pParse->db, nByte));
  if ((pIdx == 0)) {
    return;
  }  
  (pLoop->u.btree.pIndex = pIdx);
  (pIdx->azColl = ((char **) (&pIdx[1])));
  (pIdx->aiColumn = ((int *) (&pIdx->azColl[nColumn])));
  (pIdx->aSortOrder = ((u8 *) (&pIdx->aiColumn[nColumn])));
  (pIdx->zName = "auto-index");
  (pIdx->nColumn = nColumn);
  (pIdx->pTable = pTable);
  (n = 0);
  (idxCols = 0);
  for ((pTerm = pWC->a); (pTerm < pWCEnd); pTerm++) {
    if (termCanDriveIndex(pTerm, pSrc, notReady)) {
      int iCol =  pTerm->u.leftColumn;
      Bitmask cMask =  ((iCol >= ((int ) (sizeof(Bitmask ) * 8))) ? (((Bitmask ) 1) << (((int ) (sizeof(Bitmask ) * 8)) - 1)) : (((Bitmask ) 1) << iCol));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((iCol == (((int ) (sizeof(Bitmask ) * 8)) - 1))) {
          sqlite3Coverage(108595);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((iCol == ((int ) (sizeof(Bitmask ) * 8)))) {
          sqlite3Coverage(108596);
        }  
      }  
      if (((idxCols & cMask) == 0)) {
        Expr *pX =  pTerm->pExpr;
        (idxCols |= cMask);
        (pIdx->aiColumn[n] = pTerm->u.leftColumn);
        (pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight));
        if (((id2i_sqlite_coverage_test ) )) {
          (pIdx->azColl[n] = (1 ? pColl->zName : "BINARY"));
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          (pIdx->azColl[n] = (pColl ? pColl->zName : "BINARY"));
        }  
        n++;
      }  
    }  
  }
  ((void ) 0);
  for ((i = 0); (i < mxBitCol); i++) {
    if ((extraCols & (((Bitmask ) 1) << i))) {
      (pIdx->aiColumn[n] = i);
      (pIdx->azColl[n] = "BINARY");
      n++;
    }  
  }
  if ((pSrc->colUsed & (((Bitmask ) 1) << (((int ) (sizeof(Bitmask ) * 8)) - 1)))) {
    for ((i = (((int ) (sizeof(Bitmask ) * 8)) - 1)); (i < pTable->nCol); i++) {
      (pIdx->aiColumn[n] = i);
      (pIdx->azColl[n] = "BINARY");
      n++;
    }
  }  
  ((void ) 0);
  (pKeyinfo = sqlite3IndexKeyinfo(pParse, pIdx));
  ((void ) 0);
  (pLevel->iIdxCur = pParse->nTab++);
  sqlite3VdbeAddOp4(v, 50, pLevel->iIdxCur, (nColumn + 1), 0, ((char *) pKeyinfo), (- 16));
  (addrTop = sqlite3VdbeAddOp1(v, 101, pLevel->iTabCur));
  (regRecord = sqlite3GetTempReg(pParse));
  sqlite3GenerateIndexKey(pParse, pIdx, pLevel->iTabCur, regRecord, 1, 0);
  sqlite3VdbeAddOp2(v, 103, pLevel->iIdxCur, regRecord);
  sqlite3VdbeChangeP5(v, 0x10);
  sqlite3VdbeAddOp2(v, 7, pLevel->iTabCur, (addrTop + 1));
  sqlite3VdbeChangeP5(v, 3);
  sqlite3VdbeJumpHere(v, addrTop);
  sqlite3ReleaseTempReg(pParse, regRecord);
  sqlite3VdbeJumpHere(v, addrInit);
}
static  sqlite3_index_info *allocateIndexInfo(Parse *pParse , WhereClause *pWC , struct  SrcList_item   *pSrc , ExprList *pOrderBy )  {
  int i, j;
  int nTerm;
  struct  sqlite3_index_constraint   *pIdxCons;
  struct  sqlite3_index_orderby   *pIdxOrderBy;
  struct  sqlite3_index_constraint_usage   *pUsage;
  WhereTerm *pTerm;
  int nOrderBy;
  sqlite3_index_info *pIdxInfo;
  for ((i = (nTerm = 0)), (pTerm = pWC->a); (i < pWC->nTerm); i++, pTerm++) {
    if ((pTerm->leftCursor != pSrc->iCursor)) {
      continue;
    }  
    ((void ) 0);
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pTerm->eOperator & 0x001)) {
        sqlite3Coverage(108677);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pTerm->eOperator & 0x080)) {
        sqlite3Coverage(108678);
      }  
    }  
    if ((pTerm->eOperator & 0x080)) {
      continue;
    }  
    if ((pTerm->wtFlags & 0x00)) {
      continue;
    }  
    nTerm++;
  }
  (nOrderBy = 0);
  if (pOrderBy) {
    int n =  pOrderBy->nExpr;
    for ((i = 0); (i < n); i++) {
      Expr *pExpr =  pOrderBy->a[i].pExpr;
      if (((pExpr->op != 152) || (pExpr->iTable != pSrc->iCursor))) {
        break;
      }  
    }
    if ((i == n)) {
      (nOrderBy = n);
    }  
  }  
  (pIdxInfo = sqlite3DbMallocZero(pParse->db, (sizeof((*pIdxInfo)) + ((sizeof((*pIdxCons)) + sizeof((*pUsage))) * nTerm) + (sizeof((*pIdxOrderBy)) * nOrderBy))));
  if ((pIdxInfo == 0)) {
    sqlite3ErrorMsg(pParse, "out of memory");
    return 0;
  }  
  (pIdxCons = ((struct  sqlite3_index_constraint   *) (&pIdxInfo[1])));
  (pIdxOrderBy = ((struct  sqlite3_index_orderby   *) (&pIdxCons[nTerm])));
  (pUsage = ((struct  sqlite3_index_constraint_usage   *) (&pIdxOrderBy[nOrderBy])));
  ((*((int *) (&pIdxInfo->nConstraint))) = nTerm);
  ((*((int *) (&pIdxInfo->nOrderBy))) = nOrderBy);
  ((*((struct  sqlite3_index_constraint   **) (&pIdxInfo->aConstraint))) = pIdxCons);
  ((*((struct  sqlite3_index_orderby   **) (&pIdxInfo->aOrderBy))) = pIdxOrderBy);
  ((*((struct  sqlite3_index_constraint_usage   **) (&pIdxInfo->aConstraintUsage))) = pUsage);
  for ((i = (j = 0)), (pTerm = pWC->a); (i < pWC->nTerm); i++, pTerm++) {
    u8 op;
    if ((pTerm->leftCursor != pSrc->iCursor)) {
      continue;
    }  
    ((void ) 0);
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pTerm->eOperator & 0x001)) {
        sqlite3Coverage(108729);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pTerm->eOperator & 0x080)) {
        sqlite3Coverage(108730);
      }  
    }  
    if ((pTerm->eOperator & 0x080)) {
      continue;
    }  
    if ((pTerm->wtFlags & 0x00)) {
      continue;
    }  
    (pIdxCons[j].iColumn = pTerm->u.leftColumn);
    (pIdxCons[j].iTermOffset = i);
    (op = (((u8 ) pTerm->eOperator) & 0xfff));
    if ((op == 0x001)) {
      (op = 0x002);
    }  
    (pIdxCons[j].op = op);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    ((void ) 0);
    j++;
  }
  for ((i = 0); (i < nOrderBy); i++) {
    Expr *pExpr =  pOrderBy->a[i].pExpr;
    (pIdxOrderBy[i].iColumn = pExpr->iColumn);
    (pIdxOrderBy[i].desc = pOrderBy->a[i].sortOrder);
  }
  return pIdxInfo;
}
static  int vtabBestIndex(Parse *pParse , Table *pTab , sqlite3_index_info *p )  {
  sqlite3_vtab *pVtab =  sqlite3GetVTable(pParse->db, pTab)->pVtab;
  int i;
  int rc;
  (rc = pVtab->pModule->xBestIndex(pVtab, p));
  if ((rc != 0)) {
    if ((rc == 7)) {
      (pParse->db->mallocFailed = 1);
    } 
    else if ((! pVtab->zErrMsg)) {
      sqlite3ErrorMsg(pParse, "%s", sqlite3ErrStr(rc));
    } 
    else {
      sqlite3ErrorMsg(pParse, "%s", pVtab->zErrMsg);
    }
  }  
  sqlite3_free(pVtab->zErrMsg);
  (pVtab->zErrMsg = 0);
  for ((i = 0); (i < p->nConstraint); i++) {
    if (((! p->aConstraint[i].usable) && (p->aConstraintUsage[i].argvIndex > 0))) {
      sqlite3ErrorMsg(pParse, "table %s: xBestIndex returned an invalid plan", pTab->zName);
    }  
  }
  return pParse->nErr;
}
static  int whereRangeScanEst(Parse *pParse , WhereLoopBuilder *pBuilder , WhereTerm *pLower , WhereTerm *pUpper , WhereLoop *pLoop )  {
  int rc =  0;
  int nOut =  pLoop->nOut;
  LogEst nNew;
  ((void ) pParse);
  ((void ) pBuilder);
  ((void ) 0);
  (nNew = nOut);
  if ((pLower && ((pLower->wtFlags & 0x00) == 0))) {
    (nNew -= 20);
    ((void ) 0);
    nOut--;
  }  
  if (pUpper) {
    (nNew -= 20);
    ((void ) 0);
    nOut--;
  }  
  if ((nNew < 10)) {
    (nNew = 10);
  }  
  if ((nNew < nOut)) {
    (nOut = nNew);
  }  
  (pLoop->nOut = ((LogEst ) nOut));
  return rc;
}
static  void disableTerm(WhereLevel *pLevel , WhereTerm *pTerm )  {
  if ((pTerm && ((pTerm->wtFlags & 0x04) == 0) && ((pLevel->iLeftJoin == 0) || ((pTerm->pExpr->flags & 0x000001) != 0)) && ((pLevel->notReady & pTerm->prereqAll) == 0))) {
    (pTerm->wtFlags |= 0x04);
    if ((pTerm->iParent >= 0)) {
      WhereTerm *pOther =  (&pTerm->pWC->a[pTerm->iParent]);
      if ((--pOther->nChild == 0)) {
        disableTerm(pLevel, pOther);
      }  
    }  
  }  
}
static  void codeApplyAffinity(Parse *pParse , int base , int n , char *zAff )  {
  Vdbe *v =  pParse->pVdbe;
  if ((zAff == 0)) {
    ((void ) 0);
    return;
  }  
  ((void ) 0);
  while (((n > 0) && (zAff[0] == 'b'))) {
    n--;
    base++;
    zAff++;
  }
  while (((n > 1) && (zAff[(n - 1)] == 'b'))) {
    n--;
  }
  if ((n > 0)) {
    sqlite3VdbeAddOp2(v, 42, base, n);
    sqlite3VdbeChangeP4(v, (- 1), zAff, n);
    sqlite3ExprCacheAffinityChange(pParse, base, n);
  }  
}
static  int codeEqualityTerm(Parse *pParse , WhereTerm *pTerm , WhereLevel *pLevel , int iEq , int bRev , int iTarget )  {
  Expr *pX =  pTerm->pExpr;
  Vdbe *v =  pParse->pVdbe;
  int iReg;
  ((void ) 0);
  if ((((! id2i_sqlite_omit_subquery) ) )) {
    if ((pX->op == 76)) {
      (iReg = sqlite3ExprCodeTarget(pParse, pX->pRight, iTarget));
    } 
    else if ((pX->op == 73)) {
      (iReg = iTarget);
      sqlite3VdbeAddOp2(v, 24, 0, iReg);
    } 
    else {
      int eType;
      int iTab;
      struct  InLoop   *pIn;
      WhereLoop *pLoop =  pLevel->pWLoop;
      if ((((pLoop->wsFlags & 0x00000400) == 0) && (pLoop->u.btree.pIndex != 0) && pLoop->u.btree.pIndex->aSortOrder[iEq])) {
        if (((id2i_sqlite_coverage_test ) )) {
          if ((iEq == 0)) {
            sqlite3Coverage(109303);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if (bRev) {
            sqlite3Coverage(109304);
          }  
        }  
        (bRev = (! bRev));
      }  
      ((void ) 0);
      (iReg = iTarget);
      (eType = sqlite3FindInIndex(pParse, pX, 0));
      if ((eType == 4)) {
        if (((id2i_sqlite_coverage_test ) )) {
          if (bRev) {
            sqlite3Coverage(109311);
          }  
        }  
        (bRev = (! bRev));
      }  
      (iTab = pX->iTable);
      sqlite3VdbeAddOp2(v, (bRev ? 98 : 101), iTab, 0);
      ((void ) 0);
      (pLoop->wsFlags |= 0x00000800);
      if ((pLevel->u.in.nIn == 0)) {
        (pLevel->addrNxt = sqlite3VdbeMakeLabel(v));
      }  
      pLevel->u.in.nIn++;
      (pLevel->u.in.aInLoop = sqlite3DbReallocOrFree(pParse->db, pLevel->u.in.aInLoop, (sizeof(pLevel->u.in.aInLoop[0]) * pLevel->u.in.nIn)));
      (pIn = pLevel->u.in.aInLoop);
      if (pIn) {
        (pIn += (pLevel->u.in.nIn - 1));
        (pIn->iCur = iTab);
        if ((eType == 1)) {
          (pIn->addrInTop = sqlite3VdbeAddOp2(v, 96, iTab, iReg));
        }  
        else {
          (pIn->addrInTop = sqlite3VdbeAddOp3(v, 41, iTab, 0, iReg));
        }
        (pIn->eEndLoopOp = (bRev ? 6 : 7));
        sqlite3VdbeAddOp1(v, 73, iReg);
      }  
      else {
        (pLevel->u.in.nIn = 0);
      }
    }
  }  
  if (((id2i_sqlite_omit_subquery ) )) {
    if ((pX->op == 76)) {
      (iReg = sqlite3ExprCodeTarget(pParse, pX->pRight, iTarget));
    } 
    else if ((pX->op == 73)) {
      (iReg = iTarget);
      sqlite3VdbeAddOp2(v, 24, 0, iReg);
    } 
  }  
  disableTerm(pLevel, pTerm);
  return iReg;
}
static  int codeAllEqualityTerms(Parse *pParse , WhereLevel *pLevel , int bRev , int nExtraReg , char **pzAff )  {
  int nEq;
  Vdbe *v =  pParse->pVdbe;
  Index *pIdx;
  WhereTerm *pTerm;
  WhereLoop *pLoop;
  int j;
  int regBase;
  int nReg;
  char *zAff;
  (pLoop = pLevel->pWLoop);
  ((void ) 0);
  (nEq = pLoop->u.btree.nEq);
  (pIdx = pLoop->u.btree.pIndex);
  ((void ) 0);
  (regBase = (pParse->nMem + 1));
  (nReg = (pLoop->u.btree.nEq + nExtraReg));
  (pParse->nMem += nReg);
  (zAff = sqlite3DbStrDup(pParse->db, sqlite3IndexAffinityStr(v, pIdx)));
  if ((! zAff)) {
    (pParse->db->mallocFailed = 1);
  }  
  ((void ) 0);
  for ((j = 0); (j < nEq); j++) {
    int r1;
    (pTerm = pLoop->aLTerm[j]);
    ((void ) 0);
    if (((id2i_sqlite_coverage_test ) )) {
      if (((pTerm->wtFlags & 0x04) != 0)) {
        sqlite3Coverage(109428);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pTerm->wtFlags & 0x02)) {
        sqlite3Coverage(109429);
      }  
    }  
    (r1 = codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, (regBase + j)));
    if ((r1 != (regBase + j))) {
      if ((nReg == 1)) {
        sqlite3ReleaseTempReg(pParse, regBase);
        (regBase = r1);
      }  
      else {
        sqlite3VdbeAddOp2(v, 29, r1, (regBase + j));
      }
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pTerm->eOperator & 0x080)) {
        sqlite3Coverage(109439);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pTerm->eOperator & 0x001)) {
        sqlite3Coverage(109440);
      }  
    }  
    if (((pTerm->eOperator & (0x080 | 0x001)) == 0)) {
      Expr *pRight =  pTerm->pExpr->pRight;
      sqlite3ExprCodeIsNullJump(v, pRight, (regBase + j), pLevel->addrBrk);
      if (zAff) {
        if ((sqlite3CompareAffinity(pRight, zAff[j]) == 'b')) {
          (zAff[j] = 'b');
        }  
        if (sqlite3ExprNeedsNoAffinityChange(pRight, zAff[j])) {
          (zAff[j] = 'b');
        }  
      }  
    }  
  }
  ((*pzAff) = zAff);
  return regBase;
}
static  void explainAppendTerm(StrAccum *pStr , int iTerm , const  char *zColumn , const  char *zOp )  {
  if (iTerm) {
    sqlite3StrAccumAppend(pStr, " AND ", 5);
  }  
  sqlite3StrAccumAppend(pStr, zColumn, (- 1));
  sqlite3StrAccumAppend(pStr, zOp, 1);
  sqlite3StrAccumAppend(pStr, "?", 1);
}
static  char *explainIndexRange(sqlite3 *db , WhereLoop *pLoop , Table *pTab )  {
  Index *pIndex =  pLoop->u.btree.pIndex;
  int nEq =  pLoop->u.btree.nEq;
  int i, j;
  Column *aCol =  pTab->aCol;
  int *aiColumn =  pIndex->aiColumn;
  StrAccum txt;
  if (((nEq == 0) && ((pLoop->wsFlags & (0x00000020 | 0x00000010)) == 0))) {
    return 0;
  }  
  sqlite3StrAccumInit((&txt), 0, 0, 1000000000);
  (txt.db = db);
  sqlite3StrAccumAppend((&txt), " (", 2);
  for ((i = 0); (i < nEq); i++) {
    char *z =  ((i == pIndex->nColumn) ? "rowid" : aCol[aiColumn[i]].zName);
    explainAppendTerm((&txt), i, z, "=");
  }
  (j = i);
  if ((pLoop->wsFlags & 0x00000020)) {
    char *z =  ((j == pIndex->nColumn) ? "rowid" : aCol[aiColumn[j]].zName);
    explainAppendTerm((&txt), i++, z, ">");
  }  
  if ((pLoop->wsFlags & 0x00000010)) {
    char *z =  ((j == pIndex->nColumn) ? "rowid" : aCol[aiColumn[j]].zName);
    explainAppendTerm((&txt), i, z, "<");
  }  
  sqlite3StrAccumAppend((&txt), ")", 1);
  return sqlite3StrAccumFinish((&txt));
}
static  void explainOneScan(Parse *pParse , SrcList *pTabList , WhereLevel *pLevel , int iLevel , int iFrom , u16 wctrlFlags )  {
  if ((pParse->explain == 2)) {
    struct  SrcList_item   *pItem =  (&pTabList->a[pLevel->iFrom]);
    Vdbe *v =  pParse->pVdbe;
    sqlite3 *db =  pParse->db;
    char *zMsg;
    int iId =  pParse->_1272_iSelectId;
    int isSearch;
    WhereLoop *pLoop;
    u32 flags;
    (pLoop = pLevel->pWLoop);
    (flags = pLoop->wsFlags);
    if (((flags & 0x00002000) || (wctrlFlags & 0x0040))) {
      return;
    }  
    (isSearch = (((flags & (0x00000020 | 0x00000010)) != 0) || (((flags & 0x00000400) == 0) && (pLoop->u.btree.nEq > 0)) || (wctrlFlags & (0x0001 | 0x0002))));
    (zMsg = sqlite3MPrintf(db, "%s", (isSearch ? "SEARCH" : "SCAN")));
    if (pItem->pSelect) {
      (zMsg = sqlite3MAppendf(db, zMsg, "%s SUBQUERY %d", zMsg, pItem->_1272_iSelectId));
    }  
    else {
      (zMsg = sqlite3MAppendf(db, zMsg, "%s TABLE %s", zMsg, pItem->zName));
    }
    if (pItem->zAlias) {
      (zMsg = sqlite3MAppendf(db, zMsg, "%s AS %s", zMsg, pItem->zAlias));
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      if ((((flags & (0x00000100 | 0x00000400)) == 0) && (pLoop->u.btree.pIndex != 0))) {
        char *zWhere =  explainIndexRange(db, pLoop, pItem->pTab);
        (zMsg = sqlite3MAppendf(db, zMsg, ((flags & 0x00004000) ? "%s USING AUTOMATIC %sINDEX%.0s%s" : "%s USING %sINDEX %s%s"), zMsg, ((flags & 0x00000040) ? "COVERING " : ""), pLoop->u.btree.pIndex->zName, zWhere));
        sqlite3DbFree(db, zWhere);
      } 
      else if ((((flags & 0x00000100) != 0) && ((flags & 0x0000000f) != 0))) {
        (zMsg = sqlite3MAppendf(db, zMsg, "%s USING INTEGER PRIMARY KEY", zMsg));
        if ((flags & (0x00000001 | 0x00000004))) {
          (zMsg = sqlite3MAppendf(db, zMsg, "%s (rowid=?)", zMsg));
        } 
        else if (((flags & 0x00000030) == 0x00000030)) {
          (zMsg = sqlite3MAppendf(db, zMsg, "%s (rowid>? AND rowid<?)", zMsg));
        }
        
        else if ((flags & 0x00000020)) {
          (zMsg = sqlite3MAppendf(db, zMsg, "%s (rowid>?)", zMsg));
        }
        
        else if ((flags & 0x00000010)) {
          (zMsg = sqlite3MAppendf(db, zMsg, "%s (rowid<?)", zMsg));
        } 
      }
      
      else if (((flags & 0x00000400) != 0)) {
        (zMsg = sqlite3MAppendf(db, zMsg, "%s VIRTUAL TABLE INDEX %d:%s", zMsg, pLoop->u.vtab.idxNum, pLoop->u.vtab.idxStr));
      } 
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((((flags & (0x00000100 | 0x00000400)) == 0) && 1)) {
        char *zWhere =  explainIndexRange(db, pLoop, pItem->pTab);
        (zMsg = sqlite3MAppendf(db, zMsg, ((flags & 0x00004000) ? "%s USING AUTOMATIC %sINDEX%.0s%s" : "%s USING %sINDEX %s%s"), zMsg, ((flags & 0x00000040) ? "COVERING " : ""), pLoop->u.btree.pIndex->zName, zWhere));
        sqlite3DbFree(db, zWhere);
      } 
      else if ((((flags & 0x00000100) != 0) && ((flags & 0x0000000f) != 0))) {
        (zMsg = sqlite3MAppendf(db, zMsg, "%s USING INTEGER PRIMARY KEY", zMsg));
        if ((flags & (0x00000001 | 0x00000004))) {
          (zMsg = sqlite3MAppendf(db, zMsg, "%s (rowid=?)", zMsg));
        } 
        else if (((flags & 0x00000030) == 0x00000030)) {
          (zMsg = sqlite3MAppendf(db, zMsg, "%s (rowid>? AND rowid<?)", zMsg));
        }
        
        else if ((flags & 0x00000020)) {
          (zMsg = sqlite3MAppendf(db, zMsg, "%s (rowid>?)", zMsg));
        }
        
        else if (1) {
          (zMsg = sqlite3MAppendf(db, zMsg, "%s (rowid<?)", zMsg));
        } 
      }
      
      else if (((flags & 0x00000400) != 0)) {
        (zMsg = sqlite3MAppendf(db, zMsg, "%s VIRTUAL TABLE INDEX %d:%s", zMsg, pLoop->u.vtab.idxNum, pLoop->u.vtab.idxStr));
      } 
    }  
    (zMsg = sqlite3MAppendf(db, zMsg, "%s", zMsg));
    sqlite3VdbeAddOp4(v, 150, iId, iLevel, iFrom, zMsg, (- 1));
  }  
}
static  Bitmask codeOneLoopStart(WhereInfo *pWInfo , int iLevel , Bitmask notReady )  {
  int j, k;
  int iCur;
  int addrNxt;
  int omitTable;
  int bRev;
  WhereLevel *pLevel;
  WhereLoop *pLoop;
  WhereClause *pWC;
  WhereTerm *pTerm;
  Parse *pParse;
  sqlite3 *db;
  Vdbe *v;
  struct  SrcList_item   *pTabItem;
  int addrBrk;
  int addrCont;
  int iRowidReg =  0;
  int iReleaseReg =  0;
  (pParse = pWInfo->pParse);
  (v = pParse->pVdbe);
  (pWC = (&pWInfo->sWC));
  (db = pParse->db);
  (pLevel = (&pWInfo->a[iLevel]));
  (pLoop = pLevel->pWLoop);
  (pTabItem = (&pWInfo->pTabList->a[pLevel->iFrom]));
  (iCur = pTabItem->iCursor);
  (pLevel->notReady = (notReady & (~ getMask((&pWInfo->sMaskSet), iCur))));
  (bRev = ((pWInfo->revMask >> iLevel) & 1));
  (omitTable = (((pLoop->wsFlags & 0x00000040) != 0) && ((pWInfo->wctrlFlags & 0x0020) == 0)));
  (addrBrk = (pLevel->addrBrk = (pLevel->addrNxt = sqlite3VdbeMakeLabel(v))));
  (addrCont = (pLevel->addrCont = sqlite3VdbeMakeLabel(v)));
  if (((pLevel->iFrom > 0) && ((pTabItem[0].jointype & 0x0008) != 0))) {
    (pLevel->iLeftJoin = ++pParse->nMem);
    sqlite3VdbeAddOp2(v, 21, 0, pLevel->iLeftJoin);
  }  
  if ((((! id2i_sqlite_omit_or_optimization) ) )) {
    if (pTabItem->viaCoroutine) {
      int regYield =  pTabItem->regReturn;
      sqlite3VdbeAddOp2(v, 21, (pTabItem->addrFillSub - 1), regYield);
      (pLevel->p2 = sqlite3VdbeAddOp1(v, 17, regYield));
      sqlite3VdbeAddOp2(v, 39, (regYield + 1), addrBrk);
      (pLevel->op = 14);
    } 
    else if (((pLoop->wsFlags & 0x00000400) != 0)) {
      int iReg;
      int addrNotFound;
      int nConstraint =  pLoop->nLTerm;
      sqlite3ExprCachePush(pParse);
      (iReg = sqlite3GetTempRange(pParse, (nConstraint + 2)));
      (addrNotFound = pLevel->addrBrk);
      for ((j = 0); (j < nConstraint); j++) {
        int iTarget =  (iReg + j + 2);
        (pTerm = pLoop->aLTerm[j]);
        if ((pTerm == 0)) {
          continue;
        }  
        if ((pTerm->eOperator & 0x001)) {
          codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, iTarget);
          (addrNotFound = pLevel->addrNxt);
        }  
        else {
          sqlite3ExprCode(pParse, pTerm->pExpr->pRight, iTarget);
        }
      }
      sqlite3VdbeAddOp2(v, 21, pLoop->u.vtab.idxNum, iReg);
      sqlite3VdbeAddOp2(v, 21, nConstraint, (iReg + 1));
      sqlite3VdbeAddOp4(v, 12, iCur, addrNotFound, iReg, pLoop->u.vtab.idxStr, (pLoop->u.vtab.needFree ? (- 11) : (- 2)));
      (pLoop->u.vtab.needFree = 0);
      for ((j = 0); ((j < nConstraint) && (j < 16)); j++) {
        if (((pLoop->u.vtab.omitMask >> j) & 1)) {
          disableTerm(pLevel, pLoop->aLTerm[j]);
        }  
      }
      (pLevel->op = 139);
      (pLevel->p1 = iCur);
      (pLevel->p2 = sqlite3VdbeCurrentAddr(v));
      sqlite3ReleaseTempRange(pParse, iReg, (nConstraint + 2));
      sqlite3ExprCachePop(pParse, 1);
    }
    
    else if ((((pLoop->wsFlags & 0x00000100) != 0) && ((pLoop->wsFlags & (0x00000004 | 0x00000001)) != 0))) {
      ((void ) 0);
      (iReleaseReg = sqlite3GetTempReg(pParse));
      (pTerm = pLoop->aLTerm[0]);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pTerm->wtFlags & 0x02)) {
          sqlite3Coverage(109741);
        }  
      }  
      (iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg));
      (addrNxt = pLevel->addrNxt);
      sqlite3VdbeAddOp2(v, 33, iRowidReg, addrNxt);
      sqlite3VdbeAddOp3(v, 63, iCur, addrNxt, iRowidReg);
      sqlite3ExprCacheAffinityChange(pParse, iRowidReg, 1);
      sqlite3ExprCacheStore(pParse, iCur, (- 1), iRowidReg);
      (pLevel->op = 149);
    }
    
    else if ((((pLoop->wsFlags & 0x00000100) != 0) && ((pLoop->wsFlags & 0x00000002) != 0))) {
      int testOp =  149;
      int start;
      int memEndValue =  0;
      WhereTerm *pStart, *pEnd;
      ((void ) 0);
      (j = 0);
      (pStart = (pEnd = 0));
      if ((pLoop->wsFlags & 0x00000020)) {
        (pStart = pLoop->aLTerm[j++]);
      }  
      if ((pLoop->wsFlags & 0x00000010)) {
        (pEnd = pLoop->aLTerm[j++]);
      }  
      ((void ) 0);
      if (bRev) {
        (pTerm = pStart);
        (pStart = pEnd);
        (pEnd = pTerm);
      }  
      if (pStart) {
        Expr *pX;
        int r1, rTemp;
        const u8 aMoveOp[] =  { 58,  56,  55,  57};
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pStart->wtFlags & 0x02)) {
            sqlite3Coverage(109789);
          }  
        }  
        (pX = pStart->pExpr);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pStart->leftCursor != iCur)) {
            sqlite3Coverage(109792);
          }  
        }  
        (r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, (&rTemp)));
        sqlite3VdbeAddOp3(v, aMoveOp[(pX->op - 77)], iCur, addrBrk, r1);
        sqlite3ExprCacheAffinityChange(pParse, r1, 1);
        sqlite3ReleaseTempReg(pParse, rTemp);
        disableTerm(pLevel, pStart);
      }  
      else {
        sqlite3VdbeAddOp2(v, (bRev ? 98 : 101), iCur, addrBrk);
      }
      if (pEnd) {
        Expr *pX;
        (pX = pEnd->pExpr);
        ((void ) 0);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pEnd->leftCursor != iCur)) {
            sqlite3Coverage(109807);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pEnd->wtFlags & 0x02)) {
            sqlite3Coverage(109808);
          }  
        }  
        (memEndValue = ++pParse->nMem);
        sqlite3ExprCode(pParse, pX->pRight, memEndValue);
        if (((pX->op == 79) || (pX->op == 77))) {
          (testOp = (bRev ? 78 : 80));
        }  
        else {
          (testOp = (bRev ? 79 : 77));
        }
        disableTerm(pLevel, pEnd);
      }  
      (start = sqlite3VdbeCurrentAddr(v));
      (pLevel->op = (bRev ? 6 : 7));
      (pLevel->p1 = iCur);
      (pLevel->p2 = start);
      ((void ) 0);
      if ((testOp != 149)) {
        (iRowidReg = (iReleaseReg = sqlite3GetTempReg(pParse)));
        sqlite3VdbeAddOp2(v, 96, iCur, iRowidReg);
        sqlite3ExprCacheStore(pParse, iCur, (- 1), iRowidReg);
        sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg);
        sqlite3VdbeChangeP5(v, ('c' | 0x08));
      }  
    }
    
    else if ((pLoop->wsFlags & 0x00000200)) {
      static const u8 aStartOp[] =  { 0,  0,  101,  98,  58,  55,  57,  56};
      static const u8 aEndOp[] =  { 149,  107,  106};
      int nEq =  pLoop->u.btree.nEq;
      int isMinQuery =  0;
      int regBase;
      int r1;
      WhereTerm *pRangeStart =  0;
      WhereTerm *pRangeEnd =  0;
      int startEq;
      int endEq;
      int start_constraints;
      int nConstraint;
      Index *pIdx;
      int iIdxCur;
      int nExtraReg =  0;
      int op;
      char *zStartAff;
      char *zEndAff;
      (pIdx = pLoop->u.btree.pIndex);
      (iIdxCur = pLevel->iIdxCur);
      if ((((pWInfo->wctrlFlags & 0x0001) != 0) && (pWInfo->bOBSat != 0) && (pIdx->nColumn > nEq))) {
        (isMinQuery = 1);
        (nExtraReg = 1);
      }  
      (j = nEq);
      if ((pLoop->wsFlags & 0x00000020)) {
        (pRangeStart = pLoop->aLTerm[j++]);
        (nExtraReg = 1);
      }  
      if ((pLoop->wsFlags & 0x00000010)) {
        (pRangeEnd = pLoop->aLTerm[j++]);
        (nExtraReg = 1);
      }  
      (regBase = codeAllEqualityTerms(pParse, pLevel, bRev, nExtraReg, (&zStartAff)));
      (zEndAff = sqlite3DbStrDup(db, zStartAff));
      (addrNxt = pLevel->addrNxt);
      if ((((nEq < pIdx->nColumn) && (bRev == (pIdx->aSortOrder[nEq] == 0))) || (bRev && (pIdx->nColumn == nEq)))) {
        {
          WhereTerm *t =  pRangeEnd;
          (pRangeEnd = pRangeStart);
          (pRangeStart = t);
        }
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pRangeStart && ((pRangeStart->eOperator & (0x002 << (78 - 76))) != 0))) {
          sqlite3Coverage(109946);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pRangeStart && ((pRangeStart->eOperator & (0x002 << (80 - 76))) != 0))) {
          sqlite3Coverage(109947);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pRangeEnd && ((pRangeEnd->eOperator & (0x002 << (78 - 76))) != 0))) {
          sqlite3Coverage(109948);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pRangeEnd && ((pRangeEnd->eOperator & (0x002 << (80 - 76))) != 0))) {
          sqlite3Coverage(109949);
        }  
      }  
      (startEq = ((! pRangeStart) || (pRangeStart->eOperator & ((0x002 << (78 - 76)) | (0x002 << (80 - 76))))));
      (endEq = ((! pRangeEnd) || (pRangeEnd->eOperator & ((0x002 << (78 - 76)) | (0x002 << (80 - 76))))));
      (start_constraints = (pRangeStart || (nEq > 0)));
      (nConstraint = nEq);
      if (pRangeStart) {
        Expr *pRight =  pRangeStart->pExpr->pRight;
        sqlite3ExprCode(pParse, pRight, (regBase + nEq));
        if (((pRangeStart->wtFlags & 0x00) == 0)) {
          sqlite3ExprCodeIsNullJump(v, pRight, (regBase + nEq), addrNxt);
        }  
        if (zStartAff) {
          if ((sqlite3CompareAffinity(pRight, zStartAff[nEq]) == 'b')) {
            (zStartAff[nEq] = 'b');
          }  
          if (sqlite3ExprNeedsNoAffinityChange(pRight, zStartAff[nEq])) {
            (zStartAff[nEq] = 'b');
          }  
        }  
        nConstraint++;
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pRangeStart->wtFlags & 0x02)) {
            sqlite3Coverage(109974);
          }  
        }  
      } 
      else if (isMinQuery) {
        sqlite3VdbeAddOp2(v, 24, 0, (regBase + nEq));
        nConstraint++;
        (startEq = 0);
        (start_constraints = 1);
      } 
      codeApplyAffinity(pParse, regBase, nConstraint, zStartAff);
      (op = aStartOp[((start_constraints << 2) + (startEq << 1) + bRev)]);
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 101)) {
          sqlite3Coverage(109984);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 98)) {
          sqlite3Coverage(109985);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 58)) {
          sqlite3Coverage(109986);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 57)) {
          sqlite3Coverage(109987);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 56)) {
          sqlite3Coverage(109988);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 55)) {
          sqlite3Coverage(109989);
        }  
      }  
      sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
      (nConstraint = nEq);
      if (pRangeEnd) {
        Expr *pRight =  pRangeEnd->pExpr->pRight;
        sqlite3ExprCacheRemove(pParse, (regBase + nEq), 1);
        sqlite3ExprCode(pParse, pRight, (regBase + nEq));
        if (((pRangeEnd->wtFlags & 0x00) == 0)) {
          sqlite3ExprCodeIsNullJump(v, pRight, (regBase + nEq), addrNxt);
        }  
        if (zEndAff) {
          if ((sqlite3CompareAffinity(pRight, zEndAff[nEq]) == 'b')) {
            (zEndAff[nEq] = 'b');
          }  
          if (sqlite3ExprNeedsNoAffinityChange(pRight, zEndAff[nEq])) {
            (zEndAff[nEq] = 'b');
          }  
        }  
        codeApplyAffinity(pParse, regBase, (nEq + 1), zEndAff);
        nConstraint++;
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pRangeEnd->wtFlags & 0x02)) {
            sqlite3Coverage(110016);
          }  
        }  
      }  
      sqlite3DbFree(db, zStartAff);
      sqlite3DbFree(db, zEndAff);
      (pLevel->p2 = sqlite3VdbeCurrentAddr(v));
      (op = aEndOp[((pRangeEnd || nEq) * (1 + bRev))]);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 149)) {
          sqlite3Coverage(110026);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 107)) {
          sqlite3Coverage(110027);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 106)) {
          sqlite3Coverage(110028);
        }  
      }  
      if ((op != 149)) {
        sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
        sqlite3VdbeChangeP5(v, ((endEq != bRev) ? 1 : 0));
      }  
      (r1 = sqlite3GetTempReg(pParse));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pLoop->wsFlags & 0x00000020)) {
          sqlite3Coverage(110039);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pLoop->wsFlags & 0x00000010)) {
          sqlite3Coverage(110040);
        }  
      }  
      if (((pLoop->wsFlags & (0x00000020 | 0x00000010)) != 0)) {
        sqlite3VdbeAddOp3(v, 41, iIdxCur, nEq, r1);
        sqlite3VdbeAddOp2(v, 73, r1, addrCont);
      }  
      sqlite3ReleaseTempReg(pParse, r1);
      disableTerm(pLevel, pRangeStart);
      disableTerm(pLevel, pRangeEnd);
      if ((! omitTable)) {
        (iRowidReg = (iReleaseReg = sqlite3GetTempReg(pParse)));
        sqlite3VdbeAddOp2(v, 105, iIdxCur, iRowidReg);
        sqlite3ExprCacheStore(pParse, iCur, (- 1), iRowidReg);
        sqlite3VdbeAddOp2(v, 59, iCur, iRowidReg);
      }  
      if ((pLoop->wsFlags & 0x00001000)) {
        (pLevel->op = 149);
      } 
      else if (bRev) {
        (pLevel->op = 6);
      } 
      else {
        (pLevel->op = 7);
      }
      (pLevel->p1 = iIdxCur);
      if (((pLoop->wsFlags & 0x0000000f) == 0)) {
        (pLevel->p5 = 1);
      }  
      else {
        ((void ) 0);
      }
    }
    
    else if ((pLoop->wsFlags & 0x00002000)) {
      WhereClause *pOrWc;
      SrcList *pOrTab;
      Index *pCov =  0;
      int iCovCur =  pParse->nTab++;
      int regReturn =  ++pParse->nMem;
      int regRowset =  0;
      int regRowid =  0;
      int iLoopBody =  sqlite3VdbeMakeLabel(v);
      int iRetInit;
      int untestedTerms =  0;
      int ii;
      Expr *pAndExpr =  0;
      (pTerm = pLoop->aLTerm[0]);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      (pOrWc = (&pTerm->u.pOrInfo->wc));
      (pLevel->op = 16);
      (pLevel->p1 = regReturn);
      if ((pWInfo->nLevel > 1)) {
        int nNotReady;
        struct  SrcList_item   *origSrc;
        (nNotReady = (pWInfo->nLevel - iLevel - 1));
        (pOrTab = sqlite3DbMallocRaw(db, (sizeof((*pOrTab)) + (nNotReady * sizeof(pOrTab->a[0])))));
        if ((pOrTab == 0)) {
          return notReady;
        }  
        (pOrTab->nAlloc = ((u8 ) (nNotReady + 1)));
        (pOrTab->nSrc = pOrTab->nAlloc);
        memcpy(pOrTab->a, pTabItem, sizeof((*pTabItem)));
        (origSrc = pWInfo->pTabList->a);
        for ((k = 1); (k <= nNotReady); k++) {
          memcpy((&pOrTab->a[k]), (&origSrc[pLevel[k].iFrom]), sizeof(pOrTab->a[k]));
        }
      }  
      else {
        (pOrTab = pWInfo->pTabList);
      }
      if (((pWInfo->wctrlFlags & 0x0008) == 0)) {
        (regRowset = ++pParse->nMem);
        (regRowid = ++pParse->nMem);
        sqlite3VdbeAddOp2(v, 24, 0, regRowset);
      }  
      (iRetInit = sqlite3VdbeAddOp2(v, 21, 0, regReturn));
      if ((pWC->nTerm > 1)) {
        int iTerm;
        for ((iTerm = 0); (iTerm < pWC->nTerm); iTerm++) {
          Expr *pExpr =  pWC->a[iTerm].pExpr;
          if (((&pWC->a[iTerm]) == pTerm)) {
            continue;
          }  
          if (((pExpr->flags & 0x000001) != 0)) {
            continue;
          }  
          if ((pWC->a[iTerm].wtFlags & 0x10)) {
            continue;
          }  
          if (((pWC->a[iTerm].eOperator & 0xfff) == 0)) {
            continue;
          }  
          (pExpr = sqlite3ExprDup(db, pExpr, 0));
          (pAndExpr = sqlite3ExprAnd(db, pAndExpr, pExpr));
        }
        if (pAndExpr) {
          (pAndExpr = sqlite3PExpr(pParse, 69, 0, pAndExpr, 0));
        }  
      }  
      for ((ii = 0); (ii < pOrWc->nTerm); ii++) {
        WhereTerm *pOrTerm =  (&pOrWc->a[ii]);
        if (((pOrTerm->leftCursor == iCur) || ((pOrTerm->eOperator & 0x200) != 0))) {
          WhereInfo *pSubWInfo;
          Expr *pOrExpr =  pOrTerm->pExpr;
          if ((pAndExpr && (! ((pOrExpr->flags & 0x000001) != 0)))) {
            (pAndExpr->pLeft = pOrExpr);
            (pOrExpr = pAndExpr);
          }  
          (pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, 0, 0, (0x0010 | 0x0080 | 0x0020 | 0x0040), iCovCur));
          ((void ) 0);
          if (pSubWInfo) {
            WhereLoop *pSubLoop;
            if ((((! id2i_sqlite_omit_explain) ) )) {
              explainOneScan(pParse, pOrTab, (&pSubWInfo->a[0]), iLevel, pLevel->iFrom, 0);
            }  
            if (((pWInfo->wctrlFlags & 0x0008) == 0)) {
              int iSet =  ((ii == (pOrWc->nTerm - 1)) ? (- 1) : ii);
              int r;
              (r = sqlite3ExprCodeGetColumn(pParse, pTabItem->pTab, (- 1), iCur, regRowid, 0));
              sqlite3VdbeAddOp4Int(v, 120, regRowset, (sqlite3VdbeCurrentAddr(v) + 2), r, iSet);
            }  
            sqlite3VdbeAddOp2(v, 15, regReturn, iLoopBody);
            if (pSubWInfo->untestedTerms) {
              (untestedTerms = 1);
            }  
            (pSubLoop = pSubWInfo->a[0].pWLoop);
            ((void ) 0);
            if ((((pSubLoop->wsFlags & 0x00000200) != 0) && ((ii == 0) || (pSubLoop->u.btree.pIndex == pCov)))) {
              ((void ) 0);
              (pCov = pSubLoop->u.btree.pIndex);
            }  
            else {
              (pCov = 0);
            }
            sqlite3WhereEnd(pSubWInfo);
          }  
        }  
      }
      (pLevel->u.pCovidx = pCov);
      if (pCov) {
        (pLevel->iIdxCur = iCovCur);
      }  
      if (pAndExpr) {
        (pAndExpr->pLeft = 0);
        sqlite3ExprDelete(db, pAndExpr);
      }  
      sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v));
      sqlite3VdbeAddOp2(v, 14, 0, pLevel->addrBrk);
      sqlite3VdbeResolveLabel(v, iLoopBody);
      if ((pWInfo->nLevel > 1)) {
        sqlite3DbFree(db, pOrTab);
      }  
      if ((! untestedTerms)) {
        disableTerm(pLevel, pTerm);
      }  
    } 
    else {
      static const u8 aStep[] =  { 7,  6};
      static const u8 aStart[] =  { 101,  98};
      ((void ) 0);
      (pLevel->op = aStep[bRev]);
      (pLevel->p1 = iCur);
      (pLevel->p2 = (1 + sqlite3VdbeAddOp2(v, aStart[bRev], iCur, addrBrk)));
      (pLevel->p5 = 1);
    }
  }  
  if (((id2i_sqlite_omit_or_optimization ) )) {
    if (pTabItem->viaCoroutine) {
      int regYield =  pTabItem->regReturn;
      sqlite3VdbeAddOp2(v, 21, (pTabItem->addrFillSub - 1), regYield);
      (pLevel->p2 = sqlite3VdbeAddOp1(v, 17, regYield));
      sqlite3VdbeAddOp2(v, 39, (regYield + 1), addrBrk);
      (pLevel->op = 14);
    } 
    else if (((pLoop->wsFlags & 0x00000400) != 0)) {
      int iReg;
      int addrNotFound;
      int nConstraint =  pLoop->nLTerm;
      sqlite3ExprCachePush(pParse);
      (iReg = sqlite3GetTempRange(pParse, (nConstraint + 2)));
      (addrNotFound = pLevel->addrBrk);
      for ((j = 0); (j < nConstraint); j++) {
        int iTarget =  (iReg + j + 2);
        (pTerm = pLoop->aLTerm[j]);
        if ((pTerm == 0)) {
          continue;
        }  
        if ((pTerm->eOperator & 0x001)) {
          codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, iTarget);
          (addrNotFound = pLevel->addrNxt);
        }  
        else {
          sqlite3ExprCode(pParse, pTerm->pExpr->pRight, iTarget);
        }
      }
      sqlite3VdbeAddOp2(v, 21, pLoop->u.vtab.idxNum, iReg);
      sqlite3VdbeAddOp2(v, 21, nConstraint, (iReg + 1));
      sqlite3VdbeAddOp4(v, 12, iCur, addrNotFound, iReg, pLoop->u.vtab.idxStr, (pLoop->u.vtab.needFree ? (- 11) : (- 2)));
      (pLoop->u.vtab.needFree = 0);
      for ((j = 0); ((j < nConstraint) && (j < 16)); j++) {
        if (((pLoop->u.vtab.omitMask >> j) & 1)) {
          disableTerm(pLevel, pLoop->aLTerm[j]);
        }  
      }
      (pLevel->op = 139);
      (pLevel->p1 = iCur);
      (pLevel->p2 = sqlite3VdbeCurrentAddr(v));
      sqlite3ReleaseTempRange(pParse, iReg, (nConstraint + 2));
      sqlite3ExprCachePop(pParse, 1);
    }
    
    else if ((((pLoop->wsFlags & 0x00000100) != 0) && ((pLoop->wsFlags & (0x00000004 | 0x00000001)) != 0))) {
      ((void ) 0);
      (iReleaseReg = sqlite3GetTempReg(pParse));
      (pTerm = pLoop->aLTerm[0]);
      ((void ) 0);
      ((void ) 0);
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pTerm->wtFlags & 0x02)) {
          sqlite3Coverage(109741);
        }  
      }  
      (iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg));
      (addrNxt = pLevel->addrNxt);
      sqlite3VdbeAddOp2(v, 33, iRowidReg, addrNxt);
      sqlite3VdbeAddOp3(v, 63, iCur, addrNxt, iRowidReg);
      sqlite3ExprCacheAffinityChange(pParse, iRowidReg, 1);
      sqlite3ExprCacheStore(pParse, iCur, (- 1), iRowidReg);
      (pLevel->op = 149);
    }
    
    else if ((((pLoop->wsFlags & 0x00000100) != 0) && ((pLoop->wsFlags & 0x00000002) != 0))) {
      int testOp =  149;
      int start;
      int memEndValue =  0;
      WhereTerm *pStart, *pEnd;
      ((void ) 0);
      (j = 0);
      (pStart = (pEnd = 0));
      if ((pLoop->wsFlags & 0x00000020)) {
        (pStart = pLoop->aLTerm[j++]);
      }  
      if ((pLoop->wsFlags & 0x00000010)) {
        (pEnd = pLoop->aLTerm[j++]);
      }  
      ((void ) 0);
      if (bRev) {
        (pTerm = pStart);
        (pStart = pEnd);
        (pEnd = pTerm);
      }  
      if (pStart) {
        Expr *pX;
        int r1, rTemp;
        const u8 aMoveOp[] =  { 58,  56,  55,  57};
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pStart->wtFlags & 0x02)) {
            sqlite3Coverage(109789);
          }  
        }  
        (pX = pStart->pExpr);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pStart->leftCursor != iCur)) {
            sqlite3Coverage(109792);
          }  
        }  
        (r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, (&rTemp)));
        sqlite3VdbeAddOp3(v, aMoveOp[(pX->op - 77)], iCur, addrBrk, r1);
        sqlite3ExprCacheAffinityChange(pParse, r1, 1);
        sqlite3ReleaseTempReg(pParse, rTemp);
        disableTerm(pLevel, pStart);
      }  
      else {
        sqlite3VdbeAddOp2(v, (bRev ? 98 : 101), iCur, addrBrk);
      }
      if (pEnd) {
        Expr *pX;
        (pX = pEnd->pExpr);
        ((void ) 0);
        ((void ) 0);
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pEnd->leftCursor != iCur)) {
            sqlite3Coverage(109807);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pEnd->wtFlags & 0x02)) {
            sqlite3Coverage(109808);
          }  
        }  
        (memEndValue = ++pParse->nMem);
        sqlite3ExprCode(pParse, pX->pRight, memEndValue);
        if (((pX->op == 79) || (pX->op == 77))) {
          (testOp = (bRev ? 78 : 80));
        }  
        else {
          (testOp = (bRev ? 79 : 77));
        }
        disableTerm(pLevel, pEnd);
      }  
      (start = sqlite3VdbeCurrentAddr(v));
      (pLevel->op = (bRev ? 6 : 7));
      (pLevel->p1 = iCur);
      (pLevel->p2 = start);
      ((void ) 0);
      if ((testOp != 149)) {
        (iRowidReg = (iReleaseReg = sqlite3GetTempReg(pParse)));
        sqlite3VdbeAddOp2(v, 96, iCur, iRowidReg);
        sqlite3ExprCacheStore(pParse, iCur, (- 1), iRowidReg);
        sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg);
        sqlite3VdbeChangeP5(v, ('c' | 0x08));
      }  
    }
    
    else if ((pLoop->wsFlags & 0x00000200)) {
      static const u8 aStartOp[] =  { 0,  0,  101,  98,  58,  55,  57,  56};
      static const u8 aEndOp[] =  { 149,  107,  106};
      int nEq =  pLoop->u.btree.nEq;
      int isMinQuery =  0;
      int regBase;
      int r1;
      WhereTerm *pRangeStart =  0;
      WhereTerm *pRangeEnd =  0;
      int startEq;
      int endEq;
      int start_constraints;
      int nConstraint;
      Index *pIdx;
      int iIdxCur;
      int nExtraReg =  0;
      int op;
      char *zStartAff;
      char *zEndAff;
      (pIdx = pLoop->u.btree.pIndex);
      (iIdxCur = pLevel->iIdxCur);
      if ((((pWInfo->wctrlFlags & 0x0001) != 0) && (pWInfo->bOBSat != 0) && (pIdx->nColumn > nEq))) {
        (isMinQuery = 1);
        (nExtraReg = 1);
      }  
      (j = nEq);
      if ((pLoop->wsFlags & 0x00000020)) {
        (pRangeStart = pLoop->aLTerm[j++]);
        (nExtraReg = 1);
      }  
      if ((pLoop->wsFlags & 0x00000010)) {
        (pRangeEnd = pLoop->aLTerm[j++]);
        (nExtraReg = 1);
      }  
      (regBase = codeAllEqualityTerms(pParse, pLevel, bRev, nExtraReg, (&zStartAff)));
      (zEndAff = sqlite3DbStrDup(db, zStartAff));
      (addrNxt = pLevel->addrNxt);
      if ((((nEq < pIdx->nColumn) && (bRev == (pIdx->aSortOrder[nEq] == 0))) || (bRev && (pIdx->nColumn == nEq)))) {
        {
          WhereTerm *t =  pRangeEnd;
          (pRangeEnd = pRangeStart);
          (pRangeStart = t);
        }
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pRangeStart && ((pRangeStart->eOperator & (0x002 << (78 - 76))) != 0))) {
          sqlite3Coverage(109946);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pRangeStart && ((pRangeStart->eOperator & (0x002 << (80 - 76))) != 0))) {
          sqlite3Coverage(109947);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pRangeEnd && ((pRangeEnd->eOperator & (0x002 << (78 - 76))) != 0))) {
          sqlite3Coverage(109948);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pRangeEnd && ((pRangeEnd->eOperator & (0x002 << (80 - 76))) != 0))) {
          sqlite3Coverage(109949);
        }  
      }  
      (startEq = ((! pRangeStart) || (pRangeStart->eOperator & ((0x002 << (78 - 76)) | (0x002 << (80 - 76))))));
      (endEq = ((! pRangeEnd) || (pRangeEnd->eOperator & ((0x002 << (78 - 76)) | (0x002 << (80 - 76))))));
      (start_constraints = (pRangeStart || (nEq > 0)));
      (nConstraint = nEq);
      if (pRangeStart) {
        Expr *pRight =  pRangeStart->pExpr->pRight;
        sqlite3ExprCode(pParse, pRight, (regBase + nEq));
        if (((pRangeStart->wtFlags & 0x00) == 0)) {
          sqlite3ExprCodeIsNullJump(v, pRight, (regBase + nEq), addrNxt);
        }  
        if (zStartAff) {
          if ((sqlite3CompareAffinity(pRight, zStartAff[nEq]) == 'b')) {
            (zStartAff[nEq] = 'b');
          }  
          if (sqlite3ExprNeedsNoAffinityChange(pRight, zStartAff[nEq])) {
            (zStartAff[nEq] = 'b');
          }  
        }  
        nConstraint++;
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pRangeStart->wtFlags & 0x02)) {
            sqlite3Coverage(109974);
          }  
        }  
      } 
      else if (isMinQuery) {
        sqlite3VdbeAddOp2(v, 24, 0, (regBase + nEq));
        nConstraint++;
        (startEq = 0);
        (start_constraints = 1);
      } 
      codeApplyAffinity(pParse, regBase, nConstraint, zStartAff);
      (op = aStartOp[((start_constraints << 2) + (startEq << 1) + bRev)]);
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 101)) {
          sqlite3Coverage(109984);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 98)) {
          sqlite3Coverage(109985);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 58)) {
          sqlite3Coverage(109986);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 57)) {
          sqlite3Coverage(109987);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 56)) {
          sqlite3Coverage(109988);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 55)) {
          sqlite3Coverage(109989);
        }  
      }  
      sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
      (nConstraint = nEq);
      if (pRangeEnd) {
        Expr *pRight =  pRangeEnd->pExpr->pRight;
        sqlite3ExprCacheRemove(pParse, (regBase + nEq), 1);
        sqlite3ExprCode(pParse, pRight, (regBase + nEq));
        if (((pRangeEnd->wtFlags & 0x00) == 0)) {
          sqlite3ExprCodeIsNullJump(v, pRight, (regBase + nEq), addrNxt);
        }  
        if (zEndAff) {
          if ((sqlite3CompareAffinity(pRight, zEndAff[nEq]) == 'b')) {
            (zEndAff[nEq] = 'b');
          }  
          if (sqlite3ExprNeedsNoAffinityChange(pRight, zEndAff[nEq])) {
            (zEndAff[nEq] = 'b');
          }  
        }  
        codeApplyAffinity(pParse, regBase, (nEq + 1), zEndAff);
        nConstraint++;
        if (((id2i_sqlite_coverage_test ) )) {
          if ((pRangeEnd->wtFlags & 0x02)) {
            sqlite3Coverage(110016);
          }  
        }  
      }  
      sqlite3DbFree(db, zStartAff);
      sqlite3DbFree(db, zEndAff);
      (pLevel->p2 = sqlite3VdbeCurrentAddr(v));
      (op = aEndOp[((pRangeEnd || nEq) * (1 + bRev))]);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 149)) {
          sqlite3Coverage(110026);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 107)) {
          sqlite3Coverage(110027);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((op == 106)) {
          sqlite3Coverage(110028);
        }  
      }  
      if ((op != 149)) {
        sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
        sqlite3VdbeChangeP5(v, ((endEq != bRev) ? 1 : 0));
      }  
      (r1 = sqlite3GetTempReg(pParse));
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pLoop->wsFlags & 0x00000020)) {
          sqlite3Coverage(110039);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pLoop->wsFlags & 0x00000010)) {
          sqlite3Coverage(110040);
        }  
      }  
      if (((pLoop->wsFlags & (0x00000020 | 0x00000010)) != 0)) {
        sqlite3VdbeAddOp3(v, 41, iIdxCur, nEq, r1);
        sqlite3VdbeAddOp2(v, 73, r1, addrCont);
      }  
      sqlite3ReleaseTempReg(pParse, r1);
      disableTerm(pLevel, pRangeStart);
      disableTerm(pLevel, pRangeEnd);
      if ((! omitTable)) {
        (iRowidReg = (iReleaseReg = sqlite3GetTempReg(pParse)));
        sqlite3VdbeAddOp2(v, 105, iIdxCur, iRowidReg);
        sqlite3ExprCacheStore(pParse, iCur, (- 1), iRowidReg);
        sqlite3VdbeAddOp2(v, 59, iCur, iRowidReg);
      }  
      if ((pLoop->wsFlags & 0x00001000)) {
        (pLevel->op = 149);
      } 
      else if (bRev) {
        (pLevel->op = 6);
      } 
      else {
        (pLevel->op = 7);
      }
      (pLevel->p1 = iIdxCur);
      if (((pLoop->wsFlags & 0x0000000f) == 0)) {
        (pLevel->p5 = 1);
      }  
      else {
        ((void ) 0);
      }
    } 
    else {
      static const u8 aStep[] =  { 7,  6};
      static const u8 aStart[] =  { 101,  98};
      ((void ) 0);
      (pLevel->op = aStep[bRev]);
      (pLevel->p1 = iCur);
      (pLevel->p2 = (1 + sqlite3VdbeAddOp2(v, aStart[bRev], iCur, addrBrk)));
      (pLevel->p5 = 1);
    }
  }  
  for ((pTerm = pWC->a), (j = pWC->nTerm); (j > 0); j--, pTerm++) {
    Expr *pE;
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pTerm->wtFlags & 0x02)) {
        sqlite3Coverage(110305);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pTerm->wtFlags & 0x04)) {
        sqlite3Coverage(110306);
      }  
    }  
    if ((pTerm->wtFlags & (0x02 | 0x04))) {
      continue;
    }  
    if (((pTerm->prereqAll & pLevel->notReady) != 0)) {
      if (((id2i_sqlite_coverage_test ) )) {
        if (((pWInfo->untestedTerms == 0) && ((pWInfo->wctrlFlags & 0x0040) != 0))) {
          sqlite3Coverage(110310);
        }  
      }  
      (pWInfo->untestedTerms = 1);
      continue;
    }  
    (pE = pTerm->pExpr);
    ((void ) 0);
    if ((pLevel->iLeftJoin && (! ((pE->flags & 0x000001) != 0)))) {
      continue;
    }  
    sqlite3ExprIfFalse(pParse, pE, addrCont, 0x08);
    (pTerm->wtFlags |= 0x04);
  }
  for ((pTerm = pWC->a), (j = pWC->nTerm); (j > 0); j--, pTerm++) {
    Expr *pE, *pEAlt;
    WhereTerm *pAlt;
    if ((pTerm->wtFlags & (0x02 | 0x04))) {
      continue;
    }  
    if ((pTerm->eOperator != (0x400 | 0x002))) {
      continue;
    }  
    if ((pTerm->leftCursor != iCur)) {
      continue;
    }  
    if (pLevel->iLeftJoin) {
      continue;
    }  
    (pE = pTerm->pExpr);
    ((void ) 0);
    ((void ) 0);
    (pAlt = findTerm(pWC, iCur, pTerm->u.leftColumn, notReady, (0x002 | 0x001), 0));
    if ((pAlt == 0)) {
      continue;
    }  
    if ((pAlt->wtFlags & 0x04)) {
      continue;
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pAlt->eOperator & 0x002)) {
        sqlite3Coverage(110344);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((pAlt->eOperator & 0x001)) {
        sqlite3Coverage(110345);
      }  
    }  
    (pEAlt = sqlite3DbMallocRaw(db, sizeof((*pEAlt))));
    if (pEAlt) {
      ((*pEAlt) = (*pAlt->pExpr));
      (pEAlt->pLeft = pE->pLeft);
      sqlite3ExprIfFalse(pParse, pEAlt, addrCont, 0x08);
      sqlite3DbFree(db, pEAlt);
    }  
  }
  if (pLevel->iLeftJoin) {
    (pLevel->addrFirst = sqlite3VdbeCurrentAddr(v));
    sqlite3VdbeAddOp2(v, 21, 1, pLevel->iLeftJoin);
    sqlite3ExprCacheClear(pParse);
    for ((pTerm = pWC->a), (j = 0); (j < pWC->nTerm); j++, pTerm++) {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pTerm->wtFlags & 0x02)) {
          sqlite3Coverage(110365);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pTerm->wtFlags & 0x04)) {
          sqlite3Coverage(110366);
        }  
      }  
      if ((pTerm->wtFlags & (0x02 | 0x04))) {
        continue;
      }  
      if (((pTerm->prereqAll & pLevel->notReady) != 0)) {
        ((void ) 0);
        continue;
      }  
      ((void ) 0);
      sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, 0x08);
      (pTerm->wtFlags |= 0x04);
    }
  }  
  sqlite3ReleaseTempReg(pParse, iReleaseReg);
  return pLevel->notReady;
}
static  void whereLoopInit(WhereLoop *p )  {
  (p->aLTerm = p->aLTermSpace);
  (p->nLTerm = 0);
  (p->nLSlot = ((int ) (sizeof(p->aLTermSpace) / sizeof(p->aLTermSpace[0]))));
  (p->wsFlags = 0);
}
static  void whereLoopClearUnion(sqlite3 *db , WhereLoop *p )  {
  if ((p->wsFlags & (0x00000400 | 0x00004000))) {
    if ((((p->wsFlags & 0x00000400) != 0) && p->u.vtab.needFree)) {
      sqlite3_free(p->u.vtab.idxStr);
      (p->u.vtab.needFree = 0);
      (p->u.vtab.idxStr = 0);
    } 
    else if ((((p->wsFlags & 0x00004000) != 0) && (p->u.btree.pIndex != 0))) {
      sqlite3DbFree(db, p->u.btree.pIndex->zColAff);
      sqlite3DbFree(db, p->u.btree.pIndex);
      (p->u.btree.pIndex = 0);
    } 
  }  
}
static  void whereLoopClear(sqlite3 *db , WhereLoop *p )  {
  if ((p->aLTerm != p->aLTermSpace)) {
    sqlite3DbFree(db, p->aLTerm);
  }  
  whereLoopClearUnion(db, p);
  whereLoopInit(p);
}
static  int whereLoopResize(sqlite3 *db , WhereLoop *p , int n )  {
  WhereTerm **paNew;
  if ((p->nLSlot >= n)) {
    return 0;
  }  
  (n = ((n + 7) & (~ 7)));
  (paNew = sqlite3DbMallocRaw(db, (sizeof(p->aLTerm[0]) * n)));
  if ((paNew == 0)) {
    return 7;
  }  
  memcpy(paNew, p->aLTerm, (sizeof(p->aLTerm[0]) * p->nLSlot));
  if ((p->aLTerm != p->aLTermSpace)) {
    sqlite3DbFree(db, p->aLTerm);
  }  
  (p->aLTerm = paNew);
  (p->nLSlot = n);
  return 0;
}
static  int whereLoopXfer(sqlite3 *db , WhereLoop *pTo , WhereLoop *pFrom )  {
  whereLoopClearUnion(db, pTo);
  if (whereLoopResize(db, pTo, pFrom->nLTerm)) {
    memset((&pTo->u), 0, sizeof(pTo->u));
    return 7;
  }  
  memcpy(pTo, pFrom, __builtin_offsetof(WhereLoop , nLSlot));
  memcpy(pTo->aLTerm, pFrom->aLTerm, (pTo->nLTerm * sizeof(pTo->aLTerm[0])));
  if ((pFrom->wsFlags & 0x00000400)) {
    (pFrom->u.vtab.needFree = 0);
  } 
  else if (((pFrom->wsFlags & 0x00004000) != 0)) {
    (pFrom->u.btree.pIndex = 0);
  } 
  return 0;
}
static  void whereLoopDelete(sqlite3 *db , WhereLoop *p )  {
  whereLoopClear(db, p);
  sqlite3DbFree(db, p);
}
static  void whereInfoFree(sqlite3 *db , WhereInfo *pWInfo )  {
  if (((id2i_sqlite_coverage_test ) )) {
    if (1) {
      whereClauseClear((&pWInfo->sWC));
      while (pWInfo->pLoops) {
        WhereLoop *p =  pWInfo->pLoops;
        (pWInfo->pLoops = p->pNextLoop);
        whereLoopDelete(db, p);
      }
      sqlite3DbFree(db, pWInfo);
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (pWInfo) {
      whereClauseClear((&pWInfo->sWC));
      while (pWInfo->pLoops) {
        WhereLoop *p =  pWInfo->pLoops;
        (pWInfo->pLoops = p->pNextLoop);
        whereLoopDelete(db, p);
      }
      sqlite3DbFree(db, pWInfo);
    }  
  }  
}
static  int whereLoopInsert(WhereLoopBuilder *pBuilder , WhereLoop *pTemplate )  {
  WhereLoop **ppPrev, *p, *pNext =  0;
  WhereInfo *pWInfo =  pBuilder->pWInfo;
  sqlite3 *db =  pWInfo->pParse->db;
  if ((pBuilder->pOrSet != 0)) {
    whereOrInsert(pBuilder->pOrSet, pTemplate->prereq, pTemplate->rRun, pTemplate->nOut);
    return 0;
  }  
  for ((ppPrev = (&pWInfo->pLoops)), (p = (*ppPrev)); p; (ppPrev = (&p->pNextLoop)), (p = (*ppPrev))) {
    if (((p->iTab != pTemplate->iTab) || (p->iSortIdx != pTemplate->iSortIdx))) {
      continue;
    }  
    ((void ) 0);
    ((void ) 0);
    if ((((p->prereq & pTemplate->prereq) == p->prereq) && (p->rSetup <= pTemplate->rSetup) && (p->rRun <= pTemplate->rRun) && (p->nOut <= pTemplate->nOut))) {
      ((void ) 0);
      if (((p->prereq == pTemplate->prereq) && (p->nLTerm < pTemplate->nLTerm) && ((p->wsFlags & pTemplate->wsFlags & 0x00000200) != 0) && ((p->u.btree.pIndex == pTemplate->u.btree.pIndex) || ((pTemplate->rRun + p->nLTerm) <= (p->rRun + pTemplate->nLTerm))))) {
        (pNext = p->pNextLoop);
        break;
      }  
      else {
        goto whereLoopInsert_noop;
      }
    }  
    if ((((p->prereq & pTemplate->prereq) == pTemplate->prereq) && (p->rRun >= pTemplate->rRun) && (p->nOut >= pTemplate->nOut))) {
      ((void ) 0);
      (pNext = p->pNextLoop);
      break;
    }  
  }
  if ((p == 0)) {
    (p = sqlite3DbMallocRaw(db, sizeof(WhereLoop )));
    if ((p == 0)) {
      return 7;
    }  
    whereLoopInit(p);
  }  
  whereLoopXfer(db, p, pTemplate);
  (p->pNextLoop = pNext);
  ((*ppPrev) = p);
  if (((p->wsFlags & 0x00000400) == 0)) {
    Index *pIndex =  p->u.btree.pIndex;
    if ((pIndex && (pIndex->tnum == 0))) {
      (p->u.btree.pIndex = 0);
    }  
  }  
  return 0;
  whereLoopInsert_noop:
  return 0;
}
static  void whereLoopOutputAdjust(WhereClause *pWC , WhereLoop *pLoop )  {
  WhereTerm *pTerm, *pX;
  Bitmask notAllowed =  (~ (pLoop->prereq | pLoop->maskSelf));
  int i, j;
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    if ((! ((pWC->pWInfo->pParse->db->dbOptFlags & 0x1000) == 0))) {
      return;
    }  
  }  
  if (((id2i_sqlite_omit_builtin_test ) )) {
    if ((! 1)) {
      return;
    }  
  }  
  for ((i = pWC->nTerm), (pTerm = pWC->a); (i > 0); i--, pTerm++) {
    if (((pTerm->wtFlags & 0x02) != 0)) {
      break;
    }  
    if (((pTerm->prereqAll & pLoop->maskSelf) == 0)) {
      continue;
    }  
    if (((pTerm->prereqAll & notAllowed) != 0)) {
      continue;
    }  
    for ((j = (pLoop->nLTerm - 1)); (j >= 0); j--) {
      (pX = pLoop->aLTerm[j]);
      if ((pX == pTerm)) {
        break;
      }  
      if (((pX->iParent >= 0) && ((&pWC->a[pX->iParent]) == pTerm))) {
        break;
      }  
    }
    if ((j < 0)) {
      (pLoop->nOut += pTerm->truthProb);
    }  
  }
}
static  int whereLoopAddBtreeIndex(WhereLoopBuilder *pBuilder , struct  SrcList_item   *pSrc , Index *pProbe , LogEst nInMul )  {
  WhereInfo *pWInfo =  pBuilder->pWInfo;
  Parse *pParse =  pWInfo->pParse;
  sqlite3 *db =  pParse->db;
  WhereLoop *pNew;
  WhereTerm *pTerm;
  int opMask;
  WhereScan scan;
  Bitmask saved_prereq;
  u16 saved_nLTerm;
  int saved_nEq;
  u32 saved_wsFlags;
  LogEst saved_nOut;
  int iCol;
  int rc =  0;
  LogEst nRowEst;
  LogEst rLogSize;
  WhereTerm *pTop =  0, *pBtm =  0;
  (pNew = pBuilder->pNew);
  if (db->mallocFailed) {
    return 7;
  }  
  ((void ) 0);
  ((void ) 0);
  if ((pNew->wsFlags & 0x00000020)) {
    (opMask = ((0x002 << (79 - 76)) | (0x002 << (78 - 76))));
  } 
  else if (((pProbe->tnum <= 0) || ((pSrc->jointype & 0x0008) != 0))) {
    (opMask = (0x002 | 0x001 | (0x002 << (77 - 76)) | (0x002 << (80 - 76)) | (0x002 << (79 - 76)) | (0x002 << (78 - 76))));
  } 
  else {
    (opMask = (0x002 | 0x001 | 0x080 | (0x002 << (77 - 76)) | (0x002 << (80 - 76)) | (0x002 << (79 - 76)) | (0x002 << (78 - 76))));
  }
  if (pProbe->bUnordered) {
    (opMask &= (~ ((0x002 << (77 - 76)) | (0x002 << (80 - 76)) | (0x002 << (79 - 76)) | (0x002 << (78 - 76)))));
  }  
  ((void ) 0);
  if ((pNew->u.btree.nEq < pProbe->nColumn)) {
    (iCol = pProbe->aiColumn[pNew->u.btree.nEq]);
    (nRowEst = sqlite3LogEst(pProbe->aiRowEst[(pNew->u.btree.nEq + 1)]));
    if (((nRowEst == 0) && (pProbe->onError == 0))) {
      (nRowEst = 1);
    }  
  }  
  else {
    (iCol = (- 1));
    (nRowEst = 0);
  }
  (pTerm = whereScanInit((&scan), pBuilder->pWC, pSrc->iCursor, iCol, opMask, pProbe));
  (saved_nEq = pNew->u.btree.nEq);
  (saved_nLTerm = pNew->nLTerm);
  (saved_wsFlags = pNew->wsFlags);
  (saved_prereq = pNew->prereq);
  (saved_nOut = pNew->nOut);
  (pNew->rSetup = 0);
  (rLogSize = estLog(sqlite3LogEst(pProbe->aiRowEst[0])));
  for (; ((rc == 0) && (pTerm != 0)); (pTerm = whereScanNext((&scan)))) {
    int nIn =  0;
    if ((((pTerm->eOperator == 0x080) || ((pTerm->wtFlags & 0x00) != 0)) && ((iCol < 0) || pSrc->pTab->aCol[iCol].notNull))) {
      continue;
    }  
    if ((pTerm->prereqRight & pNew->maskSelf)) {
      continue;
    }  
    ((void ) 0);
    (pNew->wsFlags = saved_wsFlags);
    (pNew->u.btree.nEq = saved_nEq);
    (pNew->nLTerm = saved_nLTerm);
    if (whereLoopResize(db, pNew, (pNew->nLTerm + 1))) {
      break;
    }  
    (pNew->aLTerm[pNew->nLTerm++] = pTerm);
    (pNew->prereq = ((saved_prereq | pTerm->prereqRight) & (~ pNew->maskSelf)));
    (pNew->rRun = rLogSize);
    if ((pTerm->eOperator & 0x001)) {
      Expr *pExpr =  pTerm->pExpr;
      (pNew->wsFlags |= 0x00000004);
      if (((pExpr->flags & 0x000800) != 0)) {
        (nIn = 46);
        ((void ) 0);
      } 
      else if ((((id2i_sqlite_coverage_test ) ) && 1)) {
        (nIn = sqlite3LogEst(pExpr->x.pList->nExpr));
      }
      
      else if (((((! id2i_sqlite_coverage_test) ) ) && (pExpr->x.pList && pExpr->x.pList->nExpr))) {
        (nIn = sqlite3LogEst(pExpr->x.pList->nExpr));
      } 
      (pNew->rRun += nIn);
      pNew->u.btree.nEq++;
      (pNew->nOut = (nRowEst + nInMul + nIn));
    } 
    else if ((pTerm->eOperator & 0x002)) {
      ((void ) 0);
      (pNew->wsFlags |= 0x00000001);
      if (((iCol < 0) || ((pProbe->onError != 0) && (nInMul == 0) && (pNew->u.btree.nEq == (pProbe->nColumn - 1))))) {
        ((void ) 0);
        (pNew->wsFlags |= 0x00001000);
      }  
      pNew->u.btree.nEq++;
      (pNew->nOut = (nRowEst + nInMul));
    }
    
    else if ((pTerm->eOperator & 0x080)) {
      (pNew->wsFlags |= 0x00000008);
      pNew->u.btree.nEq++;
      (nIn = 10);
      ((void ) 0);
      (pNew->nOut = (nRowEst + nInMul + nIn));
    }
    
    else if ((pTerm->eOperator & ((0x002 << (77 - 76)) | (0x002 << (80 - 76))))) {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pTerm->eOperator & (0x002 << (77 - 76)))) {
          sqlite3Coverage(110816);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pTerm->eOperator & (0x002 << (80 - 76)))) {
          sqlite3Coverage(110817);
        }  
      }  
      (pNew->wsFlags |= (0x00000002 | 0x00000020));
      (pBtm = pTerm);
      (pTop = 0);
    } 
    else {
      ((void ) 0);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pTerm->eOperator & (0x002 << (79 - 76)))) {
          sqlite3Coverage(110823);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((pTerm->eOperator & (0x002 << (78 - 76)))) {
          sqlite3Coverage(110824);
        }  
      }  
      (pNew->wsFlags |= (0x00000002 | 0x00000010));
      (pTop = pTerm);
      (pBtm = (((pNew->wsFlags & 0x00000020) != 0) ? pNew->aLTerm[(pNew->nLTerm - 2)] : 0));
    }
    if ((pNew->wsFlags & 0x00000002)) {
      ((void ) 0);
      whereRangeScanEst(pParse, pBuilder, pBtm, pTop, pNew);
    }  
    if (((pNew->wsFlags & (0x00000040 | 0x00000100)) == 0)) {
      (pNew->rRun = sqlite3LogEstAdd(pNew->rRun, ((rLogSize > 27) ? (rLogSize - 17) : 10)));
    }  
    (pNew->rRun = sqlite3LogEstAdd(pNew->rRun, pNew->nOut));
    whereLoopOutputAdjust(pBuilder->pWC, pNew);
    (rc = whereLoopInsert(pBuilder, pNew));
    if ((((pNew->wsFlags & 0x00000010) == 0) && (pNew->u.btree.nEq < (pProbe->nColumn + (pProbe->zName != 0))))) {
      whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, (nInMul + nIn));
    }  
    (pNew->nOut = saved_nOut);
  }
  (pNew->prereq = saved_prereq);
  (pNew->u.btree.nEq = saved_nEq);
  (pNew->wsFlags = saved_wsFlags);
  (pNew->nOut = saved_nOut);
  (pNew->nLTerm = saved_nLTerm);
  return rc;
}
static  int indexMightHelpWithOrderBy(WhereLoopBuilder *pBuilder , Index *pIndex , int iCursor )  {
  ExprList *pOB;
  int ii, jj;
  if (pIndex->bUnordered) {
    return 0;
  }  
  if (((pOB = pBuilder->pWInfo->pOrderBy) == 0)) {
    return 0;
  }  
  for ((ii = 0); (ii < pOB->nExpr); ii++) {
    Expr *pExpr =  sqlite3ExprSkipCollate(pOB->a[ii].pExpr);
    if ((pExpr->op != 152)) {
      return 0;
    }  
    if ((pExpr->iTable == iCursor)) {
      for ((jj = 0); (jj < pIndex->nColumn); jj++) {
        if ((pExpr->iColumn == pIndex->aiColumn[jj])) {
          return 1;
        }  
      }
    }  
  }
  return 0;
}
static  Bitmask columnsInIndex(Index *pIdx )  {
  Bitmask m =  0;
  int j;
  for ((j = (pIdx->nColumn - 1)); (j >= 0); j--) {
    int x =  pIdx->aiColumn[j];
    ((void ) 0);
    if (((id2i_sqlite_coverage_test ) )) {
      if ((x == (((int ) (sizeof(Bitmask ) * 8)) - 1))) {
        sqlite3Coverage(110925);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((x == (((int ) (sizeof(Bitmask ) * 8)) - 2))) {
        sqlite3Coverage(110926);
      }  
    }  
    if ((x < (((int ) (sizeof(Bitmask ) * 8)) - 1))) {
      (m |= (((Bitmask ) 1) << x));
    }  
  }
  return m;
}
static  int whereUsablePartialIndex(int iTab , WhereClause *pWC , Expr *pWhere )  {
  int i;
  WhereTerm *pTerm;
  for ((i = 0), (pTerm = pWC->a); (i < pWC->nTerm); i++, pTerm++) {
    if (sqlite3ExprImpliesExpr(pTerm->pExpr, pWhere, iTab)) {
      return 1;
    }  
  }
  return 0;
}
static  int whereLoopAddBtree(WhereLoopBuilder *pBuilder , Bitmask mExtra )  {
  WhereInfo *pWInfo;
  Index *pProbe;
  Index sPk;
  tRowcnt aiRowEstPk[2];
  int aiColumnPk =  (- 1);
  SrcList *pTabList;
  struct  SrcList_item   *pSrc;
  WhereLoop *pNew;
  int rc =  0;
  int iSortIdx =  1;
  int b;
  LogEst rSize;
  LogEst rLogSize;
  WhereClause *pWC;
  Table *pTab;
  (pNew = pBuilder->pNew);
  (pWInfo = pBuilder->pWInfo);
  (pTabList = pWInfo->pTabList);
  (pSrc = (pTabList->a + pNew->iTab));
  (pTab = pSrc->pTab);
  (pWC = pBuilder->pWC);
  ((void ) 0);
  if (pSrc->pIndex) {
    (pProbe = pSrc->pIndex);
  }  
  else {
    Index *pFirst;
    memset((&sPk), 0, sizeof(Index ));
    (sPk.nColumn = 1);
    (sPk.aiColumn = (&aiColumnPk));
    (sPk.aiRowEst = aiRowEstPk);
    (sPk.onError = 5);
    (sPk.pTable = pTab);
    (aiRowEstPk[0] = pTab->nRowEst);
    (aiRowEstPk[1] = 1);
    (pFirst = pSrc->pTab->pIndex);
    if ((pSrc->notIndexed == 0)) {
      (sPk.pNext = pFirst);
    }  
    (pProbe = (&sPk));
  }
  (rSize = sqlite3LogEst(pTab->nRowEst));
  (rLogSize = estLog(rSize));
  if (((! pBuilder->pOrSet) && ((pWInfo->pParse->db->flags & 0x00100000) != 0) && (pSrc->pIndex == 0) && (! pSrc->viaCoroutine) && (! pSrc->notIndexed) && (! pSrc->isCorrelated))) {
    WhereTerm *pTerm;
    WhereTerm *pWCEnd =  (pWC->a + pWC->nTerm);
    for ((pTerm = pWC->a); ((rc == 0) && (pTerm < pWCEnd)); pTerm++) {
      if ((pTerm->prereqRight & pNew->maskSelf)) {
        continue;
      }  
      if (termCanDriveIndex(pTerm, pSrc, 0)) {
        (pNew->u.btree.nEq = 1);
        (pNew->u.btree.pIndex = 0);
        (pNew->nLTerm = 1);
        (pNew->aLTerm[0] = pTerm);
        (pNew->rSetup = (rLogSize + rSize + 28));
        ((void ) 0);
        (pNew->nOut = 43);
        ((void ) 0);
        (pNew->rRun = sqlite3LogEstAdd(rLogSize, pNew->nOut));
        (pNew->wsFlags = 0x00004000);
        (pNew->prereq = (mExtra | pTerm->prereqRight));
        (rc = whereLoopInsert(pBuilder, pNew));
      }  
    }
  }  
  for (; ((rc == 0) && pProbe); (pProbe = pProbe->pNext), iSortIdx++) {
    if (((pProbe->pPartIdxWhere != 0) && (! whereUsablePartialIndex(pNew->iTab, pWC, pProbe->pPartIdxWhere)))) {
      continue;
    }  
    (pNew->u.btree.nEq = 0);
    (pNew->nLTerm = 0);
    (pNew->iSortIdx = 0);
    (pNew->rSetup = 0);
    (pNew->prereq = mExtra);
    (pNew->nOut = rSize);
    (pNew->u.btree.pIndex = pProbe);
    (b = indexMightHelpWithOrderBy(pBuilder, pProbe, pSrc->iCursor));
    ((void ) 0);
    if ((pProbe->tnum <= 0)) {
      (pNew->wsFlags = 0x00000100);
      (pNew->iSortIdx = (b ? iSortIdx : 0));
      (pNew->rRun = (sqlite3LogEstAdd(rSize, rLogSize) + 16));
      whereLoopOutputAdjust(pWC, pNew);
      (rc = whereLoopInsert(pBuilder, pNew));
      (pNew->nOut = rSize);
      if (rc) {
        break;
      }  
    }  
    else {
      Bitmask m =  (pSrc->colUsed & (~ columnsInIndex(pProbe)));
      (pNew->wsFlags = ((m == 0) ? (0x00000040 | 0x00000200) : 0x00000200));
      if (((id2i_sqlite_omit_builtin_test && (! id2i_sqlite_default_memstatus)) )) {
        if ((b || ((m == 0) && (pProbe->bUnordered == 0) && (pProbe->szIdxRow < pTab->szTabRow) && ((pWInfo->wctrlFlags & 0x0004) == 0) && _1283_sqlite3Config.bUseCis && 1))) {
          (pNew->iSortIdx = (b ? iSortIdx : 0));
          if ((m == 0)) {
            (pNew->rRun = (sqlite3LogEstAdd(rSize, rLogSize) + 1 + ((15 * pProbe->szIdxRow) / pTab->szTabRow)));
          }  
          else {
            ((void ) 0);
            (pNew->rRun = (rSize + rLogSize));
          }
          whereLoopOutputAdjust(pWC, pNew);
          (rc = whereLoopInsert(pBuilder, pNew));
          (pNew->nOut = rSize);
          if (rc) {
            break;
          }  
        }  
      }  
      if (((id2i_sqlite_omit_builtin_test && id2i_sqlite_default_memstatus) )) {
        if ((b || ((m == 0) && (pProbe->bUnordered == 0) && (pProbe->szIdxRow < pTab->szTabRow) && ((pWInfo->wctrlFlags & 0x0004) == 0) && _1284_sqlite3Config.bUseCis && 1))) {
          (pNew->iSortIdx = (b ? iSortIdx : 0));
          if ((m == 0)) {
            (pNew->rRun = (sqlite3LogEstAdd(rSize, rLogSize) + 1 + ((15 * pProbe->szIdxRow) / pTab->szTabRow)));
          }  
          else {
            ((void ) 0);
            (pNew->rRun = (rSize + rLogSize));
          }
          whereLoopOutputAdjust(pWC, pNew);
          (rc = whereLoopInsert(pBuilder, pNew));
          (pNew->nOut = rSize);
          if (rc) {
            break;
          }  
        }  
      }  
      if ((((! id2i_sqlite_omit_builtin_test) && (! id2i_sqlite_default_memstatus)) )) {
        if ((b || ((m == 0) && (pProbe->bUnordered == 0) && (pProbe->szIdxRow < pTab->szTabRow) && ((pWInfo->wctrlFlags & 0x0004) == 0) && _1283_sqlite3Config.bUseCis && ((pWInfo->pParse->db->dbOptFlags & 0x0040) == 0)))) {
          (pNew->iSortIdx = (b ? iSortIdx : 0));
          if ((m == 0)) {
            (pNew->rRun = (sqlite3LogEstAdd(rSize, rLogSize) + 1 + ((15 * pProbe->szIdxRow) / pTab->szTabRow)));
          }  
          else {
            ((void ) 0);
            (pNew->rRun = (rSize + rLogSize));
          }
          whereLoopOutputAdjust(pWC, pNew);
          (rc = whereLoopInsert(pBuilder, pNew));
          (pNew->nOut = rSize);
          if (rc) {
            break;
          }  
        }  
      }  
      if ((((! id2i_sqlite_omit_builtin_test) && id2i_sqlite_default_memstatus) )) {
        if ((b || ((m == 0) && (pProbe->bUnordered == 0) && (pProbe->szIdxRow < pTab->szTabRow) && ((pWInfo->wctrlFlags & 0x0004) == 0) && _1284_sqlite3Config.bUseCis && ((pWInfo->pParse->db->dbOptFlags & 0x0040) == 0)))) {
          (pNew->iSortIdx = (b ? iSortIdx : 0));
          if ((m == 0)) {
            (pNew->rRun = (sqlite3LogEstAdd(rSize, rLogSize) + 1 + ((15 * pProbe->szIdxRow) / pTab->szTabRow)));
          }  
          else {
            ((void ) 0);
            (pNew->rRun = (rSize + rLogSize));
          }
          whereLoopOutputAdjust(pWC, pNew);
          (rc = whereLoopInsert(pBuilder, pNew));
          (pNew->nOut = rSize);
          if (rc) {
            break;
          }  
        }  
      }  
    }
    (rc = whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, 0));
    if (pSrc->pIndex) {
      break;
    }  
  }
  return rc;
}
static  int whereLoopAddVirtual(WhereLoopBuilder *pBuilder )  {
  WhereInfo *pWInfo;
  Parse *pParse;
  WhereClause *pWC;
  struct  SrcList_item   *pSrc;
  Table *pTab;
  sqlite3 *db;
  sqlite3_index_info *pIdxInfo;
  struct  sqlite3_index_constraint   *pIdxCons;
  struct  sqlite3_index_constraint_usage   *pUsage;
  WhereTerm *pTerm;
  int i, j;
  int iTerm, mxTerm;
  int nConstraint;
  int seenIn =  0;
  int seenVar =  0;
  int iPhase;
  WhereLoop *pNew;
  int rc =  0;
  (pWInfo = pBuilder->pWInfo);
  (pParse = pWInfo->pParse);
  (db = pParse->db);
  (pWC = pBuilder->pWC);
  (pNew = pBuilder->pNew);
  (pSrc = (&pWInfo->pTabList->a[pNew->iTab]));
  (pTab = pSrc->pTab);
  ((void ) 0);
  (pIdxInfo = allocateIndexInfo(pParse, pWC, pSrc, pBuilder->pOrderBy));
  if ((pIdxInfo == 0)) {
    return 7;
  }  
  (pNew->prereq = 0);
  (pNew->rSetup = 0);
  (pNew->wsFlags = 0x00000400);
  (pNew->nLTerm = 0);
  (pNew->u.vtab.needFree = 0);
  (pUsage = pIdxInfo->aConstraintUsage);
  (nConstraint = pIdxInfo->nConstraint);
  if (whereLoopResize(db, pNew, nConstraint)) {
    sqlite3DbFree(db, pIdxInfo);
    return 7;
  }  
  for ((iPhase = 0); (iPhase <= 3); iPhase++) {
    if (((! seenIn) && ((iPhase & 1) != 0))) {
      iPhase++;
      if ((iPhase > 3)) {
        break;
      }  
    }  
    if (((! seenVar) && (iPhase > 1))) {
      break;
    }  
    (pIdxCons = (*((struct  sqlite3_index_constraint   **) (&pIdxInfo->aConstraint))));
    for ((i = 0); (i < pIdxInfo->nConstraint); i++, pIdxCons++) {
      (j = pIdxCons->iTermOffset);
      (pTerm = (&pWC->a[j]));
      switch (iPhase) {
        case 0:
        (pIdxCons->usable = 0);
        if (((pTerm->eOperator & 0x001) != 0)) {
          (seenIn = 1);
        }  
        if ((pTerm->prereqRight != 0)) {
          (seenVar = 1);
        } 
        else if (((pTerm->eOperator & 0x001) == 0)) {
          (pIdxCons->usable = 1);
        } 
        break;
        case 1:
        ((void ) 0);
        (pIdxCons->usable = (pTerm->prereqRight == 0));
        break;
        case 2:
        ((void ) 0);
        (pIdxCons->usable = ((pTerm->eOperator & 0x001) == 0));
        break;
        id2i_label_1:
        default:
        ((void ) 0);
        (pIdxCons->usable = 1);
        break;
      }
    }
    memset(pUsage, 0, (sizeof(pUsage[0]) * pIdxInfo->nConstraint));
    if (pIdxInfo->needToFreeIdxStr) {
      sqlite3_free(pIdxInfo->idxStr);
    }  
    (pIdxInfo->idxStr = 0);
    (pIdxInfo->idxNum = 0);
    (pIdxInfo->needToFreeIdxStr = 0);
    (pIdxInfo->orderByConsumed = 0);
    (pIdxInfo->estimatedCost = (1e99 / ((double ) 2)));
    (rc = vtabBestIndex(pParse, pTab, pIdxInfo));
    if (rc) {
      goto whereLoopAddVtab_exit;
    }  
    (pIdxCons = (*((struct  sqlite3_index_constraint   **) (&pIdxInfo->aConstraint))));
    (pNew->prereq = 0);
    (mxTerm = (- 1));
    ((void ) 0);
    for ((i = 0); (i < nConstraint); i++) {
      (pNew->aLTerm[i] = 0);
    }
    (pNew->u.vtab.omitMask = 0);
    for ((i = 0); (i < nConstraint); i++, pIdxCons++) {
      if (((iTerm = (pUsage[i].argvIndex - 1)) >= 0)) {
        (j = pIdxCons->iTermOffset);
        if (((iTerm >= nConstraint) || (j < 0) || (j >= pWC->nTerm) || (pNew->aLTerm[iTerm] != 0))) {
          (rc = 1);
          sqlite3ErrorMsg(pParse, "%s.xBestIndex() malfunction", pTab->zName);
          goto whereLoopAddVtab_exit;
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((iTerm == (nConstraint - 1))) {
            sqlite3Coverage(111235);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((j == 0)) {
            sqlite3Coverage(111236);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((j == (pWC->nTerm - 1))) {
            sqlite3Coverage(111237);
          }  
        }  
        (pTerm = (&pWC->a[j]));
        (pNew->prereq |= pTerm->prereqRight);
        ((void ) 0);
        (pNew->aLTerm[iTerm] = pTerm);
        if ((iTerm > mxTerm)) {
          (mxTerm = iTerm);
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((iTerm == 15)) {
            sqlite3Coverage(111243);
          }  
        }  
        if (((id2i_sqlite_coverage_test ) )) {
          if ((iTerm == 16)) {
            sqlite3Coverage(111244);
          }  
        }  
        if (((iTerm < 16) && pUsage[i].omit)) {
          (pNew->u.vtab.omitMask |= (1 << iTerm));
        }  
        if (((pTerm->eOperator & 0x001) != 0)) {
          if ((pUsage[i].omit == 0)) {
            break;
          }  
          (pIdxInfo->orderByConsumed = 0);
        }  
      }  
    }
    if ((i >= nConstraint)) {
      (pNew->nLTerm = (mxTerm + 1));
      ((void ) 0);
      (pNew->u.vtab.idxNum = pIdxInfo->idxNum);
      (pNew->u.vtab.needFree = pIdxInfo->needToFreeIdxStr);
      (pIdxInfo->needToFreeIdxStr = 0);
      (pNew->u.vtab.idxStr = pIdxInfo->idxStr);
      (pNew->u.vtab.isOrdered = ((u8 ) ((pIdxInfo->nOrderBy != 0) && pIdxInfo->orderByConsumed)));
      (pNew->rSetup = 0);
      (pNew->rRun = sqlite3LogEstFromDouble(pIdxInfo->estimatedCost));
      (pNew->nOut = 46);
      ((void ) 0);
      whereLoopInsert(pBuilder, pNew);
      if (pNew->u.vtab.needFree) {
        sqlite3_free(pNew->u.vtab.idxStr);
        (pNew->u.vtab.needFree = 0);
      }  
    }  
  }
  whereLoopAddVtab_exit:
  if (pIdxInfo->needToFreeIdxStr) {
    sqlite3_free(pIdxInfo->idxStr);
  }  
  sqlite3DbFree(db, pIdxInfo);
  return rc;
}
static  int whereLoopAddOr(WhereLoopBuilder *pBuilder , Bitmask mExtra )  {
  WhereInfo *pWInfo =  pBuilder->pWInfo;
  WhereClause *pWC;
  WhereLoop *pNew;
  WhereTerm *pTerm, *pWCEnd;
  int rc =  0;
  int iCur;
  WhereClause tempWC;
  WhereLoopBuilder sSubBuild;
  WhereOrSet sSum, sCur, sPrev;
  struct  SrcList_item   *pItem;
  (pWC = pBuilder->pWC);
  if ((pWInfo->wctrlFlags & 0x0080)) {
    return 0;
  }  
  (pWCEnd = (pWC->a + pWC->nTerm));
  (pNew = pBuilder->pNew);
  memset((&sSum), 0, sizeof(sSum));
  (pItem = (pWInfo->pTabList->a + pNew->iTab));
  (iCur = pItem->iCursor);
  for ((pTerm = pWC->a); ((pTerm < pWCEnd) && (rc == 0)); pTerm++) {
    if ((((pTerm->eOperator & 0x100) != 0) && ((pTerm->u.pOrInfo->indexable & pNew->maskSelf) != 0))) {
      WhereClause *const pOrWC =  (&pTerm->u.pOrInfo->wc);
      WhereTerm *const pOrWCEnd =  (&pOrWC->a[pOrWC->nTerm]);
      WhereTerm *pOrTerm;
      int once =  1;
      int i, j;
      (sSubBuild = (*pBuilder));
      (sSubBuild.pOrderBy = 0);
      (sSubBuild.pOrSet = (&sCur));
      for ((pOrTerm = pOrWC->a); (pOrTerm < pOrWCEnd); pOrTerm++) {
        if (((pOrTerm->eOperator & 0x200) != 0)) {
          (sSubBuild.pWC = (&pOrTerm->u.pAndInfo->wc));
        } 
        else if ((pOrTerm->leftCursor == iCur)) {
          (tempWC.pWInfo = pWC->pWInfo);
          (tempWC.pOuter = pWC);
          (tempWC.op = 69);
          (tempWC.nTerm = 1);
          (tempWC.a = pOrTerm);
          (sSubBuild.pWC = (&tempWC));
        } 
        else {
          continue;
        }
        (sCur.n = 0);
        if (((pItem->pTab->tabFlags & 0x10) != 0)) {
          (rc = whereLoopAddVirtual((&sSubBuild)));
          for ((i = 0); (i < sCur.n); i++) {
            (sCur.a[i].prereq |= mExtra);
          }
        }  
        else {
          (rc = whereLoopAddBtree((&sSubBuild), mExtra));
        }
        ((void ) 0);
        if ((sCur.n == 0)) {
          (sSum.n = 0);
          break;
        } 
        else if (once) {
          whereOrMove((&sSum), (&sCur));
          (once = 0);
        } 
        else {
          whereOrMove((&sPrev), (&sSum));
          (sSum.n = 0);
          for ((i = 0); (i < sPrev.n); i++) {
            for ((j = 0); (j < sCur.n); j++) {
              whereOrInsert((&sSum), (sPrev.a[i].prereq | sCur.a[j].prereq), sqlite3LogEstAdd(sPrev.a[i].rRun, sCur.a[j].rRun), sqlite3LogEstAdd(sPrev.a[i].nOut, sCur.a[j].nOut));
            }
          }
        }
      }
      (pNew->nLTerm = 1);
      (pNew->aLTerm[0] = pTerm);
      (pNew->wsFlags = 0x00002000);
      (pNew->rSetup = 0);
      (pNew->iSortIdx = 0);
      memset((&pNew->u), 0, sizeof(pNew->u));
      for ((i = 0); ((rc == 0) && (i < sSum.n)); i++) {
        (pNew->rRun = (sSum.a[i].rRun + 18));
        (pNew->nOut = sSum.a[i].nOut);
        (pNew->prereq = sSum.a[i].prereq);
        (rc = whereLoopInsert(pBuilder, pNew));
      }
    }  
  }
  return rc;
}
static  int whereLoopAddAll(WhereLoopBuilder *pBuilder )  {
  WhereInfo *pWInfo =  pBuilder->pWInfo;
  Bitmask mExtra =  0;
  Bitmask mPrior =  0;
  int iTab;
  SrcList *pTabList =  pWInfo->pTabList;
  struct  SrcList_item   *pItem;
  sqlite3 *db =  pWInfo->pParse->db;
  int nTabList =  pWInfo->nLevel;
  int rc =  0;
  u8 priorJoinType =  0;
  WhereLoop *pNew;
  (pNew = pBuilder->pNew);
  whereLoopInit(pNew);
  for ((iTab = 0), (pItem = pTabList->a); (iTab < nTabList); iTab++, pItem++) {
    (pNew->iTab = iTab);
    (pNew->maskSelf = getMask((&pWInfo->sMaskSet), pItem->iCursor));
    if ((((pItem->jointype | priorJoinType) & (0x0008 | 0x0002)) != 0)) {
      (mExtra = mPrior);
    }  
    (priorJoinType = pItem->jointype);
    if (((pItem->pTab->tabFlags & 0x10) != 0)) {
      (rc = whereLoopAddVirtual(pBuilder));
    }  
    else {
      (rc = whereLoopAddBtree(pBuilder, mExtra));
    }
    if ((rc == 0)) {
      (rc = whereLoopAddOr(pBuilder, mExtra));
    }  
    (mPrior |= pNew->maskSelf);
    if ((rc || db->mallocFailed)) {
      break;
    }  
  }
  whereLoopClear(db, pNew);
  return rc;
}
static  int wherePathSatisfiesOrderBy(WhereInfo *pWInfo , ExprList *pOrderBy , WherePath *pPath , u16 wctrlFlags , u16 nLoop , WhereLoop *pLast , Bitmask *pRevMask )  {
  u8 revSet;
  u8 rev;
  u8 revIdx;
  u8 isOrderDistinct;
  u8 distinctColumns;
  u8 isMatch;
  u16 nColumn;
  u16 nOrderBy;
  int iLoop;
  int i, j;
  int iCur;
  int iColumn;
  WhereLoop *pLoop =  0;
  WhereTerm *pTerm;
  Expr *pOBExpr;
  CollSeq *pColl;
  Index *pIndex;
  sqlite3 *db =  pWInfo->pParse->db;
  Bitmask obSat =  0;
  Bitmask obDone;
  Bitmask orderDistinctMask;
  Bitmask ready;
  ((void ) 0);
  if ((pLast->wsFlags & 0x00000400)) {
    if (((id2i_sqlite_coverage_test ) )) {
      if ((nLoop > 0)) {
        sqlite3Coverage(111506);
      }  
    }  
    return pLast->u.vtab.isOrdered;
  }  
  if (((id2i_sqlite_omit_builtin_test ) )) {
    if ((nLoop && 0)) {
      return 0;
    }  
  }  
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    if ((nLoop && ((db->dbOptFlags & 0x0080) != 0))) {
      return 0;
    }  
  }  
  (nOrderBy = pOrderBy->nExpr);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((nOrderBy == (((int ) (sizeof(Bitmask ) * 8)) - 1))) {
      sqlite3Coverage(111513);
    }  
  }  
  if ((nOrderBy > (((int ) (sizeof(Bitmask ) * 8)) - 1))) {
    return 0;
  }  
  (isOrderDistinct = 1);
  (obDone = ((((Bitmask ) 1) << nOrderBy) - 1));
  (orderDistinctMask = 0);
  (ready = 0);
  for ((iLoop = 0); (isOrderDistinct && (obSat < obDone) && (iLoop <= nLoop)); iLoop++) {
    if ((iLoop > 0)) {
      (ready |= pLoop->maskSelf);
    }  
    (pLoop = ((iLoop < nLoop) ? pPath->aLoop[iLoop] : pLast));
    ((void ) 0);
    (iCur = pWInfo->pTabList->a[pLoop->iTab].iCursor);
    for ((i = 0); (i < nOrderBy); i++) {
      if (((((Bitmask ) 1) << i) & obSat)) {
        continue;
      }  
      (pOBExpr = sqlite3ExprSkipCollate(pOrderBy->a[i].pExpr));
      if ((pOBExpr->op != 152)) {
        continue;
      }  
      if ((pOBExpr->iTable != iCur)) {
        continue;
      }  
      (pTerm = findTerm((&pWInfo->sWC), iCur, pOBExpr->iColumn, (~ ready), (0x002 | 0x080), 0));
      if ((pTerm == 0)) {
        continue;
      }  
      if ((((pTerm->eOperator & 0x002) != 0) && (pOBExpr->iColumn >= 0))) {
        const char *z1, *z2;
        (pColl = sqlite3ExprCollSeq(pWInfo->pParse, pOrderBy->a[i].pExpr));
        if ((! pColl)) {
          (pColl = db->pDfltColl);
        }  
        (z1 = pColl->zName);
        (pColl = sqlite3ExprCollSeq(pWInfo->pParse, pTerm->pExpr));
        if ((! pColl)) {
          (pColl = db->pDfltColl);
        }  
        (z2 = pColl->zName);
        if ((sqlite3_stricmp(z1, z2) != 0)) {
          continue;
        }  
      }  
      (obSat |= (((Bitmask ) 1) << i));
    }
    if (((pLoop->wsFlags & 0x00001000) == 0)) {
      if ((pLoop->wsFlags & 0x00000100)) {
        (pIndex = 0);
        (nColumn = 0);
      } 
      else if ((((pIndex = pLoop->u.btree.pIndex) == 0) || pIndex->bUnordered)) {
        return 0;
      } 
      else {
        (nColumn = pIndex->nColumn);
        (isOrderDistinct = (pIndex->onError != 0));
      }
      (rev = (revSet = 0));
      (distinctColumns = 0);
      for ((j = 0); (j <= nColumn); j++) {
        u8 bOnce;
        if (((j < pLoop->u.btree.nEq) && (((i = pLoop->aLTerm[j]->eOperator) & (0x002 | 0x080)) != 0))) {
          if ((i & 0x080)) {
            if (((id2i_sqlite_coverage_test ) )) {
              if (isOrderDistinct) {
                sqlite3Coverage(111575);
              }  
            }  
            (isOrderDistinct = 0);
          }  
          continue;
        }  
        if ((j < nColumn)) {
          (iColumn = pIndex->aiColumn[j]);
          (revIdx = pIndex->aSortOrder[j]);
          if ((iColumn == pIndex->pTable->iPKey)) {
            (iColumn = (- 1));
          }  
        }  
        else {
          ((void ) 0);
          (iColumn = (- 1));
          (revIdx = 0);
        }
        if ((isOrderDistinct && (iColumn >= 0) && (j >= pLoop->u.btree.nEq) && (pIndex->pTable->aCol[iColumn].notNull == 0))) {
          (isOrderDistinct = 0);
        }  
        (bOnce = 1);
        (isMatch = 0);
        for ((i = 0); (bOnce && (i < nOrderBy)); i++) {
          if (((((Bitmask ) 1) << i) & obSat)) {
            continue;
          }  
          (pOBExpr = sqlite3ExprSkipCollate(pOrderBy->a[i].pExpr));
          if (((id2i_sqlite_coverage_test ) )) {
            if ((wctrlFlags & 0x0100)) {
              sqlite3Coverage(111615);
            }  
          }  
          if (((id2i_sqlite_coverage_test ) )) {
            if ((wctrlFlags & 0x0200)) {
              sqlite3Coverage(111616);
            }  
          }  
          if (((wctrlFlags & (0x0100 | 0x0200)) == 0)) {
            (bOnce = 0);
          }  
          if ((pOBExpr->op != 152)) {
            continue;
          }  
          if ((pOBExpr->iTable != iCur)) {
            continue;
          }  
          if ((pOBExpr->iColumn != iColumn)) {
            continue;
          }  
          if ((iColumn >= 0)) {
            (pColl = sqlite3ExprCollSeq(pWInfo->pParse, pOrderBy->a[i].pExpr));
            if ((! pColl)) {
              (pColl = db->pDfltColl);
            }  
            if ((sqlite3_stricmp(pColl->zName, pIndex->azColl[j]) != 0)) {
              continue;
            }  
          }  
          (isMatch = 1);
          break;
        }
        if (isMatch) {
          if ((iColumn < 0)) {
            if (((id2i_sqlite_coverage_test ) )) {
              if ((distinctColumns == 0)) {
                sqlite3Coverage(111631);
              }  
            }  
            (distinctColumns = 1);
          }  
          (obSat |= (((Bitmask ) 1) << i));
          if (((pWInfo->wctrlFlags & 0x0100) == 0)) {
            if (revSet) {
              if (((rev ^ revIdx) != pOrderBy->a[i].sortOrder)) {
                return 0;
              }  
            }  
            else {
              (rev = (revIdx ^ pOrderBy->a[i].sortOrder));
              if (rev) {
                ((*pRevMask) |= (((Bitmask ) 1) << iLoop));
              }  
              (revSet = 1);
            }
          }  
        }  
        else {
          if (((j == 0) || (j < nColumn))) {
            if (((id2i_sqlite_coverage_test ) )) {
              if ((isOrderDistinct != 0)) {
                sqlite3Coverage(111649);
              }  
            }  
            (isOrderDistinct = 0);
          }  
          break;
        }
      }
      if (distinctColumns) {
        if (((id2i_sqlite_coverage_test ) )) {
          if ((isOrderDistinct == 0)) {
            sqlite3Coverage(111656);
          }  
        }  
        (isOrderDistinct = 1);
      }  
    }  
    if (isOrderDistinct) {
      (orderDistinctMask |= pLoop->maskSelf);
      for ((i = 0); (i < nOrderBy); i++) {
        Expr *p;
        if (((((Bitmask ) 1) << i) & obSat)) {
          continue;
        }  
        (p = pOrderBy->a[i].pExpr);
        if (((exprTableUsage((&pWInfo->sMaskSet), p) & (~ orderDistinctMask)) == 0)) {
          (obSat |= (((Bitmask ) 1) << i));
        }  
      }
    }  
  }
  if ((obSat == obDone)) {
    return 1;
  }  
  if ((! isOrderDistinct)) {
    return 0;
  }  
  return (- 1);
}
static  int wherePathSolver(WhereInfo *pWInfo , LogEst nRowEst )  {
  int mxChoice;
  int nLoop;
  Parse *pParse;
  sqlite3 *db;
  int iLoop;
  int ii, jj;
  int mxI =  0;
  LogEst rCost;
  LogEst nOut;
  LogEst mxCost =  0;
  LogEst mxOut =  0;
  LogEst rSortCost;
  int nTo, nFrom;
  WherePath *aFrom;
  WherePath *aTo;
  WherePath *pFrom;
  WherePath *pTo;
  WhereLoop *pWLoop;
  WhereLoop **pX;
  char *pSpace;
  (pParse = pWInfo->pParse);
  (db = pParse->db);
  (nLoop = pWInfo->nLevel);
  (mxChoice = ((nLoop == 1) ? 1 : ((nLoop == 2) ? 5 : 10)));
  ((void ) 0);
  (ii = ((sizeof(WherePath ) + (sizeof(WhereLoop *) * nLoop)) * mxChoice * 2));
  (pSpace = sqlite3DbMallocRaw(db, ii));
  if ((pSpace == 0)) {
    return 7;
  }  
  (aTo = ((WherePath *) pSpace));
  (aFrom = (aTo + mxChoice));
  memset(aFrom, 0, sizeof(aFrom[0]));
  (pX = ((WhereLoop **) (aFrom + mxChoice)));
  for ((ii = (mxChoice * 2)), (pFrom = aTo); (ii > 0); ii--, pFrom++, (pX += nLoop)) {
    (pFrom->aLoop = pX);
  }
  (aFrom[0].nRow = ((pParse->nQueryLoop < 46) ? pParse->nQueryLoop : 46));
  ((void ) 0);
  (nFrom = 1);
  (rSortCost = 0);
  if (((pWInfo->pOrderBy == 0) || (nRowEst == 0))) {
    (aFrom[0].isOrderedValid = 1);
  }  
  else {
    (rSortCost = (nRowEst + estLog(nRowEst)));
  }
  for ((iLoop = 0); (iLoop < nLoop); iLoop++) {
    (nTo = 0);
    for ((ii = 0), (pFrom = aFrom); (ii < nFrom); ii++, pFrom++) {
      for ((pWLoop = pWInfo->pLoops); pWLoop; (pWLoop = pWLoop->pNextLoop)) {
        Bitmask maskNew;
        Bitmask revMask =  0;
        u8 isOrderedValid =  pFrom->isOrderedValid;
        u8 isOrdered =  pFrom->isOrdered;
        if (((pWLoop->prereq & (~ pFrom->maskLoop)) != 0)) {
          continue;
        }  
        if (((pWLoop->maskSelf & pFrom->maskLoop) != 0)) {
          continue;
        }  
        (rCost = sqlite3LogEstAdd(pWLoop->rSetup, (pWLoop->rRun + pFrom->nRow)));
        (rCost = sqlite3LogEstAdd(rCost, pFrom->rCost));
        (nOut = (pFrom->nRow + pWLoop->nOut));
        (maskNew = (pFrom->maskLoop | pWLoop->maskSelf));
        if ((! isOrderedValid)) {
          switch (wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy, pFrom, pWInfo->wctrlFlags, iLoop, pWLoop, (&revMask))) {
            case 1:
            (isOrdered = 1);
            (isOrderedValid = 1);
            break;
            case 0:
            (isOrdered = 0);
            (isOrderedValid = 1);
            (rCost = sqlite3LogEstAdd(rCost, rSortCost));
            break;
            id2i_label_1:
            default:
            break;
          }
        }  
        else {
          (revMask = pFrom->revLoop);
        }
        for ((jj = 0), (pTo = aTo); (jj < nTo); jj++, pTo++) {
          if (((pTo->maskLoop == maskNew) && (pTo->isOrderedValid == isOrderedValid) && (((pTo->rCost <= rCost) && (pTo->nRow <= nOut)) || ((pTo->rCost >= rCost) && (pTo->nRow >= nOut))))) {
            if (((id2i_sqlite_coverage_test ) )) {
              if ((jj == (nTo - 1))) {
                sqlite3Coverage(111815);
              }  
            }  
            break;
          }  
        }
        if ((jj >= nTo)) {
          if (((nTo >= mxChoice) && (rCost >= mxCost))) {
            continue;
          }  
          if ((nTo < mxChoice)) {
            (jj = nTo++);
          }  
          else {
            (jj = mxI);
          }
          (pTo = (&aTo[jj]));
        }  
        else {
          if (((pTo->rCost <= rCost) && (pTo->nRow <= nOut))) {
            if (((id2i_sqlite_coverage_test ) )) {
              if ((pTo->rCost == rCost)) {
                sqlite3Coverage(111859);
              }  
            }  
            continue;
          }  
          if (((id2i_sqlite_coverage_test ) )) {
            if ((pTo->rCost == (rCost + 1))) {
              sqlite3Coverage(111862);
            }  
          }  
        }
        (pTo->maskLoop = (pFrom->maskLoop | pWLoop->maskSelf));
        (pTo->revLoop = revMask);
        (pTo->nRow = nOut);
        (pTo->rCost = rCost);
        (pTo->isOrderedValid = isOrderedValid);
        (pTo->isOrdered = isOrdered);
        memcpy(pTo->aLoop, pFrom->aLoop, (sizeof(WhereLoop *) * iLoop));
        (pTo->aLoop[iLoop] = pWLoop);
        if ((nTo >= mxChoice)) {
          (mxI = 0);
          (mxCost = aTo[0].rCost);
          (mxOut = aTo[0].nRow);
          for ((jj = 1), (pTo = (&aTo[1])); (jj < mxChoice); jj++, pTo++) {
            if (((pTo->rCost > mxCost) || ((pTo->rCost == mxCost) && (pTo->nRow > mxOut)))) {
              (mxCost = pTo->rCost);
              (mxOut = pTo->nRow);
              (mxI = jj);
            }  
          }
        }  
      }
    }
    (pFrom = aTo);
    (aTo = aFrom);
    (aFrom = pFrom);
    (nFrom = nTo);
  }
  if ((nFrom == 0)) {
    sqlite3ErrorMsg(pParse, "no query solution");
    sqlite3DbFree(db, pSpace);
    return 1;
  }  
  (pFrom = aFrom);
  for ((ii = 1); (ii < nFrom); ii++) {
    if ((pFrom->rCost > aFrom[ii].rCost)) {
      (pFrom = (&aFrom[ii]));
    }  
  }
  ((void ) 0);
  for ((iLoop = 0); (iLoop < nLoop); iLoop++) {
    WhereLevel *pLevel =  (pWInfo->a + iLoop);
    (pLevel->pWLoop = (pWLoop = pFrom->aLoop[iLoop]));
    (pLevel->iFrom = pWLoop->iTab);
    (pLevel->iTabCur = pWInfo->pTabList->a[pLevel->iFrom].iCursor);
  }
  if ((((pWInfo->wctrlFlags & 0x0400) != 0) && ((pWInfo->wctrlFlags & 0x0200) == 0) && (pWInfo->eDistinct == 0) && nRowEst)) {
    Bitmask notUsed;
    int rc =  wherePathSatisfiesOrderBy(pWInfo, pWInfo->pResultSet, pFrom, 0x0200, (nLoop - 1), pFrom->aLoop[(nLoop - 1)], (&notUsed));
    if ((rc == 1)) {
      (pWInfo->eDistinct = 2);
    }  
  }  
  if (pFrom->isOrdered) {
    if ((pWInfo->wctrlFlags & 0x0200)) {
      (pWInfo->eDistinct = 2);
    }  
    else {
      (pWInfo->bOBSat = 1);
      (pWInfo->revMask = pFrom->revLoop);
    }
  }  
  (pWInfo->nRowOut = pFrom->nRow);
  sqlite3DbFree(db, pSpace);
  return 0;
}
static  int whereShortCut(WhereLoopBuilder *pBuilder )  {
  WhereInfo *pWInfo;
  struct  SrcList_item   *pItem;
  WhereClause *pWC;
  WhereTerm *pTerm;
  WhereLoop *pLoop;
  int iCur;
  int j;
  Table *pTab;
  Index *pIdx;
  (pWInfo = pBuilder->pWInfo);
  if ((pWInfo->wctrlFlags & 0x0020)) {
    return 0;
  }  
  ((void ) 0);
  (pItem = pWInfo->pTabList->a);
  (pTab = pItem->pTab);
  if (((pTab->tabFlags & 0x10) != 0)) {
    return 0;
  }  
  if (pItem->zIndex) {
    return 0;
  }  
  (iCur = pItem->iCursor);
  (pWC = (&pWInfo->sWC));
  (pLoop = pBuilder->pNew);
  (pLoop->wsFlags = 0);
  (pTerm = findTerm(pWC, iCur, (- 1), 0, 0x002, 0));
  if (pTerm) {
    (pLoop->wsFlags = (0x00000001 | 0x00000100 | 0x00001000));
    (pLoop->aLTerm[0] = pTerm);
    (pLoop->nLTerm = 1);
    (pLoop->u.btree.nEq = 1);
    (pLoop->rRun = 33);
  }  
  else {
    for ((pIdx = pTab->pIndex); pIdx; (pIdx = pIdx->pNext)) {
      ((void ) 0);
      ((void ) 0);
      if (((pIdx->onError == 0) || (pIdx->pPartIdxWhere != 0) || (pIdx->nColumn > ((int ) (sizeof(pLoop->aLTermSpace) / sizeof(pLoop->aLTermSpace[0])))))) {
        continue;
      }  
      for ((j = 0); (j < pIdx->nColumn); j++) {
        (pTerm = findTerm(pWC, iCur, pIdx->aiColumn[j], 0, 0x002, pIdx));
        if ((pTerm == 0)) {
          break;
        }  
        (pLoop->aLTerm[j] = pTerm);
      }
      if ((j != pIdx->nColumn)) {
        continue;
      }  
      (pLoop->wsFlags = (0x00000001 | 0x00001000 | 0x00000200));
      if (((pItem->colUsed & (~ columnsInIndex(pIdx))) == 0)) {
        (pLoop->wsFlags |= 0x00000040);
      }  
      (pLoop->nLTerm = j);
      (pLoop->u.btree.nEq = j);
      (pLoop->u.btree.pIndex = pIdx);
      (pLoop->rRun = 39);
      break;
    }
  }
  if (pLoop->wsFlags) {
    (pLoop->nOut = ((LogEst ) 1));
    (pWInfo->a[0].pWLoop = pLoop);
    (pLoop->maskSelf = getMask((&pWInfo->sMaskSet), iCur));
    (pWInfo->a[0].iTabCur = iCur);
    (pWInfo->nRowOut = 1);
    if (pWInfo->pOrderBy) {
      (pWInfo->bOBSat = 1);
    }  
    if ((pWInfo->wctrlFlags & 0x0400)) {
      (pWInfo->eDistinct = 1);
    }  
    return 1;
  }  
  return 0;
}
static  WhereInfo *sqlite3WhereBegin(Parse *pParse , SrcList *pTabList , Expr *pWhere , ExprList *pOrderBy , ExprList *pResultSet , u16 wctrlFlags , int iIdxCur )  {
  int nByteWInfo;
  int nTabList;
  WhereInfo *pWInfo;
  Vdbe *v =  pParse->pVdbe;
  Bitmask notReady;
  WhereLoopBuilder sWLB;
  WhereMaskSet *pMaskSet;
  WhereLevel *pLevel;
  WhereLoop *pLoop;
  int ii;
  sqlite3 *db;
  int rc;
  (db = pParse->db);
  memset((&sWLB), 0, sizeof(sWLB));
  (sWLB.pOrderBy = pOrderBy);
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    if (((db->dbOptFlags & 0x0020) != 0)) {
      (wctrlFlags &= (~ 0x0400));
    }  
  }  
  if (((id2i_sqlite_omit_builtin_test ) )) {
    if (0) {
      (wctrlFlags &= (~ 0x0400));
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pTabList->nSrc == ((int ) (sizeof(Bitmask ) * 8)))) {
      sqlite3Coverage(112169);
    }  
  }  
  if ((pTabList->nSrc > ((int ) (sizeof(Bitmask ) * 8)))) {
    sqlite3ErrorMsg(pParse, "at most %d tables in a join", ((int ) (sizeof(Bitmask ) * 8)));
    return 0;
  }  
  (nTabList = ((wctrlFlags & 0x0040) ? 1 : pTabList->nSrc));
  (nByteWInfo = (((sizeof(WhereInfo ) + ((nTabList - 1) * sizeof(WhereLevel ))) + 7) & (~ 7)));
  (pWInfo = sqlite3DbMallocZero(db, (nByteWInfo + sizeof(WhereLoop ))));
  if (db->mallocFailed) {
    sqlite3DbFree(db, pWInfo);
    (pWInfo = 0);
    goto whereBeginError;
  }  
  (pWInfo->nLevel = nTabList);
  (pWInfo->pParse = pParse);
  (pWInfo->pTabList = pTabList);
  (pWInfo->pOrderBy = pOrderBy);
  (pWInfo->pResultSet = pResultSet);
  (pWInfo->iBreak = sqlite3VdbeMakeLabel(v));
  (pWInfo->wctrlFlags = wctrlFlags);
  (pWInfo->savedNQueryLoop = pParse->nQueryLoop);
  (pMaskSet = (&pWInfo->sMaskSet));
  (sWLB.pWInfo = pWInfo);
  (sWLB.pWC = (&pWInfo->sWC));
  (sWLB.pNew = ((WhereLoop *) (((char *) pWInfo) + nByteWInfo)));
  ((void ) 0);
  whereLoopInit(sWLB.pNew);
  (pMaskSet->n = 0);
  whereClauseInit((&pWInfo->sWC), pWInfo);
  sqlite3ExprCodeConstants(pParse, pWhere);
  whereSplit((&pWInfo->sWC), pWhere, 69);
  sqlite3CodeVerifySchema(pParse, (- 1));
  if ((pWhere && ((nTabList == 0) || sqlite3ExprIsConstantNotJoin(pWhere)))) {
    sqlite3ExprIfFalse(pParse, pWhere, pWInfo->iBreak, 0x08);
    (pWhere = 0);
  }  
  if ((nTabList == 0)) {
    if (pOrderBy) {
      (pWInfo->bOBSat = 1);
    }  
    if ((wctrlFlags & 0x0400)) {
      (pWInfo->eDistinct = 1);
    }  
  }  
  for ((ii = 0); (ii < pTabList->nSrc); ii++) {
    createMask(pMaskSet, pTabList->a[ii].iCursor);
  }
  exprAnalyzeAll(pTabList, (&pWInfo->sWC));
  if (db->mallocFailed) {
    goto whereBeginError;
  }  
  if ((pOrderBy && ((wctrlFlags & 0x0400) != 0))) {
    for ((ii = 0); (ii < pOrderBy->nExpr); ii++) {
      Expr *pExpr =  sqlite3ExprSkipCollate(pOrderBy->a[ii].pExpr);
      if ((pExpr->op != 152)) {
        (pWInfo->pOrderBy = (pOrderBy = 0));
        break;
      } 
      else if ((pExpr->iColumn < 0)) {
        break;
      } 
    }
  }  
  if ((wctrlFlags & 0x0400)) {
    if (isDistinctRedundant(pParse, pTabList, (&pWInfo->sWC), pResultSet)) {
      (pWInfo->eDistinct = 1);
    } 
    else if ((pOrderBy == 0)) {
      (pWInfo->wctrlFlags |= 0x0200);
      (pWInfo->pOrderBy = pResultSet);
    } 
  }  
  if (((nTabList != 1) || (whereShortCut((&sWLB)) == 0))) {
    (rc = whereLoopAddAll((&sWLB)));
    if (rc) {
      goto whereBeginError;
    }  
    wherePathSolver(pWInfo, 0);
    if (db->mallocFailed) {
      goto whereBeginError;
    }  
    if (pWInfo->pOrderBy) {
      wherePathSolver(pWInfo, (pWInfo->nRowOut + 1));
      if (db->mallocFailed) {
        goto whereBeginError;
      }  
    }  
  }  
  if (((pWInfo->pOrderBy == 0) && ((db->flags & 0x00020000) != 0))) {
    (pWInfo->revMask = ((Bitmask ) (- 1)));
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pParse->nErr || db->mallocFailed)) {
      goto whereBeginError;
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((pParse->nErr || 0)) {
      goto whereBeginError;
    }  
  }  
  if (((id2i_sqlite_omit_builtin_test ) )) {
    if (((pWInfo->nLevel >= 2) && (pResultSet != 0) && 1)) {
      Bitmask tabUsed =  exprListTableUsage(pMaskSet, pResultSet);
      if (sWLB.pOrderBy) {
        (tabUsed |= exprListTableUsage(pMaskSet, sWLB.pOrderBy));
      }  
      while ((pWInfo->nLevel >= 2)) {
        WhereTerm *pTerm, *pEnd;
        (pLoop = pWInfo->a[(pWInfo->nLevel - 1)].pWLoop);
        if (((pWInfo->pTabList->a[pLoop->iTab].jointype & 0x0008) == 0)) {
          break;
        }  
        if ((((wctrlFlags & 0x0400) == 0) && ((pLoop->wsFlags & 0x00001000) == 0))) {
          break;
        }  
        if (((tabUsed & pLoop->maskSelf) != 0)) {
          break;
        }  
        (pEnd = (sWLB.pWC->a + sWLB.pWC->nTerm));
        for ((pTerm = sWLB.pWC->a); (pTerm < pEnd); pTerm++) {
          if ((((pTerm->prereqAll & pLoop->maskSelf) != 0) && (! ((pTerm->pExpr->flags & 0x000001) != 0)))) {
            break;
          }  
        }
        if ((pTerm < pEnd)) {
          break;
        }  
        pWInfo->nLevel--;
        nTabList--;
      }
    }  
  }  
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    if (((pWInfo->nLevel >= 2) && (pResultSet != 0) && ((db->dbOptFlags & 0x0400) == 0))) {
      Bitmask tabUsed =  exprListTableUsage(pMaskSet, pResultSet);
      if (sWLB.pOrderBy) {
        (tabUsed |= exprListTableUsage(pMaskSet, sWLB.pOrderBy));
      }  
      while ((pWInfo->nLevel >= 2)) {
        WhereTerm *pTerm, *pEnd;
        (pLoop = pWInfo->a[(pWInfo->nLevel - 1)].pWLoop);
        if (((pWInfo->pTabList->a[pLoop->iTab].jointype & 0x0008) == 0)) {
          break;
        }  
        if ((((wctrlFlags & 0x0400) == 0) && ((pLoop->wsFlags & 0x00001000) == 0))) {
          break;
        }  
        if (((tabUsed & pLoop->maskSelf) != 0)) {
          break;
        }  
        (pEnd = (sWLB.pWC->a + sWLB.pWC->nTerm));
        for ((pTerm = sWLB.pWC->a); (pTerm < pEnd); pTerm++) {
          if ((((pTerm->prereqAll & pLoop->maskSelf) != 0) && (! ((pTerm->pExpr->flags & 0x000001) != 0)))) {
            break;
          }  
        }
        if ((pTerm < pEnd)) {
          break;
        }  
        pWInfo->nLevel--;
        nTabList--;
      }
    }  
  }  
  (pWInfo->pParse->nQueryLoop += pWInfo->nRowOut);
  ((void ) 0);
  if ((((wctrlFlags & 0x0004) != 0) && ((pWInfo->a[0].pWLoop->wsFlags & 0x00001000) != 0))) {
    (pWInfo->okOnePass = 1);
    (pWInfo->a[0].pWLoop->wsFlags &= (~ 0x00000040));
  }  
  (notReady = (~ ((Bitmask ) 0)));
  for ((ii = 0), (pLevel = pWInfo->a); (ii < nTabList); ii++, pLevel++) {
    Table *pTab;
    int iDb;
    struct  SrcList_item   *pTabItem;
    (pTabItem = (&pTabList->a[pLevel->iFrom]));
    (pTab = pTabItem->pTab);
    (iDb = sqlite3SchemaToIndex(db, pTab->pSchema));
    (pLoop = pLevel->pWLoop);
    if ((((pTab->tabFlags & 0x02) != 0) || pTab->pSelect)) {
      
    } 
    else if (((pLoop->wsFlags & 0x00000400) != 0)) {
      const char *pVTab =  ((const  char *) sqlite3GetVTable(db, pTab));
      int iCur =  pTabItem->iCursor;
      sqlite3VdbeAddOp4(v, 137, iCur, 0, 0, pVTab, (- 10));
    }
    
    else if (((pTab->tabFlags & 0x10) != 0)) {
      
    }
    
    else if ((((pLoop->wsFlags & 0x00000040) == 0) && ((wctrlFlags & 0x0010) == 0))) {
      int op =  (pWInfo->okOnePass ? 49 : 48);
      sqlite3OpenTable(pParse, pTabItem->iCursor, iDb, pTab, op);
      if (((id2i_sqlite_coverage_test ) )) {
        if (((! pWInfo->okOnePass) && (pTab->nCol == (((int ) (sizeof(Bitmask ) * 8)) - 1)))) {
          sqlite3Coverage(112442);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if (((! pWInfo->okOnePass) && (pTab->nCol == ((int ) (sizeof(Bitmask ) * 8))))) {
          sqlite3Coverage(112443);
        }  
      }  
      if (((! pWInfo->okOnePass) && (pTab->nCol < ((int ) (sizeof(Bitmask ) * 8))))) {
        Bitmask b =  pTabItem->colUsed;
        int n =  0;
        for (; b; (b = (b >> 1)), n++) {
          
        }
        sqlite3VdbeChangeP4(v, (sqlite3VdbeCurrentAddr(v) - 1), ((void *) ((long  int ) n)), (- 14));
        ((void ) 0);
      }  
    } 
    else {
      sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
    }
    if ((pLoop->wsFlags & 0x00000200)) {
      Index *pIx =  pLoop->u.btree.pIndex;
      KeyInfo *pKey =  sqlite3IndexKeyinfo(pParse, pIx);
      int iIndexCur =  (pLevel->iIdxCur = (iIdxCur ? iIdxCur : pParse->nTab++));
      ((void ) 0);
      ((void ) 0);
      sqlite3VdbeAddOp4(v, 48, iIndexCur, pIx->tnum, iDb, ((char *) pKey), (- 16));
    }  
    sqlite3CodeVerifySchema(pParse, iDb);
    (notReady &= (~ getMask((&pWInfo->sMaskSet), pTabItem->iCursor)));
  }
  (pWInfo->iTop = sqlite3VdbeCurrentAddr(v));
  if (db->mallocFailed) {
    goto whereBeginError;
  }  
  (notReady = (~ ((Bitmask ) 0)));
  for ((ii = 0); (ii < nTabList); ii++) {
    (pLevel = (&pWInfo->a[ii]));
    if (((pLevel->pWLoop->wsFlags & 0x00004000) != 0)) {
      constructAutomaticIndex(pParse, (&pWInfo->sWC), (&pTabList->a[pLevel->iFrom]), notReady, pLevel);
      if (db->mallocFailed) {
        goto whereBeginError;
      }  
    }  
    if ((((! id2i_sqlite_omit_explain) ) )) {
      explainOneScan(pParse, pTabList, pLevel, ii, pLevel->iFrom, wctrlFlags);
    }  
    (pLevel->addrBody = sqlite3VdbeCurrentAddr(v));
    (notReady = codeOneLoopStart(pWInfo, ii, notReady));
    (pWInfo->iContinue = pLevel->addrCont);
  }
  return pWInfo;
  whereBeginError:
  if (pWInfo) {
    (pParse->nQueryLoop = pWInfo->savedNQueryLoop);
    whereInfoFree(db, pWInfo);
  }  
  return 0;
}
static  void sqlite3WhereEnd(WhereInfo *pWInfo )  {
  Parse *pParse =  pWInfo->pParse;
  Vdbe *v =  pParse->pVdbe;
  int i;
  WhereLevel *pLevel;
  WhereLoop *pLoop;
  SrcList *pTabList =  pWInfo->pTabList;
  sqlite3 *db =  pParse->db;
  sqlite3ExprCacheClear(pParse);
  for ((i = (pWInfo->nLevel - 1)); (i >= 0); i--) {
    (pLevel = (&pWInfo->a[i]));
    (pLoop = pLevel->pWLoop);
    sqlite3VdbeResolveLabel(v, pLevel->addrCont);
    if ((pLevel->op != 149)) {
      sqlite3VdbeAddOp2(v, pLevel->op, pLevel->p1, pLevel->p2);
      sqlite3VdbeChangeP5(v, pLevel->p5);
    }  
    if (((pLoop->wsFlags & 0x00000800) && (pLevel->u.in.nIn > 0))) {
      struct  InLoop   *pIn;
      int j;
      sqlite3VdbeResolveLabel(v, pLevel->addrNxt);
      for ((j = pLevel->u.in.nIn), (pIn = (&pLevel->u.in.aInLoop[(j - 1)])); (j > 0); j--, pIn--) {
        sqlite3VdbeJumpHere(v, (pIn->addrInTop + 1));
        sqlite3VdbeAddOp2(v, pIn->eEndLoopOp, pIn->iCur, pIn->addrInTop);
        sqlite3VdbeJumpHere(v, (pIn->addrInTop - 1));
      }
      sqlite3DbFree(db, pLevel->u.in.aInLoop);
    }  
    sqlite3VdbeResolveLabel(v, pLevel->addrBrk);
    if (pLevel->iLeftJoin) {
      int addr;
      (addr = sqlite3VdbeAddOp1(v, 126, pLevel->iLeftJoin));
      ((void ) 0);
      if (((pLoop->wsFlags & 0x00000040) == 0)) {
        sqlite3VdbeAddOp1(v, 97, pTabList->a[i].iCursor);
      }  
      if ((pLoop->wsFlags & 0x00000200)) {
        sqlite3VdbeAddOp1(v, 97, pLevel->iIdxCur);
      }  
      if ((pLevel->op == 16)) {
        sqlite3VdbeAddOp2(v, 15, pLevel->p1, pLevel->addrFirst);
      }  
      else {
        sqlite3VdbeAddOp2(v, 14, 0, pLevel->addrFirst);
      }
      sqlite3VdbeJumpHere(v, addr);
    }  
  }
  sqlite3VdbeResolveLabel(v, pWInfo->iBreak);
  ((void ) 0);
  for ((i = 0), (pLevel = pWInfo->a); (i < pWInfo->nLevel); i++, pLevel++) {
    Index *pIdx =  0;
    struct  SrcList_item   *pTabItem =  (&pTabList->a[pLevel->iFrom]);
    Table *pTab =  pTabItem->pTab;
    ((void ) 0);
    (pLoop = pLevel->pWLoop);
    if ((((pTab->tabFlags & 0x02) == 0) && (pTab->pSelect == 0) && ((pWInfo->wctrlFlags & 0x0010) == 0))) {
      int ws =  pLoop->wsFlags;
      if (((! pWInfo->okOnePass) && ((ws & 0x00000040) == 0))) {
        sqlite3VdbeAddOp1(v, 54, pTabItem->iCursor);
      }  
      if ((((ws & 0x00000200) != 0) && ((ws & (0x00000100 | 0x00004000)) == 0))) {
        sqlite3VdbeAddOp1(v, 54, pLevel->iIdxCur);
      }  
    }  
    if ((pLoop->wsFlags & (0x00000200 | 0x00000040))) {
      (pIdx = pLoop->u.btree.pIndex);
    } 
    else if ((pLoop->wsFlags & 0x00002000)) {
      (pIdx = pLevel->u.pCovidx);
    } 
    if ((pIdx && (! db->mallocFailed))) {
      int k, j, last;
      VdbeOp *pOp;
      (last = sqlite3VdbeCurrentAddr(v));
      (k = pLevel->addrBody);
      (pOp = sqlite3VdbeGetOp(v, k));
      for (; (k < last); k++, pOp++) {
        if ((pOp->p1 != pLevel->iTabCur)) {
          continue;
        }  
        if ((pOp->opcode == 41)) {
          for ((j = 0); (j < pIdx->nColumn); j++) {
            if ((pOp->p2 == pIdx->aiColumn[j])) {
              (pOp->p2 = j);
              (pOp->p1 = pLevel->iIdxCur);
              break;
            }  
          }
          ((void ) 0);
        } 
        else if ((pOp->opcode == 96)) {
          (pOp->p1 = pLevel->iIdxCur);
          (pOp->opcode = 105);
        } 
      }
    }  
  }
  (pParse->nQueryLoop = pWInfo->savedNQueryLoop);
  whereInfoFree(db, pWInfo);
  return;
}
struct  LimitVal {
  Expr *pLimit ;
  Expr *pOffset ;
}  ;
struct  LikeOp {
  Token eOperator ;
  int bNot ;
}  ;
struct  TrigEvent {
  int a ;
  IdList *b ;
}  ;
struct  AttachKey {
  int type ;
  Token key ;
}  ;
struct  ValueList {
  ExprList *pList ;
  Select *pSelect ;
}  ;
static  void spanSet(ExprSpan *pOut , Token *pStart , Token *pEnd )  {
  (pOut->zStart = pStart->z);
  (pOut->zEnd = (&pEnd->z[pEnd->n]));
}
static  void spanExpr(ExprSpan *pOut , Parse *pParse , int op , Token *pValue )  {
  (pOut->pExpr = sqlite3PExpr(pParse, op, 0, 0, pValue));
  (pOut->zStart = pValue->z);
  (pOut->zEnd = (&pValue->z[pValue->n]));
}
static  void spanBinaryExpr(ExprSpan *pOut , Parse *pParse , int op , ExprSpan *pLeft , ExprSpan *pRight )  {
  (pOut->pExpr = sqlite3PExpr(pParse, op, pLeft->pExpr, pRight->pExpr, 0));
  (pOut->zStart = pLeft->zStart);
  (pOut->zEnd = pRight->zEnd);
}
static  void spanUnaryPostfix(ExprSpan *pOut , Parse *pParse , int op , ExprSpan *pOperand , Token *pPostOp )  {
  (pOut->pExpr = sqlite3PExpr(pParse, op, pOperand->pExpr, 0, 0));
  (pOut->zStart = pOperand->zStart);
  (pOut->zEnd = (&pPostOp->z[pPostOp->n]));
}
static  void binaryToUnaryIfNull(Parse *pParse , Expr *pY , Expr *pA , int op )  {
  sqlite3 *db =  pParse->db;
  if (((db->mallocFailed == 0) && (pY->op == 98))) {
    (pA->op = ((u8 ) op));
    sqlite3ExprDelete(db, pA->pRight);
    (pA->pRight = 0);
  }  
}
static  void spanUnaryPrefix(ExprSpan *pOut , Parse *pParse , int op , ExprSpan *pOperand , Token *pPreOp )  {
  (pOut->pExpr = sqlite3PExpr(pParse, op, pOperand->pExpr, 0, 0));
  (pOut->zStart = pPreOp->z);
  (pOut->zEnd = pOperand->zEnd);
}
typedef union   {
  int yyinit ;
  Token yy0 ;
  struct  LimitVal   yy64 ;
  Expr *yy122 ;
  Select *yy159 ;
  IdList *yy180 ;
  struct   {
    int value ;
    int mask ;
  }  yy207 ;
  u8 yy258 ;
  u16 yy305 ;
  struct  LikeOp   yy318 ;
  TriggerStep *yy327 ;
  ExprSpan yy342 ;
  SrcList *yy347 ;
  int yy392 ;
  struct  TrigEvent   yy410 ;
  ExprList *yy442 ;
  struct  ValueList   yy487 ;
}  YYMINORTYPE;
static const YYMINORTYPE yyzerominor =  { 0};
static const unsigned short int yy_action[] =  { 310,  956,  184,  418,  2,  171,  625,  595,  56,  56,  56,  56,  49,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  621,  620,  299,  621,  620,  234,  588,  582,  56,  56,  56,  56,  19,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  606,  57,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  542,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  595,  326,  196,  195,  194,  33,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  618,  617,  165,  618,  617,  381,  378,  377,  408,  533,  577,  577,  588,  582,  304,  423,  376,  59,  53,  53,  52,  52,  52,  51,  233,  50,  47,  146,  575,  546,  65,  57,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  213,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  223,  540,  421,  170,  176,  138,  281,  384,  276,  383,  168,  490,  552,  410,  669,  621,  620,  272,  439,  410,  439,  551,  605,  67,  483,  508,  619,  600,  413,  588,  582,  601,  484,  619,  413,  619,  599,  91,  440,  441,  440,  336,  599,  73,  670,  222,  267,  481,  57,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  671,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  280,  232,  231,  1,  132,  200,  386,  621,  620,  618,  617,  279,  436,  290,  564,  175,  263,  410,  265,  438,  498,  437,  166,  442,  569,  337,  569,  201,  538,  588,  582,  600,  413,  165,  595,  601,  381,  378,  377,  598,  599,  92,  524,  619,  570,  570,  593,  376,  57,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  598,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  464,  618,  617,  591,  591,  591,  174,  273,  397,  410,  273,  410,  549,  398,  621,  620,  68,  327,  621,  620,  621,  620,  619,  547,  413,  619,  413,  472,  595,  588,  582,  473,  599,  92,  599,  92,  52,  52,  52,  51,  233,  514,  513,  206,  323,  364,  465,  221,  57,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  530,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  397,  410,  397,  598,  373,  387,  531,  348,  618,  617,  576,  202,  618,  617,  618,  617,  413,  621,  620,  145,  255,  347,  254,  578,  599,  74,  352,  45,  490,  588,  582,  235,  189,  465,  545,  167,  297,  187,  470,  480,  67,  62,  39,  619,  547,  598,  346,  574,  57,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  6,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  563,  559,  408,  529,  577,  577,  345,  255,  347,  254,  182,  618,  617,  504,  505,  315,  410,  558,  235,  166,  272,  410,  353,  565,  181,  408,  547,  577,  577,  588,  582,  413,  538,  557,  562,  518,  413,  619,  249,  599,  16,  7,  36,  468,  599,  92,  517,  619,  57,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  542,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  328,  573,  572,  526,  559,  561,  395,  872,  246,  410,  248,  171,  393,  595,  219,  408,  410,  577,  577,  503,  558,  365,  145,  511,  413,  408,  229,  577,  577,  588,  582,  413,  599,  92,  382,  270,  557,  166,  401,  599,  69,  502,  420,  946,  199,  946,  198,  547,  57,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  569,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  318,  420,  945,  509,  945,  309,  598,  595,  566,  491,  212,  173,  247,  424,  616,  615,  614,  324,  197,  143,  406,  573,  572,  490,  66,  50,  47,  146,  595,  588,  582,  232,  231,  560,  428,  67,  556,  15,  619,  186,  544,  304,  422,  35,  206,  433,  424,  553,  57,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  205,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  570,  570,  261,  269,  598,  12,  374,  569,  166,  410,  314,  410,  421,  410,  474,  474,  366,  619,  50,  47,  146,  598,  595,  256,  413,  166,  413,  352,  413,  588,  582,  32,  599,  94,  599,  97,  599,  95,  628,  626,  330,  142,  50,  47,  146,  334,  350,  359,  57,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  410,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  410,  389,  413,  410,  22,  566,  405,  212,  363,  390,  599,  104,  360,  410,  156,  413,  410,  604,  413,  538,  332,  570,  570,  599,  103,  494,  599,  105,  413,  588,  582,  413,  261,  550,  619,  11,  599,  106,  522,  599,  133,  169,  458,  457,  170,  35,  602,  619,  57,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  410,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  410,  260,  413,  410,  50,  47,  146,  358,  319,  356,  599,  134,  528,  353,  338,  413,  410,  357,  413,  358,  410,  358,  619,  599,  98,  129,  599,  102,  619,  588,  582,  413,  21,  235,  619,  413,  619,  211,  143,  599,  101,  30,  167,  599,  93,  351,  536,  203,  57,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  410,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  410,  527,  413,  410,  426,  215,  306,  598,  552,  141,  599,  100,  40,  410,  38,  413,  410,  551,  413,  410,  228,  220,  315,  599,  77,  501,  599,  96,  413,  588,  582,  413,  339,  253,  413,  218,  599,  137,  380,  599,  136,  28,  599,  135,  271,  716,  210,  482,  57,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  410,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  410,  273,  413,  410,  316,  147,  598,  273,  627,  2,  599,  76,  209,  410,  127,  413,  619,  126,  413,  410,  622,  235,  619,  599,  90,  375,  599,  89,  413,  588,  582,  27,  261,  351,  413,  619,  599,  75,  322,  542,  542,  125,  599,  88,  321,  279,  598,  619,  57,  46,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  410,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  410,  451,  413,  164,  285,  283,  273,  610,  425,  305,  599,  87,  371,  410,  478,  413,  410,  609,  410,  608,  603,  619,  619,  599,  99,  587,  586,  122,  413,  588,  582,  413,  619,  413,  619,  619,  599,  86,  367,  599,  17,  599,  85,  320,  185,  520,  519,  584,  583,  58,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  410,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  310,  585,  410,  413,  410,  261,  261,  261,  409,  592,  475,  599,  84,  170,  410,  467,  519,  413,  121,  413,  619,  619,  619,  619,  619,  599,  83,  599,  72,  413,  588,  582,  51,  233,  626,  330,  471,  599,  71,  258,  159,  120,  14,  463,  157,  158,  117,  261,  449,  448,  447,  48,  580,  579,  581,  581,  55,  55,  56,  56,  56,  56,  619,  54,  54,  54,  54,  53,  53,  52,  52,  52,  51,  233,  44,  404,  261,  3,  410,  460,  261,  414,  620,  118,  399,  10,  25,  24,  555,  349,  217,  619,  407,  413,  410,  619,  4,  44,  404,  619,  3,  599,  82,  619,  414,  620,  456,  543,  115,  413,  539,  402,  537,  275,  507,  407,  251,  599,  81,  216,  274,  564,  619,  243,  454,  619,  154,  619,  619,  619,  450,  417,  624,  110,  402,  619,  410,  236,  64,  123,  488,  41,  42,  532,  564,  204,  410,  268,  43,  412,  411,  413,  266,  593,  108,  619,  107,  435,  333,  599,  80,  413,  619,  264,  41,  42,  444,  619,  410,  599,  70,  43,  412,  411,  434,  262,  593,  149,  619,  598,  257,  237,  188,  413,  591,  591,  591,  590,  589,  13,  619,  599,  18,  329,  235,  619,  44,  404,  361,  3,  419,  462,  340,  414,  620,  227,  124,  591,  591,  591,  590,  589,  13,  619,  407,  410,  619,  410,  139,  34,  404,  388,  3,  148,  623,  313,  414,  620,  312,  331,  413,  461,  413,  402,  180,  354,  413,  407,  599,  79,  599,  78,  250,  564,  599,  9,  619,  613,  612,  611,  619,  8,  453,  443,  242,  416,  402,  619,  239,  235,  179,  238,  429,  41,  42,  289,  564,  619,  619,  619,  43,  412,  411,  619,  144,  593,  619,  619,  177,  61,  619,  597,  392,  621,  620,  288,  41,  42,  415,  619,  294,  30,  394,  43,  412,  411,  293,  619,  593,  31,  619,  396,  292,  60,  230,  37,  591,  591,  591,  590,  589,  13,  214,  554,  183,  291,  172,  302,  301,  300,  178,  298,  596,  564,  452,  29,  286,  391,  541,  591,  591,  591,  590,  589,  13,  284,  521,  535,  150,  534,  241,  282,  385,  192,  191,  325,  516,  515,  277,  240,  511,  524,  308,  512,  128,  593,  510,  225,  226,  487,  486,  224,  152,  492,  465,  307,  485,  163,  153,  372,  479,  151,  162,  259,  370,  161,  368,  208,  476,  477,  26,  160,  469,  466,  362,  140,  591,  591,  591,  116,  119,  455,  344,  155,  114,  343,  113,  112,  446,  111,  131,  109,  432,  317,  130,  431,  23,  20,  430,  427,  190,  63,  255,  342,  244,  607,  295,  287,  311,  594,  278,  508,  496,  235,  493,  571,  497,  568,  495,  403,  459,  379,  355,  245,  193,  303,  567,  296,  341,  5,  445,  548,  506,  207,  525,  500,  335,  489,  252,  369,  400,  499,  523,  233};
static const unsigned char yy_lookahead[] =  { 19,  142,  143,  144,  145,  24,  1,  26,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  26,  27,  15,  26,  27,  197,  49,  50,  77,  78,  79,  80,  204,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  23,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  166,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  94,  19,  105,  106,  107,  25,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  94,  95,  96,  94,  95,  99,  100,  101,  112,  205,  114,  115,  49,  50,  22,  23,  110,  54,  86,  87,  88,  89,  90,  91,  92,  221,  222,  223,  23,  120,  25,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  22,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  92,  23,  67,  25,  96,  97,  98,  99,  100,  101,  102,  150,  32,  150,  118,  26,  27,  109,  150,  150,  150,  41,  161,  162,  180,  181,  165,  113,  165,  49,  50,  117,  188,  165,  165,  165,  173,  174,  170,  171,  170,  171,  173,  174,  118,  184,  16,  186,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  118,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  98,  86,  87,  22,  24,  160,  88,  26,  27,  94,  95,  109,  97,  224,  66,  118,  60,  150,  62,  104,  23,  106,  25,  229,  230,  229,  230,  160,  150,  49,  50,  113,  165,  96,  26,  117,  99,  100,  101,  194,  173,  174,  94,  165,  129,  130,  98,  110,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  194,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  11,  94,  95,  129,  130,  131,  118,  150,  215,  150,  150,  150,  25,  220,  26,  27,  22,  213,  26,  27,  26,  27,  165,  25,  165,  165,  165,  30,  94,  49,  50,  34,  173,  174,  173,  174,  88,  89,  90,  91,  92,  7,  8,  160,  187,  48,  57,  187,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  23,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  215,  150,  215,  194,  19,  220,  88,  220,  94,  95,  23,  160,  94,  95,  94,  95,  165,  26,  27,  95,  105,  106,  107,  113,  173,  174,  217,  22,  150,  49,  50,  116,  119,  57,  120,  50,  158,  22,  21,  161,  162,  232,  136,  165,  120,  194,  237,  23,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  22,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  23,  12,  112,  23,  114,  115,  63,  105,  106,  107,  23,  94,  95,  97,  98,  104,  150,  28,  116,  25,  109,  150,  150,  23,  23,  112,  25,  114,  115,  49,  50,  165,  150,  44,  11,  46,  165,  165,  16,  173,  174,  76,  136,  100,  173,  174,  57,  165,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  166,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  169,  170,  171,  23,  12,  23,  214,  138,  60,  150,  62,  24,  215,  26,  216,  112,  150,  114,  115,  36,  28,  213,  95,  103,  165,  112,  205,  114,  115,  49,  50,  165,  173,  174,  51,  23,  44,  25,  46,  173,  174,  58,  22,  23,  22,  25,  160,  120,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  230,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  215,  22,  23,  23,  25,  163,  194,  94,  166,  167,  168,  25,  138,  67,  7,  8,  9,  108,  206,  207,  169,  170,  171,  150,  22,  221,  222,  223,  26,  49,  50,  86,  87,  23,  161,  162,  23,  22,  165,  24,  120,  22,  23,  25,  160,  241,  67,  176,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  160,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  129,  130,  150,  23,  194,  35,  23,  230,  25,  150,  155,  150,  67,  150,  105,  106,  107,  165,  221,  222,  223,  194,  94,  23,  165,  25,  165,  217,  165,  49,  50,  25,  173,  174,  173,  174,  173,  174,  0,  1,  2,  118,  221,  222,  223,  193,  219,  237,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  150,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  150,  19,  165,  150,  24,  166,  167,  168,  227,  27,  173,  174,  231,  150,  25,  165,  150,  172,  165,  150,  242,  129,  130,  173,  174,  180,  173,  174,  165,  49,  50,  165,  150,  176,  165,  35,  173,  174,  165,  173,  174,  35,  23,  23,  25,  25,  173,  165,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  150,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  150,  193,  165,  150,  221,  222,  223,  150,  213,  19,  173,  174,  23,  150,  97,  165,  150,  27,  165,  150,  150,  150,  165,  173,  174,  22,  173,  174,  165,  49,  50,  165,  52,  116,  165,  165,  165,  206,  207,  173,  174,  126,  50,  173,  174,  128,  27,  160,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  150,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  150,  23,  165,  150,  23,  216,  25,  194,  32,  39,  173,  174,  135,  150,  137,  165,  150,  41,  165,  150,  52,  238,  104,  173,  174,  29,  173,  174,  165,  49,  50,  165,  219,  238,  165,  238,  173,  174,  52,  173,  174,  22,  173,  174,  23,  23,  160,  25,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  150,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  150,  150,  165,  150,  245,  246,  194,  150,  144,  145,  173,  174,  160,  150,  22,  165,  165,  22,  165,  150,  150,  116,  165,  173,  174,  52,  173,  174,  165,  49,  50,  22,  150,  128,  165,  165,  173,  174,  187,  166,  166,  22,  173,  174,  187,  109,  194,  165,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  150,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  150,  193,  165,  102,  205,  205,  150,  150,  247,  248,  173,  174,  19,  150,  20,  165,  150,  150,  150,  150,  150,  165,  165,  173,  174,  49,  50,  104,  165,  49,  50,  165,  165,  165,  165,  165,  173,  174,  43,  173,  174,  173,  174,  187,  24,  190,  191,  71,  72,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  150,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  98,  150,  165,  150,  150,  150,  150,  150,  150,  59,  173,  174,  25,  150,  190,  191,  165,  53,  165,  165,  165,  165,  165,  165,  173,  174,  173,  174,  165,  49,  50,  91,  92,  1,  2,  53,  173,  174,  138,  104,  22,  5,  1,  35,  118,  127,  150,  193,  193,  193,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  165,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  19,  20,  150,  22,  150,  27,  150,  26,  27,  108,  150,  22,  76,  76,  150,  25,  193,  165,  37,  165,  150,  165,  22,  19,  20,  165,  22,  173,  174,  165,  26,  27,  23,  150,  119,  165,  150,  56,  150,  150,  150,  37,  16,  173,  174,  193,  150,  66,  165,  193,  1,  165,  121,  165,  165,  165,  20,  146,  147,  119,  56,  165,  150,  152,  16,  154,  150,  86,  87,  88,  66,  160,  150,  150,  93,  94,  95,  165,  150,  98,  108,  165,  127,  23,  65,  173,  174,  165,  165,  150,  86,  87,  128,  165,  150,  173,  174,  93,  94,  95,  23,  150,  98,  15,  165,  194,  150,  140,  22,  165,  129,  130,  131,  132,  133,  134,  165,  173,  174,  3,  116,  165,  19,  20,  150,  22,  4,  150,  217,  26,  27,  179,  179,  129,  130,  131,  132,  133,  134,  165,  37,  150,  165,  150,  164,  19,  20,  150,  22,  246,  149,  249,  26,  27,  249,  244,  165,  150,  165,  56,  6,  150,  165,  37,  173,  174,  173,  174,  150,  66,  173,  174,  165,  149,  149,  13,  165,  25,  150,  150,  150,  149,  56,  165,  150,  116,  151,  150,  150,  86,  87,  150,  66,  165,  165,  165,  93,  94,  95,  165,  150,  98,  165,  165,  151,  22,  165,  194,  150,  26,  27,  150,  86,  87,  159,  165,  199,  126,  123,  93,  94,  95,  200,  165,  98,  124,  165,  122,  201,  125,  225,  135,  129,  130,  131,  132,  133,  134,  5,  157,  157,  202,  118,  10,  11,  12,  13,  14,  203,  66,  17,  104,  210,  121,  211,  129,  130,  131,  132,  133,  134,  210,  175,  211,  31,  211,  33,  210,  104,  86,  87,  47,  175,  183,  175,  42,  103,  94,  178,  177,  22,  98,  175,  92,  228,  175,  175,  228,  55,  183,  57,  178,  175,  156,  61,  18,  157,  64,  156,  235,  157,  156,  45,  157,  236,  157,  135,  156,  199,  189,  157,  68,  129,  130,  131,  22,  189,  199,  157,  156,  192,  18,  192,  192,  199,  192,  218,  189,  40,  157,  218,  157,  240,  240,  157,  38,  196,  243,  105,  106,  107,  153,  198,  209,  111,  166,  176,  181,  166,  116,  166,  230,  176,  230,  176,  226,  199,  177,  239,  209,  185,  148,  166,  195,  209,  196,  199,  208,  182,  233,  173,  182,  139,  186,  239,  234,  191,  182,  173,  92};
static const short yy_shift_ofst[] =  { 1143,  1188,  1417,  1188,  1287,  1287,  138,  138,  (- 2),  (- 19),  1287,  1287,  1287,  1287,  347,  362,  129,  129,  795,  1165,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1310,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  1287,  286,  362,  362,  538,  538,  231,  1253,  55,  721,  647,  573,  499,  425,  351,  277,  203,  869,  869,  869,  869,  869,  869,  869,  869,  869,  869,  869,  869,  869,  869,  869,  943,  869,  1017,  1091,  1091,  (- 69),  (- 45),  (- 45),  (- 45),  (- 45),  (- 45),  (- 1),  24,  245,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  388,  356,  362,  362,  362,  362,  362,  732,  868,  231,  1051,  1471,  (- 70),  (- 70),  (- 70),  1367,  57,  434,  434,  289,  291,  285,  1,  204,  572,  539,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  362,  506,  506,  506,  705,  1253,  1253,  1253,  (- 70),  (- 70),  (- 70),  171,  171,  160,  502,  502,  502,  446,  432,  511,  422,  358,  335,  (- 12),  (- 12),  (- 12),  (- 12),  576,  294,  (- 12),  (- 12),  295,  595,  141,  600,  730,  723,  723,  805,  730,  805,  439,  911,  231,  865,  231,  865,  807,  865,  723,  766,  633,  633,  231,  284,  63,  608,  1481,  1308,  1308,  1472,  1472,  1308,  1477,  1427,  1275,  1487,  1487,  1487,  1487,  1308,  1461,  1275,  1477,  1427,  1427,  1275,  1308,  1461,  1355,  1441,  1308,  1308,  1461,  1308,  1461,  1308,  1461,  1442,  1348,  1348,  1348,  1408,  1375,  1375,  1442,  1348,  1357,  1348,  1408,  1348,  1348,  1316,  1331,  1316,  1331,  1316,  1331,  1308,  1308,  1280,  1288,  1289,  1285,  1279,  1275,  1253,  1336,  1346,  1346,  1338,  1338,  1338,  1338,  (- 70),  (- 70),  (- 70),  (- 70),  (- 70),  (- 70),  1013,  467,  612,  84,  179,  (- 28),  870,  410,  761,  760,  667,  650,  531,  220,  361,  331,  125,  127,  97,  1306,  1300,  1270,  1151,  1272,  1203,  1232,  1261,  1244,  1148,  1174,  1139,  1156,  1124,  1220,  1115,  1210,  1233,  1099,  1193,  1184,  1174,  1173,  1029,  1121,  1120,  1085,  1162,  1119,  1037,  1152,  1147,  1129,  1046,  1011,  1093,  1098,  1075,  1061,  1032,  960,  1057,  1031,  1030,  899,  938,  982,  936,  972,  958,  910,  955,  875,  885,  908,  857,  859,  867,  804,  590,  834,  747,  818,  513,  611,  741,  673,  637,  611,  606,  603,  579,  501,  541,  468,  386,  445,  395,  376,  281,  185,  120,  92,  75,  45,  114,  25,  11,  5};
static const short yy_reduce_ofst[] =  { (- 141),  90,  1095,  222,  158,  156,  19,  17,  10,  (- 104),  378,  316,  311,  12,  180,  249,  598,  464,  397,  1181,  1177,  1175,  1128,  1106,  1096,  1054,  1038,  974,  964,  962,  948,  905,  903,  900,  887,  874,  832,  826,  816,  813,  800,  758,  755,  752,  742,  739,  726,  685,  681,  668,  665,  652,  607,  604,  594,  591,  578,  530,  528,  526,  385,  18,  477,  466,  519,  444,  350,  435,  405,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  488,  1040,  678,  1036,  1007,  967,  966,  965,  845,  686,  610,  684,  317,  672,  893,  327,  623,  522,  (- 7),  820,  814,  157,  154,  101,  702,  494,  580,  488,  488,  488,  488,  488,  614,  586,  935,  892,  968,  1245,  1242,  1234,  1225,  798,  798,  1222,  1221,  1218,  1214,  1213,  1212,  1202,  1195,  1191,  1161,  1158,  1140,  1135,  1123,  1112,  1107,  1100,  1080,  1074,  1073,  1072,  1070,  1067,  1048,  1044,  969,  968,  907,  906,  904,  894,  833,  837,  836,  340,  827,  815,  775,  68,  722,  646,  (- 168),  1389,  1381,  1371,  1379,  1373,  1370,  1343,  1352,  1369,  1352,  1352,  1352,  1352,  1352,  1352,  1352,  1325,  1320,  1352,  1352,  1343,  1380,  1353,  1397,  1351,  1339,  1334,  1319,  1341,  1303,  1364,  1359,  1368,  1362,  1366,  1360,  1350,  1354,  1318,  1313,  1307,  1305,  1363,  1328,  1324,  1372,  1278,  1361,  1358,  1277,  1276,  1356,  1296,  1322,  1309,  1317,  1315,  1314,  1312,  1345,  1347,  1302,  1292,  1311,  1304,  1293,  1337,  1335,  1252,  1248,  1332,  1330,  1329,  1327,  1326,  1323,  1321,  1297,  1301,  1295,  1294,  1290,  1243,  1240,  1284,  1291,  1286,  1283,  1274,  1281,  1271,  1238,  1241,  1236,  1235,  1227,  1226,  1267,  1266,  1189,  1229,  1223,  1211,  1206,  1201,  1197,  1239,  1237,  1219,  1216,  1209,  1208,  1185,  1089,  1086,  1087,  1137,  1136,  1164};
static const unsigned short int yy_default[] =  { 633,  867,  955,  955,  867,  867,  955,  955,  955,  757,  955,  955,  955,  865,  955,  955,  785,  785,  929,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  672,  761,  791,  955,  955,  955,  955,  955,  955,  955,  955,  928,  930,  799,  798,  908,  772,  796,  789,  793,  868,  861,  862,  860,  864,  869,  955,  792,  828,  845,  827,  839,  844,  851,  843,  840,  830,  829,  831,  832,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  659,  726,  955,  955,  955,  955,  955,  955,  955,  955,  833,  834,  848,  847,  846,  955,  664,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  935,  933,  955,  880,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  639,  757,  757,  757,  633,  955,  955,  955,  947,  761,  751,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  801,  740,  918,  920,  955,  901,  738,  661,  759,  674,  749,  641,  795,  774,  774,  913,  795,  913,  697,  720,  955,  785,  955,  785,  694,  785,  774,  863,  955,  955,  955,  758,  749,  955,  940,  765,  765,  932,  932,  765,  807,  730,  795,  737,  737,  737,  737,  765,  656,  795,  807,  730,  730,  795,  765,  656,  907,  905,  765,  765,  656,  765,  656,  765,  656,  873,  728,  728,  728,  712,  877,  877,  873,  728,  697,  728,  712,  728,  728,  778,  773,  778,  773,  778,  773,  765,  765,  955,  790,  779,  788,  786,  795,  955,  715,  649,  649,  638,  638,  638,  638,  952,  952,  947,  699,  699,  682,  955,  955,  955,  955,  955,  955,  955,  882,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  634,  942,  955,  955,  939,  955,  955,  955,  955,  800,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  917,  955,  955,  955,  955,  955,  955,  955,  911,  955,  955,  955,  955,  955,  955,  904,  903,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  787,  955,  780,  955,  866,  955,  955,  955,  955,  955,  955,  955,  955,  955,  955,  743,  816,  955,  815,  819,  814,  666,  955,  647,  955,  630,  635,  951,  954,  953,  950,  949,  948,  943,  941,  938,  937,  936,  934,  931,  927,  886,  884,  891,  890,  889,  888,  887,  885,  883,  881,  802,  797,  794,  926,  879,  739,  736,  735,  655,  944,  910,  919,  806,  805,  808,  916,  915,  914,  912,  909,  896,  804,  803,  731,  871,  870,  658,  900,  899,  898,  902,  906,  897,  767,  657,  654,  663,  718,  719,  727,  725,  724,  723,  722,  721,  717,  665,  673,  711,  696,  695,  876,  878,  875,  874,  704,  703,  709,  708,  707,  706,  705,  702,  701,  700,  693,  692,  698,  691,  714,  713,  710,  690,  734,  733,  732,  729,  689,  688,  687,  819,  686,  685,  825,  824,  812,  855,  754,  753,  752,  764,  763,  776,  775,  810,  809,  777,  762,  756,  755,  771,  770,  769,  768,  760,  750,  782,  784,  783,  781,  857,  766,  854,  925,  924,  923,  922,  921,  859,  858,  826,  823,  677,  678,  894,  893,  895,  892,  680,  679,  676,  675,  856,  745,  744,  852,  849,  841,  837,  853,  850,  842,  838,  836,  835,  821,  820,  818,  817,  813,  822,  668,  746,  742,  741,  811,  748,  747,  684,  683,  681,  662,  660,  653,  651,  650,  652,  648,  646,  645,  644,  643,  642,  671,  670,  669,  667,  666,  640,  637,  636,  632,  631,  629};
static const unsigned char yyFallback[] =  { 0,  0,  26,  26,  26,  26,  0,  26,  26,  26,  0,  26,  26,  26,  26,  0,  0,  0,  26,  0,  0,  26,  0,  0,  0,  0,  0,  0,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26};
struct  yyStackEntry {
  unsigned  short  int stateno ;
  unsigned  char major ;
  YYMINORTYPE minor ;
}  ;
typedef struct  yyStackEntry   yyStackEntry;
struct  yyParser {
  int yyidx ;
  int yyerrcnt ;
  Parse *pParse ;
  yyStackEntry yystack[100] ;
}  ;
typedef struct  yyParser   yyParser;
static  void *sqlite3ParserAlloc(void *( *mallocProc)(size_t ) )  {
  yyParser *pParser;
  (pParser = ((yyParser *) (*mallocProc)(((size_t ) sizeof(yyParser )))));
  if (pParser) {
    (pParser->yyidx = (- 1));
  }  
  return pParser;
}
static  void yy_destructor(yyParser *yypParser , unsigned  char yymajor , YYMINORTYPE *yypminor )  {
  Parse *pParse =  yypParser->pParse;
  switch (yymajor) {
    case 160:
    case 194:
    {
      sqlite3SelectDelete(pParse->db, yypminor->yy159);
    }
    break;
    case 173:
    case 174:
    {
      sqlite3ExprDelete(pParse->db, yypminor->yy342.pExpr);
    }
    break;
    case 178:
    case 187:
    case 197:
    case 200:
    case 202:
    case 204:
    case 214:
    case 215:
    case 216:
    case 220:
    case 225:
    {
      sqlite3ExprListDelete(pParse->db, yypminor->yy442);
    }
    break;
    case 193:
    case 198:
    case 206:
    case 207:
    {
      sqlite3SrcListDelete(pParse->db, yypminor->yy347);
    }
    break;
    case 199:
    case 201:
    case 210:
    case 224:
    case 226:
    case 236:
    case 241:
    {
      sqlite3ExprDelete(pParse->db, yypminor->yy122);
    }
    break;
    case 211:
    case 213:
    case 218:
    {
      sqlite3IdListDelete(pParse->db, yypminor->yy180);
    }
    break;
    case 219:
    {
      sqlite3ExprListDelete(pParse->db, yypminor->yy487.pList);
      sqlite3SelectDelete(pParse->db, yypminor->yy487.pSelect);
    }
    break;
    case 232:
    case 237:
    {
      sqlite3DeleteTriggerStep(pParse->db, yypminor->yy327);
    }
    break;
    case 234:
    {
      sqlite3IdListDelete(pParse->db, yypminor->yy410.b);
    }
    break;
    id2i_label_1:
    default:
    break;
  }
}
static  int yy_pop_parser_stack(yyParser *pParser )  {
  unsigned char yymajor;
  yyStackEntry *yytos =  (&pParser->yystack[pParser->yyidx]);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return 0;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pParser->yyidx < 0)) {
      return 0;
    }  
  }  
  (yymajor = yytos->major);
  yy_destructor(pParser, yymajor, (&yytos->minor));
  pParser->yyidx--;
  return yymajor;
}
static  void sqlite3ParserFree(void *p , void ( *freeProc)(void * ) )  {
  yyParser *pParser =  ((yyParser *) p);
  if (((id2i_sqlite_coverage_test ) )) {
    if (0) {
      return;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if ((pParser == 0)) {
      return;
    }  
  }  
  while ((pParser->yyidx >= 0)) {
    yy_pop_parser_stack(pParser);
  }
  (*freeProc)(((void *) pParser));
}
static  int yy_find_shift_action(yyParser *pParser , unsigned  char iLookAhead )  {
  int i;
  int stateno =  pParser->yystack[pParser->yyidx].stateno;
  if (((stateno > 417) || ((i = yy_shift_ofst[stateno]) == (- 70)))) {
    return yy_default[stateno];
  }  
  ((void ) 0);
  (i += iLookAhead);
  if (((i < 0) || (i >= 1564) || (yy_lookahead[i] != iLookAhead))) {
    if ((iLookAhead > 0)) {
      unsigned char iFallback;
      if (((iLookAhead < (sizeof(yyFallback) / sizeof(yyFallback[0]))) && ((iFallback = yyFallback[iLookAhead]) != 0))) {
        return yy_find_shift_action(pParser, iFallback);
      }  
      {
        int j =  (i - iLookAhead + 67);
        if (((j >= 0) && (yy_lookahead[j] == 67))) {
          return yy_action[j];
        }  
      }
    }  
    return yy_default[stateno];
  }  
  else {
    return yy_action[i];
  }
}
static  int yy_find_reduce_action(int stateno , unsigned  char iLookAhead )  {
  int i;
  ((void ) 0);
  (i = yy_reduce_ofst[stateno]);
  ((void ) 0);
  ((void ) 0);
  (i += iLookAhead);
  ((void ) 0);
  ((void ) 0);
  return yy_action[i];
}
static  void yyStackOverflow(yyParser *yypParser , YYMINORTYPE *yypMinor )  {
  Parse *pParse =  yypParser->pParse;
  yypParser->yyidx--;
  while ((yypParser->yyidx >= 0)) {
    yy_pop_parser_stack(yypParser);
  }
  ((void ) yypMinor);
  sqlite3ErrorMsg(pParse, "parser stack overflow");
  (yypParser->pParse = pParse);
}
static  void yy_shift(yyParser *yypParser , int yyNewState , int yyMajor , YYMINORTYPE *yypMinor )  {
  yyStackEntry *yytos;
  yypParser->yyidx++;
  if ((yypParser->yyidx >= 100)) {
    yyStackOverflow(yypParser, yypMinor);
    return;
  }  
  (yytos = (&yypParser->yystack[yypParser->yyidx]));
  (yytos->stateno = ((unsigned  short  int ) yyNewState));
  (yytos->major = ((unsigned  char ) yyMajor));
  (yytos->minor = (*yypMinor));
}
static const struct   {
  unsigned  char lhs ;
  unsigned  char nrhs ;
}  yyRuleInfo[] =  { { 142,  1},  { 143,  2},  { 143,  1},  { 144,  1},  { 144,  3},  { 145,  0},  { 145,  1},  { 145,  3},  { 146,  1},  { 147,  3},  { 149,  0},  { 149,  1},  { 149,  2},  { 148,  0},  { 148,  1},  { 148,  1},  { 148,  1},  { 147,  2},  { 147,  2},  { 147,  2},  { 151,  1},  { 151,  0},  { 147,  2},  { 147,  3},  { 147,  5},  { 147,  2},  { 152,  6},  { 154,  1},  { 156,  0},  { 156,  3},  { 155,  1},  { 155,  0},  { 153,  4},  { 153,  2},  { 158,  3},  { 158,  1},  { 161,  3},  { 162,  1},  { 165,  1},  { 165,  1},  { 166,  1},  { 150,  1},  { 150,  1},  { 150,  1},  { 163,  0},  { 163,  1},  { 167,  1},  { 167,  4},  { 167,  6},  { 168,  1},  { 168,  2},  { 169,  1},  { 169,  1},  { 164,  2},  { 164,  0},  { 172,  2},  { 172,  2},  { 172,  4},  { 172,  3},  { 172,  3},  { 172,  2},  { 172,  2},  { 172,  3},  { 172,  5},  { 172,  2},  { 172,  4},  { 172,  4},  { 172,  1},  { 172,  2},  { 177,  0},  { 177,  1},  { 179,  0},  { 179,  2},  { 181,  2},  { 181,  3},  { 181,  3},  { 181,  3},  { 182,  2},  { 182,  2},  { 182,  1},  { 182,  1},  { 182,  2},  { 180,  3},  { 180,  2},  { 183,  0},  { 183,  2},  { 183,  2},  { 159,  0},  { 159,  2},  { 184,  3},  { 184,  1},  { 185,  1},  { 185,  0},  { 186,  2},  { 186,  7},  { 186,  5},  { 186,  5},  { 186,  10},  { 188,  0},  { 188,  1},  { 175,  0},  { 175,  3},  { 189,  0},  { 189,  2},  { 190,  1},  { 190,  1},  { 190,  1},  { 147,  4},  { 192,  2},  { 192,  0},  { 147,  8},  { 147,  4},  { 147,  1},  { 160,  1},  { 160,  3},  { 195,  1},  { 195,  2},  { 195,  1},  { 194,  9},  { 196,  1},  { 196,  1},  { 196,  0},  { 204,  2},  { 204,  0},  { 197,  3},  { 197,  2},  { 197,  4},  { 205,  2},  { 205,  1},  { 205,  0},  { 198,  0},  { 198,  2},  { 207,  2},  { 207,  0},  { 206,  7},  { 206,  7},  { 206,  7},  { 157,  0},  { 157,  2},  { 193,  2},  { 208,  1},  { 208,  2},  { 208,  3},  { 208,  4},  { 210,  2},  { 210,  0},  { 209,  0},  { 209,  3},  { 209,  2},  { 211,  4},  { 211,  0},  { 202,  0},  { 202,  3},  { 214,  4},  { 214,  2},  { 176,  1},  { 176,  1},  { 176,  0},  { 200,  0},  { 200,  3},  { 201,  0},  { 201,  2},  { 203,  0},  { 203,  2},  { 203,  4},  { 203,  4},  { 147,  5},  { 199,  0},  { 199,  2},  { 147,  7},  { 216,  5},  { 216,  3},  { 147,  5},  { 147,  5},  { 147,  6},  { 217,  2},  { 217,  1},  { 219,  4},  { 219,  5},  { 218,  0},  { 218,  3},  { 213,  3},  { 213,  1},  { 174,  1},  { 174,  3},  { 173,  1},  { 174,  1},  { 174,  1},  { 174,  3},  { 174,  5},  { 173,  1},  { 173,  1},  { 174,  1},  { 174,  1},  { 174,  3},  { 174,  6},  { 174,  5},  { 174,  4},  { 173,  1},  { 174,  3},  { 174,  3},  { 174,  3},  { 174,  3},  { 174,  3},  { 174,  3},  { 174,  3},  { 174,  3},  { 221,  1},  { 221,  2},  { 221,  1},  { 221,  2},  { 174,  3},  { 174,  5},  { 174,  2},  { 174,  3},  { 174,  3},  { 174,  4},  { 174,  2},  { 174,  2},  { 174,  2},  { 174,  2},  { 222,  1},  { 222,  2},  { 174,  5},  { 223,  1},  { 223,  2},  { 174,  5},  { 174,  3},  { 174,  5},  { 174,  4},  { 174,  4},  { 174,  5},  { 225,  5},  { 225,  4},  { 226,  2},  { 226,  0},  { 224,  1},  { 224,  0},  { 220,  1},  { 220,  0},  { 215,  3},  { 215,  1},  { 147,  12},  { 227,  1},  { 227,  0},  { 178,  0},  { 178,  3},  { 187,  5},  { 187,  3},  { 228,  0},  { 228,  2},  { 147,  4},  { 147,  1},  { 147,  2},  { 147,  3},  { 147,  5},  { 147,  6},  { 147,  5},  { 147,  6},  { 229,  1},  { 229,  1},  { 229,  1},  { 229,  1},  { 229,  1},  { 170,  2},  { 170,  1},  { 171,  2},  { 230,  1},  { 147,  5},  { 231,  11},  { 233,  1},  { 233,  1},  { 233,  2},  { 233,  0},  { 234,  1},  { 234,  1},  { 234,  3},  { 235,  0},  { 235,  3},  { 236,  0},  { 236,  2},  { 232,  3},  { 232,  2},  { 238,  1},  { 238,  3},  { 239,  0},  { 239,  3},  { 239,  2},  { 237,  7},  { 237,  5},  { 237,  5},  { 237,  5},  { 237,  1},  { 174,  4},  { 174,  6},  { 191,  1},  { 191,  1},  { 191,  1},  { 147,  4},  { 147,  6},  { 147,  3},  { 241,  0},  { 241,  2},  { 240,  1},  { 240,  0},  { 147,  1},  { 147,  3},  { 147,  1},  { 147,  3},  { 147,  6},  { 147,  6},  { 242,  1},  { 243,  0},  { 243,  1},  { 147,  1},  { 147,  4},  { 244,  8},  { 245,  1},  { 245,  3},  { 246,  0},  { 246,  2},  { 247,  1},  { 247,  3},  { 248,  1},  { 249,  0},  { 249,  4},  { 249,  2}};
static void yy_accept(yyParser * );
static  void yy_reduce(yyParser *yypParser , int yyruleno )  {
  int yygoto;
  int yyact;
  YYMINORTYPE yygotominor;
  yyStackEntry *yymsp;
  int yysize;
  Parse *pParse =  yypParser->pParse;
  (yymsp = (&yypParser->yystack[yypParser->yyidx]));
  (yygotominor = yyzerominor);
  switch (yyruleno) {
    case 5:
    {
      sqlite3BeginParse(pParse, 0);
    }
    break;
    case 6:
    {
      sqlite3BeginParse(pParse, 1);
    }
    break;
    case 7:
    {
      sqlite3BeginParse(pParse, 2);
    }
    break;
    case 8:
    {
      sqlite3FinishCoding(pParse);
    }
    break;
    case 9:
    {
      sqlite3BeginTransaction(pParse, yymsp[(- 1)].minor.yy392);
    }
    break;
    case 13:
    {
      (yygotominor.yy392 = 7);
    }
    break;
    case 14:
    case 15:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 15)) {
        sqlite3Coverage(114745);
      }  
    }  
    case 16:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 16)) {
        sqlite3Coverage(114746);
      }  
    }  
    case 115:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 115)) {
        sqlite3Coverage(114747);
      }  
    }  
    case 117:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 117)) {
        sqlite3Coverage(114748);
      }  
    }  
    {
      (yygotominor.yy392 = yymsp[0].major);
    }
    break;
    case 17:
    case 18:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 18)) {
        sqlite3Coverage(114752);
      }  
    }  
    {
      sqlite3CommitTransaction(pParse);
    }
    break;
    case 19:
    {
      sqlite3RollbackTransaction(pParse);
    }
    break;
    case 22:
    {
      sqlite3Savepoint(pParse, 0, (&yymsp[0].minor.yy0));
    }
    break;
    case 23:
    {
      sqlite3Savepoint(pParse, 1, (&yymsp[0].minor.yy0));
    }
    break;
    case 24:
    {
      sqlite3Savepoint(pParse, 2, (&yymsp[0].minor.yy0));
    }
    break;
    case 26:
    {
      sqlite3StartTable(pParse, (&yymsp[(- 1)].minor.yy0), (&yymsp[0].minor.yy0), yymsp[(- 4)].minor.yy392, 0, 0, yymsp[(- 2)].minor.yy392);
    }
    break;
    case 27:
    {
      (pParse->db->lookaside.bEnabled = 0);
      (yygotominor.yy0 = yymsp[0].minor.yy0);
    }
    break;
    case 28:
    case 31:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 31)) {
        sqlite3Coverage(114785);
      }  
    }  
    case 69:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 69)) {
        sqlite3Coverage(114786);
      }  
    }  
    case 82:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 82)) {
        sqlite3Coverage(114787);
      }  
    }  
    case 84:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 84)) {
        sqlite3Coverage(114788);
      }  
    }  
    case 86:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 86)) {
        sqlite3Coverage(114789);
      }  
    }  
    case 98:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 98)) {
        sqlite3Coverage(114790);
      }  
    }  
    case 109:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 109)) {
        sqlite3Coverage(114791);
      }  
    }  
    case 221:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 221)) {
        sqlite3Coverage(114792);
      }  
    }  
    case 224:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 224)) {
        sqlite3Coverage(114793);
      }  
    }  
    {
      (yygotominor.yy392 = 0);
    }
    break;
    case 29:
    case 30:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 30)) {
        sqlite3Coverage(114797);
      }  
    }  
    case 70:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 70)) {
        sqlite3Coverage(114798);
      }  
    }  
    case 85:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 85)) {
        sqlite3Coverage(114799);
      }  
    }  
    case 108:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 108)) {
        sqlite3Coverage(114800);
      }  
    }  
    case 222:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 222)) {
        sqlite3Coverage(114801);
      }  
    }  
    case 225:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 225)) {
        sqlite3Coverage(114802);
      }  
    }  
    {
      (yygotominor.yy392 = 1);
    }
    break;
    case 32:
    {
      sqlite3EndTable(pParse, (&yymsp[(- 1)].minor.yy0), (&yymsp[0].minor.yy0), 0);
    }
    break;
    case 33:
    {
      sqlite3EndTable(pParse, 0, 0, yymsp[0].minor.yy159);
      sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy159);
    }
    break;
    case 36:
    {
      (yygotominor.yy0.z = yymsp[(- 2)].minor.yy0.z);
      (yygotominor.yy0.n = (((int ) (pParse->sLastToken.z - yymsp[(- 2)].minor.yy0.z)) + pParse->sLastToken.n));
    }
    break;
    case 37:
    {
      sqlite3AddColumn(pParse, (&yymsp[0].minor.yy0));
      (yygotominor.yy0 = yymsp[0].minor.yy0);
      (pParse->constraintName.n = 0);
    }
    break;
    case 38:
    case 39:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 39)) {
        sqlite3Coverage(114830);
      }  
    }  
    case 40:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 40)) {
        sqlite3Coverage(114831);
      }  
    }  
    case 41:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 41)) {
        sqlite3Coverage(114832);
      }  
    }  
    case 42:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 42)) {
        sqlite3Coverage(114833);
      }  
    }  
    case 43:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 43)) {
        sqlite3Coverage(114834);
      }  
    }  
    case 46:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 46)) {
        sqlite3Coverage(114835);
      }  
    }  
    case 49:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 49)) {
        sqlite3Coverage(114836);
      }  
    }  
    case 127:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 127)) {
        sqlite3Coverage(114837);
      }  
    }  
    case 128:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 128)) {
        sqlite3Coverage(114838);
      }  
    }  
    case 138:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 138)) {
        sqlite3Coverage(114839);
      }  
    }  
    case 147:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 147)) {
        sqlite3Coverage(114840);
      }  
    }  
    case 250:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 250)) {
        sqlite3Coverage(114841);
      }  
    }  
    case 259:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 259)) {
        sqlite3Coverage(114842);
      }  
    }  
    case 260:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 260)) {
        sqlite3Coverage(114843);
      }  
    }  
    case 261:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 261)) {
        sqlite3Coverage(114844);
      }  
    }  
    case 262:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 262)) {
        sqlite3Coverage(114845);
      }  
    }  
    case 263:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 263)) {
        sqlite3Coverage(114846);
      }  
    }  
    case 264:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 264)) {
        sqlite3Coverage(114847);
      }  
    }  
    case 265:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 265)) {
        sqlite3Coverage(114848);
      }  
    }  
    case 266:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 266)) {
        sqlite3Coverage(114849);
      }  
    }  
    case 267:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 267)) {
        sqlite3Coverage(114850);
      }  
    }  
    case 283:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 283)) {
        sqlite3Coverage(114851);
      }  
    }  
    {
      (yygotominor.yy0 = yymsp[0].minor.yy0);
    }
    break;
    case 45:
    {
      sqlite3AddColumnType(pParse, (&yymsp[0].minor.yy0));
    }
    break;
    case 47:
    {
      (yygotominor.yy0.z = yymsp[(- 3)].minor.yy0.z);
      (yygotominor.yy0.n = ((int ) ((&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n]) - yymsp[(- 3)].minor.yy0.z)));
    }
    break;
    case 48:
    {
      (yygotominor.yy0.z = yymsp[(- 5)].minor.yy0.z);
      (yygotominor.yy0.n = ((int ) ((&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n]) - yymsp[(- 5)].minor.yy0.z)));
    }
    break;
    case 50:
    {
      (yygotominor.yy0.z = yymsp[(- 1)].minor.yy0.z);
      (yygotominor.yy0.n = (yymsp[0].minor.yy0.n + ((int ) (yymsp[0].minor.yy0.z - yymsp[(- 1)].minor.yy0.z))));
    }
    break;
    case 55:
    case 93:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 93)) {
        sqlite3Coverage(114873);
      }  
    }  
    {
      (pParse->constraintName = yymsp[0].minor.yy0);
    }
    break;
    case 56:
    case 58:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 58)) {
        sqlite3Coverage(114877);
      }  
    }  
    {
      sqlite3AddDefaultValue(pParse, (&yymsp[0].minor.yy342));
    }
    break;
    case 57:
    {
      sqlite3AddDefaultValue(pParse, (&yymsp[(- 1)].minor.yy342));
    }
    break;
    case 59:
    {
      ExprSpan v;
      (v.pExpr = sqlite3PExpr(pParse, 156, yymsp[0].minor.yy342.pExpr, 0, 0));
      (v.zStart = yymsp[(- 1)].minor.yy0.z);
      (v.zEnd = yymsp[0].minor.yy342.zEnd);
      sqlite3AddDefaultValue(pParse, (&v));
    }
    break;
    case 60:
    {
      ExprSpan v;
      spanExpr((&v), pParse, 94, (&yymsp[0].minor.yy0));
      sqlite3AddDefaultValue(pParse, (&v));
    }
    break;
    case 62:
    {
      sqlite3AddNotNull(pParse, yymsp[0].minor.yy392);
    }
    break;
    case 63:
    {
      sqlite3AddPrimaryKey(pParse, 0, yymsp[(- 1)].minor.yy392, yymsp[0].minor.yy392, yymsp[(- 2)].minor.yy392);
    }
    break;
    case 64:
    {
      sqlite3CreateIndex(pParse, 0, 0, 0, 0, yymsp[0].minor.yy392, 0, 0, 0, 0);
    }
    break;
    case 65:
    {
      sqlite3AddCheckConstraint(pParse, yymsp[(- 1)].minor.yy342.pExpr);
    }
    break;
    case 66:
    {
      sqlite3CreateForeignKey(pParse, 0, (&yymsp[(- 2)].minor.yy0), yymsp[(- 1)].minor.yy442, yymsp[0].minor.yy392);
    }
    break;
    case 67:
    {
      sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy392);
    }
    break;
    case 68:
    {
      sqlite3AddCollateType(pParse, (&yymsp[0].minor.yy0));
    }
    break;
    case 71:
    {
      (yygotominor.yy392 = (0 * 0x0101));
    }
    break;
    case 72:
    {
      (yygotominor.yy392 = ((yymsp[(- 1)].minor.yy392 & (~ yymsp[0].minor.yy207.mask)) | yymsp[0].minor.yy207.value));
    }
    break;
    case 73:
    case 74:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 74)) {
        sqlite3Coverage(114927);
      }  
    }  
    {
      (yygotominor.yy207.value = 0);
      (yygotominor.yy207.mask = 0x000000);
    }
    break;
    case 75:
    {
      (yygotominor.yy207.value = yymsp[0].minor.yy392);
      (yygotominor.yy207.mask = 0x0000ff);
    }
    break;
    case 76:
    {
      (yygotominor.yy207.value = (yymsp[0].minor.yy392 << 8));
      (yygotominor.yy207.mask = 0x00ff00);
    }
    break;
    case 77:
    {
      (yygotominor.yy392 = 7);
    }
    break;
    case 78:
    {
      (yygotominor.yy392 = 8);
    }
    break;
    case 79:
    {
      (yygotominor.yy392 = 9);
    }
    break;
    case 80:
    {
      (yygotominor.yy392 = 6);
    }
    break;
    case 81:
    {
      (yygotominor.yy392 = 0);
    }
    break;
    case 83:
    case 99:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 99)) {
        sqlite3Coverage(114952);
      }  
    }  
    case 101:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 101)) {
        sqlite3Coverage(114953);
      }  
    }  
    case 104:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 104)) {
        sqlite3Coverage(114954);
      }  
    }  
    {
      (yygotominor.yy392 = yymsp[0].minor.yy392);
    }
    break;
    case 87:
    {
      (yygotominor.yy0.n = 0);
      (yygotominor.yy0.z = 0);
    }
    break;
    case 88:
    {
      (yygotominor.yy0 = yymsp[(- 1)].minor.yy0);
    }
    break;
    case 91:
    {
      (pParse->constraintName.n = 0);
    }
    break;
    case 94:
    {
      sqlite3AddPrimaryKey(pParse, yymsp[(- 3)].minor.yy442, yymsp[0].minor.yy392, yymsp[(- 2)].minor.yy392, 0);
    }
    break;
    case 95:
    {
      sqlite3CreateIndex(pParse, 0, 0, 0, yymsp[(- 2)].minor.yy442, yymsp[0].minor.yy392, 0, 0, 0, 0);
    }
    break;
    case 96:
    {
      sqlite3AddCheckConstraint(pParse, yymsp[(- 2)].minor.yy342.pExpr);
    }
    break;
    case 97:
    {
      sqlite3CreateForeignKey(pParse, yymsp[(- 6)].minor.yy442, (&yymsp[(- 3)].minor.yy0), yymsp[(- 2)].minor.yy442, yymsp[(- 1)].minor.yy392);
      sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy392);
    }
    break;
    case 100:
    {
      (yygotominor.yy392 = 10);
    }
    break;
    case 102:
    {
      (yygotominor.yy258 = 10);
    }
    break;
    case 103:
    {
      (yygotominor.yy258 = ((u8 ) yymsp[0].minor.yy392));
    }
    break;
    case 105:
    {
      (yygotominor.yy392 = 4);
    }
    break;
    case 106:
    {
      (yygotominor.yy392 = 5);
    }
    break;
    case 107:
    {
      sqlite3DropTable(pParse, yymsp[0].minor.yy347, 0, yymsp[(- 1)].minor.yy392);
    }
    break;
    case 110:
    {
      sqlite3CreateView(pParse, (&yymsp[(- 7)].minor.yy0), (&yymsp[(- 3)].minor.yy0), (&yymsp[(- 2)].minor.yy0), yymsp[0].minor.yy159, yymsp[(- 6)].minor.yy392, yymsp[(- 4)].minor.yy392);
    }
    break;
    case 111:
    {
      sqlite3DropTable(pParse, yymsp[0].minor.yy347, 1, yymsp[(- 1)].minor.yy392);
    }
    break;
    case 112:
    {
      SelectDest dest =  { 5,  0,  0,  0,  0};
      sqlite3Select(pParse, yymsp[0].minor.yy159, (&dest));
      if (((id2i_sqlite_enable_tree_explain ) )) {
        sqlite3ExplainBegin(pParse->pVdbe);
      }  
      if (((id2i_sqlite_enable_tree_explain ) )) {
        sqlite3ExplainSelect(pParse->pVdbe, yymsp[0].minor.yy159);
      }  
      if (((id2i_sqlite_enable_tree_explain ) )) {
        sqlite3ExplainFinish(pParse->pVdbe);
      }  
      sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy159);
    }
    break;
    case 113:
    {
      (yygotominor.yy159 = yymsp[0].minor.yy159);
    }
    break;
    case 114:
    {
      if (yymsp[0].minor.yy159) {
        (yymsp[0].minor.yy159->op = ((u8 ) yymsp[(- 1)].minor.yy392));
        (yymsp[0].minor.yy159->pPrior = yymsp[(- 2)].minor.yy159);
        if ((yymsp[(- 1)].minor.yy392 != 113)) {
          (pParse->hasCompound = 1);
        }  
      }  
      else {
        sqlite3SelectDelete(pParse->db, yymsp[(- 2)].minor.yy159);
      }
      (yygotominor.yy159 = yymsp[0].minor.yy159);
    }
    break;
    case 116:
    {
      (yygotominor.yy392 = 113);
    }
    break;
    case 118:
    {
      (yygotominor.yy159 = sqlite3SelectNew(pParse, yymsp[(- 6)].minor.yy442, yymsp[(- 5)].minor.yy347, yymsp[(- 4)].minor.yy122, yymsp[(- 3)].minor.yy442, yymsp[(- 2)].minor.yy122, yymsp[(- 1)].minor.yy442, yymsp[(- 7)].minor.yy305, yymsp[0].minor.yy64.pLimit, yymsp[0].minor.yy64.pOffset));
    }
    break;
    case 119:
    {
      (yygotominor.yy305 = 0x0001);
    }
    break;
    case 120:
    case 121:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 121)) {
        sqlite3Coverage(115048);
      }  
    }  
    {
      (yygotominor.yy305 = 0);
    }
    break;
    case 122:
    case 246:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 246)) {
        sqlite3Coverage(115052);
      }  
    }  
    {
      (yygotominor.yy442 = yymsp[(- 1)].minor.yy442);
    }
    break;
    case 123:
    case 151:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 151)) {
        sqlite3Coverage(115056);
      }  
    }  
    case 158:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 158)) {
        sqlite3Coverage(115057);
      }  
    }  
    case 239:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 239)) {
        sqlite3Coverage(115058);
      }  
    }  
    case 245:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 245)) {
        sqlite3Coverage(115059);
      }  
    }  
    {
      (yygotominor.yy442 = 0);
    }
    break;
    case 124:
    {
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, yymsp[(- 2)].minor.yy442, yymsp[(- 1)].minor.yy342.pExpr));
      if ((yymsp[0].minor.yy0.n > 0)) {
        sqlite3ExprListSetName(pParse, yygotominor.yy442, (&yymsp[0].minor.yy0), 1);
      }  
      sqlite3ExprListSetSpan(pParse, yygotominor.yy442, (&yymsp[(- 1)].minor.yy342));
    }
    break;
    case 125:
    {
      Expr *p =  sqlite3Expr(pParse->db, 113, 0);
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, yymsp[(- 1)].minor.yy442, p));
    }
    break;
    case 126:
    {
      Expr *pRight =  sqlite3PExpr(pParse, 113, 0, 0, (&yymsp[0].minor.yy0));
      Expr *pLeft =  sqlite3PExpr(pParse, 26, 0, 0, (&yymsp[(- 2)].minor.yy0));
      Expr *pDot =  sqlite3PExpr(pParse, 118, pLeft, pRight, 0);
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, yymsp[(- 3)].minor.yy442, pDot));
    }
    break;
    case 129:
    {
      (yygotominor.yy0.n = 0);
    }
    break;
    case 130:
    {
      (yygotominor.yy347 = sqlite3DbMallocZero(pParse->db, sizeof((*yygotominor.yy347))));
    }
    break;
    case 131:
    {
      (yygotominor.yy347 = yymsp[0].minor.yy347);
      sqlite3SrcListShiftJoinType(yygotominor.yy347);
    }
    break;
    case 132:
    {
      (yygotominor.yy347 = yymsp[(- 1)].minor.yy347);
      if (((id2i_sqlite_coverage_test ) )) {
        if (1) {
          (yygotominor.yy347->a[(yygotominor.yy347->nSrc - 1)].jointype = ((u8 ) yymsp[0].minor.yy392));
        }  
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if ((yygotominor.yy347 && (yygotominor.yy347->nSrc > 0))) {
          (yygotominor.yy347->a[(yygotominor.yy347->nSrc - 1)].jointype = ((u8 ) yymsp[0].minor.yy392));
        }  
      }  
    }
    break;
    case 133:
    {
      (yygotominor.yy347 = 0);
    }
    break;
    case 134:
    {
      (yygotominor.yy347 = sqlite3SrcListAppendFromTerm(pParse, yymsp[(- 6)].minor.yy347, (&yymsp[(- 5)].minor.yy0), (&yymsp[(- 4)].minor.yy0), (&yymsp[(- 3)].minor.yy0), 0, yymsp[(- 1)].minor.yy122, yymsp[0].minor.yy180));
      sqlite3SrcListIndexedBy(pParse, yygotominor.yy347, (&yymsp[(- 2)].minor.yy0));
    }
    break;
    case 135:
    {
      (yygotominor.yy347 = sqlite3SrcListAppendFromTerm(pParse, yymsp[(- 6)].minor.yy347, 0, 0, (&yymsp[(- 2)].minor.yy0), yymsp[(- 4)].minor.yy159, yymsp[(- 1)].minor.yy122, yymsp[0].minor.yy180));
    }
    break;
    case 136:
    {
      if (((yymsp[(- 6)].minor.yy347 == 0) && (yymsp[(- 2)].minor.yy0.n == 0) && (yymsp[(- 1)].minor.yy122 == 0) && (yymsp[0].minor.yy180 == 0))) {
        (yygotominor.yy347 = yymsp[(- 4)].minor.yy347);
      } 
      else if ((yymsp[(- 4)].minor.yy347->nSrc == 1)) {
        (yygotominor.yy347 = sqlite3SrcListAppendFromTerm(pParse, yymsp[(- 6)].minor.yy347, 0, 0, (&yymsp[(- 2)].minor.yy0), 0, yymsp[(- 1)].minor.yy122, yymsp[0].minor.yy180));
        if (yygotominor.yy347) {
          struct  SrcList_item   *pNew =  (&yygotominor.yy347->a[(yygotominor.yy347->nSrc - 1)]);
          struct  SrcList_item   *pOld =  yymsp[(- 4)].minor.yy347->a;
          (pNew->zName = pOld->zName);
          (pNew->zDatabase = pOld->zDatabase);
          (pNew->pSelect = pOld->pSelect);
          (pOld->zName = (pOld->zDatabase = 0));
          (pOld->pSelect = 0);
        }  
        sqlite3SrcListDelete(pParse->db, yymsp[(- 4)].minor.yy347);
      } 
      else {
        Select *pSubquery;
        sqlite3SrcListShiftJoinType(yymsp[(- 4)].minor.yy347);
        (pSubquery = sqlite3SelectNew(pParse, 0, yymsp[(- 4)].minor.yy347, 0, 0, 0, 0, 0x0200, 0, 0));
        (yygotominor.yy347 = sqlite3SrcListAppendFromTerm(pParse, yymsp[(- 6)].minor.yy347, 0, 0, (&yymsp[(- 2)].minor.yy0), pSubquery, yymsp[(- 1)].minor.yy122, yymsp[0].minor.yy180));
      }
    }
    break;
    case 137:
    case 146:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 146)) {
        sqlite3Coverage(115140);
      }  
    }  
    {
      (yygotominor.yy0.z = 0);
      (yygotominor.yy0.n = 0);
    }
    break;
    case 139:
    {
      (yygotominor.yy347 = sqlite3SrcListAppend(pParse->db, 0, (&yymsp[(- 1)].minor.yy0), (&yymsp[0].minor.yy0)));
    }
    break;
    case 140:
    {
      (yygotominor.yy392 = 0x0001);
    }
    break;
    case 141:
    {
      (yygotominor.yy392 = sqlite3JoinType(pParse, (&yymsp[(- 1)].minor.yy0), 0, 0));
    }
    break;
    case 142:
    {
      (yygotominor.yy392 = sqlite3JoinType(pParse, (&yymsp[(- 2)].minor.yy0), (&yymsp[(- 1)].minor.yy0), 0));
    }
    break;
    case 143:
    {
      (yygotominor.yy392 = sqlite3JoinType(pParse, (&yymsp[(- 3)].minor.yy0), (&yymsp[(- 2)].minor.yy0), (&yymsp[(- 1)].minor.yy0)));
    }
    break;
    case 144:
    case 161:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 161)) {
        sqlite3Coverage(115159);
      }  
    }  
    case 168:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 168)) {
        sqlite3Coverage(115160);
      }  
    }  
    case 234:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 234)) {
        sqlite3Coverage(115161);
      }  
    }  
    case 236:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 236)) {
        sqlite3Coverage(115162);
      }  
    }  
    {
      (yygotominor.yy122 = yymsp[0].minor.yy342.pExpr);
    }
    break;
    case 145:
    case 160:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 160)) {
        sqlite3Coverage(115166);
      }  
    }  
    case 167:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 167)) {
        sqlite3Coverage(115167);
      }  
    }  
    case 235:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 235)) {
        sqlite3Coverage(115168);
      }  
    }  
    case 237:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 237)) {
        sqlite3Coverage(115169);
      }  
    }  
    {
      (yygotominor.yy122 = 0);
    }
    break;
    case 148:
    {
      (yygotominor.yy0.z = 0);
      (yygotominor.yy0.n = 1);
    }
    break;
    case 149:
    case 180:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 180)) {
        sqlite3Coverage(115176);
      }  
    }  
    {
      (yygotominor.yy180 = yymsp[(- 1)].minor.yy180);
    }
    break;
    case 150:
    case 179:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 179)) {
        sqlite3Coverage(115180);
      }  
    }  
    {
      (yygotominor.yy180 = 0);
    }
    break;
    case 152:
    case 159:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 159)) {
        sqlite3Coverage(115184);
      }  
    }  
    case 238:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 238)) {
        sqlite3Coverage(115185);
      }  
    }  
    {
      (yygotominor.yy442 = yymsp[0].minor.yy442);
    }
    break;
    case 153:
    {
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, yymsp[(- 3)].minor.yy442, yymsp[(- 1)].minor.yy342.pExpr));
      if (yygotominor.yy442) {
        (yygotominor.yy442->a[(yygotominor.yy442->nExpr - 1)].sortOrder = ((u8 ) yymsp[0].minor.yy392));
      }  
    }
    break;
    case 154:
    {
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, 0, yymsp[(- 1)].minor.yy342.pExpr));
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if ((yygotominor.yy442 && yygotominor.yy442->a)) {
          (yygotominor.yy442->a[0].sortOrder = ((u8 ) yymsp[0].minor.yy392));
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((yygotominor.yy442 && 1)) {
          (yygotominor.yy442->a[0].sortOrder = ((u8 ) yymsp[0].minor.yy392));
        }  
      }  
    }
    break;
    case 155:
    case 157:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 157)) {
        sqlite3Coverage(115201);
      }  
    }  
    {
      (yygotominor.yy392 = 0);
    }
    break;
    case 156:
    {
      (yygotominor.yy392 = 1);
    }
    break;
    case 162:
    {
      (yygotominor.yy64.pLimit = 0);
      (yygotominor.yy64.pOffset = 0);
    }
    break;
    case 163:
    {
      (yygotominor.yy64.pLimit = yymsp[0].minor.yy342.pExpr);
      (yygotominor.yy64.pOffset = 0);
    }
    break;
    case 164:
    {
      (yygotominor.yy64.pLimit = yymsp[(- 2)].minor.yy342.pExpr);
      (yygotominor.yy64.pOffset = yymsp[0].minor.yy342.pExpr);
    }
    break;
    case 165:
    {
      (yygotominor.yy64.pOffset = yymsp[(- 2)].minor.yy342.pExpr);
      (yygotominor.yy64.pLimit = yymsp[0].minor.yy342.pExpr);
    }
    break;
    case 166:
    {
      sqlite3SrcListIndexedBy(pParse, yymsp[(- 2)].minor.yy347, (&yymsp[(- 1)].minor.yy0));
      sqlite3DeleteFrom(pParse, yymsp[(- 2)].minor.yy347, yymsp[0].minor.yy122);
    }
    break;
    case 169:
    {
      sqlite3SrcListIndexedBy(pParse, yymsp[(- 4)].minor.yy347, (&yymsp[(- 3)].minor.yy0));
      sqlite3ExprListCheckLength(pParse, yymsp[(- 1)].minor.yy442, "set list");
      sqlite3Update(pParse, yymsp[(- 4)].minor.yy347, yymsp[(- 1)].minor.yy442, yymsp[0].minor.yy122, yymsp[(- 5)].minor.yy258);
    }
    break;
    case 170:
    {
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, yymsp[(- 4)].minor.yy442, yymsp[0].minor.yy342.pExpr));
      sqlite3ExprListSetName(pParse, yygotominor.yy442, (&yymsp[(- 2)].minor.yy0), 1);
    }
    break;
    case 171:
    {
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy342.pExpr));
      sqlite3ExprListSetName(pParse, yygotominor.yy442, (&yymsp[(- 2)].minor.yy0), 1);
    }
    break;
    case 172:
    {
      sqlite3Insert(pParse, yymsp[(- 2)].minor.yy347, yymsp[0].minor.yy487.pList, yymsp[0].minor.yy487.pSelect, yymsp[(- 1)].minor.yy180, yymsp[(- 4)].minor.yy258);
    }
    break;
    case 173:
    {
      sqlite3Insert(pParse, yymsp[(- 2)].minor.yy347, 0, yymsp[0].minor.yy159, yymsp[(- 1)].minor.yy180, yymsp[(- 4)].minor.yy258);
    }
    break;
    case 174:
    {
      sqlite3Insert(pParse, yymsp[(- 3)].minor.yy347, 0, 0, yymsp[(- 2)].minor.yy180, yymsp[(- 5)].minor.yy258);
    }
    break;
    case 175:
    {
      (yygotominor.yy258 = yymsp[0].minor.yy258);
    }
    break;
    case 176:
    {
      (yygotominor.yy258 = 5);
    }
    break;
    case 177:
    {
      (yygotominor.yy487.pList = yymsp[(- 1)].minor.yy442);
      (yygotominor.yy487.pSelect = 0);
    }
    break;
    case 178:
    {
      Select *pRight =  sqlite3SelectNew(pParse, yymsp[(- 1)].minor.yy442, 0, 0, 0, 0, 0, 0, 0, 0);
      if (yymsp[(- 4)].minor.yy487.pList) {
        (yymsp[(- 4)].minor.yy487.pSelect = sqlite3SelectNew(pParse, yymsp[(- 4)].minor.yy487.pList, 0, 0, 0, 0, 0, 0, 0, 0));
        (yymsp[(- 4)].minor.yy487.pList = 0);
      }  
      (yygotominor.yy487.pList = 0);
      if (((yymsp[(- 4)].minor.yy487.pSelect == 0) || (pRight == 0))) {
        sqlite3SelectDelete(pParse->db, pRight);
        sqlite3SelectDelete(pParse->db, yymsp[(- 4)].minor.yy487.pSelect);
        (yygotominor.yy487.pSelect = 0);
      }  
      else {
        (pRight->op = 113);
        (pRight->pPrior = yymsp[(- 4)].minor.yy487.pSelect);
        (pRight->selFlags |= 0x0080);
        (pRight->pPrior->selFlags |= 0x0080);
        (yygotominor.yy487.pSelect = pRight);
      }
    }
    break;
    case 181:
    {
      (yygotominor.yy180 = sqlite3IdListAppend(pParse->db, yymsp[(- 2)].minor.yy180, (&yymsp[0].minor.yy0)));
    }
    break;
    case 182:
    {
      (yygotominor.yy180 = sqlite3IdListAppend(pParse->db, 0, (&yymsp[0].minor.yy0)));
    }
    break;
    case 183:
    {
      (yygotominor.yy342 = yymsp[0].minor.yy342);
    }
    break;
    case 184:
    {
      (yygotominor.yy342.pExpr = yymsp[(- 1)].minor.yy342.pExpr);
      spanSet((&yygotominor.yy342), (&yymsp[(- 2)].minor.yy0), (&yymsp[0].minor.yy0));
    }
    break;
    case 185:
    case 190:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 190)) {
        sqlite3Coverage(115299);
      }  
    }  
    case 191:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 191)) {
        sqlite3Coverage(115300);
      }  
    }  
    {
      spanExpr((&yygotominor.yy342), pParse, yymsp[0].major, (&yymsp[0].minor.yy0));
    }
    break;
    case 186:
    case 187:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 187)) {
        sqlite3Coverage(115304);
      }  
    }  
    {
      spanExpr((&yygotominor.yy342), pParse, 26, (&yymsp[0].minor.yy0));
    }
    break;
    case 188:
    {
      Expr *temp1 =  sqlite3PExpr(pParse, 26, 0, 0, (&yymsp[(- 2)].minor.yy0));
      Expr *temp2 =  sqlite3PExpr(pParse, 26, 0, 0, (&yymsp[0].minor.yy0));
      (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 118, temp1, temp2, 0));
      spanSet((&yygotominor.yy342), (&yymsp[(- 2)].minor.yy0), (&yymsp[0].minor.yy0));
    }
    break;
    case 189:
    {
      Expr *temp1 =  sqlite3PExpr(pParse, 26, 0, 0, (&yymsp[(- 4)].minor.yy0));
      Expr *temp2 =  sqlite3PExpr(pParse, 26, 0, 0, (&yymsp[(- 2)].minor.yy0));
      Expr *temp3 =  sqlite3PExpr(pParse, 26, 0, 0, (&yymsp[0].minor.yy0));
      Expr *temp4 =  sqlite3PExpr(pParse, 118, temp2, temp3, 0);
      (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 118, temp1, temp4, 0));
      spanSet((&yygotominor.yy342), (&yymsp[(- 4)].minor.yy0), (&yymsp[0].minor.yy0));
    }
    break;
    case 192:
    {
      if ((pParse->nested == 0)) {
        sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", (&yymsp[0].minor.yy0));
        (yygotominor.yy342.pExpr = 0);
      }  
      else {
        (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 132, 0, 0, (&yymsp[0].minor.yy0)));
        if (yygotominor.yy342.pExpr) {
          sqlite3GetInt32((&yymsp[0].minor.yy0.z[1]), (&yygotominor.yy342.pExpr->iTable));
        }  
      }
      spanSet((&yygotominor.yy342), (&yymsp[0].minor.yy0), (&yymsp[0].minor.yy0));
    }
    break;
    case 193:
    {
      spanExpr((&yygotominor.yy342), pParse, 133, (&yymsp[0].minor.yy0));
      sqlite3ExprAssignVarNumber(pParse, yygotominor.yy342.pExpr);
      spanSet((&yygotominor.yy342), (&yymsp[0].minor.yy0), (&yymsp[0].minor.yy0));
    }
    break;
    case 194:
    {
      (yygotominor.yy342.pExpr = sqlite3ExprAddCollateToken(pParse, yymsp[(- 2)].minor.yy342.pExpr, (&yymsp[0].minor.yy0)));
      (yygotominor.yy342.zStart = yymsp[(- 2)].minor.yy342.zStart);
      (yygotominor.yy342.zEnd = (&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n]));
    }
    break;
    case 195:
    {
      (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 37, yymsp[(- 3)].minor.yy342.pExpr, 0, (&yymsp[(- 1)].minor.yy0)));
      spanSet((&yygotominor.yy342), (&yymsp[(- 5)].minor.yy0), (&yymsp[0].minor.yy0));
    }
    break;
    case 196:
    {
      if ((yymsp[(- 1)].minor.yy442 && (yymsp[(- 1)].minor.yy442->nExpr > pParse->db->aLimit[6]))) {
        sqlite3ErrorMsg(pParse, "too many arguments on function %T", (&yymsp[(- 4)].minor.yy0));
      }  
      (yygotominor.yy342.pExpr = sqlite3ExprFunction(pParse, yymsp[(- 1)].minor.yy442, (&yymsp[(- 4)].minor.yy0)));
      spanSet((&yygotominor.yy342), (&yymsp[(- 4)].minor.yy0), (&yymsp[0].minor.yy0));
      if ((yymsp[(- 2)].minor.yy305 && yygotominor.yy342.pExpr)) {
        (yygotominor.yy342.pExpr->flags |= 0x000010);
      }  
    }
    break;
    case 197:
    {
      (yygotominor.yy342.pExpr = sqlite3ExprFunction(pParse, 0, (&yymsp[(- 3)].minor.yy0)));
      spanSet((&yygotominor.yy342), (&yymsp[(- 3)].minor.yy0), (&yymsp[0].minor.yy0));
    }
    break;
    case 198:
    {
      (yygotominor.yy342.pExpr = sqlite3ExprFunction(pParse, 0, (&yymsp[0].minor.yy0)));
      if (yygotominor.yy342.pExpr) {
        (yygotominor.yy342.pExpr->op = 155);
      }  
      spanSet((&yygotominor.yy342), (&yymsp[0].minor.yy0), (&yymsp[0].minor.yy0));
    }
    break;
    case 199:
    case 200:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 200)) {
        sqlite3Coverage(115390);
      }  
    }  
    case 201:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 201)) {
        sqlite3Coverage(115391);
      }  
    }  
    case 202:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 202)) {
        sqlite3Coverage(115392);
      }  
    }  
    case 203:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 203)) {
        sqlite3Coverage(115393);
      }  
    }  
    case 204:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 204)) {
        sqlite3Coverage(115394);
      }  
    }  
    case 205:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 205)) {
        sqlite3Coverage(115395);
      }  
    }  
    case 206:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 206)) {
        sqlite3Coverage(115396);
      }  
    }  
    {
      spanBinaryExpr((&yygotominor.yy342), pParse, yymsp[(- 1)].major, (&yymsp[(- 2)].minor.yy342), (&yymsp[0].minor.yy342));
    }
    break;
    case 207:
    case 209:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 209)) {
        sqlite3Coverage(115400);
      }  
    }  
    {
      (yygotominor.yy318.eOperator = yymsp[0].minor.yy0);
      (yygotominor.yy318.bNot = 0);
    }
    break;
    case 208:
    case 210:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 210)) {
        sqlite3Coverage(115404);
      }  
    }  
    {
      (yygotominor.yy318.eOperator = yymsp[0].minor.yy0);
      (yygotominor.yy318.bNot = 1);
    }
    break;
    case 211:
    {
      ExprList *pList;
      (pList = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy342.pExpr));
      (pList = sqlite3ExprListAppend(pParse, pList, yymsp[(- 2)].minor.yy342.pExpr));
      (yygotominor.yy342.pExpr = sqlite3ExprFunction(pParse, pList, (&yymsp[(- 1)].minor.yy318.eOperator)));
      if (yymsp[(- 1)].minor.yy318.bNot) {
        (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 19, yygotominor.yy342.pExpr, 0, 0));
      }  
      (yygotominor.yy342.zStart = yymsp[(- 2)].minor.yy342.zStart);
      (yygotominor.yy342.zEnd = yymsp[0].minor.yy342.zEnd);
      if (yygotominor.yy342.pExpr) {
        (yygotominor.yy342.pExpr->flags |= 0x000080);
      }  
    }
    break;
    case 212:
    {
      ExprList *pList;
      (pList = sqlite3ExprListAppend(pParse, 0, yymsp[(- 2)].minor.yy342.pExpr));
      (pList = sqlite3ExprListAppend(pParse, pList, yymsp[(- 4)].minor.yy342.pExpr));
      (pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy342.pExpr));
      (yygotominor.yy342.pExpr = sqlite3ExprFunction(pParse, pList, (&yymsp[(- 3)].minor.yy318.eOperator)));
      if (yymsp[(- 3)].minor.yy318.bNot) {
        (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 19, yygotominor.yy342.pExpr, 0, 0));
      }  
      (yygotominor.yy342.zStart = yymsp[(- 4)].minor.yy342.zStart);
      (yygotominor.yy342.zEnd = yymsp[0].minor.yy342.zEnd);
      if (yygotominor.yy342.pExpr) {
        (yygotominor.yy342.pExpr->flags |= 0x000080);
      }  
    }
    break;
    case 213:
    {
      spanUnaryPostfix((&yygotominor.yy342), pParse, yymsp[0].major, (&yymsp[(- 1)].minor.yy342), (&yymsp[0].minor.yy0));
    }
    break;
    case 214:
    {
      spanUnaryPostfix((&yygotominor.yy342), pParse, 74, (&yymsp[(- 2)].minor.yy342), (&yymsp[0].minor.yy0));
    }
    break;
    case 215:
    {
      spanBinaryExpr((&yygotominor.yy342), pParse, 70, (&yymsp[(- 2)].minor.yy342), (&yymsp[0].minor.yy342));
      binaryToUnaryIfNull(pParse, yymsp[0].minor.yy342.pExpr, yygotominor.yy342.pExpr, 73);
    }
    break;
    case 216:
    {
      spanBinaryExpr((&yygotominor.yy342), pParse, 146, (&yymsp[(- 3)].minor.yy342), (&yymsp[0].minor.yy342));
      binaryToUnaryIfNull(pParse, yymsp[0].minor.yy342.pExpr, yygotominor.yy342.pExpr, 74);
    }
    break;
    case 217:
    case 218:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 218)) {
        sqlite3Coverage(115451);
      }  
    }  
    {
      spanUnaryPrefix((&yygotominor.yy342), pParse, yymsp[(- 1)].major, (&yymsp[0].minor.yy342), (&yymsp[(- 1)].minor.yy0));
    }
    break;
    case 219:
    {
      spanUnaryPrefix((&yygotominor.yy342), pParse, 156, (&yymsp[0].minor.yy342), (&yymsp[(- 1)].minor.yy0));
    }
    break;
    case 220:
    {
      spanUnaryPrefix((&yygotominor.yy342), pParse, 157, (&yymsp[0].minor.yy342), (&yymsp[(- 1)].minor.yy0));
    }
    break;
    case 223:
    {
      ExprList *pList =  sqlite3ExprListAppend(pParse, 0, yymsp[(- 2)].minor.yy342.pExpr);
      (pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy342.pExpr));
      (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 71, yymsp[(- 4)].minor.yy342.pExpr, 0, 0));
      if (yygotominor.yy342.pExpr) {
        (yygotominor.yy342.pExpr->x.pList = pList);
      }  
      else {
        sqlite3ExprListDelete(pParse->db, pList);
      }
      if (yymsp[(- 3)].minor.yy392) {
        (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 19, yygotominor.yy342.pExpr, 0, 0));
      }  
      (yygotominor.yy342.zStart = yymsp[(- 4)].minor.yy342.zStart);
      (yygotominor.yy342.zEnd = yymsp[0].minor.yy342.zEnd);
    }
    break;
    case 226:
    {
      if ((yymsp[(- 1)].minor.yy442 == 0)) {
        (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 129, 0, 0, (&sqlite3IntTokens[yymsp[(- 3)].minor.yy392])));
        sqlite3ExprDelete(pParse->db, yymsp[(- 4)].minor.yy342.pExpr);
      }  
      else {
        (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 72, yymsp[(- 4)].minor.yy342.pExpr, 0, 0));
        if (yygotominor.yy342.pExpr) {
          (yygotominor.yy342.pExpr->x.pList = yymsp[(- 1)].minor.yy442);
          sqlite3ExprSetHeight(pParse, yygotominor.yy342.pExpr);
        }  
        else {
          sqlite3ExprListDelete(pParse->db, yymsp[(- 1)].minor.yy442);
        }
        if (yymsp[(- 3)].minor.yy392) {
          (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 19, yygotominor.yy342.pExpr, 0, 0));
        }  
      }
      (yygotominor.yy342.zStart = yymsp[(- 4)].minor.yy342.zStart);
      (yygotominor.yy342.zEnd = (&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n]));
    }
    break;
    case 227:
    {
      (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 116, 0, 0, 0));
      if (yygotominor.yy342.pExpr) {
        (yygotominor.yy342.pExpr->x.pSelect = yymsp[(- 1)].minor.yy159);
        (yygotominor.yy342.pExpr->flags |= 0x000800);
        sqlite3ExprSetHeight(pParse, yygotominor.yy342.pExpr);
      }  
      else {
        sqlite3SelectDelete(pParse->db, yymsp[(- 1)].minor.yy159);
      }
      (yygotominor.yy342.zStart = yymsp[(- 2)].minor.yy0.z);
      (yygotominor.yy342.zEnd = (&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n]));
    }
    break;
    case 228:
    {
      (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 72, yymsp[(- 4)].minor.yy342.pExpr, 0, 0));
      if (yygotominor.yy342.pExpr) {
        (yygotominor.yy342.pExpr->x.pSelect = yymsp[(- 1)].minor.yy159);
        (yygotominor.yy342.pExpr->flags |= 0x000800);
        sqlite3ExprSetHeight(pParse, yygotominor.yy342.pExpr);
      }  
      else {
        sqlite3SelectDelete(pParse->db, yymsp[(- 1)].minor.yy159);
      }
      if (yymsp[(- 3)].minor.yy392) {
        (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 19, yygotominor.yy342.pExpr, 0, 0));
      }  
      (yygotominor.yy342.zStart = yymsp[(- 4)].minor.yy342.zStart);
      (yygotominor.yy342.zEnd = (&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n]));
    }
    break;
    case 229:
    {
      SrcList *pSrc =  sqlite3SrcListAppend(pParse->db, 0, (&yymsp[(- 1)].minor.yy0), (&yymsp[0].minor.yy0));
      (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 72, yymsp[(- 3)].minor.yy342.pExpr, 0, 0));
      if (yygotominor.yy342.pExpr) {
        (yygotominor.yy342.pExpr->x.pSelect = sqlite3SelectNew(pParse, 0, pSrc, 0, 0, 0, 0, 0, 0, 0));
        (yygotominor.yy342.pExpr->flags |= 0x000800);
        sqlite3ExprSetHeight(pParse, yygotominor.yy342.pExpr);
      }  
      else {
        sqlite3SrcListDelete(pParse->db, pSrc);
      }
      if (yymsp[(- 2)].minor.yy392) {
        (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 19, yygotominor.yy342.pExpr, 0, 0));
      }  
      (yygotominor.yy342.zStart = yymsp[(- 3)].minor.yy342.zStart);
      (yygotominor.yy342.zEnd = (yymsp[0].minor.yy0.z ? (&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n]) : (&yymsp[(- 1)].minor.yy0.z[yymsp[(- 1)].minor.yy0.n])));
    }
    break;
    case 230:
    {
      Expr *p =  (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 20, 0, 0, 0));
      if (p) {
        (p->x.pSelect = yymsp[(- 1)].minor.yy159);
        (p->flags |= 0x000800);
        sqlite3ExprSetHeight(pParse, p);
      }  
      else {
        sqlite3SelectDelete(pParse->db, yymsp[(- 1)].minor.yy159);
      }
      (yygotominor.yy342.zStart = yymsp[(- 3)].minor.yy0.z);
      (yygotominor.yy342.zEnd = (&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n]));
    }
    break;
    case 231:
    {
      (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 134, yymsp[(- 3)].minor.yy122, 0, 0));
      if (yygotominor.yy342.pExpr) {
        (yygotominor.yy342.pExpr->x.pList = (yymsp[(- 1)].minor.yy122 ? sqlite3ExprListAppend(pParse, yymsp[(- 2)].minor.yy442, yymsp[(- 1)].minor.yy122) : yymsp[(- 2)].minor.yy442));
        sqlite3ExprSetHeight(pParse, yygotominor.yy342.pExpr);
      }  
      else {
        sqlite3ExprListDelete(pParse->db, yymsp[(- 2)].minor.yy442);
        sqlite3ExprDelete(pParse->db, yymsp[(- 1)].minor.yy122);
      }
      (yygotominor.yy342.zStart = yymsp[(- 4)].minor.yy0.z);
      (yygotominor.yy342.zEnd = (&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n]));
    }
    break;
    case 232:
    {
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, yymsp[(- 4)].minor.yy442, yymsp[(- 2)].minor.yy342.pExpr));
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, yygotominor.yy442, yymsp[0].minor.yy342.pExpr));
    }
    break;
    case 233:
    {
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, 0, yymsp[(- 2)].minor.yy342.pExpr));
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, yygotominor.yy442, yymsp[0].minor.yy342.pExpr));
    }
    break;
    case 240:
    {
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, yymsp[(- 2)].minor.yy442, yymsp[0].minor.yy342.pExpr));
    }
    break;
    case 241:
    {
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy342.pExpr));
    }
    break;
    case 242:
    {
      sqlite3CreateIndex(pParse, (&yymsp[(- 7)].minor.yy0), (&yymsp[(- 6)].minor.yy0), sqlite3SrcListAppend(pParse->db, 0, (&yymsp[(- 4)].minor.yy0), 0), yymsp[(- 2)].minor.yy442, yymsp[(- 10)].minor.yy392, (&yymsp[(- 11)].minor.yy0), yymsp[0].minor.yy122, 0, yymsp[(- 8)].minor.yy392);
    }
    break;
    case 243:
    case 296:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 296)) {
        sqlite3Coverage(115601);
      }  
    }  
    {
      (yygotominor.yy392 = 2);
    }
    break;
    case 244:
    {
      (yygotominor.yy392 = 0);
    }
    break;
    case 247:
    {
      Expr *p =  sqlite3ExprAddCollateToken(pParse, 0, (&yymsp[(- 1)].minor.yy0));
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, yymsp[(- 4)].minor.yy442, p));
      sqlite3ExprListSetName(pParse, yygotominor.yy442, (&yymsp[(- 2)].minor.yy0), 1);
      sqlite3ExprListCheckLength(pParse, yygotominor.yy442, "index");
      if (yygotominor.yy442) {
        (yygotominor.yy442->a[(yygotominor.yy442->nExpr - 1)].sortOrder = ((u8 ) yymsp[0].minor.yy392));
      }  
    }
    break;
    case 248:
    {
      Expr *p =  sqlite3ExprAddCollateToken(pParse, 0, (&yymsp[(- 1)].minor.yy0));
      (yygotominor.yy442 = sqlite3ExprListAppend(pParse, 0, p));
      sqlite3ExprListSetName(pParse, yygotominor.yy442, (&yymsp[(- 2)].minor.yy0), 1);
      sqlite3ExprListCheckLength(pParse, yygotominor.yy442, "index");
      if (yygotominor.yy442) {
        (yygotominor.yy442->a[(yygotominor.yy442->nExpr - 1)].sortOrder = ((u8 ) yymsp[0].minor.yy392));
      }  
    }
    break;
    case 249:
    {
      (yygotominor.yy0.z = 0);
      (yygotominor.yy0.n = 0);
    }
    break;
    case 251:
    {
      sqlite3DropIndex(pParse, yymsp[0].minor.yy347, yymsp[(- 1)].minor.yy392);
    }
    break;
    case 252:
    case 253:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 253)) {
        sqlite3Coverage(115632);
      }  
    }  
    {
      sqlite3Vacuum(pParse);
    }
    break;
    case 254:
    {
      sqlite3Pragma(pParse, (&yymsp[(- 1)].minor.yy0), (&yymsp[0].minor.yy0), 0, 0);
    }
    break;
    case 255:
    {
      sqlite3Pragma(pParse, (&yymsp[(- 3)].minor.yy0), (&yymsp[(- 2)].minor.yy0), (&yymsp[0].minor.yy0), 0);
    }
    break;
    case 256:
    {
      sqlite3Pragma(pParse, (&yymsp[(- 4)].minor.yy0), (&yymsp[(- 3)].minor.yy0), (&yymsp[(- 1)].minor.yy0), 0);
    }
    break;
    case 257:
    {
      sqlite3Pragma(pParse, (&yymsp[(- 3)].minor.yy0), (&yymsp[(- 2)].minor.yy0), (&yymsp[0].minor.yy0), 1);
    }
    break;
    case 258:
    {
      sqlite3Pragma(pParse, (&yymsp[(- 4)].minor.yy0), (&yymsp[(- 3)].minor.yy0), (&yymsp[(- 1)].minor.yy0), 1);
    }
    break;
    case 268:
    {
      Token all;
      (all.z = yymsp[(- 3)].minor.yy0.z);
      (all.n = (((int ) (yymsp[0].minor.yy0.z - yymsp[(- 3)].minor.yy0.z)) + yymsp[0].minor.yy0.n));
      sqlite3FinishTrigger(pParse, yymsp[(- 1)].minor.yy327, (&all));
    }
    break;
    case 269:
    {
      sqlite3BeginTrigger(pParse, (&yymsp[(- 7)].minor.yy0), (&yymsp[(- 6)].minor.yy0), yymsp[(- 5)].minor.yy392, yymsp[(- 4)].minor.yy410.a, yymsp[(- 4)].minor.yy410.b, yymsp[(- 2)].minor.yy347, yymsp[0].minor.yy122, yymsp[(- 10)].minor.yy392, yymsp[(- 8)].minor.yy392);
      (yygotominor.yy0 = ((yymsp[(- 6)].minor.yy0.n == 0) ? yymsp[(- 7)].minor.yy0 : yymsp[(- 6)].minor.yy0));
    }
    break;
    case 270:
    case 273:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 273)) {
        sqlite3Coverage(115665);
      }  
    }  
    {
      (yygotominor.yy392 = 34);
    }
    break;
    case 271:
    {
      (yygotominor.yy392 = 30);
    }
    break;
    case 272:
    {
      (yygotominor.yy392 = 48);
    }
    break;
    case 274:
    case 275:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 275)) {
        sqlite3Coverage(115675);
      }  
    }  
    {
      (yygotominor.yy410.a = yymsp[0].major);
      (yygotominor.yy410.b = 0);
    }
    break;
    case 276:
    {
      (yygotominor.yy410.a = 107);
      (yygotominor.yy410.b = yymsp[0].minor.yy180);
    }
    break;
    case 279:
    case 301:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 301)) {
        sqlite3Coverage(115682);
      }  
    }  
    {
      (yygotominor.yy122 = 0);
    }
    break;
    case 280:
    case 302:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 302)) {
        sqlite3Coverage(115686);
      }  
    }  
    {
      (yygotominor.yy122 = yymsp[0].minor.yy342.pExpr);
    }
    break;
    case 281:
    {
      ((void ) 0);
      (yymsp[(- 2)].minor.yy327->pLast->pNext = yymsp[(- 1)].minor.yy327);
      (yymsp[(- 2)].minor.yy327->pLast = yymsp[(- 1)].minor.yy327);
      (yygotominor.yy327 = yymsp[(- 2)].minor.yy327);
    }
    break;
    case 282:
    {
      ((void ) 0);
      (yymsp[(- 1)].minor.yy327->pLast = yymsp[(- 1)].minor.yy327);
      (yygotominor.yy327 = yymsp[(- 1)].minor.yy327);
    }
    break;
    case 284:
    {
      (yygotominor.yy0 = yymsp[0].minor.yy0);
      sqlite3ErrorMsg(pParse, "qualified table names are not allowed on INSERT, UPDATE, and DELETE " "statements within triggers");
    }
    break;
    case 286:
    {
      sqlite3ErrorMsg(pParse, "the INDEXED BY clause is not allowed on UPDATE or DELETE statements " "within triggers");
    }
    break;
    case 287:
    {
      sqlite3ErrorMsg(pParse, "the NOT INDEXED clause is not allowed on UPDATE or DELETE statements " "within triggers");
    }
    break;
    case 288:
    {
      (yygotominor.yy327 = sqlite3TriggerUpdateStep(pParse->db, (&yymsp[(- 4)].minor.yy0), yymsp[(- 1)].minor.yy442, yymsp[0].minor.yy122, yymsp[(- 5)].minor.yy258));
    }
    break;
    case 289:
    {
      (yygotominor.yy327 = sqlite3TriggerInsertStep(pParse->db, (&yymsp[(- 2)].minor.yy0), yymsp[(- 1)].minor.yy180, yymsp[0].minor.yy487.pList, yymsp[0].minor.yy487.pSelect, yymsp[(- 4)].minor.yy258));
    }
    break;
    case 290:
    {
      (yygotominor.yy327 = sqlite3TriggerInsertStep(pParse->db, (&yymsp[(- 2)].minor.yy0), yymsp[(- 1)].minor.yy180, 0, yymsp[0].minor.yy159, yymsp[(- 4)].minor.yy258));
    }
    break;
    case 291:
    {
      (yygotominor.yy327 = sqlite3TriggerDeleteStep(pParse->db, (&yymsp[(- 2)].minor.yy0), yymsp[0].minor.yy122));
    }
    break;
    case 292:
    {
      (yygotominor.yy327 = sqlite3TriggerSelectStep(pParse->db, yymsp[0].minor.yy159));
    }
    break;
    case 293:
    {
      (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 56, 0, 0, 0));
      if (yygotominor.yy342.pExpr) {
        (yygotominor.yy342.pExpr->affinity = 4);
      }  
      (yygotominor.yy342.zStart = yymsp[(- 3)].minor.yy0.z);
      (yygotominor.yy342.zEnd = (&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n]));
    }
    break;
    case 294:
    {
      (yygotominor.yy342.pExpr = sqlite3PExpr(pParse, 56, 0, 0, (&yymsp[(- 1)].minor.yy0)));
      if (yygotominor.yy342.pExpr) {
        (yygotominor.yy342.pExpr->affinity = ((char ) yymsp[(- 3)].minor.yy392));
      }  
      (yygotominor.yy342.zStart = yymsp[(- 5)].minor.yy0.z);
      (yygotominor.yy342.zEnd = (&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n]));
    }
    break;
    case 295:
    {
      (yygotominor.yy392 = 1);
    }
    break;
    case 297:
    {
      (yygotominor.yy392 = 3);
    }
    break;
    case 298:
    {
      sqlite3DropTrigger(pParse, yymsp[0].minor.yy347, yymsp[(- 1)].minor.yy392);
    }
    break;
    case 299:
    {
      sqlite3Attach(pParse, yymsp[(- 3)].minor.yy342.pExpr, yymsp[(- 1)].minor.yy342.pExpr, yymsp[0].minor.yy122);
    }
    break;
    case 300:
    {
      sqlite3Detach(pParse, yymsp[0].minor.yy342.pExpr);
    }
    break;
    case 305:
    {
      sqlite3Reindex(pParse, 0, 0);
    }
    break;
    case 306:
    {
      sqlite3Reindex(pParse, (&yymsp[(- 1)].minor.yy0), (&yymsp[0].minor.yy0));
    }
    break;
    case 307:
    {
      sqlite3Analyze(pParse, 0, 0);
    }
    break;
    case 308:
    {
      sqlite3Analyze(pParse, (&yymsp[(- 1)].minor.yy0), (&yymsp[0].minor.yy0));
    }
    break;
    case 309:
    {
      sqlite3AlterRenameTable(pParse, yymsp[(- 3)].minor.yy347, (&yymsp[0].minor.yy0));
    }
    break;
    case 310:
    {
      sqlite3AlterFinishAddColumn(pParse, (&yymsp[0].minor.yy0));
    }
    break;
    case 311:
    {
      (pParse->db->lookaside.bEnabled = 0);
      sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy347);
    }
    break;
    case 314:
    {
      sqlite3VtabFinishParse(pParse, 0);
    }
    break;
    case 315:
    {
      sqlite3VtabFinishParse(pParse, (&yymsp[0].minor.yy0));
    }
    break;
    case 316:
    {
      sqlite3VtabBeginParse(pParse, (&yymsp[(- 3)].minor.yy0), (&yymsp[(- 2)].minor.yy0), (&yymsp[0].minor.yy0), yymsp[(- 4)].minor.yy392);
    }
    break;
    case 319:
    {
      sqlite3VtabArgInit(pParse);
    }
    break;
    case 321:
    case 322:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 322)) {
        sqlite3Coverage(115825);
      }  
    }  
    case 323:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 323)) {
        sqlite3Coverage(115826);
      }  
    }  
    {
      sqlite3VtabArgExtend(pParse, (&yymsp[0].minor.yy0));
    }
    break;
    id2i_label_1:
    default:
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 0)) {
        sqlite3Coverage(115830);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 1)) {
        sqlite3Coverage(115831);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 2)) {
        sqlite3Coverage(115832);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 3)) {
        sqlite3Coverage(115833);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 4)) {
        sqlite3Coverage(115834);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 10)) {
        sqlite3Coverage(115835);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 11)) {
        sqlite3Coverage(115836);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 12)) {
        sqlite3Coverage(115837);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 20)) {
        sqlite3Coverage(115838);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 21)) {
        sqlite3Coverage(115839);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 25)) {
        sqlite3Coverage(115840);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 34)) {
        sqlite3Coverage(115841);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 35)) {
        sqlite3Coverage(115842);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 44)) {
        sqlite3Coverage(115843);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 51)) {
        sqlite3Coverage(115844);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 52)) {
        sqlite3Coverage(115845);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 53)) {
        sqlite3Coverage(115846);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 54)) {
        sqlite3Coverage(115847);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 61)) {
        sqlite3Coverage(115848);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 89)) {
        sqlite3Coverage(115849);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 90)) {
        sqlite3Coverage(115850);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 92)) {
        sqlite3Coverage(115851);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 277)) {
        sqlite3Coverage(115852);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 278)) {
        sqlite3Coverage(115853);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 285)) {
        sqlite3Coverage(115854);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 303)) {
        sqlite3Coverage(115855);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 304)) {
        sqlite3Coverage(115856);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 312)) {
        sqlite3Coverage(115857);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 313)) {
        sqlite3Coverage(115858);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 317)) {
        sqlite3Coverage(115859);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 318)) {
        sqlite3Coverage(115860);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 320)) {
        sqlite3Coverage(115861);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 324)) {
        sqlite3Coverage(115862);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 325)) {
        sqlite3Coverage(115863);
      }  
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      if ((yyruleno == 326)) {
        sqlite3Coverage(115864);
      }  
    }  
    break;
  }
  ((void ) 0);
  (yygoto = yyRuleInfo[yyruleno].lhs);
  (yysize = yyRuleInfo[yyruleno].nrhs);
  (yypParser->yyidx -= yysize);
  (yyact = yy_find_reduce_action(yymsp[(- yysize)].stateno, ((unsigned  char ) yygoto)));
  if ((yyact < 628)) {
    if (yysize) {
      yypParser->yyidx++;
      (yymsp -= (yysize - 1));
      (yymsp->stateno = ((unsigned  short  int ) yyact));
      (yymsp->major = ((unsigned  char ) yygoto));
      (yymsp->minor = yygotominor);
    }  
    else {
      yy_shift(yypParser, yyact, yygoto, (&yygotominor));
    }
  }  
  else {
    ((void ) 0);
    yy_accept(yypParser);
  }
}
static  void yy_syntax_error(yyParser *yypParser , int yymajor , YYMINORTYPE yyminor )  {
  Parse *pParse =  yypParser->pParse;
  ((void ) yymajor);
  ((void ) 0);
  sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", (&yyminor.yy0));
  (yypParser->pParse = pParse);
}
static  void yy_accept(yyParser *yypParser )  {
  Parse *pParse =  yypParser->pParse;
  while ((yypParser->yyidx >= 0)) {
    yy_pop_parser_stack(yypParser);
  }
  (yypParser->pParse = pParse);
}
static  void sqlite3Parser(void *yyp , int yymajor , Token yyminor , Parse *pParse )  {
  YYMINORTYPE yyminorunion;
  int yyact;
  yyParser *yypParser;
  (yypParser = ((yyParser *) yyp));
  if ((yypParser->yyidx < 0)) {
    (yypParser->yyidx = 0);
    (yypParser->yyerrcnt = (- 1));
    (yypParser->yystack[0].stateno = 0);
    (yypParser->yystack[0].major = 0);
  }  
  (yyminorunion.yy0 = yyminor);
  (yypParser->pParse = pParse);
  do {
    (yyact = yy_find_shift_action(yypParser, ((unsigned  char ) yymajor)));
    if ((yyact < 628)) {
      yy_shift(yypParser, yyact, yymajor, (&yyminorunion));
      yypParser->yyerrcnt--;
      (yymajor = 251);
    } 
    else if ((yyact < (628 + 327))) {
      yy_reduce(yypParser, (yyact - 628));
    } 
    else {
      ((void ) 0);
      yy_syntax_error(yypParser, yymajor, yyminorunion);
      yy_destructor(yypParser, ((unsigned  char ) yymajor), (&yyminorunion));
      (yymajor = 251);
    }
  } while (((yymajor != 251) && (yypParser->yyidx >= 0)));
  return;
}
const unsigned char ebcdicToAscii[] =  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  95,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  97,  98,  99,  100,  101,  102,  103,  104,  105,  0,  0,  0,  0,  0,  0,  0,  106,  107,  108,  109,  110,  111,  112,  113,  114,  0,  0,  0,  0,  0,  0,  0,  0,  115,  116,  117,  118,  119,  120,  121,  122,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  97,  98,  99,  100,  101,  102,  103,  104,  105,  0,  0,  0,  0,  0,  0,  0,  106,  107,  108,  109,  110,  111,  112,  113,  114,  0,  0,  0,  0,  0,  0,  0,  0,  115,  116,  117,  118,  119,  120,  121,  122,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0};
static  int keywordCode(const  char *z , int n )  {
  static const char zText[540] =  { 'R',  'E',  'I',  'N',  'D',  'E',  'X',  'E',  'D',  'E',  'S',  'C',  'A',  'P',  'E',  'A',  'C',  'H',  'E',  'C',  'K',  'E',  'Y',  'B',  'E',  'F',  'O',  'R',  'E',  'I',  'G',  'N',  'O',  'R',  'E',  'G',  'E',  'X',  'P',  'L',  'A',  'I',  'N',  'S',  'T',  'E',  'A',  'D',  'D',  'A',  'T',  'A',  'B',  'A',  'S',  'E',  'L',  'E',  'C',  'T',  'A',  'B',  'L',  'E',  'F',  'T',  'H',  'E',  'N',  'D',  'E',  'F',  'E',  'R',  'R',  'A',  'B',  'L',  'E',  'L',  'S',  'E',  'X',  'C',  'E',  'P',  'T',  'R',  'A',  'N',  'S',  'A',  'C',  'T',  'I',  'O',  'N',  'A',  'T',  'U',  'R',  'A',  'L',  'T',  'E',  'R',  'A',  'I',  'S',  'E',  'X',  'C',  'L',  'U',  'S',  'I',  'V',  'E',  'X',  'I',  'S',  'T',  'S',  'A',  'V',  'E',  'P',  'O',  'I',  'N',  'T',  'E',  'R',  'S',  'E',  'C',  'T',  'R',  'I',  'G',  'G',  'E',  'R',  'E',  'F',  'E',  'R',  'E',  'N',  'C',  'E',  'S',  'C',  'O',  'N',  'S',  'T',  'R',  'A',  'I',  'N',  'T',  'O',  'F',  'F',  'S',  'E',  'T',  'E',  'M',  'P',  'O',  'R',  'A',  'R',  'Y',  'U',  'N',  'I',  'Q',  'U',  'E',  'R',  'Y',  'A',  'T',  'T',  'A',  'C',  'H',  'A',  'V',  'I',  'N',  'G',  'R',  'O',  'U',  'P',  'D',  'A',  'T',  'E',  'B',  'E',  'G',  'I',  'N',  'N',  'E',  'R',  'E',  'L',  'E',  'A',  'S',  'E',  'B',  'E',  'T',  'W',  'E',  'E',  'N',  'O',  'T',  'N',  'U',  'L',  'L',  'I',  'K',  'E',  'C',  'A',  'S',  'C',  'A',  'D',  'E',  'L',  'E',  'T',  'E',  'C',  'A',  'S',  'E',  'C',  'O',  'L',  'L',  'A',  'T',  'E',  'C',  'R',  'E',  'A',  'T',  'E',  'C',  'U',  'R',  'R',  'E',  'N',  'T',  '_',  'D',  'A',  'T',  'E',  'D',  'E',  'T',  'A',  'C',  'H',  'I',  'M',  'M',  'E',  'D',  'I',  'A',  'T',  'E',  'J',  'O',  'I',  'N',  'S',  'E',  'R',  'T',  'M',  'A',  'T',  'C',  'H',  'P',  'L',  'A',  'N',  'A',  'L',  'Y',  'Z',  'E',  'P',  'R',  'A',  'G',  'M',  'A',  'B',  'O',  'R',  'T',  'V',  'A',  'L',  'U',  'E',  'S',  'V',  'I',  'R',  'T',  'U',  'A',  'L',  'I',  'M',  'I',  'T',  'W',  'H',  'E',  'N',  'W',  'H',  'E',  'R',  'E',  'N',  'A',  'M',  'E',  'A',  'F',  'T',  'E',  'R',  'E',  'P',  'L',  'A',  'C',  'E',  'A',  'N',  'D',  'E',  'F',  'A',  'U',  'L',  'T',  'A',  'U',  'T',  'O',  'I',  'N',  'C',  'R',  'E',  'M',  'E',  'N',  'T',  'C',  'A',  'S',  'T',  'C',  'O',  'L',  'U',  'M',  'N',  'C',  'O',  'M',  'M',  'I',  'T',  'C',  'O',  'N',  'F',  'L',  'I',  'C',  'T',  'C',  'R',  'O',  'S',  'S',  'C',  'U',  'R',  'R',  'E',  'N',  'T',  '_',  'T',  'I',  'M',  'E',  'S',  'T',  'A',  'M',  'P',  'R',  'I',  'M',  'A',  'R',  'Y',  'D',  'E',  'F',  'E',  'R',  'R',  'E',  'D',  'I',  'S',  'T',  'I',  'N',  'C',  'T',  'D',  'R',  'O',  'P',  'F',  'A',  'I',  'L',  'F',  'R',  'O',  'M',  'F',  'U',  'L',  'L',  'G',  'L',  'O',  'B',  'Y',  'I',  'F',  'I',  'S',  'N',  'U',  'L',  'L',  'O',  'R',  'D',  'E',  'R',  'E',  'S',  'T',  'R',  'I',  'C',  'T',  'O',  'U',  'T',  'E',  'R',  'I',  'G',  'H',  'T',  'R',  'O',  'L',  'L',  'B',  'A',  'C',  'K',  'R',  'O',  'W',  'U',  'N',  'I',  'O',  'N',  'U',  'S',  'I',  'N',  'G',  'V',  'A',  'C',  'U',  'U',  'M',  'V',  'I',  'E',  'W',  'I',  'N',  'I',  'T',  'I',  'A',  'L',  'L',  'Y'};
  static const unsigned char aHash[127] =  { 72,  101,  114,  70,  0,  45,  0,  0,  78,  0,  73,  0,  0,  42,  12,  74,  15,  0,  113,  81,  50,  108,  0,  19,  0,  0,  118,  0,  116,  111,  0,  22,  89,  0,  9,  0,  0,  66,  67,  0,  65,  6,  0,  48,  86,  98,  0,  115,  97,  0,  0,  44,  0,  99,  24,  0,  17,  0,  119,  49,  23,  0,  5,  106,  25,  92,  0,  0,  121,  102,  56,  120,  53,  28,  51,  0,  87,  0,  96,  26,  0,  95,  0,  0,  0,  91,  88,  93,  84,  105,  14,  39,  104,  0,  77,  0,  18,  85,  107,  32,  0,  117,  76,  109,  58,  46,  80,  0,  0,  90,  40,  0,  112,  0,  36,  0,  0,  29,  0,  82,  59,  60,  0,  20,  57,  0,  52};
  static const unsigned char aNext[121] =  { 0,  0,  0,  0,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0,  0,  0,  0,  13,  0,  0,  0,  0,  0,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  33,  0,  21,  0,  0,  0,  43,  3,  47,  0,  0,  0,  0,  30,  0,  54,  0,  38,  0,  0,  0,  1,  62,  0,  0,  63,  0,  41,  0,  0,  0,  0,  0,  0,  0,  61,  0,  0,  0,  0,  31,  55,  16,  34,  10,  0,  0,  0,  0,  0,  0,  0,  11,  68,  75,  0,  8,  0,  100,  94,  0,  103,  0,  83,  0,  71,  0,  0,  110,  27,  37,  69,  79,  0,  35,  64,  0,  0};
  static const unsigned char aLen[121] =  { 7,  7,  5,  4,  6,  4,  5,  3,  6,  7,  3,  6,  6,  7,  7,  3,  8,  2,  6,  5,  4,  4,  3,  10,  4,  6,  11,  6,  2,  7,  5,  5,  9,  6,  9,  9,  7,  10,  10,  4,  6,  2,  3,  9,  4,  2,  6,  5,  6,  6,  5,  6,  5,  5,  7,  7,  7,  3,  2,  4,  4,  7,  3,  6,  4,  7,  6,  12,  6,  9,  4,  6,  5,  4,  7,  6,  5,  6,  7,  5,  4,  5,  6,  5,  7,  3,  7,  13,  2,  2,  4,  6,  6,  8,  5,  17,  12,  7,  8,  8,  2,  4,  4,  4,  4,  4,  2,  2,  6,  5,  8,  5,  5,  8,  3,  5,  5,  6,  4,  9,  3};
  static const unsigned short int aOffset[121] =  { 0,  2,  2,  8,  9,  14,  16,  20,  23,  25,  25,  29,  33,  36,  41,  46,  48,  53,  54,  59,  62,  65,  67,  69,  78,  81,  86,  91,  95,  96,  101,  105,  109,  117,  122,  128,  136,  142,  152,  159,  162,  162,  165,  167,  167,  171,  176,  179,  184,  189,  194,  197,  203,  206,  210,  217,  223,  223,  223,  226,  229,  233,  234,  238,  244,  248,  255,  261,  273,  279,  288,  290,  296,  301,  303,  310,  315,  320,  326,  332,  337,  341,  344,  350,  354,  361,  363,  370,  372,  374,  383,  387,  393,  399,  407,  412,  412,  428,  435,  442,  443,  450,  454,  458,  462,  466,  469,  471,  473,  479,  483,  491,  495,  500,  508,  511,  516,  521,  527,  531,  536};
  static const unsigned char aCode[121] =  { 64,  27,  138,  41,  81,  43,  101,  52,  34,  110,  45,  46,  49,  2,  48,  140,  40,  24,  116,  16,  95,  136,  11,  109,  137,  114,  6,  29,  104,  95,  139,  56,  9,  20,  13,  115,  60,  102,  96,  127,  54,  53,  108,  21,  21,  68,  100,  3,  33,  124,  123,  107,  5,  95,  14,  71,  74,  19,  51,  98,  49,  36,  32,  106,  134,  92,  17,  66,  42,  8,  120,  105,  50,  4,  31,  55,  28,  128,  63,  125,  135,  126,  65,  30,  57,  69,  97,  103,  15,  72,  37,  38,  10,  39,  95,  66,  66,  99,  7,  117,  70,  111,  44,  119,  95,  49,  35,  18,  73,  122,  58,  95,  95,  12,  59,  112,  121,  61,  62,  47,  113};
  int h, i;
  if ((n < 2)) {
    return 26;
  }  
  if ((((! id2i_sqlite_ebcdic) ) )) {
    (h = (((_1281_sqlite3UpperToLower[((unsigned  char ) z[0])] * 4) ^ (_1281_sqlite3UpperToLower[((unsigned  char ) z[(n - 1)])] * 3) ^ n) % 127));
  }  
  if (((id2i_sqlite_ebcdic ) )) {
    (h = (((ebcdicToAscii[((unsigned  char ) z[0])] * 4) ^ (ebcdicToAscii[((unsigned  char ) z[(n - 1)])] * 3) ^ n) % 127));
  }  
  for ((i = (((int ) aHash[h]) - 1)); (i >= 0); (i = (((int ) aNext[i]) - 1))) {
    if (((aLen[i] == n) && (sqlite3_strnicmp((&zText[aOffset[i]]), z, n) == 0))) {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 0)) {
          sqlite3Coverage(116330);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 1)) {
          sqlite3Coverage(116331);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 2)) {
          sqlite3Coverage(116332);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 3)) {
          sqlite3Coverage(116333);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 4)) {
          sqlite3Coverage(116334);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 5)) {
          sqlite3Coverage(116335);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 6)) {
          sqlite3Coverage(116336);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 7)) {
          sqlite3Coverage(116337);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 8)) {
          sqlite3Coverage(116338);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 9)) {
          sqlite3Coverage(116339);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 10)) {
          sqlite3Coverage(116340);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 11)) {
          sqlite3Coverage(116341);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 12)) {
          sqlite3Coverage(116342);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 13)) {
          sqlite3Coverage(116343);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 14)) {
          sqlite3Coverage(116344);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 15)) {
          sqlite3Coverage(116345);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 16)) {
          sqlite3Coverage(116346);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 17)) {
          sqlite3Coverage(116347);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 18)) {
          sqlite3Coverage(116348);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 19)) {
          sqlite3Coverage(116349);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 20)) {
          sqlite3Coverage(116350);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 21)) {
          sqlite3Coverage(116351);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 22)) {
          sqlite3Coverage(116352);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 23)) {
          sqlite3Coverage(116353);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 24)) {
          sqlite3Coverage(116354);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 25)) {
          sqlite3Coverage(116355);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 26)) {
          sqlite3Coverage(116356);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 27)) {
          sqlite3Coverage(116357);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 28)) {
          sqlite3Coverage(116358);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 29)) {
          sqlite3Coverage(116359);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 30)) {
          sqlite3Coverage(116360);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 31)) {
          sqlite3Coverage(116361);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 32)) {
          sqlite3Coverage(116362);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 33)) {
          sqlite3Coverage(116363);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 34)) {
          sqlite3Coverage(116364);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 35)) {
          sqlite3Coverage(116365);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 36)) {
          sqlite3Coverage(116366);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 37)) {
          sqlite3Coverage(116367);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 38)) {
          sqlite3Coverage(116368);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 39)) {
          sqlite3Coverage(116369);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 40)) {
          sqlite3Coverage(116370);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 41)) {
          sqlite3Coverage(116371);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 42)) {
          sqlite3Coverage(116372);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 43)) {
          sqlite3Coverage(116373);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 44)) {
          sqlite3Coverage(116374);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 45)) {
          sqlite3Coverage(116375);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 46)) {
          sqlite3Coverage(116376);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 47)) {
          sqlite3Coverage(116377);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 48)) {
          sqlite3Coverage(116378);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 49)) {
          sqlite3Coverage(116379);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 50)) {
          sqlite3Coverage(116380);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 51)) {
          sqlite3Coverage(116381);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 52)) {
          sqlite3Coverage(116382);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 53)) {
          sqlite3Coverage(116383);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 54)) {
          sqlite3Coverage(116384);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 55)) {
          sqlite3Coverage(116385);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 56)) {
          sqlite3Coverage(116386);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 57)) {
          sqlite3Coverage(116387);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 58)) {
          sqlite3Coverage(116388);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 59)) {
          sqlite3Coverage(116389);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 60)) {
          sqlite3Coverage(116390);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 61)) {
          sqlite3Coverage(116391);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 62)) {
          sqlite3Coverage(116392);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 63)) {
          sqlite3Coverage(116393);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 64)) {
          sqlite3Coverage(116394);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 65)) {
          sqlite3Coverage(116395);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 66)) {
          sqlite3Coverage(116396);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 67)) {
          sqlite3Coverage(116397);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 68)) {
          sqlite3Coverage(116398);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 69)) {
          sqlite3Coverage(116399);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 70)) {
          sqlite3Coverage(116400);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 71)) {
          sqlite3Coverage(116401);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 72)) {
          sqlite3Coverage(116402);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 73)) {
          sqlite3Coverage(116403);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 74)) {
          sqlite3Coverage(116404);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 75)) {
          sqlite3Coverage(116405);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 76)) {
          sqlite3Coverage(116406);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 77)) {
          sqlite3Coverage(116407);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 78)) {
          sqlite3Coverage(116408);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 79)) {
          sqlite3Coverage(116409);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 80)) {
          sqlite3Coverage(116410);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 81)) {
          sqlite3Coverage(116411);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 82)) {
          sqlite3Coverage(116412);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 83)) {
          sqlite3Coverage(116413);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 84)) {
          sqlite3Coverage(116414);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 85)) {
          sqlite3Coverage(116415);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 86)) {
          sqlite3Coverage(116416);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 87)) {
          sqlite3Coverage(116417);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 88)) {
          sqlite3Coverage(116418);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 89)) {
          sqlite3Coverage(116419);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 90)) {
          sqlite3Coverage(116420);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 91)) {
          sqlite3Coverage(116421);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 92)) {
          sqlite3Coverage(116422);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 93)) {
          sqlite3Coverage(116423);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 94)) {
          sqlite3Coverage(116424);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 95)) {
          sqlite3Coverage(116425);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 96)) {
          sqlite3Coverage(116426);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 97)) {
          sqlite3Coverage(116427);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 98)) {
          sqlite3Coverage(116428);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 99)) {
          sqlite3Coverage(116429);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 100)) {
          sqlite3Coverage(116430);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 101)) {
          sqlite3Coverage(116431);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 102)) {
          sqlite3Coverage(116432);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 103)) {
          sqlite3Coverage(116433);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 104)) {
          sqlite3Coverage(116434);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 105)) {
          sqlite3Coverage(116435);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 106)) {
          sqlite3Coverage(116436);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 107)) {
          sqlite3Coverage(116437);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 108)) {
          sqlite3Coverage(116438);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 109)) {
          sqlite3Coverage(116439);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 110)) {
          sqlite3Coverage(116440);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 111)) {
          sqlite3Coverage(116441);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 112)) {
          sqlite3Coverage(116442);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 113)) {
          sqlite3Coverage(116443);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 114)) {
          sqlite3Coverage(116444);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 115)) {
          sqlite3Coverage(116445);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 116)) {
          sqlite3Coverage(116446);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 117)) {
          sqlite3Coverage(116447);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 118)) {
          sqlite3Coverage(116448);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 119)) {
          sqlite3Coverage(116449);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((i == 120)) {
          sqlite3Coverage(116450);
        }  
      }  
      return aCode[i];
    }  
  }
  return 26;
}
static  int sqlite3KeywordCode(const  unsigned  char *z , int n )  {
  return keywordCode(((char *) z), n);
}
static const char sqlite3IsEbcdicIdChar[] =  { 0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  1,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  0,  1,  0,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  0};
static  int sqlite3GetToken(const  unsigned  char *z , int *tokenType )  {
  int i, c;
  switch ((*z)) {
    case ' ':
    case '\t':
    case '\n':
    case '\f':
    case '\r':
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == ' ')) {
          sqlite3Coverage(116512);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '\t')) {
          sqlite3Coverage(116513);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '\n')) {
          sqlite3Coverage(116514);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '\f')) {
          sqlite3Coverage(116515);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '\r')) {
          sqlite3Coverage(116516);
        }  
      }  
      for ((i = 1); (sqlite3CtypeMap[((unsigned  char ) z[i])] & 0x01); i++) {
        
      }
      ((*tokenType) = 149);
      return i;
    }
    case '-':
    {
      if ((z[1] == '-')) {
        for ((i = 2); (((c = z[i]) != 0) && (c != '\n')); i++) {
          
        }
        ((*tokenType) = 149);
        return i;
      }  
      ((*tokenType) = 87);
      return 1;
    }
    case '(':
    {
      ((*tokenType) = 22);
      return 1;
    }
    case ')':
    {
      ((*tokenType) = 23);
      return 1;
    }
    case ';':
    {
      ((*tokenType) = 1);
      return 1;
    }
    case '+':
    {
      ((*tokenType) = 86);
      return 1;
    }
    case '*':
    {
      ((*tokenType) = 88);
      return 1;
    }
    case '/':
    {
      if (((z[1] != '*') || (z[2] == 0))) {
        ((*tokenType) = 89);
        return 1;
      }  
      for ((i = 3), (c = z[2]); (((c != '*') || (z[i] != '/')) && ((c = z[i]) != 0)); i++) {
        
      }
      if (c) {
        i++;
      }  
      ((*tokenType) = 149);
      return i;
    }
    case '%':
    {
      ((*tokenType) = 90);
      return 1;
    }
    case '=':
    {
      ((*tokenType) = 76);
      return (1 + (z[1] == '='));
    }
    case '<':
    {
      if (((c = z[1]) == '=')) {
        ((*tokenType) = 78);
        return 2;
      } 
      else if ((c == '>')) {
        ((*tokenType) = 75);
        return 2;
      }
      
      else if ((c == '<')) {
        ((*tokenType) = 84);
        return 2;
      } 
      else {
        ((*tokenType) = 79);
        return 1;
      }
    }
    case '>':
    {
      if (((c = z[1]) == '=')) {
        ((*tokenType) = 80);
        return 2;
      } 
      else if ((c == '>')) {
        ((*tokenType) = 85);
        return 2;
      } 
      else {
        ((*tokenType) = 77);
        return 1;
      }
    }
    case '!':
    {
      if ((z[1] != '=')) {
        ((*tokenType) = 148);
        return 2;
      }  
      else {
        ((*tokenType) = 75);
        return 2;
      }
    }
    case '|':
    {
      if ((z[1] != '|')) {
        ((*tokenType) = 83);
        return 1;
      }  
      else {
        ((*tokenType) = 91);
        return 2;
      }
    }
    case ',':
    {
      ((*tokenType) = 25);
      return 1;
    }
    case '&':
    {
      ((*tokenType) = 82);
      return 1;
    }
    case '~':
    {
      ((*tokenType) = 93);
      return 1;
    }
    case '`':
    case '\'':
    case '"':
    {
      int delim =  z[0];
      if (((id2i_sqlite_coverage_test ) )) {
        if ((delim == '`')) {
          sqlite3Coverage(116629);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((delim == '\'')) {
          sqlite3Coverage(116630);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((delim == '"')) {
          sqlite3Coverage(116631);
        }  
      }  
      for ((i = 1); ((c = z[i]) != 0); i++) {
        if ((c == delim)) {
          if ((z[(i + 1)] == delim)) {
            i++;
          }  
          else {
            break;
          }
        }  
      }
      if ((c == '\'')) {
        ((*tokenType) = 94);
        return (i + 1);
      } 
      else if ((c != 0)) {
        ((*tokenType) = 26);
        return (i + 1);
      } 
      else {
        ((*tokenType) = 148);
        return i;
      }
    }
    case '.':
    {
      if ((! (sqlite3CtypeMap[((unsigned  char ) z[1])] & 0x04))) {
        ((*tokenType) = 118);
        return 1;
      }  
    }
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '0')) {
          sqlite3Coverage(116665);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '1')) {
          sqlite3Coverage(116665);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '2')) {
          sqlite3Coverage(116665);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '3')) {
          sqlite3Coverage(116666);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '4')) {
          sqlite3Coverage(116666);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '5')) {
          sqlite3Coverage(116666);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '6')) {
          sqlite3Coverage(116667);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '7')) {
          sqlite3Coverage(116667);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '8')) {
          sqlite3Coverage(116667);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '9')) {
          sqlite3Coverage(116668);
        }  
      }  
      ((*tokenType) = 129);
      for ((i = 0); (sqlite3CtypeMap[((unsigned  char ) z[i])] & 0x04); i++) {
        
      }
      if ((z[i] == '.')) {
        i++;
        while ((sqlite3CtypeMap[((unsigned  char ) z[i])] & 0x04)) {
          i++;
        }
        ((*tokenType) = 130);
      }  
      if ((((z[i] == 'e') || (z[i] == 'E')) && ((sqlite3CtypeMap[((unsigned  char ) z[(i + 1)])] & 0x04) || (((z[(i + 1)] == '+') || (z[(i + 1)] == '-')) && (sqlite3CtypeMap[((unsigned  char ) z[(i + 2)])] & 0x04))))) {
        (i += 2);
        while ((sqlite3CtypeMap[((unsigned  char ) z[i])] & 0x04)) {
          i++;
        }
        ((*tokenType) = 130);
      }  
      if ((((! id2i_sqlite_ebcdic) ) )) {
        while (((sqlite3CtypeMap[((unsigned  char ) z[i])] & 0x46) != 0)) {
          ((*tokenType) = 148);
          i++;
        }
      }  
      if (((id2i_sqlite_ebcdic ) )) {
        while ((((c = z[i]) >= 0x42) && sqlite3IsEbcdicIdChar[(c - 0x40)])) {
          ((*tokenType) = 148);
          i++;
        }
      }  
      return i;
    }
    case '[':
    {
      for ((i = 1), (c = z[0]); ((c != ']') && ((c = z[i]) != 0)); i++) {
        
      }
      ((*tokenType) = ((c == ']') ? 26 : 148));
      return i;
    }
    case '?':
    {
      ((*tokenType) = 133);
      for ((i = 1); (sqlite3CtypeMap[((unsigned  char ) z[i])] & 0x04); i++) {
        
      }
      return i;
    }
    case '#':
    {
      for ((i = 1); (sqlite3CtypeMap[((unsigned  char ) z[i])] & 0x04); i++) {
        
      }
      if ((i > 1)) {
        ((*tokenType) = 132);
        return i;
      }  
    }
    case '$':
    case '@':
    case ':':
    {
      int n =  0;
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '$')) {
          sqlite3Coverage(116720);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == '@')) {
          sqlite3Coverage(116720);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == ':')) {
          sqlite3Coverage(116720);
        }  
      }  
      ((*tokenType) = 133);
      for ((i = 1); ((c = z[i]) != 0); i++) {
        if ((((! id2i_sqlite_ebcdic) ) )) {
          if (((sqlite3CtypeMap[((unsigned  char ) c)] & 0x46) != 0)) {
            n++;
          } 
          else if (((c == '(') && (n > 0))) {
            do {
              i++;
            } while ((((c = z[i]) != 0) && (! (sqlite3CtypeMap[((unsigned  char ) c)] & 0x01)) && (c != ')')));
            if ((c == ')')) {
              i++;
            }  
            else {
              ((*tokenType) = 148);
            }
            break;
          }
          
          else if (((c == ':') && (z[(i + 1)] == ':'))) {
            i++;
          } 
          else {
            break;
          }
        }  
        if (((id2i_sqlite_ebcdic ) )) {
          if ((((c = c) >= 0x42) && sqlite3IsEbcdicIdChar[(c - 0x40)])) {
            n++;
          } 
          else if (((c == '(') && (n > 0))) {
            do {
              i++;
            } while ((((c = z[i]) != 0) && (! (sqlite3CtypeMap[((unsigned  char ) c)] & 0x01)) && (c != ')')));
            if ((c == ')')) {
              i++;
            }  
            else {
              ((*tokenType) = 148);
            }
            break;
          }
          
          else if (((c == ':') && (z[(i + 1)] == ':'))) {
            i++;
          } 
          else {
            break;
          }
        }  
      }
      if ((n == 0)) {
        ((*tokenType) = 148);
      }  
      return i;
    }
    case 'x':
    if (((id2i_sqlite_omit_blob_literal ) )) {
      if (((*z) == 'x')) {
        goto id2i_label_1;
      }  
    }  
    case 'X':
    if ((((! id2i_sqlite_omit_blob_literal) ) )) {
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == 'x')) {
          sqlite3Coverage(116748);
        }  
      }  
      if (((id2i_sqlite_coverage_test ) )) {
        if ((z[0] == 'X')) {
          sqlite3Coverage(116748);
        }  
      }  
      if ((z[1] == '\'')) {
        ((*tokenType) = 131);
        for ((i = 2); (sqlite3CtypeMap[((unsigned  char ) z[i])] & 0x08); i++) {
          
        }
        if (((z[i] != '\'') || (i % 2))) {
          ((*tokenType) = 148);
          while ((z[i] && (z[i] != '\''))) {
            i++;
          }
        }  
        if (z[i]) {
          i++;
        }  
        return i;
      }  
    }  
    id2i_label_1:
    default:
    {
      if ((((! id2i_sqlite_ebcdic) ) )) {
        if ((! ((sqlite3CtypeMap[((unsigned  char ) (*z))] & 0x46) != 0))) {
          break;
        }  
      }  
      if (((id2i_sqlite_ebcdic ) )) {
        if ((! (((c = (*z)) >= 0x42) && sqlite3IsEbcdicIdChar[(c - 0x40)]))) {
          break;
        }  
      }  
      if ((((! id2i_sqlite_ebcdic) ) )) {
        for ((i = 1); ((sqlite3CtypeMap[((unsigned  char ) z[i])] & 0x46) != 0); i++) {
          
        }
      }  
      if (((id2i_sqlite_ebcdic ) )) {
        for ((i = 1); (((c = z[i]) >= 0x42) && sqlite3IsEbcdicIdChar[(c - 0x40)]); i++) {
          
        }
      }  
      ((*tokenType) = keywordCode(((char *) z), i));
      return i;
    }
  }
  ((*tokenType) = 148);
  return 1;
}
static  int sqlite3RunParser(Parse *pParse , const  char *zSql , char **pzErrMsg )  {
  int nErr =  0;
  int i;
  void *pEngine;
  int tokenType;
  int lastTokenParsed =  (- 1);
  u8 enableLookaside;
  sqlite3 *db =  pParse->db;
  int mxSqlLen;
  (mxSqlLen = db->aLimit[1]);
  if ((db->nVdbeActive == 0)) {
    (db->u1.isInterrupted = 0);
  }  
  (pParse->rc = 0);
  (pParse->zTail = zSql);
  (i = 0);
  ((void ) 0);
  (pEngine = sqlite3ParserAlloc(((void *( *)(size_t )) sqlite3Malloc)));
  if ((pEngine == 0)) {
    (db->mallocFailed = 1);
    return 7;
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (enableLookaside = db->lookaside.bEnabled);
  if (db->lookaside.pStart) {
    (db->lookaside.bEnabled = 1);
  }  
  while (((! db->mallocFailed) && (zSql[i] != 0))) {
    ((void ) 0);
    (pParse->sLastToken.z = (&zSql[i]));
    (pParse->sLastToken.n = sqlite3GetToken(((unsigned  char *) (&zSql[i])), (&tokenType)));
    (i += pParse->sLastToken.n);
    if ((i > mxSqlLen)) {
      (pParse->rc = 18);
      break;
    }  
    switch (tokenType) {
      case 149:
      {
        if (db->u1.isInterrupted) {
          sqlite3ErrorMsg(pParse, "interrupt");
          (pParse->rc = 9);
          goto abort_parse;
        }  
        break;
      }
      case 148:
      {
        sqlite3DbFree(db, (*pzErrMsg));
        ((*pzErrMsg) = sqlite3MPrintf(db, "unrecognized token: \"%T\"", (&pParse->sLastToken)));
        nErr++;
        goto abort_parse;
      }
      case 1:
      {
        (pParse->zTail = (&zSql[i]));
      }
      id2i_label_1:
      default:
      {
        sqlite3Parser(pEngine, tokenType, pParse->sLastToken, pParse);
        (lastTokenParsed = tokenType);
        if ((pParse->rc != 0)) {
          goto abort_parse;
        }  
        break;
      }
    }
  }
  abort_parse:
  if (((zSql[i] == 0) && (nErr == 0) && (pParse->rc == 0))) {
    if ((lastTokenParsed != 1)) {
      sqlite3Parser(pEngine, 1, pParse->sLastToken, pParse);
      (pParse->zTail = (&zSql[i]));
    }  
    sqlite3Parser(pEngine, 0, pParse->sLastToken, pParse);
  }  
  sqlite3ParserFree(pEngine, sqlite3_free);
  (db->lookaside.bEnabled = enableLookaside);
  if (db->mallocFailed) {
    (pParse->rc = 7);
  }  
  if (((pParse->rc != 0) && (pParse->rc != 101) && (pParse->zErrMsg == 0))) {
    sqlite3SetString((&pParse->zErrMsg), db, "%s", sqlite3ErrStr(pParse->rc));
  }  
  ((void ) 0);
  if (pParse->zErrMsg) {
    ((*pzErrMsg) = pParse->zErrMsg);
    sqlite3_log(pParse->rc, "%s", (*pzErrMsg));
    (pParse->zErrMsg = 0);
    nErr++;
  }  
  if ((pParse->pVdbe && (pParse->nErr > 0) && (pParse->nested == 0))) {
    sqlite3VdbeDelete(pParse->pVdbe);
    (pParse->pVdbe = 0);
  }  
  if ((pParse->nested == 0)) {
    sqlite3DbFree(db, pParse->aTableLock);
    (pParse->aTableLock = 0);
    (pParse->nTableLock = 0);
  }  
  sqlite3_free(pParse->apVtabLock);
  if ((! pParse->declareVtab)) {
    sqlite3DeleteTable(db, pParse->pNewTable);
  }  
  sqlite3DeleteTrigger(db, pParse->pNewTrigger);
  for ((i = (pParse->nzVar - 1)); (i >= 0); i--) {
    sqlite3DbFree(db, pParse->azVar[i]);
  }
  sqlite3DbFree(db, pParse->azVar);
  sqlite3DbFree(db, pParse->aAlias);
  while (pParse->pAinc) {
    AutoincInfo *p =  pParse->pAinc;
    (pParse->pAinc = p->pNext);
    sqlite3DbFree(db, p);
  }
  while (pParse->pZombieTab) {
    Table *p =  pParse->pZombieTab;
    (pParse->pZombieTab = p->pNextZombie);
    sqlite3DeleteTable(db, p);
  }
  if (((nErr > 0) && (pParse->rc == 0))) {
    (pParse->rc = 1);
  }  
  return nErr;
}
int sqlite3_complete(const  char *zSql )  {
  u8 state =  0;
  u8 token;
  static const u8 trans[8][8] =  { { 1,  0,  2,  3,  4,  2,  2,  2},  { 1,  1,  2,  3,  4,  2,  2,  2},  { 1,  2,  2,  2,  2,  2,  2,  2},  { 1,  3,  3,  2,  4,  2,  2,  2},  { 1,  4,  2,  2,  2,  4,  5,  2},  { 6,  5,  5,  5,  5,  5,  5,  5},  { 6,  6,  5,  5,  5,  5,  5,  7},  { 1,  7,  5,  5,  5,  5,  5,  5}};
  while ((*zSql)) {
    switch ((*zSql)) {
      case ';':
      {
        (token = 0);
        break;
      }
      case ' ':
      case '\r':
      case '\t':
      case '\n':
      case '\f':
      {
        (token = 1);
        break;
      }
      case '/':
      {
        if ((zSql[1] != '*')) {
          (token = 2);
          break;
        }  
        (zSql += 2);
        while ((zSql[0] && ((zSql[0] != '*') || (zSql[1] != '/')))) {
          zSql++;
        }
        if ((zSql[0] == 0)) {
          return 0;
        }  
        zSql++;
        (token = 1);
        break;
      }
      case '-':
      {
        if ((zSql[1] != '-')) {
          (token = 2);
          break;
        }  
        while (((*zSql) && ((*zSql) != '\n'))) {
          zSql++;
        }
        if (((*zSql) == 0)) {
          return (state == 1);
        }  
        (token = 1);
        break;
      }
      case '[':
      {
        zSql++;
        while (((*zSql) && ((*zSql) != ']'))) {
          zSql++;
        }
        if (((*zSql) == 0)) {
          return 0;
        }  
        (token = 2);
        break;
      }
      case '`':
      case '"':
      case '\'':
      {
        int c =  (*zSql);
        zSql++;
        while (((*zSql) && ((*zSql) != c))) {
          zSql++;
        }
        if (((*zSql) == 0)) {
          return 0;
        }  
        (token = 2);
        break;
      }
      id2i_label_1:
      default:
      {
        unsigned char _1282_c;
        if ((((! id2i_sqlite_ebcdic) ) )) {
          if (((sqlite3CtypeMap[((unsigned  char ) ((u8 ) (*zSql)))] & 0x46) != 0)) {
            int nId;
            for ((nId = 1); ((sqlite3CtypeMap[((unsigned  char ) zSql[nId])] & 0x46) != 0); nId++) {
              
            }
            switch ((*zSql)) {
              case 'c':
              case 'C':
              {
                if (((nId == 6) && (sqlite3_strnicmp(zSql, "create", 6) == 0))) {
                  (token = 4);
                }  
                else {
                  (token = 2);
                }
                break;
              }
              case 't':
              case 'T':
              {
                if (((nId == 7) && (sqlite3_strnicmp(zSql, "trigger", 7) == 0))) {
                  (token = 6);
                } 
                else if (((nId == 4) && (sqlite3_strnicmp(zSql, "temp", 4) == 0))) {
                  (token = 5);
                }
                
                else if (((nId == 9) && (sqlite3_strnicmp(zSql, "temporary", 9) == 0))) {
                  (token = 5);
                } 
                else {
                  (token = 2);
                }
                break;
              }
              case 'e':
              case 'E':
              {
                if ((((! id2i_sqlite_omit_explain) ) )) {
                  if (((nId == 3) && (sqlite3_strnicmp(zSql, "end", 3) == 0))) {
                    (token = 7);
                  } 
                  else if (((nId == 7) && (sqlite3_strnicmp(zSql, "explain", 7) == 0))) {
                    (token = 3);
                  } 
                  else {
                    (token = 2);
                  }
                }  
                if (((id2i_sqlite_omit_explain ) )) {
                  if (((nId == 3) && (sqlite3_strnicmp(zSql, "end", 3) == 0))) {
                    (token = 7);
                  }  
                  else {
                    (token = 2);
                  }
                }  
                break;
              }
              id2i_label_2:
              default:
              {
                (token = 2);
                break;
              }
            }
            (zSql += (nId - 1));
          }  
          else {
            (token = 2);
          }
        }  
        if (((id2i_sqlite_ebcdic ) )) {
          if ((((_1282_c = ((u8 ) (*zSql))) >= 0x42) && sqlite3IsEbcdicIdChar[(_1282_c - 0x40)])) {
            int nId;
            for ((nId = 1); (((_1282_c = zSql[nId]) >= 0x42) && sqlite3IsEbcdicIdChar[(_1282_c - 0x40)]); nId++) {
              
            }
            switch ((*zSql)) {
              case 'c':
              case 'C':
              {
                if (((nId == 6) && (sqlite3_strnicmp(zSql, "create", 6) == 0))) {
                  (token = 4);
                }  
                else {
                  (token = 2);
                }
                break;
              }
              case 't':
              case 'T':
              {
                if (((nId == 7) && (sqlite3_strnicmp(zSql, "trigger", 7) == 0))) {
                  (token = 6);
                } 
                else if (((nId == 4) && (sqlite3_strnicmp(zSql, "temp", 4) == 0))) {
                  (token = 5);
                }
                
                else if (((nId == 9) && (sqlite3_strnicmp(zSql, "temporary", 9) == 0))) {
                  (token = 5);
                } 
                else {
                  (token = 2);
                }
                break;
              }
              case 'e':
              case 'E':
              {
                if ((((! id2i_sqlite_omit_explain) ) )) {
                  if (((nId == 3) && (sqlite3_strnicmp(zSql, "end", 3) == 0))) {
                    (token = 7);
                  } 
                  else if (((nId == 7) && (sqlite3_strnicmp(zSql, "explain", 7) == 0))) {
                    (token = 3);
                  } 
                  else {
                    (token = 2);
                  }
                }  
                if (((id2i_sqlite_omit_explain ) )) {
                  if (((nId == 3) && (sqlite3_strnicmp(zSql, "end", 3) == 0))) {
                    (token = 7);
                  }  
                  else {
                    (token = 2);
                  }
                }  
                break;
              }
              id2i_label_3:
              default:
              {
                (token = 2);
                break;
              }
            }
            (zSql += (nId - 1));
          }  
          else {
            (token = 2);
          }
        }  
        break;
      }
    }
    (state = trans[state][token]);
    zSql++;
  }
  return (state == 1);
}
int sqlite3_complete16(const  void *zSql )  {
  sqlite3_value *pVal;
  char const *zSql8;
  int rc =  7;
  (rc = sqlite3_initialize());
  if (rc) {
    return rc;
  }  
  (pVal = sqlite3ValueNew(0));
  sqlite3ValueSetStr(pVal, (- 1), zSql, 2, ((sqlite3_destructor_type ) 0));
  (zSql8 = sqlite3ValueText(pVal, 1));
  if (zSql8) {
    (rc = sqlite3_complete(zSql8));
  }  
  else {
    (rc = 7);
  }
  sqlite3ValueFree(pVal);
  return sqlite3ApiExit(0, rc);
}
static int sqlite3Fts3Init(sqlite3 *db );
const  char *sqlite3_libversion(void )  {
  return sqlite3_version;
}
const  char *sqlite3_sourceid(void )  {
  return "2013-10-17 12:57:35 c78be6d786c19073b3a6730dfe3fb1be54f5657a";
}
int sqlite3_libversion_number(void )  {
  return 3008001;
}
int sqlite3_threadsafe(void )  {
  return 0;
}
static void ( *_1280_sqlite3IoTrace)(const  char * , ...) =  0;
char *sqlite3_temp_directory =  0;
char *sqlite3_data_directory =  0;
int sqlite3_initialize(void )  {
  init_azCompileOpt();
  int rc;
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (_1283_sqlite3Config.isInit) {
      return 0;
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (_1284_sqlite3Config.isInit) {
      return 0;
    }  
  }  
  (rc = 0);
  if (rc) {
    return rc;
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    (_1283_sqlite3Config.isMutexInit = 1);
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    (_1284_sqlite3Config.isMutexInit = 1);
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if ((! _1283_sqlite3Config.isMallocInit)) {
      (rc = sqlite3MallocInit());
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if ((! _1284_sqlite3Config.isMallocInit)) {
      (rc = sqlite3MallocInit());
    }  
  }  
  if ((rc == 0)) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      (_1283_sqlite3Config.isMallocInit = 1);
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      (_1284_sqlite3Config.isMallocInit = 1);
    }  
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      if ((! _1283_sqlite3Config.pInitMutex)) {
        (_1283_sqlite3Config.pInitMutex = ((sqlite3_mutex *) 8));
        if ((_1283_sqlite3Config.bCoreMutex && (! _1283_sqlite3Config.pInitMutex))) {
          (rc = 7);
        }  
      }  
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      if ((! _1284_sqlite3Config.pInitMutex)) {
        (_1284_sqlite3Config.pInitMutex = ((sqlite3_mutex *) 8));
        if ((_1284_sqlite3Config.bCoreMutex && (! _1284_sqlite3Config.pInitMutex))) {
          (rc = 7);
        }  
      }  
    }  
  }  
  if ((rc == 0)) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      _1283_sqlite3Config.nRefInitMutex++;
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      _1284_sqlite3Config.nRefInitMutex++;
    }  
  }  
  if ((rc != 0)) {
    return rc;
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (((_1283_sqlite3Config.isInit == 0) && (_1283_sqlite3Config.inProgress == 0))) {
      FuncDefHash *pHash =  (&sqlite3GlobalFunctions);
      (_1283_sqlite3Config.inProgress = 1);
      memset(pHash, 0, sizeof(sqlite3GlobalFunctions));
      sqlite3RegisterGlobalFunctions();
      if ((_1283_sqlite3Config.isPCacheInit == 0)) {
        (rc = sqlite3PcacheInitialize());
      }  
      if ((rc == 0)) {
        (_1283_sqlite3Config.isPCacheInit = 1);
        (rc = sqlite3OsInit());
      }  
      if ((rc == 0)) {
        sqlite3PCacheBufferSetup(_1283_sqlite3Config.pPage, _1283_sqlite3Config.szPage, _1283_sqlite3Config.nPage);
        (_1283_sqlite3Config.isInit = 1);
      }  
      (_1283_sqlite3Config.inProgress = 0);
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (((_1284_sqlite3Config.isInit == 0) && (_1284_sqlite3Config.inProgress == 0))) {
      FuncDefHash *pHash =  (&sqlite3GlobalFunctions);
      (_1284_sqlite3Config.inProgress = 1);
      memset(pHash, 0, sizeof(sqlite3GlobalFunctions));
      sqlite3RegisterGlobalFunctions();
      if ((_1284_sqlite3Config.isPCacheInit == 0)) {
        (rc = sqlite3PcacheInitialize());
      }  
      if ((rc == 0)) {
        (_1284_sqlite3Config.isPCacheInit = 1);
        (rc = sqlite3OsInit());
      }  
      if ((rc == 0)) {
        sqlite3PCacheBufferSetup(_1284_sqlite3Config.pPage, _1284_sqlite3Config.szPage, _1284_sqlite3Config.nPage);
        (_1284_sqlite3Config.isInit = 1);
      }  
      (_1284_sqlite3Config.inProgress = 0);
    }  
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    _1283_sqlite3Config.nRefInitMutex--;
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    _1284_sqlite3Config.nRefInitMutex--;
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if ((_1283_sqlite3Config.nRefInitMutex <= 0)) {
      ((void ) 0);
      (_1283_sqlite3Config.pInitMutex = 0);
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if ((_1284_sqlite3Config.nRefInitMutex <= 0)) {
      ((void ) 0);
      (_1284_sqlite3Config.pInitMutex = 0);
    }  
  }  
  return rc;
}
int sqlite3_shutdown(void )  {
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (_1283_sqlite3Config.isInit) {
      sqlite3_os_end();
      sqlite3_reset_auto_extension();
      (_1283_sqlite3Config.isInit = 0);
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (_1284_sqlite3Config.isInit) {
      sqlite3_os_end();
      sqlite3_reset_auto_extension();
      (_1284_sqlite3Config.isInit = 0);
    }  
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (_1283_sqlite3Config.isPCacheInit) {
      sqlite3PcacheShutdown();
      (_1283_sqlite3Config.isPCacheInit = 0);
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (_1284_sqlite3Config.isPCacheInit) {
      sqlite3PcacheShutdown();
      (_1284_sqlite3Config.isPCacheInit = 0);
    }  
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (_1283_sqlite3Config.isMallocInit) {
      sqlite3MallocEnd();
      (_1283_sqlite3Config.isMallocInit = 0);
      (sqlite3_data_directory = 0);
      (sqlite3_temp_directory = 0);
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (_1284_sqlite3Config.isMallocInit) {
      sqlite3MallocEnd();
      (_1284_sqlite3Config.isMallocInit = 0);
      (sqlite3_data_directory = 0);
      (sqlite3_temp_directory = 0);
    }  
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (_1283_sqlite3Config.isMutexInit) {
      (_1283_sqlite3Config.isMutexInit = 0);
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (_1284_sqlite3Config.isMutexInit) {
      (_1284_sqlite3Config.isMutexInit = 0);
    }  
  }  
  return 0;
}
int sqlite3_config(int op , ...)  {
  va_list ap;
  int rc =  0;
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if (_1283_sqlite3Config.isInit) {
      return sqlite3MisuseError(117632);
    }  
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if (_1284_sqlite3Config.isInit) {
      return sqlite3MisuseError(117632);
    }  
  }  
  __builtin_va_start(ap, op);
  switch (op) {
    case 4:
    {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.m = (*__builtin_va_arg(ap, sqlite3_mem_methods *)));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.m = (*__builtin_va_arg(ap, sqlite3_mem_methods *)));
      }  
      break;
    }
    case 5:
    {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        if ((_1283_sqlite3Config.m.xMalloc == 0)) {
          sqlite3MemSetDefault();
        }  
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        if ((_1284_sqlite3Config.m.xMalloc == 0)) {
          sqlite3MemSetDefault();
        }  
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        ((*__builtin_va_arg(ap, sqlite3_mem_methods *)) = _1283_sqlite3Config.m);
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        ((*__builtin_va_arg(ap, sqlite3_mem_methods *)) = _1284_sqlite3Config.m);
      }  
      break;
    }
    case 9:
    {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.bMemstat = __builtin_va_arg(ap, int ));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.bMemstat = __builtin_va_arg(ap, int ));
      }  
      break;
    }
    case 6:
    {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.pScratch = __builtin_va_arg(ap, void *));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.pScratch = __builtin_va_arg(ap, void *));
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.szScratch = __builtin_va_arg(ap, int ));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.szScratch = __builtin_va_arg(ap, int ));
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.nScratch = __builtin_va_arg(ap, int ));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.nScratch = __builtin_va_arg(ap, int ));
      }  
      break;
    }
    case 7:
    {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.pPage = __builtin_va_arg(ap, void *));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.pPage = __builtin_va_arg(ap, void *));
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.szPage = __builtin_va_arg(ap, int ));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.szPage = __builtin_va_arg(ap, int ));
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.nPage = __builtin_va_arg(ap, int ));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.nPage = __builtin_va_arg(ap, int ));
      }  
      break;
    }
    case 14:
    {
      break;
    }
    case 15:
    {
      (rc = 1);
      break;
    }
    case 18:
    {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.pcache2 = (*__builtin_va_arg(ap, sqlite3_pcache_methods2 *)));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.pcache2 = (*__builtin_va_arg(ap, sqlite3_pcache_methods2 *)));
      }  
      break;
    }
    case 19:
    {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        if ((_1283_sqlite3Config.pcache2.xInit == 0)) {
          sqlite3PCacheSetDefault();
        }  
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        if ((_1284_sqlite3Config.pcache2.xInit == 0)) {
          sqlite3PCacheSetDefault();
        }  
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        ((*__builtin_va_arg(ap, sqlite3_pcache_methods2 *)) = _1283_sqlite3Config.pcache2);
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        ((*__builtin_va_arg(ap, sqlite3_pcache_methods2 *)) = _1284_sqlite3Config.pcache2);
      }  
      break;
    }
    case 8:
    if ((((! id2i_sqlite_enable_memsys3) && id2i_sqlite_enable_memsys5) || (id2i_sqlite_enable_memsys3 ))) {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.pHeap = __builtin_va_arg(ap, void *));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.pHeap = __builtin_va_arg(ap, void *));
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.nHeap = __builtin_va_arg(ap, int ));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.nHeap = __builtin_va_arg(ap, int ));
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.mnReq = __builtin_va_arg(ap, int ));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.mnReq = __builtin_va_arg(ap, int ));
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        if ((_1283_sqlite3Config.mnReq < 1)) {
          (_1283_sqlite3Config.mnReq = 1);
        } 
        else if ((_1283_sqlite3Config.mnReq > (1 << 12))) {
          (_1283_sqlite3Config.mnReq = (1 << 12));
        } 
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        if ((_1284_sqlite3Config.mnReq < 1)) {
          (_1284_sqlite3Config.mnReq = 1);
        } 
        else if ((_1284_sqlite3Config.mnReq > (1 << 12))) {
          (_1284_sqlite3Config.mnReq = (1 << 12));
        } 
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        if ((_1283_sqlite3Config.pHeap == 0)) {
          memset((&_1283_sqlite3Config.m), 0, sizeof(_1283_sqlite3Config.m));
        }  
        else {
          if (((id2i_sqlite_enable_memsys3 ) )) {
            (_1283_sqlite3Config.m = (*sqlite3MemGetMemsys3()));
          }  
          if (((id2i_sqlite_enable_memsys5 ) )) {
            (_1283_sqlite3Config.m = (*sqlite3MemGetMemsys5()));
          }  
        }
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        if ((_1284_sqlite3Config.pHeap == 0)) {
          memset((&_1284_sqlite3Config.m), 0, sizeof(_1284_sqlite3Config.m));
        }  
        else {
          if (((id2i_sqlite_enable_memsys3 ) )) {
            (_1284_sqlite3Config.m = (*sqlite3MemGetMemsys3()));
          }  
          if (((id2i_sqlite_enable_memsys5 ) )) {
            (_1284_sqlite3Config.m = (*sqlite3MemGetMemsys5()));
          }  
        }
      }  
      break;
    }  
    if ((((! id2i_sqlite_enable_memsys3) && (! id2i_sqlite_enable_memsys5)) )) {
      if ((op == 8)) {
        goto id2i_label_1;
      }  
    }  
    case 13:
    {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.szLookaside = __builtin_va_arg(ap, int ));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.szLookaside = __builtin_va_arg(ap, int ));
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.nLookaside = __builtin_va_arg(ap, int ));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.nLookaside = __builtin_va_arg(ap, int ));
      }  
      break;
    }
    case 16:
    {
      typedef void ( *LOGFUNC_t)(void * , int , const  char * );
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.xLog = __builtin_va_arg(ap, LOGFUNC_t ));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.xLog = __builtin_va_arg(ap, LOGFUNC_t ));
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.pLogArg = __builtin_va_arg(ap, void *));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.pLogArg = __builtin_va_arg(ap, void *));
      }  
      break;
    }
    case 17:
    {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.bOpenUri = __builtin_va_arg(ap, int ));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.bOpenUri = __builtin_va_arg(ap, int ));
      }  
      break;
    }
    case 20:
    {
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.bUseCis = __builtin_va_arg(ap, int ));
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.bUseCis = __builtin_va_arg(ap, int ));
      }  
      break;
    }
    case 22:
    {
      sqlite3_int64 szMmap =  __builtin_va_arg(ap, sqlite3_int64 );
      sqlite3_int64 mxMmap =  __builtin_va_arg(ap, sqlite3_int64 );
      if (((mxMmap < 0) || (mxMmap > 0))) {
        (mxMmap = 0);
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.mxMmap = mxMmap);
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.mxMmap = mxMmap);
      }  
      if ((szMmap < 0)) {
        (szMmap = 0);
      }  
      if ((szMmap > mxMmap)) {
        (szMmap = mxMmap);
      }  
      if ((((! id2i_sqlite_default_memstatus) ) )) {
        (_1283_sqlite3Config.szMmap = szMmap);
      }  
      if (((id2i_sqlite_default_memstatus ) )) {
        (_1284_sqlite3Config.szMmap = szMmap);
      }  
      break;
    }
    id2i_label_1:
    default:
    {
      (rc = 1);
      break;
    }
  }
  __builtin_va_end(ap);
  return rc;
}
static  int setupLookaside(sqlite3 *db , void *pBuf , int sz , int cnt )  {
  void *pStart;
  if (db->lookaside.nOut) {
    return 5;
  }  
  if (db->lookaside.bMalloced) {
    sqlite3_free(db->lookaside.pStart);
  }  
  (sz = (sz & (~ 7)));
  if ((sz <= ((int ) sizeof(LookasideSlot *)))) {
    (sz = 0);
  }  
  if ((cnt < 0)) {
    (cnt = 0);
  }  
  if (((sz == 0) || (cnt == 0))) {
    (sz = 0);
    (pStart = 0);
  } 
  else if ((pBuf == 0)) {
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      sqlite3BeginBenignMalloc();
    }  
    (pStart = sqlite3Malloc((sz * cnt)));
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      sqlite3EndBenignMalloc();
    }  
    if (pStart) {
      (cnt = (sqlite3MallocSize(pStart) / sz));
    }  
  } 
  else {
    (pStart = pBuf);
  }
  (db->lookaside.pStart = pStart);
  (db->lookaside.pFree = 0);
  (db->lookaside.sz = ((u16 ) sz));
  if (pStart) {
    int i;
    LookasideSlot *p;
    ((void ) 0);
    (p = ((LookasideSlot *) pStart));
    for ((i = (cnt - 1)); (i >= 0); i--) {
      (p->pNext = db->lookaside.pFree);
      (db->lookaside.pFree = p);
      (p = ((LookasideSlot *) (&((u8 *) p)[sz])));
    }
    (db->lookaside.pEnd = p);
    (db->lookaside.bEnabled = 1);
    (db->lookaside.bMalloced = ((pBuf == 0) ? 1 : 0));
  }  
  else {
    (db->lookaside.pEnd = 0);
    (db->lookaside.bEnabled = 0);
    (db->lookaside.bMalloced = 0);
  }
  return 0;
}
sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db )  {
  return db->mutex;
}
int sqlite3_db_release_memory(sqlite3 *db )  {
  int i;
  sqlite3BtreeEnterAll(db);
  for ((i = 0); (i < db->nDb); i++) {
    Btree *pBt =  db->aDb[i].pBt;
    if (pBt) {
      Pager *pPager =  sqlite3BtreePager(pBt);
      sqlite3PagerShrink(pPager);
    }  
  }
  return 0;
}
int sqlite3_db_config(sqlite3 *db , int op , ...)  {
  va_list ap;
  int rc;
  __builtin_va_start(ap, op);
  switch (op) {
    case 1001:
    {
      void *pBuf =  __builtin_va_arg(ap, void *);
      int sz =  __builtin_va_arg(ap, int );
      int cnt =  __builtin_va_arg(ap, int );
      (rc = setupLookaside(db, pBuf, sz, cnt));
      break;
    }
    id2i_label_1:
    default:
    {
      static const struct   {
        int op ;
        u32 mask ;
      }  aFlagOp[] =  { { 1002,  0x00080000},  { 1003,  0x00800000}};
      unsigned int i;
      (rc = 1);
      for ((i = 0); (i < ((int ) (sizeof(aFlagOp) / sizeof(aFlagOp[0])))); i++) {
        if ((aFlagOp[i].op == op)) {
          int onoff =  __builtin_va_arg(ap, int );
          int *pRes =  __builtin_va_arg(ap, int *);
          int oldFlags =  db->flags;
          if ((onoff > 0)) {
            (db->flags |= aFlagOp[i].mask);
          } 
          else if ((onoff == 0)) {
            (db->flags &= (~ aFlagOp[i].mask));
          } 
          if ((oldFlags != db->flags)) {
            sqlite3ExpirePreparedStatements(db);
          }  
          if (pRes) {
            ((*pRes) = ((db->flags & aFlagOp[i].mask) != 0));
          }  
          (rc = 0);
          break;
        }  
      }
      break;
    }
  }
  __builtin_va_end(ap);
  return rc;
}
static  int allSpaces(const  char *z , int n )  {
  while (((n > 0) && (z[(n - 1)] == ' '))) {
    n--;
  }
  return (n == 0);
}
static  int binCollFunc(void *padFlag , int nKey1 , const  void *pKey1 , int nKey2 , const  void *pKey2 )  {
  int rc, n;
  (n = ((nKey1 < nKey2) ? nKey1 : nKey2));
  (rc = memcmp(pKey1, pKey2, n));
  if ((rc == 0)) {
    if ((padFlag && allSpaces((((char *) pKey1) + n), (nKey1 - n)) && allSpaces((((char *) pKey2) + n), (nKey2 - n)))) {
      
    }  
    else {
      (rc = (nKey1 - nKey2));
    }
  }  
  return rc;
}
static  int nocaseCollatingFunc(void *NotUsed , int nKey1 , const  void *pKey1 , int nKey2 , const  void *pKey2 )  {
  int r =  sqlite3_strnicmp(((const  char *) pKey1), ((const  char *) pKey2), ((nKey1 < nKey2) ? nKey1 : nKey2));
  ((void ) NotUsed);
  if ((0 == r)) {
    (r = (nKey1 - nKey2));
  }  
  return r;
}
sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db )  {
  return db->lastRowid;
}
int sqlite3_changes(sqlite3 *db )  {
  return db->nChange;
}
int sqlite3_total_changes(sqlite3 *db )  {
  return db->nTotalChange;
}
static  void sqlite3CloseSavepoints(sqlite3 *db )  {
  while (db->pSavepoint) {
    Savepoint *pTmp =  db->pSavepoint;
    (db->pSavepoint = pTmp->pNext);
    sqlite3DbFree(db, pTmp);
  }
  (db->nSavepoint = 0);
  (db->nStatement = 0);
  (db->isTransactionSavepoint = 0);
}
static  void functionDestroy(sqlite3 *db , FuncDef *p )  {
  FuncDestructor *pDestructor =  p->pDestructor;
  if (pDestructor) {
    pDestructor->nRef--;
    if ((pDestructor->nRef == 0)) {
      pDestructor->xDestroy(pDestructor->pUserData);
      sqlite3DbFree(db, pDestructor);
    }  
  }  
}
static  void disconnectAllVtab(sqlite3 *db )  {
  int i;
  sqlite3BtreeEnterAll(db);
  for ((i = 0); (i < db->nDb); i++) {
    Schema *pSchema =  db->aDb[i].pSchema;
    if (db->aDb[i].pSchema) {
      HashElem *p;
      for ((p = (&pSchema->tblHash)->first); p; (p = p->next)) {
        Table *pTab =  ((Table *) p->data);
        if (((pTab->tabFlags & 0x10) != 0)) {
          sqlite3VtabDisconnect(db, pTab);
        }  
      }
    }  
  }
}
static  int connectionIsBusy(sqlite3 *db )  {
  int j;
  ((void ) 0);
  if (db->pVdbe) {
    return 1;
  }  
  for ((j = 0); (j < db->nDb); j++) {
    Btree *pBt =  db->aDb[j].pBt;
    if ((pBt && sqlite3BtreeIsInBackup(pBt))) {
      return 1;
    }  
  }
  return 0;
}
static  int sqlite3Close(sqlite3 *db , int forceZombie )  {
  if ((! db)) {
    return 0;
  }  
  if ((! sqlite3SafetyCheckSickOrOk(db))) {
    return sqlite3MisuseError(118130);
  }  
  disconnectAllVtab(db);
  sqlite3VtabRollback(db);
  if (((! forceZombie) && connectionIsBusy(db))) {
    sqlite3Error(db, 5, "unable to close due to unfinalized " "statements or unfinished backups");
    return 5;
  }  
  (db->magic = 0x64cffc7f);
  sqlite3LeaveMutexAndCloseZombie(db);
  return 0;
}
int sqlite3_close(sqlite3 *db )  {
  return sqlite3Close(db, 0);
}
int sqlite3_close_v2(sqlite3 *db )  {
  return sqlite3Close(db, 1);
}
static  void sqlite3LeaveMutexAndCloseZombie(sqlite3 *db )  {
  HashElem *i;
  int j;
  if (((db->magic != 0x64cffc7f) || connectionIsBusy(db))) {
    return;
  }  
  sqlite3RollbackAll(db, 0);
  sqlite3CloseSavepoints(db);
  for ((j = 0); (j < db->nDb); j++) {
    struct  Db   *pDb =  (&db->aDb[j]);
    if (pDb->pBt) {
      sqlite3BtreeClose(pDb->pBt);
      (pDb->pBt = 0);
      if ((j != 1)) {
        (pDb->pSchema = 0);
      }  
    }  
  }
  if (db->aDb[1].pSchema) {
    sqlite3SchemaClear(db->aDb[1].pSchema);
  }  
  sqlite3VtabUnlockList(db);
  sqlite3CollapseDatabaseArray(db);
  ((void ) 0);
  ((void ) 0);
  for ((j = 0); (j < ((int ) (sizeof(db->aFunc.a) / sizeof(db->aFunc.a[0])))); j++) {
    FuncDef *pNext, *pHash, *p;
    for ((p = db->aFunc.a[j]); p; (p = pHash)) {
      (pHash = p->pHash);
      while (p) {
        functionDestroy(db, p);
        (pNext = p->pNext);
        sqlite3DbFree(db, p);
        (p = pNext);
      }
    }
  }
  for ((i = (&db->aCollSeq)->first); i; (i = i->next)) {
    CollSeq *pColl =  ((CollSeq *) i->data);
    for ((j = 0); (j < 3); j++) {
      if (pColl[j].xDel) {
        pColl[j].xDel(pColl[j].pUser);
      }  
    }
    sqlite3DbFree(db, pColl);
  }
  sqlite3HashClear((&db->aCollSeq));
  for ((i = (&db->aModule)->first); i; (i = i->next)) {
    Module *pMod =  ((Module *) i->data);
    if (pMod->xDestroy) {
      pMod->xDestroy(pMod->pAux);
    }  
    sqlite3DbFree(db, pMod);
  }
  sqlite3HashClear((&db->aModule));
  sqlite3Error(db, 0, 0);
  if (db->pErr) {
    sqlite3ValueFree(db->pErr);
  }  
  (db->magic = 0xb5357930);
  sqlite3DbFree(db, db->aDb[1].pSchema);
  (db->magic = 0x9f3c2d33);
  ((void ) 0);
  if (db->lookaside.bMalloced) {
    sqlite3_free(db->lookaside.pStart);
  }  
  sqlite3_free(db);
}
static  void sqlite3RollbackAll(sqlite3 *db , int tripCode )  {
  int i;
  int inTrans =  0;
  ((void ) 0);
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    sqlite3BeginBenignMalloc();
  }  
  sqlite3BtreeEnterAll(db);
  for ((i = 0); (i < db->nDb); i++) {
    Btree *p =  db->aDb[i].pBt;
    if (p) {
      if (sqlite3BtreeIsInTrans(p)) {
        (inTrans = 1);
      }  
      sqlite3BtreeRollback(p, tripCode);
    }  
  }
  sqlite3VtabRollback(db);
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    sqlite3EndBenignMalloc();
  }  
  if ((((db->flags & 0x00000002) != 0) && (db->init.busy == 0))) {
    sqlite3ExpirePreparedStatements(db);
    sqlite3ResetAllSchemasOfConnection(db);
  }  
  (db->nDeferredCons = 0);
  (db->nDeferredImmCons = 0);
  (db->flags &= (~ 0x01000000));
  if ((db->xRollbackCallback && (inTrans || (! db->autoCommit)))) {
    db->xRollbackCallback(db->pRollbackArg);
  }  
}
static  const  char *sqlite3ErrStr(int rc )  {
  static const char *const aMsg[] =  { "not an error",  "SQL logic error or missing database",  0,  "access permission denied",  "callback requested query abort",  "database is locked",  "database table is locked",  "out of memory",  "attempt to write a readonly database",  "interrupted",  "disk I/O error",  "database disk image is malformed",  "unknown operation",  "database or disk is full",  "unable to open database file",  "locking protocol",  "table contains no data",  "database schema has changed",  "string or blob too big",  "constraint failed",  "datatype mismatch",  "library routine called out of sequence",  "large file support is disabled",  "authorization denied",  "auxiliary database format error",  "bind or column index out of range",  "file is encrypted or is not a database"};
  const char *zErr =  "unknown error";
  switch (rc) {
    case (4 | (2 << 8)):
    {
      (zErr = "abort due to ROLLBACK");
      break;
    }
    id2i_label_1:
    default:
    {
      (rc &= 0xff);
      if (((id2i_sqlite_coverage_test ) )) {
        if ((1 && (rc < ((int ) (sizeof(aMsg) / sizeof(aMsg[0])))) && (aMsg[rc] != 0))) {
          (zErr = aMsg[rc]);
        }  
      }  
      if ((((! id2i_sqlite_coverage_test) ) )) {
        if (((rc >= 0) && (rc < ((int ) (sizeof(aMsg) / sizeof(aMsg[0])))) && (aMsg[rc] != 0))) {
          (zErr = aMsg[rc]);
        }  
      }  
      break;
    }
  }
  return zErr;
}
static  int sqliteDefaultBusyCallback(void *ptr , int count )  {
  sqlite3 *db =  ((sqlite3 *) ptr);
  int timeout =  ((sqlite3 *) ptr)->busyTimeout;
  if ((((count + 1) * 1000) > timeout)) {
    return 0;
  }  
  sqlite3OsSleep(db->pVfs, 1000000);
  return 1;
}
static  int sqlite3InvokeBusyHandler(BusyHandler *p )  {
  int rc;
  if (((id2i_sqlite_coverage_test ) )) {
    if ((0 || (p->xFunc == 0) || (p->nBusy < 0))) {
      return 0;
    }  
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    if (((p == 0) || (p->xFunc == 0) || (p->nBusy < 0))) {
      return 0;
    }  
  }  
  (rc = p->xFunc(p->pArg, p->nBusy));
  if ((rc == 0)) {
    (p->nBusy = (- 1));
  }  
  else {
    p->nBusy++;
  }
  return rc;
}
int sqlite3_busy_handler(sqlite3 *db , int ( *xBusy)(void * , int ) , void *pArg )  {
  (db->busyHandler.xFunc = xBusy);
  (db->busyHandler.pArg = pArg);
  (db->busyHandler.nBusy = 0);
  (db->busyTimeout = 0);
  return 0;
}
void sqlite3_progress_handler(sqlite3 *db , int nOps , int ( *xProgress)(void * ) , void *pArg )  {
  if ((nOps > 0)) {
    (db->xProgress = xProgress);
    (db->nProgressOps = ((unsigned ) nOps));
    (db->pProgressArg = pArg);
  }  
  else {
    (db->xProgress = 0);
    (db->nProgressOps = 0);
    (db->pProgressArg = 0);
  }
}
int sqlite3_busy_timeout(sqlite3 *db , int ms )  {
  if ((ms > 0)) {
    sqlite3_busy_handler(db, sqliteDefaultBusyCallback, ((void *) db));
    (db->busyTimeout = ms);
  }  
  else {
    sqlite3_busy_handler(db, 0, 0);
  }
  return 0;
}
void sqlite3_interrupt(sqlite3 *db )  {
  (db->u1.isInterrupted = 1);
}
static  int sqlite3CreateFunc(sqlite3 *db , const  char *zFunctionName , int nArg , int enc , void *pUserData , void ( *xFunc)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xStep)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xFinal)(sqlite3_context * ) , FuncDestructor *pDestructor )  {
  FuncDef *p;
  int nName;
  ((void ) 0);
  if (((zFunctionName == 0) || (xFunc && (xFinal || xStep)) || ((! xFunc) && (xFinal && (! xStep))) || ((! xFunc) && ((! xFinal) && xStep)) || ((nArg < (- 1)) || (nArg > 127)) || (255 < (nName = sqlite3Strlen30(zFunctionName))))) {
    return sqlite3MisuseError(118672);
  }  
  if ((enc == 4)) {
    (enc = 2);
  } 
  else if ((enc == 5)) {
    int rc;
    (rc = sqlite3CreateFunc(db, zFunctionName, nArg, 1, pUserData, xFunc, xStep, xFinal, pDestructor));
    if ((rc == 0)) {
      (rc = sqlite3CreateFunc(db, zFunctionName, nArg, 2, pUserData, xFunc, xStep, xFinal, pDestructor));
    }  
    if ((rc != 0)) {
      return rc;
    }  
    (enc = 3);
  } 
  (p = sqlite3FindFunction(db, zFunctionName, nName, nArg, ((u8 ) enc), 0));
  if ((p && ((p->funcFlags & 0x003) == enc) && (p->nArg == nArg))) {
    if (db->nVdbeActive) {
      sqlite3Error(db, 5, "unable to delete/modify user-function due to active statements");
      ((void ) 0);
      return 5;
    }  
    else {
      sqlite3ExpirePreparedStatements(db);
    }
  }  
  (p = sqlite3FindFunction(db, zFunctionName, nName, nArg, ((u8 ) enc), 1));
  ((void ) 0);
  if ((! p)) {
    return 7;
  }  
  functionDestroy(db, p);
  if (pDestructor) {
    pDestructor->nRef++;
  }  
  (p->pDestructor = pDestructor);
  (p->funcFlags &= 0x003);
  (p->xFunc = xFunc);
  (p->xStep = xStep);
  (p->xFinalize = xFinal);
  (p->pUserData = pUserData);
  (p->nArg = ((u16 ) nArg));
  return 0;
}
int sqlite3_create_function(sqlite3 *db , const  char *zFunc , int nArg , int enc , void *p , void ( *xFunc)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xStep)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xFinal)(sqlite3_context * ) )  {
  return sqlite3_create_function_v2(db, zFunc, nArg, enc, p, xFunc, xStep, xFinal, 0);
}
int sqlite3_create_function_v2(sqlite3 *db , const  char *zFunc , int nArg , int enc , void *p , void ( *xFunc)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xStep)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xFinal)(sqlite3_context * ) , void ( *xDestroy)(void * ) )  {
  int rc =  1;
  FuncDestructor *pArg =  0;
  if (xDestroy) {
    (pArg = ((FuncDestructor *) sqlite3DbMallocZero(db, sizeof(FuncDestructor ))));
    if ((! pArg)) {
      xDestroy(p);
      goto out;
    }  
    (pArg->xDestroy = xDestroy);
    (pArg->pUserData = p);
  }  
  (rc = sqlite3CreateFunc(db, zFunc, nArg, enc, p, xFunc, xStep, xFinal, pArg));
  if ((pArg && (pArg->nRef == 0))) {
    ((void ) 0);
    xDestroy(p);
    sqlite3DbFree(db, pArg);
  }  
  out:
  (rc = sqlite3ApiExit(db, rc));
  return rc;
}
int sqlite3_create_function16(sqlite3 *db , const  void *zFunctionName , int nArg , int eTextRep , void *p , void ( *xFunc)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xStep)(sqlite3_context * , int , sqlite3_value ** ) , void ( *xFinal)(sqlite3_context * ) )  {
  int rc;
  char *zFunc8;
  ((void ) 0);
  (zFunc8 = sqlite3Utf16to8(db, zFunctionName, (- 1), 2));
  (rc = sqlite3CreateFunc(db, zFunc8, nArg, eTextRep, p, xFunc, xStep, xFinal, 0));
  sqlite3DbFree(db, zFunc8);
  (rc = sqlite3ApiExit(db, rc));
  return rc;
}
int sqlite3_overload_function(sqlite3 *db , const  char *zName , int nArg )  {
  int nName =  sqlite3Strlen30(zName);
  int rc =  0;
  if ((sqlite3FindFunction(db, zName, nName, nArg, 1, 0) == 0)) {
    (rc = sqlite3CreateFunc(db, zName, nArg, 1, 0, sqlite3InvalidFunction, 0, 0, 0));
  }  
  (rc = sqlite3ApiExit(db, rc));
  return rc;
}
void *sqlite3_trace(sqlite3 *db , void ( *xTrace)(void * , const  char * ) , void *pArg )  {
  void *pOld;
  (pOld = db->pTraceArg);
  (db->xTrace = xTrace);
  (db->pTraceArg = pArg);
  return pOld;
}
void *sqlite3_profile(sqlite3 *db , void ( *xProfile)(void * , const  char * , sqlite_uint64 ) , void *pArg )  {
  void *pOld;
  (pOld = db->pProfileArg);
  (db->xProfile = xProfile);
  (db->pProfileArg = pArg);
  return pOld;
}
void *sqlite3_commit_hook(sqlite3 *db , int ( *xCallback)(void * ) , void *pArg )  {
  void *pOld;
  (pOld = db->pCommitArg);
  (db->xCommitCallback = xCallback);
  (db->pCommitArg = pArg);
  return pOld;
}
void *sqlite3_update_hook(sqlite3 *db , void ( *xCallback)(void * , int , char  const * , char  const * , sqlite_int64 ) , void *pArg )  {
  void *pRet;
  (pRet = db->pUpdateArg);
  (db->xUpdateCallback = xCallback);
  (db->pUpdateArg = pArg);
  return pRet;
}
void *sqlite3_rollback_hook(sqlite3 *db , void ( *xCallback)(void * ) , void *pArg )  {
  void *pRet;
  (pRet = db->pRollbackArg);
  (db->xRollbackCallback = xCallback);
  (db->pRollbackArg = pArg);
  return pRet;
}
static  int sqlite3WalDefaultHook(void *pClientData , sqlite3 *db , const  char *zDb , int nFrame )  {
  if ((nFrame >= ((int ) ((long  int ) pClientData)))) {
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      sqlite3BeginBenignMalloc();
    }  
    sqlite3_wal_checkpoint(db, zDb);
    if ((((! id2i_sqlite_omit_builtin_test) ) )) {
      sqlite3EndBenignMalloc();
    }  
  }  
  return 0;
}
int sqlite3_wal_autocheckpoint(sqlite3 *db , int nFrame )  {
  if ((nFrame > 0)) {
    sqlite3_wal_hook(db, sqlite3WalDefaultHook, ((void *) ((long  int ) nFrame)));
  }  
  else {
    sqlite3_wal_hook(db, 0, 0);
  }
  return 0;
}
void *sqlite3_wal_hook(sqlite3 *db , int ( *xCallback)(void * , sqlite3 * , const  char * , int ) , void *pArg )  {
  void *pRet;
  (pRet = db->pWalArg);
  (db->xWalCallback = xCallback);
  (db->pWalArg = pArg);
  return pRet;
}
int sqlite3_wal_checkpoint_v2(sqlite3 *db , const  char *zDb , int eMode , int *pnLog , int *pnCkpt )  {
  int rc;
  int iDb =  10;
  if (pnLog) {
    ((*pnLog) = (- 1));
  }  
  if (pnCkpt) {
    ((*pnCkpt) = (- 1));
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((eMode < 0) || (eMode > 2))) {
    return 21;
  }  
  if ((zDb && zDb[0])) {
    (iDb = sqlite3FindDbName(db, zDb));
  }  
  if ((iDb < 0)) {
    (rc = 1);
    sqlite3Error(db, 1, "unknown database: %s", zDb);
  }  
  else {
    (rc = sqlite3Checkpoint(db, iDb, eMode, pnLog, pnCkpt));
    sqlite3Error(db, rc, 0);
  }
  (rc = sqlite3ApiExit(db, rc));
  return rc;
}
int sqlite3_wal_checkpoint(sqlite3 *db , const  char *zDb )  {
  return sqlite3_wal_checkpoint_v2(db, zDb, 0, 0, 0);
}
static  int sqlite3Checkpoint(sqlite3 *db , int iDb , int eMode , int *pnLog , int *pnCkpt )  {
  int rc =  0;
  int i;
  int bBusy =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  for ((i = 0); ((i < db->nDb) && (rc == 0)); i++) {
    if (((i == iDb) || (iDb == 10))) {
      (rc = sqlite3BtreeCheckpoint(db->aDb[i].pBt, eMode, pnLog, pnCkpt));
      (pnLog = 0);
      (pnCkpt = 0);
      if ((rc == 5)) {
        (bBusy = 1);
        (rc = 0);
      }  
    }  
  }
  return (((rc == 0) && bBusy) ? 5 : rc);
}
static  int sqlite3TempInMemory(const  sqlite3 *db )  {
  return (db->temp_store == 2);
}
const  char *sqlite3_errmsg(sqlite3 *db )  {
  const char *z;
  if ((! db)) {
    return sqlite3ErrStr(7);
  }  
  if ((! sqlite3SafetyCheckSickOrOk(db))) {
    return sqlite3ErrStr(sqlite3MisuseError(119157));
  }  
  if (db->mallocFailed) {
    (z = sqlite3ErrStr(7));
  }  
  else {
    (z = ((char *) sqlite3_value_text(db->pErr)));
    ((void ) 0);
    if ((z == 0)) {
      (z = sqlite3ErrStr(db->errCode));
    }  
  }
  return z;
}
const  void *sqlite3_errmsg16(sqlite3 *db )  {
  static const u16 outOfMem[] =  { 'o',  'u',  't',  ' ',  'o',  'f',  ' ',  'm',  'e',  'm',  'o',  'r',  'y',  0};
  static const u16 misuse[] =  { 'l',  'i',  'b',  'r',  'a',  'r',  'y',  ' ',  'r',  'o',  'u',  't',  'i',  'n',  'e',  ' ',  'c',  'a',  'l',  'l',  'e',  'd',  ' ',  'o',  'u',  't',  ' ',  'o',  'f',  ' ',  's',  'e',  'q',  'u',  'e',  'n',  'c',  'e',  0};
  const void *z;
  if ((! db)) {
    return ((void *) outOfMem);
  }  
  if ((! sqlite3SafetyCheckSickOrOk(db))) {
    return ((void *) misuse);
  }  
  if (db->mallocFailed) {
    (z = ((void *) outOfMem));
  }  
  else {
    (z = sqlite3_value_text16(db->pErr));
    if ((z == 0)) {
      sqlite3ValueSetStr(db->pErr, (- 1), sqlite3ErrStr(db->errCode), 1, ((sqlite3_destructor_type ) 0));
      (z = sqlite3_value_text16(db->pErr));
    }  
    (db->mallocFailed = 0);
  }
  return z;
}
int sqlite3_errcode(sqlite3 *db )  {
  if ((db && (! sqlite3SafetyCheckSickOrOk(db)))) {
    return sqlite3MisuseError(119226);
  }  
  if (((! db) || db->mallocFailed)) {
    return 7;
  }  
  return (db->errCode & db->errMask);
}
int sqlite3_extended_errcode(sqlite3 *db )  {
  if ((db && (! sqlite3SafetyCheckSickOrOk(db)))) {
    return sqlite3MisuseError(119235);
  }  
  if (((! db) || db->mallocFailed)) {
    return 7;
  }  
  return db->errCode;
}
const  char *sqlite3_errstr(int rc )  {
  return sqlite3ErrStr(rc);
}
static  int createCollation(sqlite3 *db , const  char *zName , u8 enc , void *pCtx , int ( *xCompare)(void * , int , const  void * , int , const  void * ) , void ( *xDel)(void * ) )  {
  CollSeq *pColl;
  int enc2;
  int nName =  sqlite3Strlen30(zName);
  ((void ) 0);
  (enc2 = enc);
  if (((id2i_sqlite_coverage_test ) )) {
    if ((enc2 == 4)) {
      sqlite3Coverage(119275);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if ((enc2 == 8)) {
      sqlite3Coverage(119276);
    }  
  }  
  if (((enc2 == 4) || (enc2 == 8))) {
    (enc2 = 2);
  }  
  if (((enc2 < 1) || (enc2 > 3))) {
    return sqlite3MisuseError(119281);
  }  
  (pColl = sqlite3FindCollSeq(db, ((u8 ) enc2), zName, 0));
  if ((pColl && pColl->xCmp)) {
    if (db->nVdbeActive) {
      sqlite3Error(db, 5, "unable to delete/modify collation sequence due to active statements");
      return 5;
    }  
    sqlite3ExpirePreparedStatements(db);
    if (((pColl->enc & (~ 8)) == enc2)) {
      CollSeq *aColl =  sqlite3HashFind((&db->aCollSeq), zName, nName);
      int j;
      for ((j = 0); (j < 3); j++) {
        CollSeq *p =  (&aColl[j]);
        if ((p->enc == pColl->enc)) {
          if (p->xDel) {
            p->xDel(p->pUser);
          }  
          (p->xCmp = 0);
        }  
      }
    }  
  }  
  (pColl = sqlite3FindCollSeq(db, ((u8 ) enc2), zName, 1));
  if ((pColl == 0)) {
    return 7;
  }  
  (pColl->xCmp = xCompare);
  (pColl->pUser = pCtx);
  (pColl->xDel = xDel);
  (pColl->enc = ((u8 ) (enc2 | (enc & 8))));
  sqlite3Error(db, 0, 0);
  return 0;
}
static const int aHardLimit[] =  { 1000000000,  1000000000,  2000,  1000,  500,  25000,  127,  10,  50000,  999,  1000};
int sqlite3_limit(sqlite3 *db , int limitId , int newLimit )  {
  int oldLimit;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((limitId < 0) || (limitId >= (10 + 1)))) {
    return (- 1);
  }  
  (oldLimit = db->aLimit[limitId]);
  if ((newLimit >= 0)) {
    if ((newLimit > aHardLimit[limitId])) {
      (newLimit = aHardLimit[limitId]);
    }  
    (db->aLimit[limitId] = newLimit);
  }  
  return oldLimit;
}
static  int sqlite3ParseUri(const  char *zDefaultVfs , const  char *zUri , unsigned  int *pFlags , sqlite3_vfs **ppVfs , char **pzFile , char **pzErrMsg )  {
  int rc =  0;
  unsigned int flags =  (*pFlags);
  const char *zVfs =  zDefaultVfs;
  char *zFile;
  char c;
  int nUri =  sqlite3Strlen30(zUri);
  ((void ) 0);
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if ((((flags & 0x00000040) || _1283_sqlite3Config.bOpenUri) && (nUri >= 5) && (memcmp(zUri, "file:", 5) == 0))) {
      char *zOpt;
      int eState;
      int iIn;
      int iOut =  0;
      int nByte =  (nUri + 2);
      (flags |= 0x00000040);
      for ((iIn = 0); (iIn < nUri); iIn++) {
        (nByte += (zUri[iIn] == '&'));
      }
      (zFile = sqlite3_malloc(nByte));
      if ((! zFile)) {
        return 7;
      }  
      (iIn = 5);
      if (((zUri[5] == '/') && (zUri[6] == '/'))) {
        (iIn = 7);
        while ((zUri[iIn] && (zUri[iIn] != '/'))) {
          iIn++;
        }
        if (((iIn != 7) && ((iIn != 16) || memcmp("localhost", (&zUri[7]), 9)))) {
          ((*pzErrMsg) = sqlite3_mprintf("invalid uri authority: %.*s", (iIn - 7), (&zUri[7])));
          (rc = 1);
          goto parse_uri_out;
        }  
      }  
      (eState = 0);
      while ((((c = zUri[iIn]) != 0) && (c != '#'))) {
        iIn++;
        if (((c == '%') && (sqlite3CtypeMap[((unsigned  char ) zUri[iIn])] & 0x08) && (sqlite3CtypeMap[((unsigned  char ) zUri[(iIn + 1)])] & 0x08))) {
          int octet =  (sqlite3HexToInt(zUri[iIn++]) << 4);
          (octet += sqlite3HexToInt(zUri[iIn++]));
          ((void ) 0);
          if ((octet == 0)) {
            while ((((c = zUri[iIn]) != 0) && (c != '#') && ((eState != 0) || (c != '?')) && ((eState != 1) || ((c != '=') && (c != '&'))) && ((eState != 2) || (c != '&')))) {
              iIn++;
            }
            continue;
          }  
          (c = octet);
        } 
        else if (((eState == 1) && ((c == '&') || (c == '=')))) {
          if ((zFile[(iOut - 1)] == 0)) {
            while ((zUri[iIn] && (zUri[iIn] != '#') && (zUri[(iIn - 1)] != '&'))) {
              iIn++;
            }
            continue;
          }  
          if ((c == '&')) {
            (zFile[iOut++] = '\0');
          }  
          else {
            (eState = 2);
          }
          (c = 0);
        }
        
        else if ((((eState == 0) && (c == '?')) || ((eState == 2) && (c == '&')))) {
          (c = 0);
          (eState = 1);
        } 
        (zFile[iOut++] = c);
      }
      if ((eState == 1)) {
        (zFile[iOut++] = '\0');
      }  
      (zFile[iOut++] = '\0');
      (zFile[iOut++] = '\0');
      (zOpt = (&zFile[(sqlite3Strlen30(zFile) + 1)]));
      while (zOpt[0]) {
        int nOpt =  sqlite3Strlen30(zOpt);
        char *zVal =  (&zOpt[(nOpt + 1)]);
        int nVal =  sqlite3Strlen30(zVal);
        if (((nOpt == 3) && (memcmp("vfs", zOpt, 3) == 0))) {
          (zVfs = zVal);
        }  
        else {
          struct  OpenMode {
            const  char *z ;
            int mode ;
          }  *aMode =  0;
          char *zModeType =  0;
          int mask =  0;
          int limit =  0;
          if (((nOpt == 5) && (memcmp("cache", zOpt, 5) == 0))) {
            static struct  OpenMode   aCacheMode[] =  { { "shared",  0x00020000},  { "private",  0x00040000},  { 0,  0}};
            (mask = (0x00020000 | 0x00040000));
            (aMode = aCacheMode);
            (limit = mask);
            (zModeType = "cache");
          }  
          if (((nOpt == 4) && (memcmp("mode", zOpt, 4) == 0))) {
            static struct  OpenMode   aOpenMode[] =  { { "ro",  0x00000001},  { "rw",  0x00000002},  { "rwc",  (0x00000002 | 0x00000004)},  { "memory",  0x00000080},  { 0,  0}};
            (mask = (0x00000001 | 0x00000002 | 0x00000004 | 0x00000080));
            (aMode = aOpenMode);
            (limit = (mask & flags));
            (zModeType = "access");
          }  
          if (aMode) {
            int i;
            int mode =  0;
            for ((i = 0); aMode[i].z; i++) {
              const char *z =  aMode[i].z;
              if (((nVal == sqlite3Strlen30(z)) && (0 == memcmp(zVal, z, nVal)))) {
                (mode = aMode[i].mode);
                break;
              }  
            }
            if ((mode == 0)) {
              ((*pzErrMsg) = sqlite3_mprintf("no such %s mode: %s", zModeType, zVal));
              (rc = 1);
              goto parse_uri_out;
            }  
            if (((mode & (~ 0x00000080)) > limit)) {
              ((*pzErrMsg) = sqlite3_mprintf("%s mode not allowed: %s", zModeType, zVal));
              (rc = 3);
              goto parse_uri_out;
            }  
            (flags = ((flags & (~ mask)) | mode));
          }  
        }
        (zOpt = (&zVal[(nVal + 1)]));
      }
    }  
    else {
      (zFile = sqlite3_malloc((nUri + 2)));
      if ((! zFile)) {
        return 7;
      }  
      memcpy(zFile, zUri, nUri);
      (zFile[nUri] = '\0');
      (zFile[(nUri + 1)] = '\0');
      (flags &= (~ 0x00000040));
    }
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if ((((flags & 0x00000040) || _1284_sqlite3Config.bOpenUri) && (nUri >= 5) && (memcmp(zUri, "file:", 5) == 0))) {
      char *zOpt;
      int eState;
      int iIn;
      int iOut =  0;
      int nByte =  (nUri + 2);
      (flags |= 0x00000040);
      for ((iIn = 0); (iIn < nUri); iIn++) {
        (nByte += (zUri[iIn] == '&'));
      }
      (zFile = sqlite3_malloc(nByte));
      if ((! zFile)) {
        return 7;
      }  
      (iIn = 5);
      if (((zUri[5] == '/') && (zUri[6] == '/'))) {
        (iIn = 7);
        while ((zUri[iIn] && (zUri[iIn] != '/'))) {
          iIn++;
        }
        if (((iIn != 7) && ((iIn != 16) || memcmp("localhost", (&zUri[7]), 9)))) {
          ((*pzErrMsg) = sqlite3_mprintf("invalid uri authority: %.*s", (iIn - 7), (&zUri[7])));
          (rc = 1);
          goto parse_uri_out;
        }  
      }  
      (eState = 0);
      while ((((c = zUri[iIn]) != 0) && (c != '#'))) {
        iIn++;
        if (((c == '%') && (sqlite3CtypeMap[((unsigned  char ) zUri[iIn])] & 0x08) && (sqlite3CtypeMap[((unsigned  char ) zUri[(iIn + 1)])] & 0x08))) {
          int octet =  (sqlite3HexToInt(zUri[iIn++]) << 4);
          (octet += sqlite3HexToInt(zUri[iIn++]));
          ((void ) 0);
          if ((octet == 0)) {
            while ((((c = zUri[iIn]) != 0) && (c != '#') && ((eState != 0) || (c != '?')) && ((eState != 1) || ((c != '=') && (c != '&'))) && ((eState != 2) || (c != '&')))) {
              iIn++;
            }
            continue;
          }  
          (c = octet);
        } 
        else if (((eState == 1) && ((c == '&') || (c == '=')))) {
          if ((zFile[(iOut - 1)] == 0)) {
            while ((zUri[iIn] && (zUri[iIn] != '#') && (zUri[(iIn - 1)] != '&'))) {
              iIn++;
            }
            continue;
          }  
          if ((c == '&')) {
            (zFile[iOut++] = '\0');
          }  
          else {
            (eState = 2);
          }
          (c = 0);
        }
        
        else if ((((eState == 0) && (c == '?')) || ((eState == 2) && (c == '&')))) {
          (c = 0);
          (eState = 1);
        } 
        (zFile[iOut++] = c);
      }
      if ((eState == 1)) {
        (zFile[iOut++] = '\0');
      }  
      (zFile[iOut++] = '\0');
      (zFile[iOut++] = '\0');
      (zOpt = (&zFile[(sqlite3Strlen30(zFile) + 1)]));
      while (zOpt[0]) {
        int nOpt =  sqlite3Strlen30(zOpt);
        char *zVal =  (&zOpt[(nOpt + 1)]);
        int nVal =  sqlite3Strlen30(zVal);
        if (((nOpt == 3) && (memcmp("vfs", zOpt, 3) == 0))) {
          (zVfs = zVal);
        }  
        else {
          struct  OpenMode {
            const  char *z ;
            int mode ;
          }  *aMode =  0;
          char *zModeType =  0;
          int mask =  0;
          int limit =  0;
          if (((nOpt == 5) && (memcmp("cache", zOpt, 5) == 0))) {
            static struct  OpenMode   aCacheMode[] =  { { "shared",  0x00020000},  { "private",  0x00040000},  { 0,  0}};
            (mask = (0x00020000 | 0x00040000));
            (aMode = aCacheMode);
            (limit = mask);
            (zModeType = "cache");
          }  
          if (((nOpt == 4) && (memcmp("mode", zOpt, 4) == 0))) {
            static struct  OpenMode   aOpenMode[] =  { { "ro",  0x00000001},  { "rw",  0x00000002},  { "rwc",  (0x00000002 | 0x00000004)},  { "memory",  0x00000080},  { 0,  0}};
            (mask = (0x00000001 | 0x00000002 | 0x00000004 | 0x00000080));
            (aMode = aOpenMode);
            (limit = (mask & flags));
            (zModeType = "access");
          }  
          if (aMode) {
            int i;
            int mode =  0;
            for ((i = 0); aMode[i].z; i++) {
              const char *z =  aMode[i].z;
              if (((nVal == sqlite3Strlen30(z)) && (0 == memcmp(zVal, z, nVal)))) {
                (mode = aMode[i].mode);
                break;
              }  
            }
            if ((mode == 0)) {
              ((*pzErrMsg) = sqlite3_mprintf("no such %s mode: %s", zModeType, zVal));
              (rc = 1);
              goto parse_uri_out;
            }  
            if (((mode & (~ 0x00000080)) > limit)) {
              ((*pzErrMsg) = sqlite3_mprintf("%s mode not allowed: %s", zModeType, zVal));
              (rc = 3);
              goto parse_uri_out;
            }  
            (flags = ((flags & (~ mask)) | mode));
          }  
        }
        (zOpt = (&zVal[(nVal + 1)]));
      }
    }  
    else {
      (zFile = sqlite3_malloc((nUri + 2)));
      if ((! zFile)) {
        return 7;
      }  
      memcpy(zFile, zUri, nUri);
      (zFile[nUri] = '\0');
      (zFile[(nUri + 1)] = '\0');
      (flags &= (~ 0x00000040));
    }
  }  
  ((*ppVfs) = sqlite3_vfs_find(zVfs));
  if (((*ppVfs) == 0)) {
    ((*pzErrMsg) = sqlite3_mprintf("no such vfs: %s", zVfs));
    (rc = 1);
  }  
  parse_uri_out:
  if ((rc != 0)) {
    sqlite3_free(zFile);
    (zFile = 0);
  }  
  ((*pFlags) = flags);
  ((*pzFile) = zFile);
  return rc;
}
static  int openDatabase(const  char *zFilename , sqlite3 **ppDb , unsigned  int flags , const  char *zVfs )  {
  sqlite3 *db;
  int rc;
  int isThreadsafe;
  char *zOpen =  0;
  char *zErrMsg =  0;
  ((*ppDb) = 0);
  (rc = sqlite3_initialize());
  if (rc) {
    return rc;
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    if (((1 << (flags & 7)) == 0x02)) {
      sqlite3Coverage(119699);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((1 << (flags & 7)) == 0x04)) {
      sqlite3Coverage(119700);
    }  
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (((1 << (flags & 7)) == 0x40)) {
      sqlite3Coverage(119701);
    }  
  }  
  if ((((1 << (flags & 7)) & 0x46) == 0)) {
    return sqlite3MisuseError(119702);
  }  
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    if ((_1283_sqlite3Config.bCoreMutex == 0)) {
      (isThreadsafe = 0);
    } 
    else if ((flags & 0x00008000)) {
      (isThreadsafe = 0);
    }
    
    else if ((flags & 0x00010000)) {
      (isThreadsafe = 1);
    } 
    else {
      (isThreadsafe = _1283_sqlite3Config.bFullMutex);
    }
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    if ((_1284_sqlite3Config.bCoreMutex == 0)) {
      (isThreadsafe = 0);
    } 
    else if ((flags & 0x00008000)) {
      (isThreadsafe = 0);
    }
    
    else if ((flags & 0x00010000)) {
      (isThreadsafe = 1);
    } 
    else {
      (isThreadsafe = _1284_sqlite3Config.bFullMutex);
    }
  }  
  if ((flags & 0x00040000)) {
    (flags &= (~ 0x00020000));
  } 
  else if (((((! id2i_sqlite_default_memstatus) ) ) && _1283_sqlite3Config.sharedCacheEnabled)) {
    (flags |= 0x00020000);
  }
  
  else if ((((id2i_sqlite_default_memstatus ) ) && _1284_sqlite3Config.sharedCacheEnabled)) {
    (flags |= 0x00020000);
  } 
  (flags &= (~ (0x00000008 | 0x00000010 | 0x00000100 | 0x00000200 | 0x00000400 | 0x00000800 | 0x00001000 | 0x00002000 | 0x00004000 | 0x00008000 | 0x00010000 | 0x00080000)));
  (db = sqlite3MallocZero(sizeof(sqlite3 )));
  if ((db == 0)) {
    goto opendb_out;
  }  
  if (isThreadsafe) {
    (db->mutex = ((sqlite3_mutex *) 8));
    if ((db->mutex == 0)) {
      sqlite3_free(db);
      (db = 0);
      goto opendb_out;
    }  
  }  
  (db->errMask = 0xff);
  (db->nDb = 2);
  (db->magic = 0xf03b7906);
  (db->aDb = db->aDbStatic);
  ((void ) 0);
  memcpy(db->aLimit, aHardLimit, sizeof(db->aLimit));
  (db->autoCommit = 1);
  (db->nextAutovac = (- 1));
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    (db->szMmap = _1283_sqlite3Config.szMmap);
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    (db->szMmap = _1284_sqlite3Config.szMmap);
  }  
  (db->nextPagesize = 0);
  (db->flags |= (0x00000040 | 0x00800000 | 0x00000010 | 0x00100000));
  sqlite3HashInit((&db->aCollSeq));
  sqlite3HashInit((&db->aModule));
  createCollation(db, "BINARY", 1, 0, binCollFunc, 0);
  createCollation(db, "BINARY", 3, 0, binCollFunc, 0);
  createCollation(db, "BINARY", 2, 0, binCollFunc, 0);
  createCollation(db, "RTRIM", 1, ((void *) 1), binCollFunc, 0);
  if (db->mallocFailed) {
    goto opendb_out;
  }  
  (db->pDfltColl = sqlite3FindCollSeq(db, 1, "BINARY", 0));
  ((void ) 0);
  createCollation(db, "NOCASE", 1, 0, nocaseCollatingFunc, 0);
  (db->openFlags = flags);
  (rc = sqlite3ParseUri(zVfs, zFilename, (&flags), (&db->pVfs), (&zOpen), (&zErrMsg)));
  if ((rc != 0)) {
    if ((rc == 7)) {
      (db->mallocFailed = 1);
    }  
    sqlite3Error(db, rc, (zErrMsg ? "%s" : 0), zErrMsg);
    sqlite3_free(zErrMsg);
    goto opendb_out;
  }  
  (rc = sqlite3BtreeOpen(db->pVfs, zOpen, db, (&db->aDb[0].pBt), 0, (flags | 0x00000100)));
  if ((rc != 0)) {
    if ((rc == (10 | (12 << 8)))) {
      (rc = 7);
    }  
    sqlite3Error(db, rc, 0);
    goto opendb_out;
  }  
  (db->aDb[0].pSchema = sqlite3SchemaGet(db, db->aDb[0].pBt));
  (db->aDb[1].pSchema = sqlite3SchemaGet(db, 0));
  (db->aDb[0].zName = "main");
  (db->aDb[0].safety_level = 3);
  (db->aDb[1].zName = "temp");
  (db->aDb[1].safety_level = 1);
  (db->magic = 0xa029a697);
  if (db->mallocFailed) {
    goto opendb_out;
  }  
  sqlite3Error(db, 0, 0);
  sqlite3RegisterBuiltinFunctions(db);
  (rc = sqlite3_errcode(db));
  if ((rc == 0)) {
    sqlite3AutoLoadExtensions(db);
    (rc = sqlite3_errcode(db));
    if ((rc != 0)) {
      goto opendb_out;
    }  
  }  
  if ((((! id2i_sqlite_enable_fts4) && id2i_sqlite_enable_fts3) || (id2i_sqlite_enable_fts4 ))) {
    if (((! db->mallocFailed) && (rc == 0))) {
      (rc = sqlite3Fts3Init(db));
    }  
  }  
  sqlite3Error(db, rc, 0);
  if ((((! id2i_sqlite_default_memstatus) ) )) {
    setupLookaside(db, 0, _1283_sqlite3Config.szLookaside, _1283_sqlite3Config.nLookaside);
  }  
  if (((id2i_sqlite_default_memstatus ) )) {
    setupLookaside(db, 0, _1284_sqlite3Config.szLookaside, _1284_sqlite3Config.nLookaside);
  }  
  sqlite3_wal_autocheckpoint(db, 1000);
  opendb_out:
  sqlite3_free(zOpen);
  if (db) {
    ((void ) 0);
  }  
  (rc = sqlite3_errcode(db));
  ((void ) 0);
  if ((rc == 7)) {
    sqlite3_close(db);
    (db = 0);
  } 
  else if ((rc != 0)) {
    (db->magic = 0x4b771290);
  } 
  ((*ppDb) = db);
  return sqlite3ApiExit(0, rc);
}
int sqlite3_open(const  char *zFilename , sqlite3 **ppDb )  {
  return openDatabase(zFilename, ppDb, (0x00000002 | 0x00000004), 0);
}
int sqlite3_open_v2(const  char *filename , sqlite3 **ppDb , int flags , const  char *zVfs )  {
  return openDatabase(filename, ppDb, ((unsigned  int ) flags), zVfs);
}
int sqlite3_open16(const  void *zFilename , sqlite3 **ppDb )  {
  char const *zFilename8;
  sqlite3_value *pVal;
  int rc;
  ((void ) 0);
  ((void ) 0);
  ((*ppDb) = 0);
  (rc = sqlite3_initialize());
  if (rc) {
    return rc;
  }  
  (pVal = sqlite3ValueNew(0));
  sqlite3ValueSetStr(pVal, (- 1), zFilename, 2, ((sqlite3_destructor_type ) 0));
  (zFilename8 = sqlite3ValueText(pVal, 1));
  if (zFilename8) {
    (rc = openDatabase(zFilename8, ppDb, (0x00000002 | 0x00000004), 0));
    ((void ) 0);
    if (((rc == 0) && (! (((*ppDb)->aDb[0].pSchema->flags & 0x0001) == 0x0001)))) {
      ((*ppDb)->aDb[0].pSchema->enc = 2);
    }  
  }  
  else {
    (rc = 7);
  }
  sqlite3ValueFree(pVal);
  return sqlite3ApiExit(0, rc);
}
int sqlite3_create_collation(sqlite3 *db , const  char *zName , int enc , void *pCtx , int ( *xCompare)(void * , int , const  void * , int , const  void * ) )  {
  int rc;
  ((void ) 0);
  (rc = createCollation(db, zName, ((u8 ) enc), pCtx, xCompare, 0));
  (rc = sqlite3ApiExit(db, rc));
  return rc;
}
int sqlite3_create_collation_v2(sqlite3 *db , const  char *zName , int enc , void *pCtx , int ( *xCompare)(void * , int , const  void * , int , const  void * ) , void ( *xDel)(void * ) )  {
  int rc;
  ((void ) 0);
  (rc = createCollation(db, zName, ((u8 ) enc), pCtx, xCompare, xDel));
  (rc = sqlite3ApiExit(db, rc));
  return rc;
}
int sqlite3_create_collation16(sqlite3 *db , const  void *zName , int enc , void *pCtx , int ( *xCompare)(void * , int , const  void * , int , const  void * ) )  {
  int rc =  0;
  char *zName8;
  ((void ) 0);
  (zName8 = sqlite3Utf16to8(db, zName, (- 1), 2));
  if (zName8) {
    (rc = createCollation(db, zName8, ((u8 ) enc), pCtx, xCompare, 0));
    sqlite3DbFree(db, zName8);
  }  
  (rc = sqlite3ApiExit(db, rc));
  return rc;
}
int sqlite3_collation_needed(sqlite3 *db , void *pCollNeededArg , void ( *xCollNeeded)(void * , sqlite3 * , int eTextRep , const  char * ) )  {
  (db->xCollNeeded = xCollNeeded);
  (db->xCollNeeded16 = 0);
  (db->pCollNeededArg = pCollNeededArg);
  return 0;
}
int sqlite3_collation_needed16(sqlite3 *db , void *pCollNeededArg , void ( *xCollNeeded16)(void * , sqlite3 * , int eTextRep , const  void * ) )  {
  (db->xCollNeeded = 0);
  (db->xCollNeeded16 = xCollNeeded16);
  (db->pCollNeededArg = pCollNeededArg);
  return 0;
}
int sqlite3_global_recover(void )  {
  return 0;
}
int sqlite3_get_autocommit(sqlite3 *db )  {
  return db->autoCommit;
}
static  int sqlite3CorruptError(int lineno )  {
  if (((id2i_sqlite_coverage_test ) )) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      if ((_1283_sqlite3Config.xLog != 0)) {
        sqlite3Coverage(120125);
      }  
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      if ((_1284_sqlite3Config.xLog != 0)) {
        sqlite3Coverage(120125);
      }  
    }  
  }  
  sqlite3_log(11, "database corruption at line %d of [%.10s]", lineno, (20 + sqlite3_sourceid()));
  return 11;
}
static  int sqlite3MisuseError(int lineno )  {
  if (((id2i_sqlite_coverage_test ) )) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      if ((_1283_sqlite3Config.xLog != 0)) {
        sqlite3Coverage(120132);
      }  
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      if ((_1284_sqlite3Config.xLog != 0)) {
        sqlite3Coverage(120132);
      }  
    }  
  }  
  sqlite3_log(21, "misuse at line %d of [%.10s]", lineno, (20 + sqlite3_sourceid()));
  return 21;
}
static  int sqlite3CantopenError(int lineno )  {
  if (((id2i_sqlite_coverage_test ) )) {
    if ((((! id2i_sqlite_default_memstatus) ) )) {
      if ((_1283_sqlite3Config.xLog != 0)) {
        sqlite3Coverage(120139);
      }  
    }  
    if (((id2i_sqlite_default_memstatus ) )) {
      if ((_1284_sqlite3Config.xLog != 0)) {
        sqlite3Coverage(120139);
      }  
    }  
  }  
  sqlite3_log(14, "cannot open file at line %d of [%.10s]", lineno, (20 + sqlite3_sourceid()));
  return 14;
}
void sqlite3_thread_cleanup(void )  {
  
}
int sqlite3_table_column_metadata(sqlite3 *db , const  char *zDbName , const  char *zTableName , const  char *zColumnName , char  const **pzDataType , char  const **pzCollSeq , int *pNotNull , int *pPrimaryKey , int *pAutoinc )  {
  int rc;
  char *zErrMsg =  0;
  Table *pTab =  0;
  Column *pCol =  0;
  int iCol;
  char const *zDataType =  0;
  char const *zCollSeq =  0;
  int notnull =  0;
  int primarykey =  0;
  int autoinc =  0;
  sqlite3BtreeEnterAll(db);
  (rc = sqlite3Init(db, (&zErrMsg)));
  if ((0 != rc)) {
    goto _1316_error_out;
  }  
  (pTab = sqlite3FindTable(db, zTableName, zDbName));
  if (((! pTab) || pTab->pSelect)) {
    (pTab = 0);
    goto _1316_error_out;
  }  
  if (sqlite3IsRowid(zColumnName)) {
    (iCol = pTab->iPKey);
    if ((iCol >= 0)) {
      (pCol = (&pTab->aCol[iCol]));
    }  
  }  
  else {
    for ((iCol = 0); (iCol < pTab->nCol); iCol++) {
      (pCol = (&pTab->aCol[iCol]));
      if ((0 == sqlite3_stricmp(pCol->zName, zColumnName))) {
        break;
      }  
    }
    if ((iCol == pTab->nCol)) {
      (pTab = 0);
      goto _1316_error_out;
    }  
  }
  if (pCol) {
    (zDataType = pCol->zType);
    (zCollSeq = pCol->zColl);
    (notnull = (pCol->notNull != 0));
    (primarykey = ((pCol->colFlags & 0x0001) != 0));
    (autoinc = ((pTab->iPKey == iCol) && ((pTab->tabFlags & 0x08) != 0)));
  }  
  else {
    (zDataType = "INTEGER");
    (primarykey = 1);
  }
  if ((! zCollSeq)) {
    (zCollSeq = "BINARY");
  }  
  _1316_error_out:
  if (pzDataType) {
    ((*pzDataType) = zDataType);
  }  
  if (pzCollSeq) {
    ((*pzCollSeq) = zCollSeq);
  }  
  if (pNotNull) {
    ((*pNotNull) = notnull);
  }  
  if (pPrimaryKey) {
    ((*pPrimaryKey) = primarykey);
  }  
  if (pAutoinc) {
    ((*pAutoinc) = autoinc);
  }  
  if (((0 == rc) && (! pTab))) {
    sqlite3DbFree(db, zErrMsg);
    (zErrMsg = sqlite3MPrintf(db, "no such table column: %s.%s", zTableName, zColumnName));
    (rc = 1);
  }  
  sqlite3Error(db, rc, (zErrMsg ? "%s" : 0), zErrMsg);
  sqlite3DbFree(db, zErrMsg);
  (rc = sqlite3ApiExit(db, rc));
  return rc;
}
int sqlite3_sleep(int ms )  {
  sqlite3_vfs *pVfs;
  int rc;
  (pVfs = sqlite3_vfs_find(0));
  if ((pVfs == 0)) {
    return 0;
  }  
  (rc = (sqlite3OsSleep(pVfs, (1000 * ms)) / 1000));
  return rc;
}
int sqlite3_extended_result_codes(sqlite3 *db , int onoff )  {
  (db->errMask = (onoff ? 0xffffffff : 0xff));
  return 0;
}
int sqlite3_file_control(sqlite3 *db , const  char *zDbName , int op , void *pArg )  {
  int rc =  1;
  Btree *pBtree;
  (pBtree = sqlite3DbNameToBtree(db, zDbName));
  if (pBtree) {
    Pager *pPager;
    sqlite3_file *fd;
    sqlite3BtreeEnter(pBtree);
    (pPager = sqlite3BtreePager(pBtree));
    ((void ) 0);
    (fd = sqlite3PagerFile(pPager));
    ((void ) 0);
    if ((op == 7)) {
      ((*((sqlite3_file **) pArg)) = fd);
      (rc = 0);
    } 
    else if (fd->pMethods) {
      (rc = sqlite3OsFileControl(fd, op, pArg));
    } 
    else {
      (rc = 12);
    }
  }  
  return rc;
}
int sqlite3_test_control(int op , ...)  {
  int rc =  0;
  va_list _1279_ap;
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    __builtin_va_start(_1279_ap, op);
  }  
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    switch (op) {
      case 5:
      {
        sqlite3PrngSaveState();
        break;
      }
      case 6:
      {
        sqlite3PrngRestoreState();
        break;
      }
      case 7:
      {
        sqlite3PrngResetState();
        break;
      }
      case 8:
      {
        int sz =  __builtin_va_arg(_1279_ap, int );
        int *aProg =  __builtin_va_arg(_1279_ap, int *);
        (rc = sqlite3BitvecBuiltinTest(sz, aProg));
        break;
      }
      case 10:
      {
        typedef void ( *void_function)(void );
        void_function xBenignBegin;
        void_function xBenignEnd;
        (xBenignBegin = __builtin_va_arg(_1279_ap, void_function ));
        (xBenignEnd = __builtin_va_arg(_1279_ap, void_function ));
        sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);
        break;
      }
      case 11:
      {
        (rc = sqlite3PendingByte);
        {
          unsigned int newVal =  __builtin_va_arg(_1279_ap, unsigned  int );
          if (newVal) {
            (sqlite3PendingByte = newVal);
          }  
        }
        break;
      }
      case 12:
      {
        volatile int x =  0;
        ((void ) 0);
        (rc = x);
        break;
      }
      case 13:
      {
        int x =  __builtin_va_arg(_1279_ap, int );
        if (((id2i_sqlite_coverage_test ) )) {
          (rc = 1);
        }  
        if ((((! id2i_sqlite_coverage_test) ) )) {
          (rc = x);
        }  
        break;
      }
      case 14:
      {
        sqlite3 *db =  __builtin_va_arg(_1279_ap, sqlite3 *);
        int x =  __builtin_va_arg(_1279_ap, int );
        sqlite3BtreeSetPageSize(db->aDb[0].pBt, 0, x, 0);
        break;
      }
      case 15:
      {
        sqlite3 *db =  __builtin_va_arg(_1279_ap, sqlite3 *);
        (db->dbOptFlags = ((u16 ) (__builtin_va_arg(_1279_ap, int ) & 0xffff)));
        break;
      }
      case 16:
      {
        const char *zWord =  __builtin_va_arg(_1279_ap, const  char *);
        int n =  sqlite3Strlen30(zWord);
        (rc = ((sqlite3KeywordCode(((u8 *) zWord), n) != 26) ? 121 : 0));
        break;
      }
      case 17:
      {
        void *pFree, **ppNew;
        int sz;
        (sz = __builtin_va_arg(_1279_ap, int ));
        (ppNew = __builtin_va_arg(_1279_ap, void **));
        (pFree = __builtin_va_arg(_1279_ap, void *));
        if (sz) {
          ((*ppNew) = sqlite3ScratchMalloc(sz));
        }  
        sqlite3ScratchFree(pFree);
        break;
      }
      case 18:
      {
        if ((((! id2i_sqlite_default_memstatus) ) )) {
          (_1283_sqlite3Config.bLocaltimeFault = __builtin_va_arg(_1279_ap, int ));
        }  
        if (((id2i_sqlite_default_memstatus ) )) {
          (_1284_sqlite3Config.bLocaltimeFault = __builtin_va_arg(_1279_ap, int ));
        }  
        break;
      }
      case 19:
      if (((id2i_sqlite_enable_tree_explain ) )) {
        sqlite3_stmt *pStmt =  __builtin_va_arg(_1279_ap, sqlite3_stmt *);
        const char **pzRet =  __builtin_va_arg(_1279_ap, const  char **);
        ((*pzRet) = sqlite3VdbeExplanation(((Vdbe *) pStmt)));
        break;
      }  
    }
  }  
  if ((((! id2i_sqlite_omit_builtin_test) ) )) {
    __builtin_va_end(_1279_ap);
  }  
  return rc;
}
const  char *sqlite3_uri_parameter(const  char *zFilename , const  char *zParam )  {
  if ((zFilename == 0)) {
    return 0;
  }  
  (zFilename += (sqlite3Strlen30(zFilename) + 1));
  while (zFilename[0]) {
    int x =  strcmp(zFilename, zParam);
    (zFilename += (sqlite3Strlen30(zFilename) + 1));
    if ((x == 0)) {
      return zFilename;
    }  
    (zFilename += (sqlite3Strlen30(zFilename) + 1));
  }
  return 0;
}
int sqlite3_uri_boolean(const  char *zFilename , const  char *zParam , int bDflt )  {
  const char *z =  sqlite3_uri_parameter(zFilename, zParam);
  (bDflt = (bDflt != 0));
  return (z ? sqlite3GetBoolean(z, bDflt) : bDflt);
}
sqlite3_int64 sqlite3_uri_int64(const  char *zFilename , const  char *zParam , sqlite3_int64 bDflt )  {
  const char *z =  sqlite3_uri_parameter(zFilename, zParam);
  sqlite3_int64 v;
  if ((z && (sqlite3Atoi64(z, (&v), sqlite3Strlen30(z), 1) == 0))) {
    (bDflt = v);
  }  
  return bDflt;
}
static  Btree *sqlite3DbNameToBtree(sqlite3 *db , const  char *zDbName )  {
  int i;
  for ((i = 0); (i < db->nDb); i++) {
    if ((db->aDb[i].pBt && ((zDbName == 0) || (sqlite3_stricmp(zDbName, db->aDb[i].zName) == 0)))) {
      return db->aDb[i].pBt;
    }  
  }
  return 0;
}
const  char *sqlite3_db_filename(sqlite3 *db , const  char *zDbName )  {
  Btree *pBt =  sqlite3DbNameToBtree(db, zDbName);
  return (pBt ? sqlite3BtreeGetFilename(pBt) : 0);
}
int sqlite3_db_readonly(sqlite3 *db , const  char *zDbName )  {
  Btree *pBt =  sqlite3DbNameToBtree(db, zDbName);
  return (pBt ? sqlite3PagerIsreadonly(sqlite3BtreePager(pBt)) : (- 1));
}
typedef struct  _1273_sqlite3_tokenizer_module   _1273_sqlite3_tokenizer_module;
typedef struct  _1273_sqlite3_tokenizer   _1273_sqlite3_tokenizer;
typedef struct  _1273_sqlite3_tokenizer_cursor   _1273_sqlite3_tokenizer_cursor;
struct  _1273_sqlite3_tokenizer_module {
  int iVersion ;
  int ( *xCreate)(int argc , const  char *const *argv , _1273_sqlite3_tokenizer **ppTokenizer ) ;
  int ( *xDestroy)(_1273_sqlite3_tokenizer *pTokenizer ) ;
  int ( *xOpen)(_1273_sqlite3_tokenizer *pTokenizer , const  char *pInput , int nBytes , _1273_sqlite3_tokenizer_cursor **ppCursor ) ;
  int ( *xClose)(_1273_sqlite3_tokenizer_cursor *pCursor ) ;
  int ( *xNext)(_1273_sqlite3_tokenizer_cursor *pCursor , const  char **ppToken , int *pnBytes , int *piStartOffset , int *piEndOffset , int *piPosition ) ;
  int ( *xLanguageid)(_1273_sqlite3_tokenizer_cursor *pCsr , int iLangid ) ;
}  ;
struct  _1273_sqlite3_tokenizer {
  const  _1273_sqlite3_tokenizer_module *pModule ;
}  ;
struct  _1273_sqlite3_tokenizer_cursor {
  _1273_sqlite3_tokenizer *pTokenizer ;
}  ;
int fts3_global_term_cnt(int iTerm , int iCol );
int fts3_term_cnt(int iTerm , int iCol );
typedef struct  _1273_Fts3Hash   _1273_Fts3Hash;
typedef struct  _1273_Fts3HashElem   _1273_Fts3HashElem;
struct  _1273_Fts3Hash {
  char keyClass ;
  char copyKey ;
  int count ;
  _1273_Fts3HashElem *first ;
  int htsize ;
  struct  _fts3ht {
    int count ;
    _1273_Fts3HashElem *chain ;
  }  *ht ;
}  ;
struct  _1273_Fts3HashElem {
  _1273_Fts3HashElem *next , *prev ;
  void *data ;
  void *pKey ;
  int nKey ;
}  ;
static void sqlite3Fts3HashInit(_1273_Fts3Hash *pNew , char keyClass , char copyKey );
static void *sqlite3Fts3HashInsert(_1273_Fts3Hash * , const  void *pKey , int nKey , void *pData );
static void *sqlite3Fts3HashFind(const  _1273_Fts3Hash * , const  void *pKey , int nKey );
static void sqlite3Fts3HashClear(_1273_Fts3Hash * );
static _1273_Fts3HashElem *sqlite3Fts3HashFindElem(const  _1273_Fts3Hash * , const  void * , int );
typedef struct  _1273_Fts3Table   _1273_Fts3Table;
typedef struct  _1273_Fts3Cursor   _1273_Fts3Cursor;
typedef struct  _1273_Fts3Expr   _1273_Fts3Expr;
typedef struct  _1273_Fts3Phrase   _1273_Fts3Phrase;
typedef struct  _1273_Fts3PhraseToken   _1273_Fts3PhraseToken;
typedef struct  _1273_Fts3Doclist   _1273_Fts3Doclist;
typedef struct  _1273_Fts3SegFilter   _1273_Fts3SegFilter;
typedef struct  _1273_Fts3DeferredToken   _1273_Fts3DeferredToken;
typedef struct  _1273_Fts3SegReader   _1273_Fts3SegReader;
typedef struct  _1273_Fts3MultiSegReader   _1273_Fts3MultiSegReader;
struct  _1273_Fts3Table {
  sqlite3_vtab base ;
  sqlite3 *db ;
  const  char *zDb ;
  const  char *zName ;
  int nColumn ;
  char **azColumn ;
  u8 *abNotindexed ;
  _1273_sqlite3_tokenizer *pTokenizer ;
  char *zContentTbl ;
  char *zLanguageid ;
  u8 bAutoincrmerge ;
  u32 nLeafAdd ;
  sqlite3_stmt *aStmt[37] ;
  char *zReadExprlist ;
  char *zWriteExprlist ;
  int nNodeSize ;
  u8 bFts4 ;
  u8 bHasStat ;
  u8 bHasDocsize ;
  u8 bDescIdx ;
  u8 bIgnoreSavepoint ;
  int nPgsz ;
  char *zSegmentsTbl ;
  sqlite3_blob *pSegments ;
  int nIndex ;
  struct  Fts3Index {
    int nPrefix ;
    _1273_Fts3Hash hPending ;
  }  *aIndex ;
  int nMaxPendingData ;
  int nPendingData ;
  sqlite_int64 iPrevDocid ;
  int iPrevLangid ;
  int _1366_inTransaction ;
  int _1366_mxSavepoint ;
}  ;
struct  _1273_Fts3Cursor {
  sqlite3_vtab_cursor base ;
  i16 eSearch ;
  u8 isEof ;
  u8 isRequireSeek ;
  sqlite3_stmt *pStmt ;
  _1273_Fts3Expr *pExpr ;
  int iLangid ;
  int nPhrase ;
  _1273_Fts3DeferredToken *pDeferred ;
  sqlite3_int64 iPrevId ;
  char *pNextId ;
  char *aDoclist ;
  int nDoclist ;
  u8 bDesc ;
  int eEvalmode ;
  int nRowAvg ;
  sqlite3_int64 nDoc ;
  i64 iMinDocid ;
  i64 iMaxDocid ;
  int isMatchinfoNeeded ;
  u32 *aMatchinfo ;
  int nMatchinfo ;
  char *zMatchinfo ;
}  ;
struct  _1273_Fts3Doclist {
  char *aAll ;
  int nAll ;
  char *pNextDocid ;
  sqlite3_int64 iDocid ;
  int bFreeList ;
  char *pList ;
  int nList ;
}  ;
struct  _1273_Fts3PhraseToken {
  char *z ;
  int n ;
  int isPrefix ;
  int bFirst ;
  _1273_Fts3DeferredToken *pDeferred ;
  _1273_Fts3MultiSegReader *pSegcsr ;
}  ;
struct  _1273_Fts3Phrase {
  _1273_Fts3Doclist doclist ;
  int bIncr ;
  int iDoclistToken ;
  int nToken ;
  int iColumn ;
  _1273_Fts3PhraseToken aToken[1] ;
}  ;
struct  _1273_Fts3Expr {
  int eType ;
  int nNear ;
  _1273_Fts3Expr *pParent ;
  _1273_Fts3Expr *pLeft ;
  _1273_Fts3Expr *pRight ;
  _1273_Fts3Phrase *pPhrase ;
  sqlite3_int64 iDocid ;
  u8 bEof ;
  u8 bStart ;
  u8 bDeferred ;
  u32 *aMI ;
}  ;
static int sqlite3Fts3UpdateMethod(sqlite3_vtab * , int , sqlite3_value ** , sqlite3_int64 * );
static int sqlite3Fts3PendingTermsFlush(_1273_Fts3Table * );
static void sqlite3Fts3PendingTermsClear(_1273_Fts3Table * );
static int sqlite3Fts3Optimize(_1273_Fts3Table * );
static int sqlite3Fts3SegReaderNew(int , int , sqlite3_int64 , sqlite3_int64 , sqlite3_int64 , const  char * , int , _1273_Fts3SegReader ** );
static int sqlite3Fts3SegReaderPending(_1273_Fts3Table * , int , const  char * , int , int , _1273_Fts3SegReader ** );
static void sqlite3Fts3SegReaderFree(_1273_Fts3SegReader * );
static int sqlite3Fts3AllSegdirs(_1273_Fts3Table * , int , int , int , sqlite3_stmt ** );
static int sqlite3Fts3ReadBlock(_1273_Fts3Table * , sqlite3_int64 , char ** , int * , int * );
static int sqlite3Fts3SelectDoctotal(_1273_Fts3Table * , sqlite3_stmt ** );
static int sqlite3Fts3SelectDocsize(_1273_Fts3Table * , sqlite3_int64 , sqlite3_stmt ** );
static void sqlite3Fts3FreeDeferredTokens(_1273_Fts3Cursor * );
static int sqlite3Fts3DeferToken(_1273_Fts3Cursor * , _1273_Fts3PhraseToken * , int );
static int sqlite3Fts3CacheDeferredDoclists(_1273_Fts3Cursor * );
static void sqlite3Fts3FreeDeferredDoclists(_1273_Fts3Cursor * );
static int sqlite3Fts3DeferredTokenList(_1273_Fts3DeferredToken * , char ** , int * );
static void sqlite3Fts3SegmentsClose(_1273_Fts3Table * );
static int sqlite3Fts3MaxLevel(_1273_Fts3Table * , int * );
static int sqlite3Fts3SegReaderStart(_1273_Fts3Table * , _1273_Fts3MultiSegReader * , _1273_Fts3SegFilter * );
static int sqlite3Fts3SegReaderStep(_1273_Fts3Table * , _1273_Fts3MultiSegReader * );
static void sqlite3Fts3SegReaderFinish(_1273_Fts3MultiSegReader * );
static int sqlite3Fts3SegReaderCursor(_1273_Fts3Table * , int , int , int , const  char * , int , int , int , _1273_Fts3MultiSegReader * );
struct  _1273_Fts3SegFilter {
  const  char *zTerm ;
  int nTerm ;
  int iCol ;
  int flags ;
}  ;
struct  _1273_Fts3MultiSegReader {
  _1273_Fts3SegReader **apSegment ;
  int nSegment ;
  int nAdvance ;
  _1273_Fts3SegFilter *pFilter ;
  char *aBuffer ;
  int nBuffer ;
  int iColFilter ;
  int bRestart ;
  int nCost ;
  int bLookup ;
  char *zTerm ;
  int nTerm ;
  char *aDoclist ;
  int nDoclist ;
}  ;
static int sqlite3Fts3Incrmerge(_1273_Fts3Table * , int , int );
static int sqlite3Fts3PutVarint(char * , sqlite3_int64 );
static int sqlite3Fts3GetVarint(const  char * , sqlite_int64 * );
static int sqlite3Fts3GetVarint32(const  char * , int * );
static int sqlite3Fts3VarintLen(sqlite3_uint64 );
static void sqlite3Fts3Dequote(char * );
static void sqlite3Fts3DoclistPrev(int , char * , int , char ** , sqlite3_int64 * , int * , u8 * );
static int sqlite3Fts3EvalPhraseStats(_1273_Fts3Cursor * , _1273_Fts3Expr * , u32 * );
static int sqlite3Fts3FirstFilter(sqlite3_int64 , char * , int , char * );
static void sqlite3Fts3CreateStatTable(int * , _1273_Fts3Table * );
static const char *sqlite3Fts3NextToken(const  char * , int * );
static int sqlite3Fts3InitHashTable(sqlite3 * , _1273_Fts3Hash * , const  char * );
static int sqlite3Fts3InitTokenizer(_1273_Fts3Hash *pHash , const  char * , _1273_sqlite3_tokenizer ** , char ** );
static int sqlite3Fts3IsIdChar(char );
static void sqlite3Fts3Offsets(sqlite3_context * , _1273_Fts3Cursor * );
static void sqlite3Fts3Snippet(sqlite3_context * , _1273_Fts3Cursor * , const  char * , const  char * , const  char * , int , int );
static void sqlite3Fts3Matchinfo(sqlite3_context * , _1273_Fts3Cursor * , const  char * );
static int sqlite3Fts3ExprParse(_1273_sqlite3_tokenizer * , int , char ** , int , int , int , const  char * , int , _1273_Fts3Expr ** , char ** );
static void sqlite3Fts3ExprFree(_1273_Fts3Expr * );
static int sqlite3Fts3OpenTokenizer(_1273_sqlite3_tokenizer * , int , const  char * , int , _1273_sqlite3_tokenizer_cursor ** );
static int sqlite3Fts3InitAux(sqlite3 *db );
static void sqlite3Fts3EvalPhraseCleanup(_1273_Fts3Phrase * );
static int sqlite3Fts3MsrIncrStart(_1273_Fts3Table * , _1273_Fts3MultiSegReader * , int , const  char * , int );
static int sqlite3Fts3MsrIncrNext(_1273_Fts3Table * , _1273_Fts3MultiSegReader * , sqlite3_int64 * , char ** , int * );
static int sqlite3Fts3EvalPhrasePoslist(_1273_Fts3Cursor * , _1273_Fts3Expr * , int iCol , char ** );
static int sqlite3Fts3MsrOvfl(_1273_Fts3Cursor * , _1273_Fts3MultiSegReader * , int * );
static int sqlite3Fts3MsrIncrRestart(_1273_Fts3MultiSegReader *pCsr );
static int sqlite3Fts3InitTok(sqlite3 * , _1273_Fts3Hash * );
static int sqlite3FtsUnicodeFold(int , int );
static int sqlite3FtsUnicodeIsalnum(int );
static int sqlite3FtsUnicodeIsdiacritic(int );
static int fts3EvalNext(_1273_Fts3Cursor *pCsr );
static int fts3EvalStart(_1273_Fts3Cursor *pCsr );
static int fts3TermSegReaderCursor(_1273_Fts3Cursor * , const  char * , int , int , _1273_Fts3MultiSegReader ** );
static  int sqlite3Fts3PutVarint(char *p , sqlite_int64 v )  {
  unsigned char *q =  ((unsigned  char *) p);
  sqlite_uint64 vu =  v;
  do {
    ((*q++) = ((unsigned  char ) ((vu & 0x7f) | 0x80)));
    (vu >>= 7);
  } while ((vu != 0));
  (q[(- 1)] &= 0x7f);
  ((void ) 0);
  return ((int ) (q - ((unsigned  char *) p)));
}
static  int sqlite3Fts3GetVarint(const  char *p , sqlite_int64 *v )  {
  const unsigned char *q =  ((const  unsigned  char *) p);
  sqlite_uint64 x =  0, y =  1;
  while (((((*q) & 0x80) == 0x80) && ((q - ((unsigned  char *) p)) < 10))) {
    (x += (y * ((*q++) & 0x7f)));
    (y <<= 7);
  }
  (x += (y * (*q++)));
  ((*v) = ((sqlite_int64 ) x));
  return ((int ) (q - ((unsigned  char *) p)));
}
static  int sqlite3Fts3GetVarint32(const  char *p , int *pi )  {
  sqlite_int64 i;
  int ret =  sqlite3Fts3GetVarint(p, (&i));
  ((*pi) = ((int ) i));
  return ret;
}
static  int sqlite3Fts3VarintLen(sqlite3_uint64 v )  {
  int i =  0;
  do {
    i++;
    (v >>= 7);
  } while ((v != 0));
  return i;
}
static  void sqlite3Fts3Dequote(char *z )  {
  char quote;
  (quote = z[0]);
  if (((quote == '[') || (quote == '\'') || (quote == '"') || (quote == '`'))) {
    int iIn =  1;
    int iOut =  0;
    if ((quote == '[')) {
      (quote = ']');
    }  
    if (((id2i_sqlite_coverage_test ) )) {
      while (1) {
        if ((z[iIn] == quote)) {
          if ((z[(iIn + 1)] != quote)) {
            break;
          }  
          (z[iOut++] = quote);
          (iIn += 2);
        }  
        else {
          (z[iOut++] = z[iIn++]);
        }
      }
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      while (z[iIn]) {
        if ((z[iIn] == quote)) {
          if ((z[(iIn + 1)] != quote)) {
            break;
          }  
          (z[iOut++] = quote);
          (iIn += 2);
        }  
        else {
          (z[iOut++] = z[iIn++]);
        }
      }
    }  
    (z[iOut] = '\0');
  }  
}
static  void fts3GetDeltaVarint(char **pp , sqlite3_int64 *pVal )  {
  sqlite3_int64 iVal;
  ((*pp) += sqlite3Fts3GetVarint((*pp), (&iVal)));
  ((*pVal) += iVal);
}
static  void fts3GetReverseVarint(char **pp , char *pStart , sqlite3_int64 *pVal )  {
  sqlite3_int64 iVal;
  char *p;
  for ((p = ((*pp) - 2)); ((p >= pStart) && ((*p) & 0x80)); p--) {
    
  }
  p++;
  ((*pp) = p);
  sqlite3Fts3GetVarint(p, (&iVal));
  ((*pVal) = iVal);
}
static  int fts3DisconnectMethod(sqlite3_vtab *pVtab )  {
  _1273_Fts3Table *p =  ((_1273_Fts3Table *) pVtab);
  int i;
  ((void ) 0);
  ((void ) 0);
  for ((i = 0); (i < ((int ) (sizeof(p->aStmt) / sizeof(p->aStmt[0])))); i++) {
    sqlite3_finalize(p->aStmt[i]);
  }
  sqlite3_free(p->zSegmentsTbl);
  sqlite3_free(p->zReadExprlist);
  sqlite3_free(p->zWriteExprlist);
  sqlite3_free(p->zContentTbl);
  sqlite3_free(p->zLanguageid);
  p->pTokenizer->pModule->xDestroy(p->pTokenizer);
  sqlite3_free(p);
  return 0;
}
static  void fts3DbExec(int *pRc , sqlite3 *db , const  char *zFormat , ...)  {
  va_list ap;
  char *zSql;
  if ((*pRc)) {
    return;
  }  
  __builtin_va_start(ap, zFormat);
  (zSql = sqlite3_vmprintf(zFormat, ap));
  __builtin_va_end(ap);
  if ((zSql == 0)) {
    ((*pRc) = 7);
  }  
  else {
    ((*pRc) = sqlite3_exec(db, zSql, 0, 0, 0));
    sqlite3_free(zSql);
  }
}
static  int fts3DestroyMethod(sqlite3_vtab *pVtab )  {
  _1273_Fts3Table *p =  ((_1273_Fts3Table *) pVtab);
  int rc =  0;
  const char *zDb =  p->zDb;
  sqlite3 *db =  p->db;
  if ((p->zContentTbl == 0)) {
    fts3DbExec((&rc), db, "DROP TABLE IF EXISTS %Q.'%q_content'", zDb, p->zName);
  }  
  fts3DbExec((&rc), db, "DROP TABLE IF EXISTS %Q.'%q_segments'", zDb, p->zName);
  fts3DbExec((&rc), db, "DROP TABLE IF EXISTS %Q.'%q_segdir'", zDb, p->zName);
  fts3DbExec((&rc), db, "DROP TABLE IF EXISTS %Q.'%q_docsize'", zDb, p->zName);
  fts3DbExec((&rc), db, "DROP TABLE IF EXISTS %Q.'%q_stat'", zDb, p->zName);
  return ((rc == 0) ? fts3DisconnectMethod(pVtab) : rc);
}
static  void fts3DeclareVtab(int *pRc , _1273_Fts3Table *p )  {
  if (((*pRc) == 0)) {
    int i;
    int rc;
    char *zSql;
    char *zCols;
    const char *zLanguageid;
    (zLanguageid = (p->zLanguageid ? p->zLanguageid : "__langid"));
    sqlite3_vtab_config(p->db, 1, 1);
    (zCols = sqlite3_mprintf("%Q, ", p->azColumn[0]));
    for ((i = 1); (zCols && (i < p->nColumn)); i++) {
      (zCols = sqlite3_mprintf("%z%Q, ", zCols, p->azColumn[i]));
    }
    (zSql = sqlite3_mprintf("CREATE TABLE x(%s %Q HIDDEN, docid HIDDEN, %Q HIDDEN)", zCols, p->zName, zLanguageid));
    if (((! zCols) || (! zSql))) {
      (rc = 7);
    }  
    else {
      (rc = sqlite3_declare_vtab(p->db, zSql));
    }
    sqlite3_free(zSql);
    sqlite3_free(zCols);
    ((*pRc) = rc);
  }  
}
static  void sqlite3Fts3CreateStatTable(int *pRc , _1273_Fts3Table *p )  {
  fts3DbExec(pRc, p->db, "CREATE TABLE IF NOT EXISTS %Q.'%q_stat'" "(id INTEGER PRIMARY KEY, value BLOB);", p->zDb, p->zName);
  if (((*pRc) == 0)) {
    (p->bHasStat = 1);
  }  
}
static  int fts3CreateTables(_1273_Fts3Table *p )  {
  int rc =  0;
  int i;
  sqlite3 *db =  p->db;
  if ((p->zContentTbl == 0)) {
    const char *zLanguageid =  p->zLanguageid;
    char *zContentCols;
    (zContentCols = sqlite3_mprintf("docid INTEGER PRIMARY KEY"));
    for ((i = 0); (zContentCols && (i < p->nColumn)); i++) {
      char *z =  p->azColumn[i];
      (zContentCols = sqlite3_mprintf("%z, 'c%d%q'", zContentCols, i, z));
    }
    if ((zLanguageid && zContentCols)) {
      (zContentCols = sqlite3_mprintf("%z, langid", zContentCols, zLanguageid));
    }  
    if ((zContentCols == 0)) {
      (rc = 7);
    }  
    fts3DbExec((&rc), db, "CREATE TABLE %Q.'%q_content'(%s)", p->zDb, p->zName, zContentCols);
    sqlite3_free(zContentCols);
  }  
  fts3DbExec((&rc), db, "CREATE TABLE %Q.'%q_segments'(blockid INTEGER PRIMARY KEY, block BLOB);", p->zDb, p->zName);
  fts3DbExec((&rc), db, "CREATE TABLE %Q.'%q_segdir'(" "level INTEGER," "idx INTEGER," "start_block INTEGER," "leaves_end_block INTEGER," "end_block INTEGER," "root BLOB," "PRIMARY KEY(level, idx)" ");", p->zDb, p->zName);
  if (p->bHasDocsize) {
    fts3DbExec((&rc), db, "CREATE TABLE %Q.'%q_docsize'(docid INTEGER PRIMARY KEY, size BLOB);", p->zDb, p->zName);
  }  
  ((void ) 0);
  if (p->bHasStat) {
    sqlite3Fts3CreateStatTable((&rc), p);
  }  
  return rc;
}
static  void fts3DatabasePageSize(int *pRc , _1273_Fts3Table *p )  {
  if (((*pRc) == 0)) {
    int rc;
    char *zSql;
    sqlite3_stmt *pStmt;
    (zSql = sqlite3_mprintf("PRAGMA %Q.page_size", p->zDb));
    if ((! zSql)) {
      (rc = 7);
    }  
    else {
      (rc = sqlite3_prepare(p->db, zSql, (- 1), (&pStmt), 0));
      if ((rc == 0)) {
        sqlite3_step(pStmt);
        (p->nPgsz = sqlite3_column_int(pStmt, 0));
        (rc = sqlite3_finalize(pStmt));
      } 
      else if ((rc == 23)) {
        (p->nPgsz = 1024);
        (rc = 0);
      } 
    }
    ((void ) 0);
    sqlite3_free(zSql);
    ((*pRc) = rc);
  }  
}
static  int fts3IsSpecialColumn(const  char *z , int *pnKey , char **pzValue )  {
  char *zValue;
  const char *zCsr =  z;
  while (((*zCsr) != '=')) {
    if (((*zCsr) == '\0')) {
      return 0;
    }  
    zCsr++;
  }
  ((*pnKey) = ((int ) (zCsr - z)));
  (zValue = sqlite3_mprintf("%s", (&zCsr[1])));
  if (zValue) {
    sqlite3Fts3Dequote(zValue);
  }  
  ((*pzValue) = zValue);
  return 1;
}
static  void fts3Appendf(int *pRc , char **pz , const  char *zFormat , ...)  {
  if (((*pRc) == 0)) {
    va_list ap;
    char *z;
    __builtin_va_start(ap, zFormat);
    (z = sqlite3_vmprintf(zFormat, ap));
    __builtin_va_end(ap);
    if ((z && (*pz))) {
      char *z2 =  sqlite3_mprintf("%s%s", (*pz), z);
      sqlite3_free(z);
      (z = z2);
    }  
    if ((z == 0)) {
      ((*pRc) = 7);
    }  
    sqlite3_free((*pz));
    ((*pz) = z);
  }  
}
static  char *fts3QuoteId(char  const *zInput )  {
  int nRet;
  char *zRet;
  (nRet = (2 + (((int ) strlen(zInput)) * 2) + 1));
  (zRet = sqlite3_malloc(nRet));
  if (zRet) {
    int i;
    char *z =  zRet;
    ((*z++) = '"');
    for ((i = 0); zInput[i]; i++) {
      if ((zInput[i] == '"')) {
        ((*z++) = '"');
      }  
      ((*z++) = zInput[i]);
    }
    ((*z++) = '"');
    ((*z++) = '\0');
  }  
  return zRet;
}
static  char *fts3ReadExprList(_1273_Fts3Table *p , const  char *zFunc , int *pRc )  {
  char *zRet =  0;
  char *zFree =  0;
  char *zFunction;
  int i;
  if ((p->zContentTbl == 0)) {
    if ((! zFunc)) {
      (zFunction = "");
    }  
    else {
      (zFree = (zFunction = fts3QuoteId(zFunc)));
    }
    fts3Appendf(pRc, (&zRet), "docid");
    for ((i = 0); (i < p->nColumn); i++) {
      fts3Appendf(pRc, (&zRet), ",%s(x.'c%d%q')", zFunction, i, p->azColumn[i]);
    }
    if (p->zLanguageid) {
      fts3Appendf(pRc, (&zRet), ", x.%Q", "langid");
    }  
    sqlite3_free(zFree);
  }  
  else {
    fts3Appendf(pRc, (&zRet), "rowid");
    for ((i = 0); (i < p->nColumn); i++) {
      fts3Appendf(pRc, (&zRet), ", x.'%q'", p->azColumn[i]);
    }
    if (p->zLanguageid) {
      fts3Appendf(pRc, (&zRet), ", x.%Q", p->zLanguageid);
    }  
  }
  fts3Appendf(pRc, (&zRet), " FROM '%q'.'%q%s' AS x", p->zDb, (p->zContentTbl ? p->zContentTbl : p->zName), (p->zContentTbl ? "" : "_content"));
  return zRet;
}
static  char *fts3WriteExprList(_1273_Fts3Table *p , const  char *zFunc , int *pRc )  {
  char *zRet =  0;
  char *zFree =  0;
  char *zFunction;
  int i;
  if ((! zFunc)) {
    (zFunction = "");
  }  
  else {
    (zFree = (zFunction = fts3QuoteId(zFunc)));
  }
  fts3Appendf(pRc, (&zRet), "?");
  for ((i = 0); (i < p->nColumn); i++) {
    fts3Appendf(pRc, (&zRet), ",%s(?)", zFunction);
  }
  if (p->zLanguageid) {
    fts3Appendf(pRc, (&zRet), ", ?");
  }  
  sqlite3_free(zFree);
  return zRet;
}
static  int fts3GobbleInt(const  char **pp , int *pnOut )  {
  const char *p;
  int nInt =  0;
  for ((p = (*pp)); ((p[0] >= '0') && (p[0] <= '9')); p++) {
    (nInt = ((nInt * 10) + (p[0] - '0')));
  }
  if ((p == (*pp))) {
    return 1;
  }  
  ((*pnOut) = nInt);
  ((*pp) = p);
  return 0;
}
static  int fts3PrefixParameter(const  char *zParam , int *pnIndex , struct  Fts3Index   **apIndex )  {
  struct  Fts3Index   *aIndex;
  int nIndex =  1;
  if ((zParam && zParam[0])) {
    const char *p;
    nIndex++;
    for ((p = zParam); (*p); p++) {
      if (((*p) == ',')) {
        nIndex++;
      }  
    }
  }  
  (aIndex = sqlite3_malloc((sizeof(struct  Fts3Index   ) * nIndex)));
  ((*apIndex) = aIndex);
  ((*pnIndex) = nIndex);
  if ((! aIndex)) {
    return 7;
  }  
  memset(aIndex, 0, (sizeof(struct  Fts3Index   ) * nIndex));
  if (zParam) {
    const char *p =  zParam;
    int i;
    for ((i = 1); (i < nIndex); i++) {
      int nPrefix;
      if (fts3GobbleInt((&p), (&nPrefix))) {
        return 1;
      }  
      (aIndex[i].nPrefix = nPrefix);
      p++;
    }
  }  
  return 0;
}
static  int fts3ContentColumns(sqlite3 *db , const  char *zDb , const  char *zTbl , const  char ***pazCol , int *pnCol , int *pnStr )  {
  int rc =  0;
  char *zSql;
  sqlite3_stmt *pStmt =  0;
  (zSql = sqlite3_mprintf("SELECT * FROM %Q.%Q", zDb, zTbl));
  if ((! zSql)) {
    (rc = 7);
  }  
  else {
    (rc = sqlite3_prepare(db, zSql, (- 1), (&pStmt), 0));
  }
  sqlite3_free(zSql);
  if ((rc == 0)) {
    const char **azCol;
    int nStr =  0;
    int nCol;
    int i;
    (nCol = sqlite3_column_count(pStmt));
    for ((i = 0); (i < nCol); i++) {
      const char *zCol =  sqlite3_column_name(pStmt, i);
      (nStr += (((int ) strlen(zCol)) + 1));
    }
    (azCol = ((const  char **) sqlite3_malloc(((sizeof(char *) * nCol) + nStr))));
    if ((azCol == 0)) {
      (rc = 7);
    }  
    else {
      char *p =  ((char *) (&azCol[nCol]));
      for ((i = 0); (i < nCol); i++) {
        const char *zCol =  sqlite3_column_name(pStmt, i);
        int n =  (((int ) strlen(zCol)) + 1);
        memcpy(p, zCol, n);
        (azCol[i] = p);
        (p += n);
      }
    }
    sqlite3_finalize(pStmt);
    ((*pnCol) = nCol);
    ((*pnStr) = nStr);
    ((*pazCol) = azCol);
  }  
  return rc;
}
static  int fts3InitVtab(int isCreate , sqlite3 *db , void *pAux , int argc , const  char *const *argv , sqlite3_vtab **ppVTab , char **pzErr )  {
  _1273_Fts3Hash *pHash =  ((_1273_Fts3Hash *) pAux);
  _1273_Fts3Table *p =  0;
  int rc =  0;
  int i;
  int nByte;
  int iCol;
  int nString =  0;
  int nCol =  0;
  char *zCsr;
  int nDb;
  int nName;
  int isFts4 =  (argv[0][3] == '4');
  const char **aCol;
  _1273_sqlite3_tokenizer *pTokenizer =  0;
  int nIndex;
  struct  Fts3Index   *aIndex =  0;
  int bNoDocsize =  0;
  int bDescIdx =  0;
  char *zPrefix =  0;
  char *zCompress =  0;
  char *zUncompress =  0;
  char *zContent =  0;
  char *zLanguageid =  0;
  char **azNotindexed =  0;
  int nNotindexed =  0;
  ((void ) 0);
  ((void ) 0);
  (nDb = (((int ) strlen(argv[1])) + 1));
  (nName = (((int ) strlen(argv[2])) + 1));
  (nByte = (sizeof(const  char *) * (argc - 2)));
  (aCol = ((const  char **) sqlite3_malloc(nByte)));
  if (aCol) {
    memset(((void *) aCol), 0, nByte);
    (azNotindexed = ((char **) sqlite3_malloc(nByte)));
  }  
  if (azNotindexed) {
    memset(azNotindexed, 0, nByte);
  }  
  if (((! aCol) || (! azNotindexed))) {
    (rc = 7);
    goto _1273_fts3_init_out;
  }  
  for ((i = 3); ((rc == 0) && (i < argc)); i++) {
    char const *z =  argv[i];
    int nKey;
    char *zVal;
    if (((! pTokenizer) && (strlen(z) > 8) && (0 == sqlite3_strnicmp(z, "tokenize", 8)) && (0 == sqlite3Fts3IsIdChar(z[8])))) {
      (rc = sqlite3Fts3InitTokenizer(pHash, (&z[9]), (&pTokenizer), pzErr));
    } 
    else if ((isFts4 && fts3IsSpecialColumn(z, (&nKey), (&zVal)))) {
      struct  Fts4Option {
        const  char *zOpt ;
        int nOpt ;
      }  aFts4Opt[] =  { { "matchinfo",  9},  { "prefix",  6},  { "compress",  8},  { "uncompress",  10},  { "order",  5},  { "content",  7},  { "languageid",  10},  { "notindexed",  10}};
      int iOpt;
      if ((! zVal)) {
        (rc = 7);
      }  
      else {
        for ((iOpt = 0); (iOpt < ((int ) (sizeof(aFts4Opt) / sizeof(aFts4Opt[0])))); iOpt++) {
          struct  Fts4Option   *pOp =  (&aFts4Opt[iOpt]);
          if (((nKey == pOp->nOpt) && (! sqlite3_strnicmp(z, pOp->zOpt, pOp->nOpt)))) {
            break;
          }  
        }
        if ((iOpt == ((int ) (sizeof(aFts4Opt) / sizeof(aFts4Opt[0]))))) {
          ((*pzErr) = sqlite3_mprintf("unrecognized parameter: %s", z));
          (rc = 1);
        }  
        else {
          switch (iOpt) {
            case 0:
            if (((strlen(zVal) != 4) || sqlite3_strnicmp(zVal, "fts3", 4))) {
              ((*pzErr) = sqlite3_mprintf("unrecognized matchinfo: %s", zVal));
              (rc = 1);
            }  
            (bNoDocsize = 1);
            break;
            case 1:
            sqlite3_free(zPrefix);
            (zPrefix = zVal);
            (zVal = 0);
            break;
            case 2:
            sqlite3_free(zCompress);
            (zCompress = zVal);
            (zVal = 0);
            break;
            case 3:
            sqlite3_free(zUncompress);
            (zUncompress = zVal);
            (zVal = 0);
            break;
            case 4:
            if ((((strlen(zVal) != 3) || sqlite3_strnicmp(zVal, "asc", 3)) && ((strlen(zVal) != 4) || sqlite3_strnicmp(zVal, "desc", 4)))) {
              ((*pzErr) = sqlite3_mprintf("unrecognized order: %s", zVal));
              (rc = 1);
            }  
            (bDescIdx = ((zVal[0] == 'd') || (zVal[0] == 'D')));
            break;
            case 5:
            sqlite3_free(zContent);
            (zContent = zVal);
            (zVal = 0);
            break;
            case 6:
            ((void ) 0);
            sqlite3_free(zLanguageid);
            (zLanguageid = zVal);
            (zVal = 0);
            break;
            case 7:
            (azNotindexed[nNotindexed++] = zVal);
            (zVal = 0);
            break;
          }
        }
        sqlite3_free(zVal);
      }
    } 
    else {
      (nString += ((int ) (strlen(z) + 1)));
      (aCol[nCol++] = z);
    }
  }
  if (((rc == 0) && zContent)) {
    sqlite3_free(zCompress);
    sqlite3_free(zUncompress);
    (zCompress = 0);
    (zUncompress = 0);
    if ((nCol == 0)) {
      sqlite3_free(((void *) aCol));
      (aCol = 0);
      (rc = fts3ContentColumns(db, argv[1], zContent, (&aCol), (&nCol), (&nString)));
      if (((rc == 0) && zLanguageid)) {
        int j;
        for ((j = 0); (j < nCol); j++) {
          if ((sqlite3_stricmp(zLanguageid, aCol[j]) == 0)) {
            int k;
            for ((k = j); (k < nCol); k++) {
              (aCol[k] = aCol[(k + 1)]);
            }
            nCol--;
            break;
          }  
        }
      }  
    }  
  }  
  if ((rc != 0)) {
    goto _1273_fts3_init_out;
  }  
  if ((nCol == 0)) {
    ((void ) 0);
    (aCol[0] = "content");
    (nString = 8);
    (nCol = 1);
  }  
  if ((pTokenizer == 0)) {
    (rc = sqlite3Fts3InitTokenizer(pHash, "simple", (&pTokenizer), pzErr));
    if ((rc != 0)) {
      goto _1273_fts3_init_out;
    }  
  }  
  ((void ) 0);
  (rc = fts3PrefixParameter(zPrefix, (&nIndex), (&aIndex)));
  if ((rc == 1)) {
    ((void ) 0);
    ((*pzErr) = sqlite3_mprintf("error parsing prefix parameter: %s", zPrefix));
  }  
  if ((rc != 0)) {
    goto _1273_fts3_init_out;
  }  
  (nByte = (sizeof(_1273_Fts3Table ) + (nCol * sizeof(char *)) + (nIndex * sizeof(struct  Fts3Index   )) + (nCol * sizeof(u8 )) + nName + nDb + nString));
  (p = ((_1273_Fts3Table *) sqlite3_malloc(nByte)));
  if ((p == 0)) {
    (rc = 7);
    goto _1273_fts3_init_out;
  }  
  memset(p, 0, nByte);
  (p->db = db);
  (p->nColumn = nCol);
  (p->nPendingData = 0);
  (p->azColumn = ((char **) (&p[1])));
  (p->pTokenizer = pTokenizer);
  (p->nMaxPendingData = (1 * 1024 * 1024));
  (p->bHasDocsize = (isFts4 && (bNoDocsize == 0)));
  (p->bHasStat = isFts4);
  (p->bFts4 = isFts4);
  (p->bDescIdx = bDescIdx);
  (p->bAutoincrmerge = 0xff);
  (p->zContentTbl = zContent);
  (p->zLanguageid = zLanguageid);
  (zContent = 0);
  (zLanguageid = 0);
  if (((id2i_sqlite_coverage_test ) )) {
    (p->_1366_inTransaction = (- 1));
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    (p->_1366_mxSavepoint = (- 1));
  }  
  (p->aIndex = ((struct  Fts3Index   *) (&p->azColumn[nCol])));
  memcpy(p->aIndex, aIndex, (sizeof(struct  Fts3Index   ) * nIndex));
  (p->nIndex = nIndex);
  for ((i = 0); (i < nIndex); i++) {
    sqlite3Fts3HashInit((&p->aIndex[i].hPending), 1, 1);
  }
  (p->abNotindexed = ((u8 *) (&p->aIndex[nIndex])));
  (zCsr = ((char *) (&p->abNotindexed[nCol])));
  (p->zName = zCsr);
  memcpy(zCsr, argv[2], nName);
  (zCsr += nName);
  (p->zDb = zCsr);
  memcpy(zCsr, argv[1], nDb);
  (zCsr += nDb);
  for ((iCol = 0); (iCol < nCol); iCol++) {
    char *z;
    int n =  0;
    (z = ((char *) sqlite3Fts3NextToken(aCol[iCol], (&n))));
    memcpy(zCsr, z, n);
    (zCsr[n] = '\0');
    sqlite3Fts3Dequote(zCsr);
    (p->azColumn[iCol] = zCsr);
    (zCsr += (n + 1));
    ((void ) 0);
  }
  for ((iCol = 0); (iCol < nCol); iCol++) {
    int n =  ((int ) strlen(p->azColumn[iCol]));
    for ((i = 0); (i < nNotindexed); i++) {
      char *zNot =  azNotindexed[i];
      if ((zNot && (0 == sqlite3_strnicmp(p->azColumn[iCol], zNot, n)))) {
        (p->abNotindexed[iCol] = 1);
        sqlite3_free(zNot);
        (azNotindexed[i] = 0);
      }  
    }
  }
  for ((i = 0); (i < nNotindexed); i++) {
    if (azNotindexed[i]) {
      ((*pzErr) = sqlite3_mprintf("no such column: %s", azNotindexed[i]));
      (rc = 1);
    }  
  }
  if (((rc == 0) && ((zCompress == 0) != (zUncompress == 0)))) {
    char const *zMiss =  ((zCompress == 0) ? "compress" : "uncompress");
    (rc = 1);
    ((*pzErr) = sqlite3_mprintf("missing %s parameter in fts4 constructor", zMiss));
  }  
  (p->zReadExprlist = fts3ReadExprList(p, zUncompress, (&rc)));
  (p->zWriteExprlist = fts3WriteExprList(p, zCompress, (&rc)));
  if ((rc != 0)) {
    goto _1273_fts3_init_out;
  }  
  if (isCreate) {
    (rc = fts3CreateTables(p));
  }  
  if (((! isFts4) && (! isCreate))) {
    int rc2 =  0;
    fts3DbExec((&rc2), db, "SELECT 1 FROM %Q.'%q_stat' WHERE id=2", p->zDb, p->zName);
    if ((rc2 == 0)) {
      (p->bHasStat = 1);
    }  
  }  
  fts3DatabasePageSize((&rc), p);
  (p->nNodeSize = (p->nPgsz - 35));
  fts3DeclareVtab((&rc), p);
  _1273_fts3_init_out:
  sqlite3_free(zPrefix);
  sqlite3_free(aIndex);
  sqlite3_free(zCompress);
  sqlite3_free(zUncompress);
  sqlite3_free(zContent);
  sqlite3_free(zLanguageid);
  for ((i = 0); (i < nNotindexed); i++) {
    sqlite3_free(azNotindexed[i]);
  }
  sqlite3_free(((void *) aCol));
  sqlite3_free(((void *) azNotindexed));
  if ((rc != 0)) {
    if (p) {
      fts3DisconnectMethod(((sqlite3_vtab *) p));
    } 
    else if (pTokenizer) {
      pTokenizer->pModule->xDestroy(pTokenizer);
    } 
  }  
  else {
    ((void ) 0);
    ((*ppVTab) = (&p->base));
  }
  return rc;
}
static  int fts3ConnectMethod(sqlite3 *db , void *pAux , int argc , const  char *const *argv , sqlite3_vtab **ppVtab , char **pzErr )  {
  return fts3InitVtab(0, db, pAux, argc, argv, ppVtab, pzErr);
}
static  int fts3CreateMethod(sqlite3 *db , void *pAux , int argc , const  char *const *argv , sqlite3_vtab **ppVtab , char **pzErr )  {
  return fts3InitVtab(1, db, pAux, argc, argv, ppVtab, pzErr);
}
static  int fts3BestIndexMethod(sqlite3_vtab *pVTab , sqlite3_index_info *pInfo )  {
  _1273_Fts3Table *p =  ((_1273_Fts3Table *) pVTab);
  int i;
  int iCons =  (- 1);
  int iLangidCons =  (- 1);
  int iDocidGe =  (- 1);
  int iDocidLe =  (- 1);
  int iIdx;
  (pInfo->idxNum = 0);
  (pInfo->estimatedCost = 5000000);
  for ((i = 0); (i < pInfo->nConstraint); i++) {
    int bDocid;
    struct  sqlite3_index_constraint   *pCons =  (&pInfo->aConstraint[i]);
    if ((pCons->usable == 0)) {
      continue;
    }  
    (bDocid = ((pCons->iColumn < 0) || (pCons->iColumn == (p->nColumn + 1))));
    if (((iCons < 0) && (pCons->op == 2) && bDocid)) {
      (pInfo->idxNum = 1);
      (pInfo->estimatedCost = 1.0);
      (iCons = i);
    }  
    if (((pCons->op == 64) && (pCons->iColumn >= 0) && (pCons->iColumn <= p->nColumn))) {
      (pInfo->idxNum = (2 + pCons->iColumn));
      (pInfo->estimatedCost = 2.0);
      (iCons = i);
    }  
    if (((pCons->op == 2) && (pCons->iColumn == (p->nColumn + 2)))) {
      (iLangidCons = i);
    }  
    if (bDocid) {
      switch (pCons->op) {
        case 32:
        case 4:
        (iDocidGe = i);
        break;
        case 8:
        case 16:
        (iDocidLe = i);
        break;
      }
    }  
  }
  (iIdx = 1);
  if ((iCons >= 0)) {
    (pInfo->aConstraintUsage[iCons].argvIndex = iIdx++);
    (pInfo->aConstraintUsage[iCons].omit = 1);
  }  
  if ((iLangidCons >= 0)) {
    (pInfo->idxNum |= 0x00010000);
    (pInfo->aConstraintUsage[iLangidCons].argvIndex = iIdx++);
  }  
  if ((iDocidGe >= 0)) {
    (pInfo->idxNum |= 0x00020000);
    (pInfo->aConstraintUsage[iDocidGe].argvIndex = iIdx++);
  }  
  if ((iDocidLe >= 0)) {
    (pInfo->idxNum |= 0x00040000);
    (pInfo->aConstraintUsage[iDocidLe].argvIndex = iIdx++);
  }  
  if ((pInfo->nOrderBy == 1)) {
    struct  sqlite3_index_orderby   *pOrder =  (&pInfo->aOrderBy[0]);
    if (((pOrder->iColumn < 0) || (pOrder->iColumn == (p->nColumn + 1)))) {
      if (pOrder->desc) {
        (pInfo->idxStr = "DESC");
      }  
      else {
        (pInfo->idxStr = "ASC");
      }
      (pInfo->orderByConsumed = 1);
    }  
  }  
  ((void ) 0);
  return 0;
}
static  int fts3OpenMethod(sqlite3_vtab *pVTab , sqlite3_vtab_cursor **ppCsr )  {
  sqlite3_vtab_cursor *pCsr;
  ((void ) pVTab);
  ((*ppCsr) = (pCsr = ((sqlite3_vtab_cursor *) sqlite3_malloc(sizeof(_1273_Fts3Cursor )))));
  if ((! pCsr)) {
    return 7;
  }  
  memset(pCsr, 0, sizeof(_1273_Fts3Cursor ));
  return 0;
}
static  int fts3CloseMethod(sqlite3_vtab_cursor *pCursor )  {
  _1273_Fts3Cursor *pCsr =  ((_1273_Fts3Cursor *) pCursor);
  ((void ) 0);
  sqlite3_finalize(pCsr->pStmt);
  sqlite3Fts3ExprFree(pCsr->pExpr);
  sqlite3Fts3FreeDeferredTokens(pCsr);
  sqlite3_free(pCsr->aDoclist);
  sqlite3_free(pCsr->aMatchinfo);
  ((void ) 0);
  sqlite3_free(pCsr);
  return 0;
}
static  int fts3CursorSeekStmt(_1273_Fts3Cursor *pCsr , sqlite3_stmt **ppStmt )  {
  int rc =  0;
  if ((pCsr->pStmt == 0)) {
    _1273_Fts3Table *p =  ((_1273_Fts3Table *) pCsr->base.pVtab);
    char *zSql;
    (zSql = sqlite3_mprintf("SELECT %s WHERE rowid = ?", p->zReadExprlist));
    if ((! zSql)) {
      return 7;
    }  
    (rc = sqlite3_prepare_v2(p->db, zSql, (- 1), (&pCsr->pStmt), 0));
    sqlite3_free(zSql);
  }  
  ((*ppStmt) = pCsr->pStmt);
  return rc;
}
static  int fts3CursorSeek(sqlite3_context *pContext , _1273_Fts3Cursor *pCsr )  {
  int rc =  0;
  if (pCsr->isRequireSeek) {
    sqlite3_stmt *pStmt =  0;
    (rc = fts3CursorSeekStmt(pCsr, (&pStmt)));
    if ((rc == 0)) {
      sqlite3_bind_int64(pCsr->pStmt, 1, pCsr->iPrevId);
      (pCsr->isRequireSeek = 0);
      if ((100 == sqlite3_step(pCsr->pStmt))) {
        return 0;
      }  
      else {
        (rc = sqlite3_reset(pCsr->pStmt));
        if (((rc == 0) && (((_1273_Fts3Table *) pCsr->base.pVtab)->zContentTbl == 0))) {
          (rc = (11 | (1 << 8)));
          (pCsr->isEof = 1);
        }  
      }
    }  
  }  
  if (((rc != 0) && pContext)) {
    sqlite3_result_error_code(pContext, rc);
  }  
  return rc;
}
static  int fts3ScanInteriorNode(const  char *zTerm , int nTerm , const  char *zNode , int nNode , sqlite3_int64 *piFirst , sqlite3_int64 *piLast )  {
  int rc =  0;
  const char *zCsr =  zNode;
  const char *zEnd =  (&zCsr[nNode]);
  char *zBuffer =  0;
  int nAlloc =  0;
  int isFirstTerm =  1;
  sqlite3_int64 iChild;
  (zCsr += sqlite3Fts3GetVarint(zCsr, (&iChild)));
  (zCsr += sqlite3Fts3GetVarint(zCsr, (&iChild)));
  if ((zCsr > zEnd)) {
    return (11 | (1 << 8));
  }  
  while (((zCsr < zEnd) && (piFirst || piLast))) {
    int cmp;
    int nSuffix;
    int nPrefix =  0;
    int nBuffer;
    if ((! isFirstTerm)) {
      (zCsr += sqlite3Fts3GetVarint32(zCsr, (&nPrefix)));
    }  
    (isFirstTerm = 0);
    (zCsr += sqlite3Fts3GetVarint32(zCsr, (&nSuffix)));
    if (((nPrefix < 0) || (nSuffix < 0) || ((&zCsr[nSuffix]) > zEnd))) {
      (rc = (11 | (1 << 8)));
      goto _1273_finish_scan;
    }  
    if (((nPrefix + nSuffix) > nAlloc)) {
      char *zNew;
      (nAlloc = ((nPrefix + nSuffix) * 2));
      (zNew = ((char *) sqlite3_realloc(zBuffer, nAlloc)));
      if ((! zNew)) {
        (rc = 7);
        goto _1273_finish_scan;
      }  
      (zBuffer = zNew);
    }  
    ((void ) 0);
    memcpy((&zBuffer[nPrefix]), zCsr, nSuffix);
    (nBuffer = (nPrefix + nSuffix));
    (zCsr += nSuffix);
    (cmp = memcmp(zTerm, zBuffer, ((nBuffer > nTerm) ? nTerm : nBuffer)));
    if ((piFirst && ((cmp < 0) || ((cmp == 0) && (nBuffer > nTerm))))) {
      ((*piFirst) = iChild);
      (piFirst = 0);
    }  
    if ((piLast && (cmp < 0))) {
      ((*piLast) = iChild);
      (piLast = 0);
    }  
    iChild++;
  }
  if (piFirst) {
    ((*piFirst) = iChild);
  }  
  if (piLast) {
    ((*piLast) = iChild);
  }  
  _1273_finish_scan:
  sqlite3_free(zBuffer);
  return rc;
}
static  int fts3SelectLeaf(_1273_Fts3Table *p , const  char *zTerm , int nTerm , const  char *zNode , int nNode , sqlite3_int64 *piLeaf , sqlite3_int64 *piLeaf2 )  {
  int rc;
  int iHeight;
  ((void ) 0);
  sqlite3Fts3GetVarint32(zNode, (&iHeight));
  (rc = fts3ScanInteriorNode(zTerm, nTerm, zNode, nNode, piLeaf, piLeaf2));
  ((void ) 0);
  if (((rc == 0) && (iHeight > 1))) {
    char *zBlob =  0;
    int nBlob;
    if ((piLeaf && piLeaf2 && ((*piLeaf) != (*piLeaf2)))) {
      (rc = sqlite3Fts3ReadBlock(p, (*piLeaf), (&zBlob), (&nBlob), 0));
      if ((rc == 0)) {
        (rc = fts3SelectLeaf(p, zTerm, nTerm, zBlob, nBlob, piLeaf, 0));
      }  
      sqlite3_free(zBlob);
      (piLeaf = 0);
      (zBlob = 0);
    }  
    if ((rc == 0)) {
      (rc = sqlite3Fts3ReadBlock(p, (piLeaf ? (*piLeaf) : (*piLeaf2)), (&zBlob), (&nBlob), 0));
    }  
    if ((rc == 0)) {
      (rc = fts3SelectLeaf(p, zTerm, nTerm, zBlob, nBlob, piLeaf, piLeaf2));
    }  
    sqlite3_free(zBlob);
  }  
  return rc;
}
static  void fts3PutDeltaVarint(char **pp , sqlite3_int64 *piPrev , sqlite3_int64 iVal )  {
  ((void ) 0);
  ((*pp) += sqlite3Fts3PutVarint((*pp), (iVal - (*piPrev))));
  ((*piPrev) = iVal);
}
static  void fts3PoslistCopy(char **pp , char **ppPoslist )  {
  char *pEnd =  (*ppPoslist);
  char c =  0;
  while (((*pEnd) | c)) {
    (c = ((*pEnd++) & 0x80));
    if (((id2i_sqlite_coverage_test ) )) {
      if (((c != 0) && ((*pEnd) == 0))) {
        sqlite3Coverage(123738);
      }  
    }  
  }
  pEnd++;
  if (pp) {
    int n =  ((int ) (pEnd - (*ppPoslist)));
    char *p =  (*pp);
    memcpy(p, (*ppPoslist), n);
    (p += n);
    ((*pp) = p);
  }  
  ((*ppPoslist) = pEnd);
}
static  void fts3ColumnlistCopy(char **pp , char **ppPoslist )  {
  char *pEnd =  (*ppPoslist);
  char c =  0;
  while ((0xFE & ((*pEnd) | c))) {
    (c = ((*pEnd++) & 0x80));
    if (((id2i_sqlite_coverage_test ) )) {
      if (((c != 0) && (((*pEnd) & 0xfe) == 0))) {
        sqlite3Coverage(123778);
      }  
    }  
  }
  if (pp) {
    int n =  ((int ) (pEnd - (*ppPoslist)));
    char *p =  (*pp);
    memcpy(p, (*ppPoslist), n);
    (p += n);
    ((*pp) = p);
  }  
  ((*ppPoslist) = pEnd);
}
static  void fts3ReadNextPos(char **pp , sqlite3_int64 *pi )  {
  if (((*(*pp)) & 0xFE)) {
    fts3GetDeltaVarint(pp, pi);
    ((*pi) -= 2);
  }  
  else {
    ((*pi) = 0x7fffffff);
  }
}
static  int fts3PutColNumber(char **pp , int iCol )  {
  int n =  0;
  if (iCol) {
    char *p =  (*pp);
    (n = (1 + sqlite3Fts3PutVarint((&p[1]), iCol)));
    ((*p) = 0x01);
    ((*pp) = (&p[n]));
  }  
  return n;
}
static  void fts3PoslistMerge(char **pp , char **pp1 , char **pp2 )  {
  char *p =  (*pp);
  char *p1 =  (*pp1);
  char *p2 =  (*pp2);
  while (((*p1) || (*p2))) {
    int iCol1;
    int iCol2;
    if (((*p1) == 1)) {
      sqlite3Fts3GetVarint32((&p1[1]), (&iCol1));
    } 
    else if (((*p1) == 0)) {
      (iCol1 = 0x7fffffff);
    } 
    else {
      (iCol1 = 0);
    }
    if (((*p2) == 1)) {
      sqlite3Fts3GetVarint32((&p2[1]), (&iCol2));
    } 
    else if (((*p2) == 0)) {
      (iCol2 = 0x7fffffff);
    } 
    else {
      (iCol2 = 0);
    }
    if ((iCol1 == iCol2)) {
      sqlite3_int64 i1 =  0;
      sqlite3_int64 i2 =  0;
      sqlite3_int64 iPrev =  0;
      int n =  fts3PutColNumber((&p), iCol1);
      (p1 += n);
      (p2 += n);
      fts3GetDeltaVarint((&p1), (&i1));
      fts3GetDeltaVarint((&p2), (&i2));
      do {
        fts3PutDeltaVarint((&p), (&iPrev), ((i1 < i2) ? i1 : i2));
        (iPrev -= 2);
        if ((i1 == i2)) {
          fts3ReadNextPos((&p1), (&i1));
          fts3ReadNextPos((&p2), (&i2));
        } 
        else if ((i1 < i2)) {
          fts3ReadNextPos((&p1), (&i1));
        } 
        else {
          fts3ReadNextPos((&p2), (&i2));
        }
      } while (((i1 != 0x7fffffff) || (i2 != 0x7fffffff)));
    } 
    else if ((iCol1 < iCol2)) {
      (p1 += fts3PutColNumber((&p), iCol1));
      fts3ColumnlistCopy((&p), (&p1));
    } 
    else {
      (p2 += fts3PutColNumber((&p), iCol2));
      fts3ColumnlistCopy((&p), (&p2));
    }
  }
  ((*p++) = 0);
  ((*pp) = p);
  ((*pp1) = (p1 + 1));
  ((*pp2) = (p2 + 1));
}
static  int fts3PoslistPhraseMerge(char **pp , int nToken , int isSaveLeft , int isExact , char **pp1 , char **pp2 )  {
  char *p =  (*pp);
  char *p1 =  (*pp1);
  char *p2 =  (*pp2);
  int iCol1 =  0;
  int iCol2 =  0;
  ((void ) 0);
  ((void ) 0);
  if (((*p1) == 1)) {
    p1++;
    (p1 += sqlite3Fts3GetVarint32(p1, (&iCol1)));
  }  
  if (((*p2) == 1)) {
    p2++;
    (p2 += sqlite3Fts3GetVarint32(p2, (&iCol2)));
  }  
  while (1) {
    if ((iCol1 == iCol2)) {
      char *pSave =  p;
      sqlite3_int64 iPrev =  0;
      sqlite3_int64 iPos1 =  0;
      sqlite3_int64 iPos2 =  0;
      if (iCol1) {
        ((*p++) = 1);
        (p += sqlite3Fts3PutVarint(p, iCol1));
      }  
      ((void ) 0);
      ((void ) 0);
      fts3GetDeltaVarint((&p1), (&iPos1));
      (iPos1 -= 2);
      fts3GetDeltaVarint((&p2), (&iPos2));
      (iPos2 -= 2);
      while (1) {
        if (((iPos2 == (iPos1 + nToken)) || ((isExact == 0) && (iPos2 > iPos1) && (iPos2 <= (iPos1 + nToken))))) {
          sqlite3_int64 iSave;
          (iSave = (isSaveLeft ? iPos1 : iPos2));
          fts3PutDeltaVarint((&p), (&iPrev), (iSave + 2));
          (iPrev -= 2);
          (pSave = 0);
          ((void ) 0);
        }  
        if ((((! isSaveLeft) && (iPos2 <= (iPos1 + nToken))) || (iPos2 <= iPos1))) {
          if ((((*p2) & 0xFE) == 0)) {
            break;
          }  
          fts3GetDeltaVarint((&p2), (&iPos2));
          (iPos2 -= 2);
        }  
        else {
          if ((((*p1) & 0xFE) == 0)) {
            break;
          }  
          fts3GetDeltaVarint((&p1), (&iPos1));
          (iPos1 -= 2);
        }
      }
      if (pSave) {
        ((void ) 0);
        (p = pSave);
      }  
      fts3ColumnlistCopy(0, (&p1));
      fts3ColumnlistCopy(0, (&p2));
      ((void ) 0);
      if (((0 == (*p1)) || (0 == (*p2)))) {
        break;
      }  
      p1++;
      (p1 += sqlite3Fts3GetVarint32(p1, (&iCol1)));
      p2++;
      (p2 += sqlite3Fts3GetVarint32(p2, (&iCol2)));
    } 
    else if ((iCol1 < iCol2)) {
      fts3ColumnlistCopy(0, (&p1));
      if ((0 == (*p1))) {
        break;
      }  
      p1++;
      (p1 += sqlite3Fts3GetVarint32(p1, (&iCol1)));
    } 
    else {
      fts3ColumnlistCopy(0, (&p2));
      if ((0 == (*p2))) {
        break;
      }  
      p2++;
      (p2 += sqlite3Fts3GetVarint32(p2, (&iCol2)));
    }
  }
  fts3PoslistCopy(0, (&p2));
  fts3PoslistCopy(0, (&p1));
  ((*pp1) = p1);
  ((*pp2) = p2);
  if (((*pp) == p)) {
    return 0;
  }  
  ((*p++) = 0x00);
  ((*pp) = p);
  return 1;
}
static  int fts3PoslistNearMerge(char **pp , char *aTmp , int nRight , int nLeft , char **pp1 , char **pp2 )  {
  char *p1 =  (*pp1);
  char *p2 =  (*pp2);
  char *pTmp1 =  aTmp;
  char *pTmp2;
  char *aTmp2;
  int res =  1;
  fts3PoslistPhraseMerge((&pTmp1), nRight, 0, 0, pp1, pp2);
  (aTmp2 = (pTmp2 = pTmp1));
  ((*pp1) = p1);
  ((*pp2) = p2);
  fts3PoslistPhraseMerge((&pTmp2), nLeft, 1, 0, pp2, pp1);
  if (((pTmp1 != aTmp) && (pTmp2 != aTmp2))) {
    fts3PoslistMerge(pp, (&aTmp), (&aTmp2));
  } 
  else if ((pTmp1 != aTmp)) {
    fts3PoslistCopy(pp, (&aTmp));
  }
  
  else if ((pTmp2 != aTmp2)) {
    fts3PoslistCopy(pp, (&aTmp2));
  } 
  else {
    (res = 0);
  }
  return res;
}
typedef struct  _1273_TermSelect   _1273_TermSelect;
struct  _1273_TermSelect {
  char *aaOutput[16] ;
  int anOutput[16] ;
}  ;
static  void fts3GetDeltaVarint3(char **pp , char *pEnd , int bDescIdx , sqlite3_int64 *pVal )  {
  if (((*pp) >= pEnd)) {
    ((*pp) = 0);
  }  
  else {
    sqlite3_int64 iVal;
    ((*pp) += sqlite3Fts3GetVarint((*pp), (&iVal)));
    if (bDescIdx) {
      ((*pVal) -= iVal);
    }  
    else {
      ((*pVal) += iVal);
    }
  }
}
static  void fts3PutDeltaVarint3(char **pp , int bDescIdx , sqlite3_int64 *piPrev , int *pbFirst , sqlite3_int64 iVal )  {
  sqlite3_int64 iWrite;
  if (((bDescIdx == 0) || ((*pbFirst) == 0))) {
    (iWrite = (iVal - (*piPrev)));
  }  
  else {
    (iWrite = ((*piPrev) - iVal));
  }
  ((void ) 0);
  ((void ) 0);
  ((*pp) += sqlite3Fts3PutVarint((*pp), iWrite));
  ((*piPrev) = iVal);
  ((*pbFirst) = 1);
}
static  int fts3DoclistOrMerge(int bDescDoclist , char *a1 , int n1 , char *a2 , int n2 , char **paOut , int *pnOut )  {
  sqlite3_int64 i1 =  0;
  sqlite3_int64 i2 =  0;
  sqlite3_int64 iPrev =  0;
  char *pEnd1 =  (&a1[n1]);
  char *pEnd2 =  (&a2[n2]);
  char *p1 =  a1;
  char *p2 =  a2;
  char *p;
  char *aOut;
  int bFirstOut =  0;
  ((*paOut) = 0);
  ((*pnOut) = 0);
  (aOut = sqlite3_malloc((n1 + n2 + 10 - 1)));
  if ((! aOut)) {
    return 7;
  }  
  (p = aOut);
  fts3GetDeltaVarint3((&p1), pEnd1, 0, (&i1));
  fts3GetDeltaVarint3((&p2), pEnd2, 0, (&i2));
  while ((p1 || p2)) {
    sqlite3_int64 iDiff =  ((bDescDoclist ? (- 1) : 1) * (i1 - i2));
    if ((p2 && p1 && (iDiff == 0))) {
      fts3PutDeltaVarint3((&p), bDescDoclist, (&iPrev), (&bFirstOut), i1);
      fts3PoslistMerge((&p), (&p1), (&p2));
      fts3GetDeltaVarint3((&p1), pEnd1, bDescDoclist, (&i1));
      fts3GetDeltaVarint3((&p2), pEnd2, bDescDoclist, (&i2));
    } 
    else if (((! p2) || (p1 && (iDiff < 0)))) {
      fts3PutDeltaVarint3((&p), bDescDoclist, (&iPrev), (&bFirstOut), i1);
      fts3PoslistCopy((&p), (&p1));
      fts3GetDeltaVarint3((&p1), pEnd1, bDescDoclist, (&i1));
    } 
    else {
      fts3PutDeltaVarint3((&p), bDescDoclist, (&iPrev), (&bFirstOut), i2);
      fts3PoslistCopy((&p), (&p2));
      fts3GetDeltaVarint3((&p2), pEnd2, bDescDoclist, (&i2));
    }
  }
  ((*paOut) = aOut);
  ((*pnOut) = ((int ) (p - aOut)));
  ((void ) 0);
  return 0;
}
static  void fts3DoclistPhraseMerge(int bDescDoclist , int nDist , char *aLeft , int nLeft , char *aRight , int *pnRight )  {
  sqlite3_int64 i1 =  0;
  sqlite3_int64 i2 =  0;
  sqlite3_int64 iPrev =  0;
  char *pEnd1 =  (&aLeft[nLeft]);
  char *pEnd2 =  (&aRight[(*pnRight)]);
  char *p1 =  aLeft;
  char *p2 =  aRight;
  char *p;
  int bFirstOut =  0;
  char *aOut =  aRight;
  ((void ) 0);
  (p = aOut);
  fts3GetDeltaVarint3((&p1), pEnd1, 0, (&i1));
  fts3GetDeltaVarint3((&p2), pEnd2, 0, (&i2));
  while ((p1 && p2)) {
    sqlite3_int64 iDiff =  ((bDescDoclist ? (- 1) : 1) * (i1 - i2));
    if ((iDiff == 0)) {
      char *pSave =  p;
      sqlite3_int64 iPrevSave =  iPrev;
      int bFirstOutSave =  bFirstOut;
      fts3PutDeltaVarint3((&p), bDescDoclist, (&iPrev), (&bFirstOut), i1);
      if ((0 == fts3PoslistPhraseMerge((&p), nDist, 0, 1, (&p1), (&p2)))) {
        (p = pSave);
        (iPrev = iPrevSave);
        (bFirstOut = bFirstOutSave);
      }  
      fts3GetDeltaVarint3((&p1), pEnd1, bDescDoclist, (&i1));
      fts3GetDeltaVarint3((&p2), pEnd2, bDescDoclist, (&i2));
    } 
    else if ((iDiff < 0)) {
      fts3PoslistCopy(0, (&p1));
      fts3GetDeltaVarint3((&p1), pEnd1, bDescDoclist, (&i1));
    } 
    else {
      fts3PoslistCopy(0, (&p2));
      fts3GetDeltaVarint3((&p2), pEnd2, bDescDoclist, (&i2));
    }
  }
  ((*pnRight) = ((int ) (p - aOut)));
}
static  int sqlite3Fts3FirstFilter(sqlite3_int64 iDelta , char *pList , int nList , char *pOut )  {
  int nOut =  0;
  int bWritten =  0;
  char *p =  pList;
  char *pEnd =  (&pList[nList]);
  if (((*p) != 0x01)) {
    if (((*p) == 0x02)) {
      (nOut += sqlite3Fts3PutVarint((&pOut[nOut]), iDelta));
      (pOut[nOut++] = 0x02);
      (bWritten = 1);
    }  
    fts3ColumnlistCopy(0, (&p));
  }  
  while (((p < pEnd) && ((*p) == 0x01))) {
    sqlite3_int64 iCol;
    p++;
    (p += sqlite3Fts3GetVarint(p, (&iCol)));
    if (((*p) == 0x02)) {
      if ((bWritten == 0)) {
        (nOut += sqlite3Fts3PutVarint((&pOut[nOut]), iDelta));
        (bWritten = 1);
      }  
      (pOut[nOut++] = 0x01);
      (nOut += sqlite3Fts3PutVarint((&pOut[nOut]), iCol));
      (pOut[nOut++] = 0x02);
    }  
    fts3ColumnlistCopy(0, (&p));
  }
  if (bWritten) {
    (pOut[nOut++] = 0x00);
  }  
  return nOut;
}
static  int fts3TermSelectFinishMerge(_1273_Fts3Table *p , _1273_TermSelect *pTS )  {
  char *aOut =  0;
  int nOut =  0;
  int i;
  for ((i = 0); (i < ((int ) (sizeof(pTS->aaOutput) / sizeof(pTS->aaOutput[0])))); i++) {
    if (pTS->aaOutput[i]) {
      if ((! aOut)) {
        (aOut = pTS->aaOutput[i]);
        (nOut = pTS->anOutput[i]);
        (pTS->aaOutput[i] = 0);
      }  
      else {
        int nNew;
        char *aNew;
        int rc =  fts3DoclistOrMerge(p->bDescIdx, pTS->aaOutput[i], pTS->anOutput[i], aOut, nOut, (&aNew), (&nNew));
        if ((rc != 0)) {
          sqlite3_free(aOut);
          return rc;
        }  
        sqlite3_free(pTS->aaOutput[i]);
        sqlite3_free(aOut);
        (pTS->aaOutput[i] = 0);
        (aOut = aNew);
        (nOut = nNew);
      }
    }  
  }
  (pTS->aaOutput[0] = aOut);
  (pTS->anOutput[0] = nOut);
  return 0;
}
static  int fts3TermSelectMerge(_1273_Fts3Table *p , _1273_TermSelect *pTS , char *aDoclist , int nDoclist )  {
  if ((pTS->aaOutput[0] == 0)) {
    (pTS->aaOutput[0] = sqlite3_malloc(nDoclist));
    (pTS->anOutput[0] = nDoclist);
    if (pTS->aaOutput[0]) {
      memcpy(pTS->aaOutput[0], aDoclist, nDoclist);
    }  
    else {
      return 7;
    }
  }  
  else {
    char *aMerge =  aDoclist;
    int nMerge =  nDoclist;
    int iOut;
    for ((iOut = 0); (iOut < ((int ) (sizeof(pTS->aaOutput) / sizeof(pTS->aaOutput[0])))); iOut++) {
      if ((pTS->aaOutput[iOut] == 0)) {
        ((void ) 0);
        (pTS->aaOutput[iOut] = aMerge);
        (pTS->anOutput[iOut] = nMerge);
        break;
      }  
      else {
        char *aNew;
        int nNew;
        int rc =  fts3DoclistOrMerge(p->bDescIdx, aMerge, nMerge, pTS->aaOutput[iOut], pTS->anOutput[iOut], (&aNew), (&nNew));
        if ((rc != 0)) {
          if ((aMerge != aDoclist)) {
            sqlite3_free(aMerge);
          }  
          return rc;
        }  
        if ((aMerge != aDoclist)) {
          sqlite3_free(aMerge);
        }  
        sqlite3_free(pTS->aaOutput[iOut]);
        (pTS->aaOutput[iOut] = 0);
        (aMerge = aNew);
        (nMerge = nNew);
        if (((iOut + 1) == ((int ) (sizeof(pTS->aaOutput) / sizeof(pTS->aaOutput[0]))))) {
          (pTS->aaOutput[iOut] = aMerge);
          (pTS->anOutput[iOut] = nMerge);
        }  
      }
    }
  }
  return 0;
}
static  int fts3SegReaderCursorAppend(_1273_Fts3MultiSegReader *pCsr , _1273_Fts3SegReader *pNew )  {
  if (((pCsr->nSegment % 16) == 0)) {
    _1273_Fts3SegReader **apNew;
    int nByte =  ((pCsr->nSegment + 16) * sizeof(_1273_Fts3SegReader *));
    (apNew = ((_1273_Fts3SegReader **) sqlite3_realloc(pCsr->apSegment, nByte)));
    if ((! apNew)) {
      sqlite3Fts3SegReaderFree(pNew);
      return 7;
    }  
    (pCsr->apSegment = apNew);
  }  
  (pCsr->apSegment[pCsr->nSegment++] = pNew);
  return 0;
}
static  int fts3SegReaderCursor(_1273_Fts3Table *p , int iLangid , int iIndex , int iLevel , const  char *zTerm , int nTerm , int isPrefix , int isScan , _1273_Fts3MultiSegReader *pCsr )  {
  int rc =  0;
  sqlite3_stmt *pStmt =  0;
  int rc2;
  if (((iLevel < 0) && p->aIndex)) {
    _1273_Fts3SegReader *pSeg =  0;
    (rc = sqlite3Fts3SegReaderPending(p, iIndex, zTerm, nTerm, isPrefix, (&pSeg)));
    if (((rc == 0) && pSeg)) {
      (rc = fts3SegReaderCursorAppend(pCsr, pSeg));
    }  
  }  
  if ((iLevel != (- 1))) {
    if ((rc == 0)) {
      (rc = sqlite3Fts3AllSegdirs(p, iLangid, iIndex, iLevel, (&pStmt)));
    }  
    while (((rc == 0) && (100 == (rc = sqlite3_step(pStmt))))) {
      _1273_Fts3SegReader *pSeg =  0;
      sqlite3_int64 iStartBlock =  sqlite3_column_int64(pStmt, 1);
      sqlite3_int64 iLeavesEndBlock =  sqlite3_column_int64(pStmt, 2);
      sqlite3_int64 iEndBlock =  sqlite3_column_int64(pStmt, 3);
      int nRoot =  sqlite3_column_bytes(pStmt, 4);
      char const *zRoot =  sqlite3_column_blob(pStmt, 4);
      if ((iStartBlock && zTerm)) {
        sqlite3_int64 *pi =  (isPrefix ? (&iLeavesEndBlock) : 0);
        (rc = fts3SelectLeaf(p, zTerm, nTerm, zRoot, nRoot, (&iStartBlock), pi));
        if ((rc != 0)) {
          goto _1273_finished;
        }  
        if (((isPrefix == 0) && (isScan == 0))) {
          (iLeavesEndBlock = iStartBlock);
        }  
      }  
      (rc = sqlite3Fts3SegReaderNew((pCsr->nSegment + 1), ((isPrefix == 0) && (isScan == 0)), iStartBlock, iLeavesEndBlock, iEndBlock, zRoot, nRoot, (&pSeg)));
      if ((rc != 0)) {
        goto _1273_finished;
      }  
      (rc = fts3SegReaderCursorAppend(pCsr, pSeg));
    }
  }  
  _1273_finished:
  (rc2 = sqlite3_reset(pStmt));
  if ((rc == 101)) {
    (rc = rc2);
  }  
  return rc;
}
static  int sqlite3Fts3SegReaderCursor(_1273_Fts3Table *p , int iLangid , int iIndex , int iLevel , const  char *zTerm , int nTerm , int isPrefix , int isScan , _1273_Fts3MultiSegReader *pCsr )  {
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  memset(pCsr, 0, sizeof(_1273_Fts3MultiSegReader ));
  return fts3SegReaderCursor(p, iLangid, iIndex, iLevel, zTerm, nTerm, isPrefix, isScan, pCsr);
}
static  int fts3SegReaderCursorAddZero(_1273_Fts3Table *p , int iLangid , const  char *zTerm , int nTerm , _1273_Fts3MultiSegReader *pCsr )  {
  return fts3SegReaderCursor(p, iLangid, 0, (- 2), zTerm, nTerm, 0, 0, pCsr);
}
static  int fts3TermSegReaderCursor(_1273_Fts3Cursor *pCsr , const  char *zTerm , int nTerm , int isPrefix , _1273_Fts3MultiSegReader **ppSegcsr )  {
  _1273_Fts3MultiSegReader *pSegcsr;
  int rc =  7;
  (pSegcsr = sqlite3_malloc(sizeof(_1273_Fts3MultiSegReader )));
  if (pSegcsr) {
    int i;
    int bFound =  0;
    _1273_Fts3Table *p =  ((_1273_Fts3Table *) pCsr->base.pVtab);
    if (isPrefix) {
      for ((i = 1); ((bFound == 0) && (i < p->nIndex)); i++) {
        if ((p->aIndex[i].nPrefix == nTerm)) {
          (bFound = 1);
          (rc = sqlite3Fts3SegReaderCursor(p, pCsr->iLangid, i, (- 2), zTerm, nTerm, 0, 0, pSegcsr));
          (pSegcsr->bLookup = 1);
        }  
      }
      for ((i = 1); ((bFound == 0) && (i < p->nIndex)); i++) {
        if ((p->aIndex[i].nPrefix == (nTerm + 1))) {
          (bFound = 1);
          (rc = sqlite3Fts3SegReaderCursor(p, pCsr->iLangid, i, (- 2), zTerm, nTerm, 1, 0, pSegcsr));
          if ((rc == 0)) {
            (rc = fts3SegReaderCursorAddZero(p, pCsr->iLangid, zTerm, nTerm, pSegcsr));
          }  
        }  
      }
    }  
    if ((bFound == 0)) {
      (rc = sqlite3Fts3SegReaderCursor(p, pCsr->iLangid, 0, (- 2), zTerm, nTerm, isPrefix, 0, pSegcsr));
      (pSegcsr->bLookup = (! isPrefix));
    }  
  }  
  ((*ppSegcsr) = pSegcsr);
  return rc;
}
static  void fts3SegReaderCursorFree(_1273_Fts3MultiSegReader *pSegcsr )  {
  sqlite3Fts3SegReaderFinish(pSegcsr);
  sqlite3_free(pSegcsr);
}
static  int fts3TermSelect(_1273_Fts3Table *p , _1273_Fts3PhraseToken *pTok , int iColumn , int *pnOut , char **ppOut )  {
  int rc;
  _1273_Fts3MultiSegReader *pSegcsr;
  _1273_TermSelect tsc;
  _1273_Fts3SegFilter filter;
  (pSegcsr = pTok->pSegcsr);
  memset((&tsc), 0, sizeof(_1273_TermSelect ));
  (filter.flags = (0x00000002 | 0x00000001 | (pTok->isPrefix ? 0x00000008 : 0) | (pTok->bFirst ? 0x00000020 : 0) | ((iColumn < p->nColumn) ? 0x00000004 : 0)));
  (filter.iCol = iColumn);
  (filter.zTerm = pTok->z);
  (filter.nTerm = pTok->n);
  (rc = sqlite3Fts3SegReaderStart(p, pSegcsr, (&filter)));
  while (((0 == rc) && (100 == (rc = sqlite3Fts3SegReaderStep(p, pSegcsr))))) {
    (rc = fts3TermSelectMerge(p, (&tsc), pSegcsr->aDoclist, pSegcsr->nDoclist));
  }
  if ((rc == 0)) {
    (rc = fts3TermSelectFinishMerge(p, (&tsc)));
  }  
  if ((rc == 0)) {
    ((*ppOut) = tsc.aaOutput[0]);
    ((*pnOut) = tsc.anOutput[0]);
  }  
  else {
    int i;
    for ((i = 0); (i < ((int ) (sizeof(tsc.aaOutput) / sizeof(tsc.aaOutput[0])))); i++) {
      sqlite3_free(tsc.aaOutput[i]);
    }
  }
  fts3SegReaderCursorFree(pSegcsr);
  (pTok->pSegcsr = 0);
  return rc;
}
static  int fts3DoclistCountDocids(char *aList , int nList )  {
  int nDoc =  0;
  if (aList) {
    char *aEnd =  (&aList[nList]);
    char *p =  aList;
    while ((p < aEnd)) {
      nDoc++;
      while (((*p++) & 0x80)) {
        
      }
      fts3PoslistCopy(0, (&p));
    }
  }  
  return nDoc;
}
static  int fts3NextMethod(sqlite3_vtab_cursor *pCursor )  {
  int rc;
  _1273_Fts3Cursor *pCsr =  ((_1273_Fts3Cursor *) pCursor);
  if (((pCsr->eSearch == 1) || (pCsr->eSearch == 0))) {
    if ((100 != sqlite3_step(pCsr->pStmt))) {
      (pCsr->isEof = 1);
      (rc = sqlite3_reset(pCsr->pStmt));
    }  
    else {
      (pCsr->iPrevId = sqlite3_column_int64(pCsr->pStmt, 0));
      (rc = 0);
    }
  }  
  else {
    (rc = fts3EvalNext(((_1273_Fts3Cursor *) pCursor)));
  }
  ((void ) 0);
  return rc;
}
static  sqlite3_int64 fts3DocidRange(sqlite3_value *pVal , i64 iDefault )  {
  if (pVal) {
    int eType =  sqlite3_value_numeric_type(pVal);
    if ((eType == 1)) {
      return sqlite3_value_int64(pVal);
    }  
  }  
  return iDefault;
}
static  int fts3FilterMethod(sqlite3_vtab_cursor *pCursor , int idxNum , const  char *idxStr , int nVal , sqlite3_value **apVal )  {
  int rc;
  char *zSql;
  int eSearch;
  _1273_Fts3Table *p =  ((_1273_Fts3Table *) pCursor->pVtab);
  _1273_Fts3Cursor *pCsr =  ((_1273_Fts3Cursor *) pCursor);
  sqlite3_value *pCons =  0;
  sqlite3_value *pLangid =  0;
  sqlite3_value *pDocidGe =  0;
  sqlite3_value *pDocidLe =  0;
  int iIdx;
  ((void ) idxStr);
  ((void ) nVal);
  (eSearch = (idxNum & 0x0000FFFF));
  ((void ) 0);
  ((void ) 0);
  (iIdx = 0);
  if ((eSearch != 0)) {
    (pCons = apVal[iIdx++]);
  }  
  if ((idxNum & 0x00010000)) {
    (pLangid = apVal[iIdx++]);
  }  
  if ((idxNum & 0x00020000)) {
    (pDocidGe = apVal[iIdx++]);
  }  
  if ((idxNum & 0x00040000)) {
    (pDocidLe = apVal[iIdx++]);
  }  
  ((void ) 0);
  sqlite3_finalize(pCsr->pStmt);
  sqlite3_free(pCsr->aDoclist);
  sqlite3Fts3ExprFree(pCsr->pExpr);
  memset((&pCursor[1]), 0, (sizeof(_1273_Fts3Cursor ) - sizeof(sqlite3_vtab_cursor )));
  (pCsr->iMinDocid = fts3DocidRange(pDocidGe, (((i64 ) (- 1)) - (0xffffffff | (((i64 ) 0x7fffffff) << 32)))));
  (pCsr->iMaxDocid = fts3DocidRange(pDocidLe, (0xffffffff | (((i64 ) 0x7fffffff) << 32))));
  if (idxStr) {
    (pCsr->bDesc = (idxStr[0] == 'D'));
  }  
  else {
    (pCsr->bDesc = p->bDescIdx);
  }
  (pCsr->eSearch = ((i16 ) eSearch));
  if (((eSearch != 1) && (eSearch != 0))) {
    int iCol =  (eSearch - 2);
    const char *zQuery =  ((const  char *) sqlite3_value_text(pCons));
    if (((zQuery == 0) && (sqlite3_value_type(pCons) != 5))) {
      return 7;
    }  
    (pCsr->iLangid = 0);
    if (pLangid) {
      (pCsr->iLangid = sqlite3_value_int(pLangid));
    }  
    ((void ) 0);
    (rc = sqlite3Fts3ExprParse(p->pTokenizer, pCsr->iLangid, p->azColumn, p->bFts4, p->nColumn, iCol, zQuery, (- 1), (&pCsr->pExpr), (&p->base.zErrMsg)));
    if ((rc != 0)) {
      return rc;
    }  
    (rc = fts3EvalStart(pCsr));
    sqlite3Fts3SegmentsClose(p);
    if ((rc != 0)) {
      return rc;
    }  
    (pCsr->pNextId = pCsr->aDoclist);
    (pCsr->iPrevId = 0);
  }  
  if ((eSearch == 0)) {
    (zSql = sqlite3_mprintf("SELECT %s ORDER BY rowid %s", p->zReadExprlist, (pCsr->bDesc ? "DESC" : "ASC")));
    if (zSql) {
      (rc = sqlite3_prepare_v2(p->db, zSql, (- 1), (&pCsr->pStmt), 0));
      sqlite3_free(zSql);
    }  
    else {
      (rc = 7);
    }
  } 
  else if ((eSearch == 1)) {
    (rc = fts3CursorSeekStmt(pCsr, (&pCsr->pStmt)));
    if ((rc == 0)) {
      (rc = sqlite3_bind_value(pCsr->pStmt, 1, pCons));
    }  
  } 
  if ((rc != 0)) {
    return rc;
  }  
  return fts3NextMethod(pCursor);
}
static  int fts3EofMethod(sqlite3_vtab_cursor *pCursor )  {
  return ((_1273_Fts3Cursor *) pCursor)->isEof;
}
static  int fts3RowidMethod(sqlite3_vtab_cursor *pCursor , sqlite_int64 *pRowid )  {
  _1273_Fts3Cursor *pCsr =  ((_1273_Fts3Cursor *) pCursor);
  ((*pRowid) = pCsr->iPrevId);
  return 0;
}
static  int fts3ColumnMethod(sqlite3_vtab_cursor *pCursor , sqlite3_context *pCtx , int iCol )  {
  int rc =  0;
  _1273_Fts3Cursor *pCsr =  ((_1273_Fts3Cursor *) pCursor);
  _1273_Fts3Table *p =  ((_1273_Fts3Table *) pCursor->pVtab);
  ((void ) 0);
  if ((iCol == (p->nColumn + 1))) {
    sqlite3_result_int64(pCtx, pCsr->iPrevId);
  } 
  else if ((iCol == p->nColumn)) {
    sqlite3_result_blob(pCtx, (&pCsr), sizeof(pCsr), ((sqlite3_destructor_type ) (- 1)));
  }
  
  else if (((iCol == (p->nColumn + 2)) && pCsr->pExpr)) {
    sqlite3_result_int64(pCtx, pCsr->iLangid);
  } 
  else {
    (rc = fts3CursorSeek(0, pCsr));
    if ((rc == 0)) {
      if ((iCol == (p->nColumn + 2))) {
        int iLangid =  0;
        if (p->zLanguageid) {
          (iLangid = sqlite3_column_int(pCsr->pStmt, (p->nColumn + 1)));
        }  
        sqlite3_result_int(pCtx, iLangid);
      } 
      else if ((sqlite3_data_count(pCsr->pStmt) > (iCol + 1))) {
        sqlite3_result_value(pCtx, sqlite3_column_value(pCsr->pStmt, (iCol + 1)));
      } 
    }  
  }
  ((void ) 0);
  return rc;
}
static  int fts3UpdateMethod(sqlite3_vtab *pVtab , int nArg , sqlite3_value **apVal , sqlite_int64 *pRowid )  {
  return sqlite3Fts3UpdateMethod(pVtab, nArg, apVal, pRowid);
}
static  int fts3SyncMethod(sqlite3_vtab *pVtab )  {
  const u32 nMinMerge =  64;
  _1273_Fts3Table *p =  ((_1273_Fts3Table *) pVtab);
  int rc =  sqlite3Fts3PendingTermsFlush(p);
  if (((rc == 0) && (p->bAutoincrmerge == 1) && (p->nLeafAdd > (nMinMerge / 16)))) {
    int mxLevel =  0;
    int A;
    (rc = sqlite3Fts3MaxLevel(p, (&mxLevel)));
    ((void ) 0);
    (A = (p->nLeafAdd * mxLevel));
    (A += (A / 2));
    if ((A > ((int ) nMinMerge))) {
      (rc = sqlite3Fts3Incrmerge(p, A, 8));
    }  
  }  
  sqlite3Fts3SegmentsClose(p);
  return rc;
}
static  int fts3BeginMethod(sqlite3_vtab *pVtab )  {
  _1273_Fts3Table *p =  ((_1273_Fts3Table *) pVtab);
  ((void ) pVtab);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    (p->_1366_inTransaction = 1);
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    (p->_1366_mxSavepoint = (- 1));
  }  
  (p->nLeafAdd = 0);
  return 0;
}
static  int fts3CommitMethod(sqlite3_vtab *pVtab )  {
  _1273_Fts3Table *_1366_p =  ((_1273_Fts3Table *) pVtab);
  ((void ) pVtab);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    (_1366_p->_1366_inTransaction = 0);
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    (_1366_p->_1366_mxSavepoint = (- 1));
  }  
  return 0;
}
static  int fts3RollbackMethod(sqlite3_vtab *pVtab )  {
  _1273_Fts3Table *p =  ((_1273_Fts3Table *) pVtab);
  sqlite3Fts3PendingTermsClear(p);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    (p->_1366_inTransaction = 0);
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    (p->_1366_mxSavepoint = (- 1));
  }  
  return 0;
}
static  void fts3ReversePoslist(char *pStart , char **ppPoslist )  {
  char *p =  (&(*ppPoslist)[(- 2)]);
  char c =  0;
  while (((p > pStart) && ((c = (*p--)) == 0))) {
    
  }
  while (((p > pStart) && (((*p) & 0x80) | c))) {
    (c = (*p--));
  }
  if ((p > pStart)) {
    (p = (&p[2]));
  }  
  while (((*p++) & 0x80)) {
    
  }
  ((*ppPoslist) = p);
}
static  int fts3FunctionArg(sqlite3_context *pContext , const  char *zFunc , sqlite3_value *pVal , _1273_Fts3Cursor **ppCsr )  {
  _1273_Fts3Cursor *pRet;
  if (((sqlite3_value_type(pVal) != 4) || (sqlite3_value_bytes(pVal) != sizeof(_1273_Fts3Cursor *)))) {
    char *zErr =  sqlite3_mprintf("illegal first argument to %s", zFunc);
    sqlite3_result_error(pContext, zErr, (- 1));
    sqlite3_free(zErr);
    return 1;
  }  
  memcpy((&pRet), sqlite3_value_blob(pVal), sizeof(_1273_Fts3Cursor *));
  ((*ppCsr) = pRet);
  return 0;
}
static  void fts3SnippetFunc(sqlite3_context *pContext , int nVal , sqlite3_value **apVal )  {
  _1273_Fts3Cursor *pCsr;
  const char *zStart =  "<b>";
  const char *zEnd =  "</b>";
  const char *zEllipsis =  "<b>...</b>";
  int iCol =  (- 1);
  int nToken =  15;
  ((void ) 0);
  if ((nVal > 6)) {
    sqlite3_result_error(pContext, "wrong number of arguments to function snippet()", (- 1));
    return;
  }  
  if (fts3FunctionArg(pContext, "snippet", apVal[0], (&pCsr))) {
    return;
  }  
  switch (nVal) {
    case 6:
    (nToken = sqlite3_value_int(apVal[5]));
    case 5:
    (iCol = sqlite3_value_int(apVal[4]));
    case 4:
    (zEllipsis = ((const  char *) sqlite3_value_text(apVal[3])));
    case 3:
    (zEnd = ((const  char *) sqlite3_value_text(apVal[2])));
    case 2:
    (zStart = ((const  char *) sqlite3_value_text(apVal[1])));
  }
  if (((! zEllipsis) || (! zEnd) || (! zStart))) {
    sqlite3_result_error_nomem(pContext);
  } 
  else if ((0 == fts3CursorSeek(pContext, pCsr))) {
    sqlite3Fts3Snippet(pContext, pCsr, zStart, zEnd, zEllipsis, iCol, nToken);
  } 
}
static  void fts3OffsetsFunc(sqlite3_context *pContext , int nVal , sqlite3_value **apVal )  {
  _1273_Fts3Cursor *pCsr;
  ((void ) nVal);
  ((void ) 0);
  if (fts3FunctionArg(pContext, "offsets", apVal[0], (&pCsr))) {
    return;
  }  
  ((void ) 0);
  if ((0 == fts3CursorSeek(pContext, pCsr))) {
    sqlite3Fts3Offsets(pContext, pCsr);
  }  
}
static  void fts3OptimizeFunc(sqlite3_context *pContext , int nVal , sqlite3_value **apVal )  {
  int rc;
  _1273_Fts3Table *p;
  _1273_Fts3Cursor *pCursor;
  ((void ) nVal);
  ((void ) 0);
  if (fts3FunctionArg(pContext, "optimize", apVal[0], (&pCursor))) {
    return;
  }  
  (p = ((_1273_Fts3Table *) pCursor->base.pVtab));
  ((void ) 0);
  (rc = sqlite3Fts3Optimize(p));
  switch (rc) {
    case 0:
    sqlite3_result_text(pContext, "Index optimized", (- 1), ((sqlite3_destructor_type ) 0));
    break;
    case 101:
    sqlite3_result_text(pContext, "Index already optimal", (- 1), ((sqlite3_destructor_type ) 0));
    break;
    id2i_label_1:
    default:
    sqlite3_result_error_code(pContext, rc);
    break;
  }
}
static  void fts3MatchinfoFunc(sqlite3_context *pContext , int nVal , sqlite3_value **apVal )  {
  _1273_Fts3Cursor *pCsr;
  ((void ) 0);
  if ((0 == fts3FunctionArg(pContext, "matchinfo", apVal[0], (&pCsr)))) {
    const char *zArg =  0;
    if ((nVal > 1)) {
      (zArg = ((const  char *) sqlite3_value_text(apVal[1])));
    }  
    sqlite3Fts3Matchinfo(pContext, pCsr, zArg);
  }  
}
static  int fts3FindFunctionMethod(sqlite3_vtab *pVtab , int nArg , const  char *zName , void ( **pxFunc)(sqlite3_context * , int , sqlite3_value ** ) , void **ppArg )  {
  struct  Overloaded {
    const  char *zName ;
    void ( *xFunc)(sqlite3_context * , int , sqlite3_value ** ) ;
  }  aOverload[] =  { { "snippet",  fts3SnippetFunc},  { "offsets",  fts3OffsetsFunc},  { "optimize",  fts3OptimizeFunc},  { "matchinfo",  fts3MatchinfoFunc}};
  int i;
  ((void ) pVtab);
  ((void ) nArg);
  ((void ) ppArg);
  for ((i = 0); (i < ((int ) (sizeof(aOverload) / sizeof(aOverload[0])))); i++) {
    if ((strcmp(zName, aOverload[i].zName) == 0)) {
      ((*pxFunc) = aOverload[i].xFunc);
      return 1;
    }  
  }
  return 0;
}
static  int fts3RenameMethod(sqlite3_vtab *pVtab , const  char *zName )  {
  _1273_Fts3Table *p =  ((_1273_Fts3Table *) pVtab);
  sqlite3 *db =  p->db;
  int rc;
  ((void ) 0);
  (rc = sqlite3Fts3PendingTermsFlush(p));
  if ((p->zContentTbl == 0)) {
    fts3DbExec((&rc), db, "ALTER TABLE %Q.'%q_content'  RENAME TO '%q_content';", p->zDb, p->zName, zName);
  }  
  if (p->bHasDocsize) {
    fts3DbExec((&rc), db, "ALTER TABLE %Q.'%q_docsize'  RENAME TO '%q_docsize';", p->zDb, p->zName, zName);
  }  
  if (p->bHasStat) {
    fts3DbExec((&rc), db, "ALTER TABLE %Q.'%q_stat'  RENAME TO '%q_stat';", p->zDb, p->zName, zName);
  }  
  fts3DbExec((&rc), db, "ALTER TABLE %Q.'%q_segments' RENAME TO '%q_segments';", p->zDb, p->zName, zName);
  fts3DbExec((&rc), db, "ALTER TABLE %Q.'%q_segdir'   RENAME TO '%q_segdir';", p->zDb, p->zName, zName);
  return rc;
}
static  int fts3SavepointMethod(sqlite3_vtab *pVtab , int iSavepoint )  {
  int rc =  0;
  ((void ) iSavepoint);
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    (((_1273_Fts3Table *) pVtab)->_1366_mxSavepoint = iSavepoint);
  }  
  if ((((_1273_Fts3Table *) pVtab)->bIgnoreSavepoint == 0)) {
    (rc = fts3SyncMethod(pVtab));
  }  
  return rc;
}
static  int fts3ReleaseMethod(sqlite3_vtab *pVtab , int iSavepoint )  {
  _1273_Fts3Table *_1366_p =  ((_1273_Fts3Table *) pVtab);
  ((void ) iSavepoint);
  ((void ) pVtab);
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    (_1366_p->_1366_mxSavepoint = (iSavepoint - 1));
  }  
  return 0;
}
static  int fts3RollbackToMethod(sqlite3_vtab *pVtab , int iSavepoint )  {
  _1273_Fts3Table *p =  ((_1273_Fts3Table *) pVtab);
  ((void ) iSavepoint);
  ((void ) 0);
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    (p->_1366_mxSavepoint = iSavepoint);
  }  
  sqlite3Fts3PendingTermsClear(p);
  return 0;
}
static const sqlite3_module fts3Module =  { 2,  fts3CreateMethod,  fts3ConnectMethod,  fts3BestIndexMethod,  fts3DisconnectMethod,  fts3DestroyMethod,  fts3OpenMethod,  fts3CloseMethod,  fts3FilterMethod,  fts3NextMethod,  fts3EofMethod,  fts3ColumnMethod,  fts3RowidMethod,  fts3UpdateMethod,  fts3BeginMethod,  fts3SyncMethod,  fts3CommitMethod,  fts3RollbackMethod,  fts3FindFunctionMethod,  fts3RenameMethod,  fts3SavepointMethod,  fts3ReleaseMethod,  fts3RollbackToMethod};
static  void hashDestroy(void *p )  {
  _1273_Fts3Hash *pHash =  ((_1273_Fts3Hash *) p);
  sqlite3Fts3HashClear(pHash);
  sqlite3_free(pHash);
}
static void sqlite3Fts3SimpleTokenizerModule(_1273_sqlite3_tokenizer_module  const **ppModule );
static void sqlite3Fts3PorterTokenizerModule(_1273_sqlite3_tokenizer_module  const **ppModule );
static void sqlite3Fts3UnicodeTokenizer(_1273_sqlite3_tokenizer_module  const **ppModule );
static  int sqlite3Fts3Init(sqlite3 *db )  {
  int rc =  0;
  _1273_Fts3Hash *pHash =  0;
  const _1273_sqlite3_tokenizer_module *pSimple =  0;
  const _1273_sqlite3_tokenizer_module *pPorter =  0;
  const _1273_sqlite3_tokenizer_module *pUnicode =  0;
  if (((id2i_sqlite_enable_fts4_unicode61 ) )) {
    sqlite3Fts3UnicodeTokenizer((&pUnicode));
  }  
  (rc = sqlite3Fts3InitAux(db));
  if ((rc != 0)) {
    return rc;
  }  
  sqlite3Fts3SimpleTokenizerModule((&pSimple));
  sqlite3Fts3PorterTokenizerModule((&pPorter));
  (pHash = sqlite3_malloc(sizeof(_1273_Fts3Hash )));
  if ((! pHash)) {
    (rc = 7);
  }  
  else {
    sqlite3Fts3HashInit(pHash, 1, 1);
  }
  if ((rc == 0)) {
    if ((((! id2i_sqlite_enable_fts4_unicode61) ) )) {
      if ((sqlite3Fts3HashInsert(pHash, "simple", 7, ((void *) pSimple)) || sqlite3Fts3HashInsert(pHash, "porter", 7, ((void *) pPorter)))) {
        (rc = 7);
      }  
    }  
    if (((id2i_sqlite_enable_fts4_unicode61 ) )) {
      if ((sqlite3Fts3HashInsert(pHash, "simple", 7, ((void *) pSimple)) || sqlite3Fts3HashInsert(pHash, "porter", 7, ((void *) pPorter)) || sqlite3Fts3HashInsert(pHash, "unicode61", 10, ((void *) pUnicode)))) {
        (rc = 7);
      }  
    }  
  }  
  if (((0 == rc) && (0 == (rc = sqlite3Fts3InitHashTable(db, pHash, "fts3_tokenizer"))) && (0 == (rc = sqlite3_overload_function(db, "snippet", (- 1)))) && (0 == (rc = sqlite3_overload_function(db, "offsets", 1))) && (0 == (rc = sqlite3_overload_function(db, "matchinfo", 1))) && (0 == (rc = sqlite3_overload_function(db, "matchinfo", 2))) && (0 == (rc = sqlite3_overload_function(db, "optimize", 1))))) {
    (rc = sqlite3_create_module_v2(db, "fts3", (&fts3Module), ((void *) pHash), hashDestroy));
    if ((rc == 0)) {
      (rc = sqlite3_create_module_v2(db, "fts4", (&fts3Module), ((void *) pHash), 0));
    }  
    if ((rc == 0)) {
      (rc = sqlite3Fts3InitTok(db, ((void *) pHash)));
    }  
    return rc;
  }  
  ((void ) 0);
  if (pHash) {
    sqlite3Fts3HashClear(pHash);
    sqlite3_free(pHash);
  }  
  return rc;
}
static  void fts3EvalAllocateReaders(_1273_Fts3Cursor *pCsr , _1273_Fts3Expr *pExpr , int *pnToken , int *pnOr , int *pRc )  {
  if ((pExpr && (0 == (*pRc)))) {
    if ((pExpr->eType == 5)) {
      int i;
      int nToken =  pExpr->pPhrase->nToken;
      ((*pnToken) += nToken);
      for ((i = 0); (i < nToken); i++) {
        _1273_Fts3PhraseToken *pToken =  (&pExpr->pPhrase->aToken[i]);
        int rc =  fts3TermSegReaderCursor(pCsr, pToken->z, pToken->n, pToken->isPrefix, (&pToken->pSegcsr));
        if ((rc != 0)) {
          ((*pRc) = rc);
          return;
        }  
      }
      ((void ) 0);
      (pExpr->pPhrase->iDoclistToken = (- 1));
    }  
    else {
      ((*pnOr) += (pExpr->eType == 4));
      fts3EvalAllocateReaders(pCsr, pExpr->pLeft, pnToken, pnOr, pRc);
      fts3EvalAllocateReaders(pCsr, pExpr->pRight, pnToken, pnOr, pRc);
    }
  }  
}
static  void fts3EvalPhraseMergeToken(_1273_Fts3Table *pTab , _1273_Fts3Phrase *p , int iToken , char *pList , int nList )  {
  ((void ) 0);
  if ((pList == 0)) {
    sqlite3_free(p->doclist.aAll);
    (p->doclist.aAll = 0);
    (p->doclist.nAll = 0);
  } 
  else if ((p->iDoclistToken < 0)) {
    (p->doclist.aAll = pList);
    (p->doclist.nAll = nList);
  }
  
  else if ((p->doclist.aAll == 0)) {
    sqlite3_free(pList);
  } 
  else {
    char *pLeft;
    char *pRight;
    int nLeft;
    int nRight;
    int nDiff;
    if ((p->iDoclistToken < iToken)) {
      (pLeft = p->doclist.aAll);
      (nLeft = p->doclist.nAll);
      (pRight = pList);
      (nRight = nList);
      (nDiff = (iToken - p->iDoclistToken));
    }  
    else {
      (pRight = p->doclist.aAll);
      (nRight = p->doclist.nAll);
      (pLeft = pList);
      (nLeft = nList);
      (nDiff = (p->iDoclistToken - iToken));
    }
    fts3DoclistPhraseMerge(pTab->bDescIdx, nDiff, pLeft, nLeft, pRight, (&nRight));
    sqlite3_free(pLeft);
    (p->doclist.aAll = pRight);
    (p->doclist.nAll = nRight);
  }
  if ((iToken > p->iDoclistToken)) {
    (p->iDoclistToken = iToken);
  }  
}
static  int fts3EvalPhraseLoad(_1273_Fts3Cursor *pCsr , _1273_Fts3Phrase *p )  {
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  int iToken;
  int rc =  0;
  for ((iToken = 0); ((rc == 0) && (iToken < p->nToken)); iToken++) {
    _1273_Fts3PhraseToken *pToken =  (&p->aToken[iToken]);
    ((void ) 0);
    if (pToken->pSegcsr) {
      int nThis =  0;
      char *pThis =  0;
      (rc = fts3TermSelect(pTab, pToken, p->iColumn, (&nThis), (&pThis)));
      if ((rc == 0)) {
        fts3EvalPhraseMergeToken(pTab, p, iToken, pThis, nThis);
      }  
    }  
    ((void ) 0);
  }
  return rc;
}
static  int fts3EvalDeferredPhrase(_1273_Fts3Cursor *pCsr , _1273_Fts3Phrase *pPhrase )  {
  int iToken;
  char *aPoslist =  0;
  int nPoslist =  0;
  int iPrev =  (- 1);
  ((void ) 0);
  for ((iToken = 0); (iToken < pPhrase->nToken); iToken++) {
    _1273_Fts3PhraseToken *pToken =  (&pPhrase->aToken[iToken]);
    _1273_Fts3DeferredToken *pDeferred =  pToken->pDeferred;
    if (pDeferred) {
      char *pList;
      int nList;
      int rc =  sqlite3Fts3DeferredTokenList(pDeferred, (&pList), (&nList));
      if ((rc != 0)) {
        return rc;
      }  
      if ((pList == 0)) {
        sqlite3_free(aPoslist);
        (pPhrase->doclist.pList = 0);
        (pPhrase->doclist.nList = 0);
        return 0;
      } 
      else if ((aPoslist == 0)) {
        (aPoslist = pList);
        (nPoslist = nList);
      } 
      else {
        char *aOut =  pList;
        char *p1 =  aPoslist;
        char *p2 =  aOut;
        ((void ) 0);
        fts3PoslistPhraseMerge((&aOut), (iToken - iPrev), 0, 1, (&p1), (&p2));
        sqlite3_free(aPoslist);
        (aPoslist = pList);
        (nPoslist = ((int ) (aOut - aPoslist)));
        if ((nPoslist == 0)) {
          sqlite3_free(aPoslist);
          (pPhrase->doclist.pList = 0);
          (pPhrase->doclist.nList = 0);
          return 0;
        }  
      }
      (iPrev = iToken);
    }  
  }
  if ((iPrev >= 0)) {
    int nMaxUndeferred =  pPhrase->iDoclistToken;
    if ((nMaxUndeferred < 0)) {
      (pPhrase->doclist.pList = aPoslist);
      (pPhrase->doclist.nList = nPoslist);
      (pPhrase->doclist.iDocid = pCsr->iPrevId);
      (pPhrase->doclist.bFreeList = 1);
    }  
    else {
      int nDistance;
      char *p1;
      char *p2;
      char *aOut;
      if ((nMaxUndeferred > iPrev)) {
        (p1 = aPoslist);
        (p2 = pPhrase->doclist.pList);
        (nDistance = (nMaxUndeferred - iPrev));
      }  
      else {
        (p1 = pPhrase->doclist.pList);
        (p2 = aPoslist);
        (nDistance = (iPrev - nMaxUndeferred));
      }
      (aOut = ((char *) sqlite3_malloc((nPoslist + 8))));
      if ((! aOut)) {
        sqlite3_free(aPoslist);
        return 7;
      }  
      (pPhrase->doclist.pList = aOut);
      if (fts3PoslistPhraseMerge((&aOut), nDistance, 0, 1, (&p1), (&p2))) {
        (pPhrase->doclist.bFreeList = 1);
        (pPhrase->doclist.nList = ((int ) (aOut - pPhrase->doclist.pList)));
      }  
      else {
        sqlite3_free(aOut);
        (pPhrase->doclist.pList = 0);
        (pPhrase->doclist.nList = 0);
      }
      sqlite3_free(aPoslist);
    }
  }  
  return 0;
}
static  int fts3EvalPhraseStart(_1273_Fts3Cursor *pCsr , int bOptOk , _1273_Fts3Phrase *p )  {
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  int rc =  0;
  int i;
  int bHaveIncr =  0;
  int bIncrOk =  (bOptOk && (pCsr->bDesc == pTab->bDescIdx) && (p->nToken <= 4) && (p->nToken > 0) && (p->nToken <= 4) && (p->nToken > 0));
  for ((i = 0); ((bIncrOk == 1) && (i < p->nToken)); i++) {
    _1273_Fts3PhraseToken *pToken =  (&p->aToken[i]);
    if ((pToken->bFirst || ((pToken->pSegcsr != 0) && (! pToken->pSegcsr->bLookup)))) {
      (bIncrOk = 0);
    }  
    if (pToken->pSegcsr) {
      (bHaveIncr = 1);
    }  
  }
  if ((bIncrOk && bHaveIncr)) {
    int iCol =  ((p->iColumn >= pTab->nColumn) ? (- 1) : p->iColumn);
    for ((i = 0); ((rc == 0) && (i < p->nToken)); i++) {
      _1273_Fts3PhraseToken *pToken =  (&p->aToken[i]);
      _1273_Fts3MultiSegReader *pSegcsr =  pToken->pSegcsr;
      if (pSegcsr) {
        (rc = sqlite3Fts3MsrIncrStart(pTab, pSegcsr, iCol, pToken->z, pToken->n));
      }  
    }
    (p->bIncr = 1);
  }  
  else {
    (rc = fts3EvalPhraseLoad(pCsr, p));
    (p->bIncr = 0);
  }
  ((void ) 0);
  return rc;
}
static  void sqlite3Fts3DoclistPrev(int bDescIdx , char *aDoclist , int nDoclist , char **ppIter , sqlite3_int64 *piDocid , int *pnList , u8 *pbEof )  {
  char *p =  (*ppIter);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((p == 0)) {
    sqlite3_int64 iDocid =  0;
    char *pNext =  0;
    char *pDocid =  aDoclist;
    char *pEnd =  (&aDoclist[nDoclist]);
    int iMul =  1;
    while ((pDocid < pEnd)) {
      sqlite3_int64 iDelta;
      (pDocid += sqlite3Fts3GetVarint(pDocid, (&iDelta)));
      (iDocid += (iMul * iDelta));
      (pNext = pDocid);
      fts3PoslistCopy(0, (&pDocid));
      while (((pDocid < pEnd) && ((*pDocid) == 0))) {
        pDocid++;
      }
      (iMul = (bDescIdx ? (- 1) : 1));
    }
    ((*pnList) = ((int ) (pEnd - pNext)));
    ((*ppIter) = pNext);
    ((*piDocid) = iDocid);
  }  
  else {
    int iMul =  (bDescIdx ? (- 1) : 1);
    sqlite3_int64 iDelta;
    fts3GetReverseVarint((&p), aDoclist, (&iDelta));
    ((*piDocid) -= (iMul * iDelta));
    if ((p == aDoclist)) {
      ((*pbEof) = 1);
    }  
    else {
      char *pSave =  p;
      fts3ReversePoslist(aDoclist, (&p));
      ((*pnList) = ((int ) (pSave - p)));
    }
    ((*ppIter) = p);
  }
}
static  void sqlite3Fts3DoclistNext(int bDescIdx , char *aDoclist , int nDoclist , char **ppIter , sqlite3_int64 *piDocid , u8 *pbEof )  {
  char *p =  (*ppIter);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((p == 0)) {
    (p = aDoclist);
    (p += sqlite3Fts3GetVarint(p, piDocid));
  }  
  else {
    fts3PoslistCopy(0, (&p));
    if ((p >= (&aDoclist[nDoclist]))) {
      ((*pbEof) = 1);
    }  
    else {
      sqlite3_int64 iVar;
      (p += sqlite3Fts3GetVarint(p, (&iVar)));
      ((*piDocid) += ((bDescIdx ? (- 1) : 1) * iVar));
    }
  }
  ((*ppIter) = p);
}
static  void fts3EvalDlPhraseNext(_1273_Fts3Table *pTab , _1273_Fts3Doclist *pDL , u8 *pbEof )  {
  char *pIter;
  char *pEnd =  (&pDL->aAll[pDL->nAll]);
  if (pDL->pNextDocid) {
    (pIter = pDL->pNextDocid);
  }  
  else {
    (pIter = pDL->aAll);
  }
  if ((pIter >= pEnd)) {
    ((*pbEof) = 1);
  }  
  else {
    sqlite3_int64 iDelta;
    (pIter += sqlite3Fts3GetVarint(pIter, (&iDelta)));
    if (((pTab->bDescIdx == 0) || (pDL->pNextDocid == 0))) {
      (pDL->iDocid += iDelta);
    }  
    else {
      (pDL->iDocid -= iDelta);
    }
    (pDL->pList = pIter);
    fts3PoslistCopy(0, (&pIter));
    (pDL->nList = ((int ) (pIter - pDL->pList)));
    while (((pIter < pEnd) && ((*pIter) == 0))) {
      pIter++;
    }
    (pDL->pNextDocid = pIter);
    ((void ) 0);
    ((*pbEof) = 0);
  }
}
typedef struct  _1273_TokenDoclist   _1273_TokenDoclist;
struct  _1273_TokenDoclist {
  int bIgnore ;
  sqlite3_int64 iDocid ;
  char *pList ;
  int nList ;
}  ;
static  int incrPhraseTokenNext(_1273_Fts3Table *pTab , _1273_Fts3Phrase *pPhrase , int iToken , _1273_TokenDoclist *p , u8 *pbEof )  {
  int rc =  0;
  if ((pPhrase->iDoclistToken == iToken)) {
    ((void ) 0);
    ((void ) 0);
    fts3EvalDlPhraseNext(pTab, (&pPhrase->doclist), pbEof);
    (p->pList = pPhrase->doclist.pList);
    (p->nList = pPhrase->doclist.nList);
    (p->iDocid = pPhrase->doclist.iDocid);
  }  
  else {
    _1273_Fts3PhraseToken *pToken =  (&pPhrase->aToken[iToken]);
    ((void ) 0);
    ((void ) 0);
    if (pToken->pSegcsr) {
      ((void ) 0);
      (rc = sqlite3Fts3MsrIncrNext(pTab, pToken->pSegcsr, (&p->iDocid), (&p->pList), (&p->nList)));
      if ((p->pList == 0)) {
        ((*pbEof) = 1);
      }  
    }  
    else {
      (p->bIgnore = 1);
    }
  }
  return rc;
}
static  int fts3EvalIncrPhraseNext(_1273_Fts3Cursor *pCsr , _1273_Fts3Phrase *p , u8 *pbEof )  {
  int rc =  0;
  _1273_Fts3Doclist *pDL =  (&p->doclist);
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  u8 bEof =  0;
  ((void ) 0);
  if (((p->nToken == 1) && p->bIncr)) {
    (rc = sqlite3Fts3MsrIncrNext(pTab, p->aToken[0].pSegcsr, (&pDL->iDocid), (&pDL->pList), (&pDL->nList)));
    if ((pDL->pList == 0)) {
      (bEof = 1);
    }  
  }  
  else {
    int bDescDoclist =  pCsr->bDesc;
    struct  _1273_TokenDoclist   a[4];
    memset(a, 0, sizeof(a));
    ((void ) 0);
    ((void ) 0);
    while ((bEof == 0)) {
      int bMaxSet =  0;
      sqlite3_int64 iMax =  0;
      int i;
      for ((i = 0); ((rc == 0) && (i < p->nToken) && (bEof == 0)); i++) {
        (rc = incrPhraseTokenNext(pTab, p, i, (&a[i]), (&bEof)));
        if (((a[i].bIgnore == 0) && ((bMaxSet == 0) || (((bDescDoclist ? (- 1) : 1) * (iMax - a[i].iDocid)) < 0)))) {
          (iMax = a[i].iDocid);
          (bMaxSet = 1);
        }  
      }
      ((void ) 0);
      ((void ) 0);
      for ((i = 0); (i < p->nToken); i++) {
        while (((rc == 0) && (bEof == 0) && (a[i].bIgnore == 0) && (((bDescDoclist ? (- 1) : 1) * (a[i].iDocid - iMax)) < 0))) {
          (rc = incrPhraseTokenNext(pTab, p, i, (&a[i]), (&bEof)));
          if ((((bDescDoclist ? (- 1) : 1) * (a[i].iDocid - iMax)) > 0)) {
            (iMax = a[i].iDocid);
            (i = 0);
          }  
        }
      }
      if ((bEof == 0)) {
        int nList =  0;
        int nByte =  a[(p->nToken - 1)].nList;
        char *aDoclist =  sqlite3_malloc((nByte + 1));
        if ((! aDoclist)) {
          return 7;
        }  
        memcpy(aDoclist, a[(p->nToken - 1)].pList, (nByte + 1));
        for ((i = 0); (i < (p->nToken - 1)); i++) {
          if ((a[i].bIgnore == 0)) {
            char *pL =  a[i].pList;
            char *pR =  aDoclist;
            char *pOut =  aDoclist;
            int nDist =  (p->nToken - 1 - i);
            int res =  fts3PoslistPhraseMerge((&pOut), nDist, 0, 1, (&pL), (&pR));
            if ((res == 0)) {
              break;
            }  
            (nList = ((int ) (pOut - aDoclist)));
          }  
        }
        if ((i == (p->nToken - 1))) {
          (pDL->iDocid = iMax);
          (pDL->pList = aDoclist);
          (pDL->nList = nList);
          (pDL->bFreeList = 1);
          break;
        }  
        sqlite3_free(aDoclist);
      }  
    }
  }
  ((*pbEof) = bEof);
  return rc;
}
static  int fts3EvalPhraseNext(_1273_Fts3Cursor *pCsr , _1273_Fts3Phrase *p , u8 *pbEof )  {
  int rc =  0;
  _1273_Fts3Doclist *pDL =  (&p->doclist);
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  if (p->bIncr) {
    (rc = fts3EvalIncrPhraseNext(pCsr, p, pbEof));
  } 
  else if (((pCsr->bDesc != pTab->bDescIdx) && pDL->nAll)) {
    sqlite3Fts3DoclistPrev(pTab->bDescIdx, pDL->aAll, pDL->nAll, (&pDL->pNextDocid), (&pDL->iDocid), (&pDL->nList), pbEof);
    (pDL->pList = pDL->pNextDocid);
  } 
  else {
    fts3EvalDlPhraseNext(pTab, pDL, pbEof);
  }
  return rc;
}
static  void fts3EvalStartReaders(_1273_Fts3Cursor *pCsr , _1273_Fts3Expr *pExpr , int *pRc )  {
  if ((pExpr && (0 == (*pRc)))) {
    if ((pExpr->eType == 5)) {
      int i;
      int nToken =  pExpr->pPhrase->nToken;
      for ((i = 0); (i < nToken); i++) {
        if ((pExpr->pPhrase->aToken[i].pDeferred == 0)) {
          break;
        }  
      }
      (pExpr->bDeferred = (i == nToken));
      ((*pRc) = fts3EvalPhraseStart(pCsr, 1, pExpr->pPhrase));
    }  
    else {
      fts3EvalStartReaders(pCsr, pExpr->pLeft, pRc);
      fts3EvalStartReaders(pCsr, pExpr->pRight, pRc);
      (pExpr->bDeferred = (pExpr->pLeft->bDeferred && pExpr->pRight->bDeferred));
    }
  }  
}
typedef struct  _1273_Fts3TokenAndCost   _1273_Fts3TokenAndCost;
struct  _1273_Fts3TokenAndCost {
  _1273_Fts3Phrase *pPhrase ;
  int iToken ;
  _1273_Fts3PhraseToken *pToken ;
  _1273_Fts3Expr *pRoot ;
  int nOvfl ;
  int iCol ;
}  ;
static  void fts3EvalTokenCosts(_1273_Fts3Cursor *pCsr , _1273_Fts3Expr *pRoot , _1273_Fts3Expr *pExpr , _1273_Fts3TokenAndCost **ppTC , _1273_Fts3Expr ***ppOr , int *pRc )  {
  if (((*pRc) == 0)) {
    if ((pExpr->eType == 5)) {
      _1273_Fts3Phrase *pPhrase =  pExpr->pPhrase;
      int i;
      for ((i = 0); (((*pRc) == 0) && (i < pPhrase->nToken)); i++) {
        _1273_Fts3TokenAndCost *pTC =  (*ppTC)++;
        (pTC->pPhrase = pPhrase);
        (pTC->iToken = i);
        (pTC->pRoot = pRoot);
        (pTC->pToken = (&pPhrase->aToken[i]));
        (pTC->iCol = pPhrase->iColumn);
        ((*pRc) = sqlite3Fts3MsrOvfl(pCsr, pTC->pToken->pSegcsr, (&pTC->nOvfl)));
      }
    } 
    else if ((pExpr->eType != 2)) {
      ((void ) 0);
      ((void ) 0);
      if ((pExpr->eType == 4)) {
        (pRoot = pExpr->pLeft);
        ((*(*ppOr)) = pRoot);
        (*ppOr)++;
      }  
      fts3EvalTokenCosts(pCsr, pRoot, pExpr->pLeft, ppTC, ppOr, pRc);
      if ((pExpr->eType == 4)) {
        (pRoot = pExpr->pRight);
        ((*(*ppOr)) = pRoot);
        (*ppOr)++;
      }  
      fts3EvalTokenCosts(pCsr, pRoot, pExpr->pRight, ppTC, ppOr, pRc);
    } 
  }  
}
static  int fts3EvalAverageDocsize(_1273_Fts3Cursor *pCsr , int *pnPage )  {
  if ((pCsr->nRowAvg == 0)) {
    int rc;
    _1273_Fts3Table *p =  ((_1273_Fts3Table *) pCsr->base.pVtab);
    sqlite3_stmt *pStmt;
    sqlite3_int64 nDoc =  0;
    sqlite3_int64 nByte =  0;
    const char *pEnd;
    const char *a;
    (rc = sqlite3Fts3SelectDoctotal(p, (&pStmt)));
    if ((rc != 0)) {
      return rc;
    }  
    (a = sqlite3_column_blob(pStmt, 0));
    ((void ) 0);
    (pEnd = (&a[sqlite3_column_bytes(pStmt, 0)]));
    (a += sqlite3Fts3GetVarint(a, (&nDoc)));
    while ((a < pEnd)) {
      (a += sqlite3Fts3GetVarint(a, (&nByte)));
    }
    if (((nDoc == 0) || (nByte == 0))) {
      sqlite3_reset(pStmt);
      return (11 | (1 << 8));
    }  
    (pCsr->nDoc = nDoc);
    (pCsr->nRowAvg = ((int ) (((nByte / nDoc) + p->nPgsz) / p->nPgsz)));
    ((void ) 0);
    (rc = sqlite3_reset(pStmt));
    if ((rc != 0)) {
      return rc;
    }  
  }  
  ((*pnPage) = pCsr->nRowAvg);
  return 0;
}
static  int fts3EvalSelectDeferred(_1273_Fts3Cursor *pCsr , _1273_Fts3Expr *pRoot , _1273_Fts3TokenAndCost *aTC , int nTC )  {
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  int nDocSize =  0;
  int rc =  0;
  int ii;
  int nOvfl =  0;
  int nToken =  0;
  int nMinEst =  0;
  int nLoad4 =  1;
  if (pTab->zContentTbl) {
    return 0;
  }  
  for ((ii = 0); (ii < nTC); ii++) {
    if ((aTC[ii].pRoot == pRoot)) {
      (nOvfl += aTC[ii].nOvfl);
      nToken++;
    }  
  }
  if (((nOvfl == 0) || (nToken < 2))) {
    return 0;
  }  
  (rc = fts3EvalAverageDocsize(pCsr, (&nDocSize)));
  ((void ) 0);
  for ((ii = 0); ((ii < nToken) && (rc == 0)); ii++) {
    int iTC;
    _1273_Fts3TokenAndCost *pTC =  0;
    for ((iTC = 0); (iTC < nTC); iTC++) {
      if ((aTC[iTC].pToken && (aTC[iTC].pRoot == pRoot) && ((! pTC) || (aTC[iTC].nOvfl < pTC->nOvfl)))) {
        (pTC = (&aTC[iTC]));
      }  
    }
    ((void ) 0);
    if ((ii && (pTC->nOvfl >= (((nMinEst + (nLoad4 / 4) - 1) / (nLoad4 / 4)) * nDocSize)))) {
      _1273_Fts3PhraseToken *pToken =  pTC->pToken;
      (rc = sqlite3Fts3DeferToken(pCsr, pToken, pTC->iCol));
      fts3SegReaderCursorFree(pToken->pSegcsr);
      (pToken->pSegcsr = 0);
    }  
    else {
      if ((ii < 12)) {
        (nLoad4 = (nLoad4 * 4));
      }  
      if (((ii == 0) || ((pTC->pPhrase->nToken > 1) && (ii != (nToken - 1))))) {
        _1273_Fts3PhraseToken *pToken =  pTC->pToken;
        int nList =  0;
        char *pList =  0;
        (rc = fts3TermSelect(pTab, pToken, pTC->iCol, (&nList), (&pList)));
        ((void ) 0);
        if ((rc == 0)) {
          int nCount;
          fts3EvalPhraseMergeToken(pTab, pTC->pPhrase, pTC->iToken, pList, nList);
          (nCount = fts3DoclistCountDocids(pTC->pPhrase->doclist.aAll, pTC->pPhrase->doclist.nAll));
          if (((ii == 0) || (nCount < nMinEst))) {
            (nMinEst = nCount);
          }  
        }  
      }  
    }
    (pTC->pToken = 0);
  }
  return rc;
}
static  int fts3EvalStart(_1273_Fts3Cursor *pCsr )  {
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  int rc =  0;
  int nToken =  0;
  int nOr =  0;
  fts3EvalAllocateReaders(pCsr, pCsr->pExpr, (&nToken), (&nOr), (&rc));
  if (((rc == 0) && (nToken > 1) && pTab->bFts4)) {
    _1273_Fts3TokenAndCost *aTC;
    _1273_Fts3Expr **apOr;
    (aTC = ((_1273_Fts3TokenAndCost *) sqlite3_malloc(((sizeof(_1273_Fts3TokenAndCost ) * nToken) + (sizeof(_1273_Fts3Expr *) * nOr * 2)))));
    (apOr = ((_1273_Fts3Expr **) (&aTC[nToken])));
    if ((! aTC)) {
      (rc = 7);
    }  
    else {
      int ii;
      _1273_Fts3TokenAndCost *pTC =  aTC;
      _1273_Fts3Expr **ppOr =  apOr;
      fts3EvalTokenCosts(pCsr, 0, pCsr->pExpr, (&pTC), (&ppOr), (&rc));
      (nToken = ((int ) (pTC - aTC)));
      (nOr = ((int ) (ppOr - apOr)));
      if ((rc == 0)) {
        (rc = fts3EvalSelectDeferred(pCsr, 0, aTC, nToken));
        for ((ii = 0); ((rc == 0) && (ii < nOr)); ii++) {
          (rc = fts3EvalSelectDeferred(pCsr, apOr[ii], aTC, nToken));
        }
      }  
      sqlite3_free(aTC);
    }
  }  
  fts3EvalStartReaders(pCsr, pCsr->pExpr, (&rc));
  return rc;
}
static  void fts3EvalInvalidatePoslist(_1273_Fts3Phrase *pPhrase )  {
  if (pPhrase->doclist.bFreeList) {
    sqlite3_free(pPhrase->doclist.pList);
  }  
  (pPhrase->doclist.pList = 0);
  (pPhrase->doclist.nList = 0);
  (pPhrase->doclist.bFreeList = 0);
}
static  int fts3EvalNearTrim(int nNear , char *aTmp , char **paPoslist , int *pnToken , _1273_Fts3Phrase *pPhrase )  {
  int nParam1 =  (nNear + pPhrase->nToken);
  int nParam2 =  (nNear + (*pnToken));
  int nNew;
  char *p2;
  char *pOut;
  int res;
  ((void ) 0);
  (p2 = (pOut = pPhrase->doclist.pList));
  (res = fts3PoslistNearMerge((&pOut), aTmp, nParam1, nParam2, paPoslist, (&p2)));
  if (res) {
    (nNew = (((int ) (pOut - pPhrase->doclist.pList)) - 1));
    ((void ) 0);
    ((void ) 0);
    memset((&pPhrase->doclist.pList[nNew]), 0, (pPhrase->doclist.nList - nNew));
    (pPhrase->doclist.nList = nNew);
    ((*paPoslist) = pPhrase->doclist.pList);
    ((*pnToken) = pPhrase->nToken);
  }  
  return res;
}
static  void fts3EvalNextRow(_1273_Fts3Cursor *pCsr , _1273_Fts3Expr *pExpr , int *pRc )  {
  if (((*pRc) == 0)) {
    int bDescDoclist =  pCsr->bDesc;
    ((void ) 0);
    (pExpr->bStart = 1);
    switch (pExpr->eType) {
      case 1:
      case 3:
      {
        _1273_Fts3Expr *pLeft =  pExpr->pLeft;
        _1273_Fts3Expr *pRight =  pExpr->pRight;
        ((void ) 0);
        if (pLeft->bDeferred) {
          fts3EvalNextRow(pCsr, pRight, pRc);
          (pExpr->iDocid = pRight->iDocid);
          (pExpr->bEof = pRight->bEof);
        } 
        else if (pRight->bDeferred) {
          fts3EvalNextRow(pCsr, pLeft, pRc);
          (pExpr->iDocid = pLeft->iDocid);
          (pExpr->bEof = pLeft->bEof);
        } 
        else {
          fts3EvalNextRow(pCsr, pLeft, pRc);
          fts3EvalNextRow(pCsr, pRight, pRc);
          while (((! pLeft->bEof) && (! pRight->bEof) && ((*pRc) == 0))) {
            sqlite3_int64 iDiff =  ((bDescDoclist ? (- 1) : 1) * (pLeft->iDocid - pRight->iDocid));
            if ((iDiff == 0)) {
              break;
            }  
            if ((iDiff < 0)) {
              fts3EvalNextRow(pCsr, pLeft, pRc);
            }  
            else {
              fts3EvalNextRow(pCsr, pRight, pRc);
            }
          }
          (pExpr->iDocid = pLeft->iDocid);
          (pExpr->bEof = (pLeft->bEof || pRight->bEof));
        }
        break;
      }
      case 4:
      {
        _1273_Fts3Expr *pLeft =  pExpr->pLeft;
        _1273_Fts3Expr *pRight =  pExpr->pRight;
        sqlite3_int64 iCmp =  ((bDescDoclist ? (- 1) : 1) * (pLeft->iDocid - pRight->iDocid));
        ((void ) 0);
        ((void ) 0);
        if ((pRight->bEof || ((pLeft->bEof == 0) && (iCmp < 0)))) {
          fts3EvalNextRow(pCsr, pLeft, pRc);
        } 
        else if ((pLeft->bEof || ((pRight->bEof == 0) && (iCmp > 0)))) {
          fts3EvalNextRow(pCsr, pRight, pRc);
        } 
        else {
          fts3EvalNextRow(pCsr, pLeft, pRc);
          fts3EvalNextRow(pCsr, pRight, pRc);
        }
        (pExpr->bEof = (pLeft->bEof && pRight->bEof));
        (iCmp = ((bDescDoclist ? (- 1) : 1) * (pLeft->iDocid - pRight->iDocid)));
        if ((pRight->bEof || ((pLeft->bEof == 0) && (iCmp < 0)))) {
          (pExpr->iDocid = pLeft->iDocid);
        }  
        else {
          (pExpr->iDocid = pRight->iDocid);
        }
        break;
      }
      case 2:
      {
        _1273_Fts3Expr *pLeft =  pExpr->pLeft;
        _1273_Fts3Expr *pRight =  pExpr->pRight;
        if ((pRight->bStart == 0)) {
          fts3EvalNextRow(pCsr, pRight, pRc);
          ((void ) 0);
        }  
        fts3EvalNextRow(pCsr, pLeft, pRc);
        if ((pLeft->bEof == 0)) {
          while (((! (*pRc)) && (! pRight->bEof) && (((bDescDoclist ? (- 1) : 1) * (pLeft->iDocid - pRight->iDocid)) > 0))) {
            fts3EvalNextRow(pCsr, pRight, pRc);
          }
        }  
        (pExpr->iDocid = pLeft->iDocid);
        (pExpr->bEof = pLeft->bEof);
        break;
      }
      id2i_label_1:
      default:
      {
        _1273_Fts3Phrase *pPhrase =  pExpr->pPhrase;
        fts3EvalInvalidatePoslist(pPhrase);
        ((*pRc) = fts3EvalPhraseNext(pCsr, pPhrase, (&pExpr->bEof)));
        (pExpr->iDocid = pPhrase->doclist.iDocid);
        break;
      }
    }
  }  
}
static  int fts3EvalNearTest(_1273_Fts3Expr *pExpr , int *pRc )  {
  int res =  1;
  if ((((*pRc) == 0) && (pExpr->eType == 1) && (pExpr->bEof == 0) && ((pExpr->pParent == 0) || (pExpr->pParent->eType != 1)))) {
    _1273_Fts3Expr *p;
    int nTmp =  0;
    char *aTmp;
    for ((p = pExpr); p->pLeft; (p = p->pLeft)) {
      (nTmp += p->pRight->pPhrase->doclist.nList);
    }
    (nTmp += p->pPhrase->doclist.nList);
    if ((nTmp == 0)) {
      (res = 0);
    }  
    else {
      (aTmp = sqlite3_malloc((nTmp * 2)));
      if ((! aTmp)) {
        ((*pRc) = 7);
        (res = 0);
      }  
      else {
        char *aPoslist =  p->pPhrase->doclist.pList;
        int nToken =  p->pPhrase->nToken;
        for ((p = p->pParent); (res && p && (p->eType == 1)); (p = p->pParent)) {
          _1273_Fts3Phrase *pPhrase =  p->pRight->pPhrase;
          int nNear =  p->nNear;
          (res = fts3EvalNearTrim(nNear, aTmp, (&aPoslist), (&nToken), pPhrase));
        }
        (aPoslist = pExpr->pRight->pPhrase->doclist.pList);
        (nToken = pExpr->pRight->pPhrase->nToken);
        for ((p = pExpr->pLeft); (p && res); (p = p->pLeft)) {
          int nNear;
          _1273_Fts3Phrase *pPhrase;
          ((void ) 0);
          (nNear = p->pParent->nNear);
          (pPhrase = ((p->eType == 1) ? p->pRight->pPhrase : p->pPhrase));
          (res = fts3EvalNearTrim(nNear, aTmp, (&aPoslist), (&nToken), pPhrase));
        }
      }
      sqlite3_free(aTmp);
    }
  }  
  return res;
}
static  int fts3EvalTestExpr(_1273_Fts3Cursor *pCsr , _1273_Fts3Expr *pExpr , int *pRc )  {
  int bHit =  1;
  if (((*pRc) == 0)) {
    switch (pExpr->eType) {
      case 1:
      case 3:
      (bHit = (fts3EvalTestExpr(pCsr, pExpr->pLeft, pRc) && fts3EvalTestExpr(pCsr, pExpr->pRight, pRc) && fts3EvalNearTest(pExpr, pRc)));
      if (((bHit == 0) && (pExpr->eType == 1) && ((pExpr->pParent == 0) || (pExpr->pParent->eType != 1)))) {
        _1273_Fts3Expr *p;
        for ((p = pExpr); (p->pPhrase == 0); (p = p->pLeft)) {
          if ((p->pRight->iDocid == pCsr->iPrevId)) {
            fts3EvalInvalidatePoslist(p->pRight->pPhrase);
          }  
        }
        if ((p->iDocid == pCsr->iPrevId)) {
          fts3EvalInvalidatePoslist(p->pPhrase);
        }  
      }  
      break;
      case 4:
      {
        int bHit1 =  fts3EvalTestExpr(pCsr, pExpr->pLeft, pRc);
        int bHit2 =  fts3EvalTestExpr(pCsr, pExpr->pRight, pRc);
        (bHit = (bHit1 || bHit2));
        break;
      }
      case 2:
      (bHit = (fts3EvalTestExpr(pCsr, pExpr->pLeft, pRc) && (! fts3EvalTestExpr(pCsr, pExpr->pRight, pRc))));
      break;
      id2i_label_1:
      default:
      {
        if ((pCsr->pDeferred && ((pExpr->iDocid == pCsr->iPrevId) || pExpr->bDeferred))) {
          _1273_Fts3Phrase *pPhrase =  pExpr->pPhrase;
          ((void ) 0);
          if (pExpr->bDeferred) {
            fts3EvalInvalidatePoslist(pPhrase);
          }  
          ((*pRc) = fts3EvalDeferredPhrase(pCsr, pPhrase));
          (bHit = (pPhrase->doclist.pList != 0));
          (pExpr->iDocid = pCsr->iPrevId);
        }  
        else {
          (bHit = ((pExpr->bEof == 0) && (pExpr->iDocid == pCsr->iPrevId)));
        }
        break;
      }
    }
  }  
  return bHit;
}
static  int fts3EvalTestDeferredAndNear(_1273_Fts3Cursor *pCsr , int *pRc )  {
  int rc =  (*pRc);
  int bMiss =  0;
  if ((rc == 0)) {
    if (pCsr->pDeferred) {
      (rc = fts3CursorSeek(0, pCsr));
      if ((rc == 0)) {
        (rc = sqlite3Fts3CacheDeferredDoclists(pCsr));
      }  
    }  
    (bMiss = (0 == fts3EvalTestExpr(pCsr, pCsr->pExpr, (&rc))));
    sqlite3Fts3FreeDeferredDoclists(pCsr);
    ((*pRc) = rc);
  }  
  return ((rc == 0) && bMiss);
}
static  int fts3EvalNext(_1273_Fts3Cursor *pCsr )  {
  int rc =  0;
  _1273_Fts3Expr *pExpr =  pCsr->pExpr;
  ((void ) 0);
  if ((pExpr == 0)) {
    (pCsr->isEof = 1);
  }  
  else {
    do {
      if ((pCsr->isRequireSeek == 0)) {
        sqlite3_reset(pCsr->pStmt);
      }  
      ((void ) 0);
      fts3EvalNextRow(pCsr, pExpr, (&rc));
      (pCsr->isEof = pExpr->bEof);
      (pCsr->isRequireSeek = 1);
      (pCsr->isMatchinfoNeeded = 1);
      (pCsr->iPrevId = pExpr->iDocid);
    } while (((pCsr->isEof == 0) && fts3EvalTestDeferredAndNear(pCsr, (&rc))));
  }
  if (((rc == 0) && (((pCsr->bDesc == 0) && (pCsr->iPrevId > pCsr->iMaxDocid)) || ((pCsr->bDesc != 0) && (pCsr->iPrevId < pCsr->iMinDocid))))) {
    (pCsr->isEof = 1);
  }  
  return rc;
}
static  void fts3EvalRestart(_1273_Fts3Cursor *pCsr , _1273_Fts3Expr *pExpr , int *pRc )  {
  if ((pExpr && ((*pRc) == 0))) {
    _1273_Fts3Phrase *pPhrase =  pExpr->pPhrase;
    if (pPhrase) {
      fts3EvalInvalidatePoslist(pPhrase);
      if (pPhrase->bIncr) {
        int i;
        for ((i = 0); (i < pPhrase->nToken); i++) {
          _1273_Fts3PhraseToken *pToken =  (&pPhrase->aToken[i]);
          ((void ) 0);
          if (pToken->pSegcsr) {
            sqlite3Fts3MsrIncrRestart(pToken->pSegcsr);
          }  
        }
        ((*pRc) = fts3EvalPhraseStart(pCsr, 0, pPhrase));
      }  
      (pPhrase->doclist.pNextDocid = 0);
      (pPhrase->doclist.iDocid = 0);
    }  
    (pExpr->iDocid = 0);
    (pExpr->bEof = 0);
    (pExpr->bStart = 0);
    fts3EvalRestart(pCsr, pExpr->pLeft, pRc);
    fts3EvalRestart(pCsr, pExpr->pRight, pRc);
  }  
}
static  void fts3EvalUpdateCounts(_1273_Fts3Expr *pExpr )  {
  if (pExpr) {
    _1273_Fts3Phrase *pPhrase =  pExpr->pPhrase;
    if ((pPhrase && pPhrase->doclist.pList)) {
      int iCol =  0;
      char *p =  pPhrase->doclist.pList;
      ((void ) 0);
      while (1) {
        u8 c =  0;
        int iCnt =  0;
        while ((0xFE & ((*p) | c))) {
          if (((c & 0x80) == 0)) {
            iCnt++;
          }  
          (c = ((*p++) & 0x80));
        }
        (pExpr->aMI[((iCol * 3) + 1)] += iCnt);
        (pExpr->aMI[((iCol * 3) + 2)] += (iCnt > 0));
        if (((*p) == 0x00)) {
          break;
        }  
        p++;
        (p += sqlite3Fts3GetVarint32(p, (&iCol)));
      }
    }  
    fts3EvalUpdateCounts(pExpr->pLeft);
    fts3EvalUpdateCounts(pExpr->pRight);
  }  
}
static  int fts3EvalGatherStats(_1273_Fts3Cursor *pCsr , _1273_Fts3Expr *pExpr )  {
  int rc =  0;
  ((void ) 0);
  if ((pExpr->aMI == 0)) {
    _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
    _1273_Fts3Expr *pRoot;
    _1273_Fts3Expr *p;
    sqlite3_int64 iPrevId =  pCsr->iPrevId;
    sqlite3_int64 iDocid;
    u8 bEof;
    (pRoot = pExpr);
    while ((pRoot->pParent && (pRoot->pParent->eType == 1))) {
      (pRoot = pRoot->pParent);
    }
    (iDocid = pRoot->iDocid);
    (bEof = pRoot->bEof);
    ((void ) 0);
    for ((p = pRoot); p; (p = p->pLeft)) {
      _1273_Fts3Expr *pE =  ((p->eType == 5) ? p : p->pRight);
      ((void ) 0);
      (pE->aMI = ((u32 *) sqlite3_malloc((pTab->nColumn * 3 * sizeof(u32 )))));
      if ((! pE->aMI)) {
        return 7;
      }  
      memset(pE->aMI, 0, (pTab->nColumn * 3 * sizeof(u32 )));
    }
    fts3EvalRestart(pCsr, pRoot, (&rc));
    while (((pCsr->isEof == 0) && (rc == 0))) {
      do {
        if ((pCsr->isRequireSeek == 0)) {
          sqlite3_reset(pCsr->pStmt);
        }  
        ((void ) 0);
        fts3EvalNextRow(pCsr, pRoot, (&rc));
        (pCsr->isEof = pRoot->bEof);
        (pCsr->isRequireSeek = 1);
        (pCsr->isMatchinfoNeeded = 1);
        (pCsr->iPrevId = pRoot->iDocid);
      } while (((pCsr->isEof == 0) && (pRoot->eType == 1) && fts3EvalTestDeferredAndNear(pCsr, (&rc))));
      if (((rc == 0) && (pCsr->isEof == 0))) {
        fts3EvalUpdateCounts(pRoot);
      }  
    }
    (pCsr->isEof = 0);
    (pCsr->iPrevId = iPrevId);
    if (bEof) {
      (pRoot->bEof = bEof);
    }  
    else {
      fts3EvalRestart(pCsr, pRoot, (&rc));
      do {
        fts3EvalNextRow(pCsr, pRoot, (&rc));
        ((void ) 0);
      } while (((pRoot->iDocid != iDocid) && (rc == 0)));
      fts3EvalTestDeferredAndNear(pCsr, (&rc));
    }
  }  
  return rc;
}
static  int sqlite3Fts3EvalPhraseStats(_1273_Fts3Cursor *pCsr , _1273_Fts3Expr *pExpr , u32 *aiOut )  {
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  int rc =  0;
  int iCol;
  if ((pExpr->bDeferred && (pExpr->pParent->eType != 1))) {
    ((void ) 0);
    for ((iCol = 0); (iCol < pTab->nColumn); iCol++) {
      (aiOut[((iCol * 3) + 1)] = ((u32 ) pCsr->nDoc));
      (aiOut[((iCol * 3) + 2)] = ((u32 ) pCsr->nDoc));
    }
  }  
  else {
    (rc = fts3EvalGatherStats(pCsr, pExpr));
    if ((rc == 0)) {
      ((void ) 0);
      for ((iCol = 0); (iCol < pTab->nColumn); iCol++) {
        (aiOut[((iCol * 3) + 1)] = pExpr->aMI[((iCol * 3) + 1)]);
        (aiOut[((iCol * 3) + 2)] = pExpr->aMI[((iCol * 3) + 2)]);
      }
    }  
  }
  return rc;
}
static  int sqlite3Fts3EvalPhrasePoslist(_1273_Fts3Cursor *pCsr , _1273_Fts3Expr *pExpr , int iCol , char **ppOut )  {
  _1273_Fts3Phrase *pPhrase =  pExpr->pPhrase;
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  char *pIter;
  int iThis;
  sqlite3_int64 iDocid;
  ((*ppOut) = 0);
  ((void ) 0);
  if (((pPhrase->iColumn < pTab->nColumn) && (pPhrase->iColumn != iCol))) {
    return 0;
  }  
  (iDocid = pExpr->iDocid);
  (pIter = pPhrase->doclist.pList);
  if (((iDocid != pCsr->iPrevId) || pExpr->bEof)) {
    int bDescDoclist =  pTab->bDescIdx;
    int iMul;
    int bOr =  0;
    u8 bEof =  0;
    u8 bTreeEof =  0;
    _1273_Fts3Expr *p;
    _1273_Fts3Expr *pNear;
    (pNear = pExpr);
    for ((p = pExpr->pParent); p; (p = p->pParent)) {
      if ((p->eType == 4)) {
        (bOr = 1);
      }  
      if ((p->eType == 1)) {
        (pNear = p);
      }  
      if (p->bEof) {
        (bTreeEof = 1);
      }  
    }
    if ((bOr == 0)) {
      return 0;
    }  
    if (pPhrase->bIncr) {
      int rc =  0;
      int bEofSave =  pExpr->bEof;
      fts3EvalRestart(pCsr, pExpr, (&rc));
      while (((rc == 0) && (! pExpr->bEof))) {
        fts3EvalNextRow(pCsr, pExpr, (&rc));
        if (((bEofSave == 0) && (pExpr->iDocid == iDocid))) {
          break;
        }  
      }
      (pIter = pPhrase->doclist.pList);
      ((void ) 0);
      if ((rc != 0)) {
        return rc;
      }  
    }  
    (iMul = ((pCsr->bDesc == bDescDoclist) ? 1 : (- 1)));
    while (((bTreeEof == 1) && (pNear->bEof == 0) && ((((bDescDoclist ? (- 1) : 1) * (pNear->iDocid - pCsr->iPrevId)) * iMul) < 0))) {
      int rc =  0;
      fts3EvalNextRow(pCsr, pExpr, (&rc));
      if ((rc != 0)) {
        return rc;
      }  
      (iDocid = pExpr->iDocid);
      (pIter = pPhrase->doclist.pList);
    }
    (bEof = (pPhrase->doclist.nAll == 0));
    ((void ) 0);
    ((void ) 0);
    if ((bEof == 0)) {
      if ((pCsr->bDesc == bDescDoclist)) {
        int dummy;
        if (pNear->bEof) {
          (pIter = (&pPhrase->doclist.aAll[(pPhrase->doclist.nAll - 1)]));
          fts3ReversePoslist(pPhrase->doclist.aAll, (&pIter));
        }  
        while ((((pIter == 0) || (((bDescDoclist ? (- 1) : 1) * (iDocid - pCsr->iPrevId)) > 0)) && (bEof == 0))) {
          sqlite3Fts3DoclistPrev(bDescDoclist, pPhrase->doclist.aAll, pPhrase->doclist.nAll, (&pIter), (&iDocid), (&dummy), (&bEof));
        }
      }  
      else {
        if (pNear->bEof) {
          (pIter = 0);
          (iDocid = 0);
        }  
        while ((((pIter == 0) || (((bDescDoclist ? (- 1) : 1) * (iDocid - pCsr->iPrevId)) < 0)) && (bEof == 0))) {
          sqlite3Fts3DoclistNext(bDescDoclist, pPhrase->doclist.aAll, pPhrase->doclist.nAll, (&pIter), (&iDocid), (&bEof));
        }
      }
    }  
    if ((bEof || (iDocid != pCsr->iPrevId))) {
      (pIter = 0);
    }  
  }  
  if ((pIter == 0)) {
    return 0;
  }  
  if (((*pIter) == 0x01)) {
    pIter++;
    (pIter += sqlite3Fts3GetVarint32(pIter, (&iThis)));
  }  
  else {
    (iThis = 0);
  }
  while ((iThis < iCol)) {
    fts3ColumnlistCopy(0, (&pIter));
    if (((*pIter) == 0x00)) {
      return 0;
    }  
    pIter++;
    (pIter += sqlite3Fts3GetVarint32(pIter, (&iThis)));
  }
  ((*ppOut) = ((iCol == iThis) ? pIter : 0));
  return 0;
}
static  void sqlite3Fts3EvalPhraseCleanup(_1273_Fts3Phrase *pPhrase )  {
  if (pPhrase) {
    int i;
    sqlite3_free(pPhrase->doclist.aAll);
    fts3EvalInvalidatePoslist(pPhrase);
    memset((&pPhrase->doclist), 0, sizeof(_1273_Fts3Doclist ));
    for ((i = 0); (i < pPhrase->nToken); i++) {
      fts3SegReaderCursorFree(pPhrase->aToken[i].pSegcsr);
      (pPhrase->aToken[i].pSegcsr = 0);
    }
  }  
}
typedef struct  _1273_Fts3auxTable   _1273_Fts3auxTable;
typedef struct  _1273_Fts3auxCursor   _1273_Fts3auxCursor;
struct  _1273_Fts3auxTable {
  sqlite3_vtab base ;
  _1273_Fts3Table *pFts3Tab ;
}  ;
struct  _1273_Fts3auxCursor {
  sqlite3_vtab_cursor base ;
  _1273_Fts3MultiSegReader csr ;
  _1273_Fts3SegFilter filter ;
  char *zStop ;
  int nStop ;
  int iLangid ;
  int isEof ;
  sqlite3_int64 iRowid ;
  int iCol ;
  int nStat ;
  struct  Fts3auxColstats {
    sqlite3_int64 nDoc ;
    sqlite3_int64 nOcc ;
  }  *aStat ;
}  ;
static  int fts3auxConnectMethod(sqlite3 *db , void *pUnused , int argc , const  char *const *argv , sqlite3_vtab **ppVtab , char **pzErr )  {
  char const *zDb;
  char const *zFts3;
  int nDb;
  int nFts3;
  int nByte;
  int rc;
  _1273_Fts3auxTable *p;
  ((void ) pUnused);
  if (((argc != 4) && (argc != 5))) {
    goto _1273_bad_args;
  }  
  (zDb = argv[1]);
  (nDb = ((int ) strlen(zDb)));
  if ((argc == 5)) {
    if (((nDb == 4) && (0 == sqlite3_strnicmp("temp", zDb, 4)))) {
      (zDb = argv[3]);
      (nDb = ((int ) strlen(zDb)));
      (zFts3 = argv[4]);
    }  
    else {
      goto _1273_bad_args;
    }
  }  
  else {
    (zFts3 = argv[3]);
  }
  (nFts3 = ((int ) strlen(zFts3)));
  (rc = sqlite3_declare_vtab(db, "CREATE TABLE x(term, col, documents, occurrences, languageid HIDDEN)"));
  if ((rc != 0)) {
    return rc;
  }  
  (nByte = (sizeof(_1273_Fts3auxTable ) + sizeof(_1273_Fts3Table ) + nDb + nFts3 + 2));
  (p = ((_1273_Fts3auxTable *) sqlite3_malloc(nByte)));
  if ((! p)) {
    return 7;
  }  
  memset(p, 0, nByte);
  (p->pFts3Tab = ((_1273_Fts3Table *) (&p[1])));
  (p->pFts3Tab->zDb = ((char *) (&p->pFts3Tab[1])));
  (p->pFts3Tab->zName = (&p->pFts3Tab->zDb[(nDb + 1)]));
  (p->pFts3Tab->db = db);
  (p->pFts3Tab->nIndex = 1);
  memcpy(((char *) p->pFts3Tab->zDb), zDb, nDb);
  memcpy(((char *) p->pFts3Tab->zName), zFts3, nFts3);
  sqlite3Fts3Dequote(((char *) p->pFts3Tab->zName));
  ((*ppVtab) = ((sqlite3_vtab *) p));
  return 0;
  _1273_bad_args:
  ((*pzErr) = sqlite3_mprintf("invalid arguments to fts4aux constructor"));
  return 1;
}
static  int fts3auxDisconnectMethod(sqlite3_vtab *pVtab )  {
  _1273_Fts3auxTable *p =  ((_1273_Fts3auxTable *) pVtab);
  _1273_Fts3Table *pFts3 =  p->pFts3Tab;
  int i;
  for ((i = 0); (i < ((int ) (sizeof(pFts3->aStmt) / sizeof(pFts3->aStmt[0])))); i++) {
    sqlite3_finalize(pFts3->aStmt[i]);
  }
  sqlite3_free(pFts3->zSegmentsTbl);
  sqlite3_free(p);
  return 0;
}
static  int fts3auxBestIndexMethod(sqlite3_vtab *pVTab , sqlite3_index_info *pInfo )  {
  int i;
  int iEq =  (- 1);
  int iGe =  (- 1);
  int iLe =  (- 1);
  int iLangid =  (- 1);
  int iNext =  1;
  ((void ) pVTab);
  if (((pInfo->nOrderBy == 1) && (pInfo->aOrderBy[0].iColumn == 0) && (pInfo->aOrderBy[0].desc == 0))) {
    (pInfo->orderByConsumed = 1);
  }  
  for ((i = 0); (i < pInfo->nConstraint); i++) {
    if (pInfo->aConstraint[i].usable) {
      int op =  pInfo->aConstraint[i].op;
      int iCol =  pInfo->aConstraint[i].iColumn;
      if ((iCol == 0)) {
        if ((op == 2)) {
          (iEq = i);
        }  
        if ((op == 16)) {
          (iLe = i);
        }  
        if ((op == 8)) {
          (iLe = i);
        }  
        if ((op == 4)) {
          (iGe = i);
        }  
        if ((op == 32)) {
          (iGe = i);
        }  
      }  
      if ((iCol == 4)) {
        if ((op == 2)) {
          (iLangid = i);
        }  
      }  
    }  
  }
  if ((iEq >= 0)) {
    (pInfo->idxNum = 1);
    (pInfo->aConstraintUsage[iEq].argvIndex = iNext++);
    (pInfo->estimatedCost = 5);
  }  
  else {
    (pInfo->idxNum = 0);
    (pInfo->estimatedCost = 20000);
    if ((iGe >= 0)) {
      (pInfo->idxNum += 2);
      (pInfo->aConstraintUsage[iGe].argvIndex = iNext++);
      (pInfo->estimatedCost /= 2);
    }  
    if ((iLe >= 0)) {
      (pInfo->idxNum += 4);
      (pInfo->aConstraintUsage[iLe].argvIndex = iNext++);
      (pInfo->estimatedCost /= 2);
    }  
  }
  if ((iLangid >= 0)) {
    (pInfo->aConstraintUsage[iLangid].argvIndex = iNext++);
    pInfo->estimatedCost--;
  }  
  return 0;
}
static  int fts3auxOpenMethod(sqlite3_vtab *pVTab , sqlite3_vtab_cursor **ppCsr )  {
  _1273_Fts3auxCursor *pCsr;
  ((void ) pVTab);
  (pCsr = ((_1273_Fts3auxCursor *) sqlite3_malloc(sizeof(_1273_Fts3auxCursor ))));
  if ((! pCsr)) {
    return 7;
  }  
  memset(pCsr, 0, sizeof(_1273_Fts3auxCursor ));
  ((*ppCsr) = ((sqlite3_vtab_cursor *) pCsr));
  return 0;
}
static  int fts3auxCloseMethod(sqlite3_vtab_cursor *pCursor )  {
  _1273_Fts3Table *pFts3 =  ((_1273_Fts3auxTable *) pCursor->pVtab)->pFts3Tab;
  _1273_Fts3auxCursor *pCsr =  ((_1273_Fts3auxCursor *) pCursor);
  sqlite3Fts3SegmentsClose(pFts3);
  sqlite3Fts3SegReaderFinish((&pCsr->csr));
  sqlite3_free(((void *) pCsr->filter.zTerm));
  sqlite3_free(pCsr->zStop);
  sqlite3_free(pCsr->aStat);
  sqlite3_free(pCsr);
  return 0;
}
static  int fts3auxGrowStatArray(_1273_Fts3auxCursor *pCsr , int nSize )  {
  if ((nSize > pCsr->nStat)) {
    struct  Fts3auxColstats   *aNew;
    (aNew = ((struct  Fts3auxColstats   *) sqlite3_realloc(pCsr->aStat, (sizeof(struct  Fts3auxColstats   ) * nSize))));
    if ((aNew == 0)) {
      return 7;
    }  
    memset((&aNew[pCsr->nStat]), 0, (sizeof(struct  Fts3auxColstats   ) * (nSize - pCsr->nStat)));
    (pCsr->aStat = aNew);
    (pCsr->nStat = nSize);
  }  
  return 0;
}
static  int fts3auxNextMethod(sqlite3_vtab_cursor *pCursor )  {
  _1273_Fts3auxCursor *pCsr =  ((_1273_Fts3auxCursor *) pCursor);
  _1273_Fts3Table *pFts3 =  ((_1273_Fts3auxTable *) pCursor->pVtab)->pFts3Tab;
  int rc;
  pCsr->iRowid++;
  for (pCsr->iCol++; (pCsr->iCol < pCsr->nStat); pCsr->iCol++) {
    if ((pCsr->aStat[pCsr->iCol].nDoc > 0)) {
      return 0;
    }  
  }
  (rc = sqlite3Fts3SegReaderStep(pFts3, (&pCsr->csr)));
  if ((rc == 100)) {
    int i =  0;
    int nDoclist =  pCsr->csr.nDoclist;
    char *aDoclist =  pCsr->csr.aDoclist;
    int iCol;
    int eState =  0;
    if (pCsr->zStop) {
      int n =  ((pCsr->nStop < pCsr->csr.nTerm) ? pCsr->nStop : pCsr->csr.nTerm);
      int mc =  memcmp(pCsr->zStop, pCsr->csr.zTerm, n);
      if (((mc < 0) || ((mc == 0) && (pCsr->csr.nTerm > pCsr->nStop)))) {
        (pCsr->isEof = 1);
        return 0;
      }  
    }  
    if (fts3auxGrowStatArray(pCsr, 2)) {
      return 7;
    }  
    memset(pCsr->aStat, 0, (sizeof(struct  Fts3auxColstats   ) * pCsr->nStat));
    (iCol = 0);
    while ((i < nDoclist)) {
      sqlite3_int64 v =  0;
      (i += sqlite3Fts3GetVarint((&aDoclist[i]), (&v)));
      switch (eState) {
        case 0:
        pCsr->aStat[0].nDoc++;
        (eState = 1);
        (iCol = 0);
        break;
        case 1:
        ((void ) 0);
        if ((v > 1)) {
          pCsr->aStat[1].nDoc++;
        }  
        (eState = 2);
        case 2:
        if ((v == 0)) {
          (eState = 0);
        } 
        else if ((v == 1)) {
          (eState = 3);
        } 
        else {
          pCsr->aStat[(iCol + 1)].nOcc++;
          pCsr->aStat[0].nOcc++;
        }
        break;
        id2i_label_1:
        default:
        ((void ) 0);
        (iCol = ((int ) v));
        if (fts3auxGrowStatArray(pCsr, (iCol + 2))) {
          return 7;
        }  
        pCsr->aStat[(iCol + 1)].nDoc++;
        (eState = 2);
        break;
      }
    }
    (pCsr->iCol = 0);
    (rc = 0);
  }  
  else {
    (pCsr->isEof = 1);
  }
  return rc;
}
static  int fts3auxFilterMethod(sqlite3_vtab_cursor *pCursor , int idxNum , const  char *idxStr , int nVal , sqlite3_value **apVal )  {
  _1273_Fts3auxCursor *pCsr =  ((_1273_Fts3auxCursor *) pCursor);
  _1273_Fts3Table *pFts3 =  ((_1273_Fts3auxTable *) pCursor->pVtab)->pFts3Tab;
  int rc;
  int isScan =  0;
  int iLangVal =  0;
  int iEq =  (- 1);
  int iGe =  (- 1);
  int iLe =  (- 1);
  int iLangid =  (- 1);
  int iNext =  0;
  ((void ) nVal);
  ((void ) idxStr);
  ((void ) 0);
  ((void ) 0);
  if ((idxNum == 1)) {
    (iEq = iNext++);
  }  
  else {
    (isScan = 1);
    if ((idxNum & 2)) {
      (iGe = iNext++);
    }  
    if ((idxNum & 4)) {
      (iLe = iNext++);
    }  
  }
  if ((iNext < nVal)) {
    (iLangid = iNext++);
  }  
  if (((id2i_sqlite_coverage_test ) )) {
    if (pCsr->filter.zTerm) {
      sqlite3Coverage(127973);
    }  
  }  
  sqlite3Fts3SegReaderFinish((&pCsr->csr));
  sqlite3_free(((void *) pCsr->filter.zTerm));
  sqlite3_free(pCsr->aStat);
  memset((&pCsr->csr), 0, (((u8 *) (&pCsr[1])) - ((u8 *) (&pCsr->csr))));
  (pCsr->filter.flags = (0x00000001 | 0x00000002));
  if (isScan) {
    (pCsr->filter.flags |= 0x00000010);
  }  
  if (((iEq >= 0) || (iGe >= 0))) {
    const unsigned char *zStr =  sqlite3_value_text(apVal[0]);
    ((void ) 0);
    if (zStr) {
      (pCsr->filter.zTerm = sqlite3_mprintf("%s", zStr));
      (pCsr->filter.nTerm = sqlite3_value_bytes(apVal[0]));
      if ((pCsr->filter.zTerm == 0)) {
        return 7;
      }  
    }  
  }  
  if ((iLe >= 0)) {
    (pCsr->zStop = sqlite3_mprintf("%s", sqlite3_value_text(apVal[iLe])));
    (pCsr->nStop = sqlite3_value_bytes(apVal[iLe]));
    if ((pCsr->zStop == 0)) {
      return 7;
    }  
  }  
  if ((iLangid >= 0)) {
    (iLangVal = sqlite3_value_int(apVal[iLangid]));
    if ((iLangVal < 0)) {
      (iLangVal = 0);
    }  
  }  
  (pCsr->iLangid = iLangVal);
  (rc = sqlite3Fts3SegReaderCursor(pFts3, iLangVal, 0, (- 2), pCsr->filter.zTerm, pCsr->filter.nTerm, 0, isScan, (&pCsr->csr)));
  if ((rc == 0)) {
    (rc = sqlite3Fts3SegReaderStart(pFts3, (&pCsr->csr), (&pCsr->filter)));
  }  
  if ((rc == 0)) {
    (rc = fts3auxNextMethod(pCursor));
  }  
  return rc;
}
static  int fts3auxEofMethod(sqlite3_vtab_cursor *pCursor )  {
  _1273_Fts3auxCursor *pCsr =  ((_1273_Fts3auxCursor *) pCursor);
  return pCsr->isEof;
}
static  int fts3auxColumnMethod(sqlite3_vtab_cursor *pCursor , sqlite3_context *pCtx , int iCol )  {
  _1273_Fts3auxCursor *p =  ((_1273_Fts3auxCursor *) pCursor);
  ((void ) 0);
  switch (iCol) {
    case 0:
    sqlite3_result_text(pCtx, p->csr.zTerm, p->csr.nTerm, ((sqlite3_destructor_type ) (- 1)));
    break;
    case 1:
    if (p->iCol) {
      sqlite3_result_int(pCtx, (p->iCol - 1));
    }  
    else {
      sqlite3_result_text(pCtx, "*", (- 1), ((sqlite3_destructor_type ) 0));
    }
    break;
    case 2:
    sqlite3_result_int64(pCtx, p->aStat[p->iCol].nDoc);
    break;
    case 3:
    sqlite3_result_int64(pCtx, p->aStat[p->iCol].nOcc);
    break;
    id2i_label_1:
    default:
    ((void ) 0);
    sqlite3_result_int(pCtx, p->iLangid);
    break;
  }
  return 0;
}
static  int fts3auxRowidMethod(sqlite3_vtab_cursor *pCursor , sqlite_int64 *pRowid )  {
  _1273_Fts3auxCursor *pCsr =  ((_1273_Fts3auxCursor *) pCursor);
  ((*pRowid) = pCsr->iRowid);
  return 0;
}
static  int sqlite3Fts3InitAux(sqlite3 *db )  {
  static const sqlite3_module fts3aux_module =  { 0,  fts3auxConnectMethod,  fts3auxConnectMethod,  fts3auxBestIndexMethod,  fts3auxDisconnectMethod,  fts3auxDisconnectMethod,  fts3auxOpenMethod,  fts3auxCloseMethod,  fts3auxFilterMethod,  fts3auxNextMethod,  fts3auxEofMethod,  fts3auxColumnMethod,  fts3auxRowidMethod,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0};
  int rc;
  (rc = sqlite3_create_module(db, "fts4aux", (&fts3aux_module), 0));
  return rc;
}
typedef struct  _1273_ParseContext   _1273_ParseContext;
struct  _1273_ParseContext {
  _1273_sqlite3_tokenizer *pTokenizer ;
  int iLangid ;
  const  char **azCol ;
  int bFts4 ;
  int nCol ;
  int iDefaultCol ;
  int isNot ;
  sqlite3_context *pCtx ;
  int nNest ;
}  ;
static  int fts3isspace(char c )  {
  return ((c == ' ') || (c == '\t') || (c == '\n') || (c == '\r') || (c == '\v') || (c == '\f'));
}
static  void *fts3MallocZero(int nByte )  {
  void *pRet =  sqlite3_malloc(nByte);
  if (pRet) {
    memset(pRet, 0, nByte);
  }  
  return pRet;
}
static  int sqlite3Fts3OpenTokenizer(_1273_sqlite3_tokenizer *pTokenizer , int iLangid , const  char *z , int n , _1273_sqlite3_tokenizer_cursor **ppCsr )  {
  _1273_sqlite3_tokenizer_module const *pModule =  pTokenizer->pModule;
  _1273_sqlite3_tokenizer_cursor *pCsr =  0;
  int rc;
  (rc = pModule->xOpen(pTokenizer, z, n, (&pCsr)));
  ((void ) 0);
  if ((rc == 0)) {
    (pCsr->pTokenizer = pTokenizer);
    if ((pModule->iVersion >= 1)) {
      (rc = pModule->xLanguageid(pCsr, iLangid));
      if ((rc != 0)) {
        pModule->xClose(pCsr);
        (pCsr = 0);
      }  
    }  
  }  
  ((*ppCsr) = pCsr);
  return rc;
}
static  int getNextToken(_1273_ParseContext *pParse , int iCol , const  char *z , int n , _1273_Fts3Expr **ppExpr , int *pnConsumed )  {
  _1273_sqlite3_tokenizer *pTokenizer =  pParse->pTokenizer;
  _1273_sqlite3_tokenizer_module const *pModule =  pTokenizer->pModule;
  int rc;
  _1273_sqlite3_tokenizer_cursor *pCursor;
  _1273_Fts3Expr *pRet =  0;
  int nConsumed =  0;
  (rc = sqlite3Fts3OpenTokenizer(pTokenizer, pParse->iLangid, z, n, (&pCursor)));
  if ((rc == 0)) {
    const char *zToken;
    int nToken =  0, iStart =  0, iEnd =  0, iPosition =  0;
    int nByte;
    (rc = pModule->xNext(pCursor, (&zToken), (&nToken), (&iStart), (&iEnd), (&iPosition)));
    if ((rc == 0)) {
      (nByte = (sizeof(_1273_Fts3Expr ) + sizeof(_1273_Fts3Phrase ) + nToken));
      (pRet = ((_1273_Fts3Expr *) fts3MallocZero(nByte)));
      if ((! pRet)) {
        (rc = 7);
      }  
      else {
        (pRet->eType = 5);
        (pRet->pPhrase = ((_1273_Fts3Phrase *) (&pRet[1])));
        (pRet->pPhrase->nToken = 1);
        (pRet->pPhrase->iColumn = iCol);
        (pRet->pPhrase->aToken[0].n = nToken);
        (pRet->pPhrase->aToken[0].z = ((char *) (&pRet->pPhrase[1])));
        memcpy(pRet->pPhrase->aToken[0].z, zToken, nToken);
        if (((iEnd < n) && (z[iEnd] == '*'))) {
          (pRet->pPhrase->aToken[0].isPrefix = 1);
          iEnd++;
        }  
        while (1) {
          if (((! 0) && (iStart > 0) && (z[(iStart - 1)] == '-'))) {
            (pParse->isNot = 1);
            iStart--;
          } 
          else if ((pParse->bFts4 && (iStart > 0) && (z[(iStart - 1)] == '^'))) {
            (pRet->pPhrase->aToken[0].bFirst = 1);
            iStart--;
          } 
          else {
            break;
          }
        }
      }
      (nConsumed = iEnd);
    }  
    pModule->xClose(pCursor);
  }  
  ((*pnConsumed) = nConsumed);
  ((*ppExpr) = pRet);
  return rc;
}
static  void *fts3ReallocOrFree(void *pOrig , int nNew )  {
  void *pRet =  sqlite3_realloc(pOrig, nNew);
  if ((! pRet)) {
    sqlite3_free(pOrig);
  }  
  return pRet;
}
static  int getNextString(_1273_ParseContext *pParse , const  char *zInput , int nInput , _1273_Fts3Expr **ppExpr )  {
  _1273_sqlite3_tokenizer *pTokenizer =  pParse->pTokenizer;
  _1273_sqlite3_tokenizer_module const *pModule =  pTokenizer->pModule;
  int rc;
  _1273_Fts3Expr *p =  0;
  _1273_sqlite3_tokenizer_cursor *pCursor =  0;
  char *zTemp =  0;
  int nTemp =  0;
  const int nSpace =  (sizeof(_1273_Fts3Expr ) + sizeof(_1273_Fts3Phrase ));
  int nToken =  0;
  (rc = sqlite3Fts3OpenTokenizer(pTokenizer, pParse->iLangid, zInput, nInput, (&pCursor)));
  if ((rc == 0)) {
    int ii;
    for ((ii = 0); (rc == 0); ii++) {
      const char *zByte;
      int nByte =  0, iBegin =  0, iEnd =  0, iPos =  0;
      (rc = pModule->xNext(pCursor, (&zByte), (&nByte), (&iBegin), (&iEnd), (&iPos)));
      if ((rc == 0)) {
        _1273_Fts3PhraseToken *pToken;
        (p = fts3ReallocOrFree(p, (nSpace + (ii * sizeof(_1273_Fts3PhraseToken )))));
        if ((! p)) {
          goto _1273_no_mem;
        }  
        (zTemp = fts3ReallocOrFree(zTemp, (nTemp + nByte)));
        if ((! zTemp)) {
          goto _1273_no_mem;
        }  
        ((void ) 0);
        (pToken = (&((_1273_Fts3Phrase *) (&p[1]))->aToken[ii]));
        memset(pToken, 0, sizeof(_1273_Fts3PhraseToken ));
        memcpy((&zTemp[nTemp]), zByte, nByte);
        (nTemp += nByte);
        (pToken->n = nByte);
        (pToken->isPrefix = ((iEnd < nInput) && (zInput[iEnd] == '*')));
        (pToken->bFirst = ((iBegin > 0) && (zInput[(iBegin - 1)] == '^')));
        (nToken = (ii + 1));
      }  
    }
    pModule->xClose(pCursor);
    (pCursor = 0);
  }  
  if ((rc == 101)) {
    int jj;
    char *zBuf =  0;
    (p = fts3ReallocOrFree(p, (nSpace + (nToken * sizeof(_1273_Fts3PhraseToken )) + nTemp)));
    if ((! p)) {
      goto _1273_no_mem;
    }  
    memset(p, 0, (((char *) (&((_1273_Fts3Phrase *) (&p[1]))->aToken[0])) - ((char *) p)));
    (p->eType = 5);
    (p->pPhrase = ((_1273_Fts3Phrase *) (&p[1])));
    (p->pPhrase->iColumn = pParse->iDefaultCol);
    (p->pPhrase->nToken = nToken);
    (zBuf = ((char *) (&p->pPhrase->aToken[nToken])));
    if (zTemp) {
      memcpy(zBuf, zTemp, nTemp);
      sqlite3_free(zTemp);
    }  
    else {
      ((void ) 0);
    }
    for ((jj = 0); (jj < p->pPhrase->nToken); jj++) {
      (p->pPhrase->aToken[jj].z = zBuf);
      (zBuf += p->pPhrase->aToken[jj].n);
    }
    (rc = 0);
  }  
  ((*ppExpr) = p);
  return rc;
  _1273_no_mem:
  if (pCursor) {
    pModule->xClose(pCursor);
  }  
  sqlite3_free(zTemp);
  sqlite3_free(p);
  ((*ppExpr) = 0);
  return 7;
}
static int fts3ExprParse(_1273_ParseContext * , const  char * , int , _1273_Fts3Expr ** , int * );
static  int getNextNode(_1273_ParseContext *pParse , const  char *z , int n , _1273_Fts3Expr **ppExpr , int *pnConsumed )  {
  static const struct  Fts3Keyword {
    char *z ;
    unsigned  char n ;
    unsigned  char parenOnly ;
    unsigned  char eType ;
  }  aKeyword[] =  { { "OR",  2,  0,  4},  { "AND",  3,  1,  3},  { "NOT",  3,  1,  2},  { "NEAR",  4,  0,  1}};
  int ii;
  int iCol;
  int iColLen;
  int rc;
  _1273_Fts3Expr *pRet =  0;
  const char *zInput =  z;
  int nInput =  n;
  (pParse->isNot = 0);
  while (((nInput > 0) && fts3isspace((*zInput)))) {
    nInput--;
    zInput++;
  }
  if ((nInput == 0)) {
    return 101;
  }  
  for ((ii = 0); (ii < ((int ) (sizeof(aKeyword) / sizeof(struct  Fts3Keyword   )))); ii++) {
    const struct  Fts3Keyword   *pKey =  (&aKeyword[ii]);
    if (((pKey->parenOnly & (~ 0)) != 0)) {
      continue;
    }  
    if (((nInput >= pKey->n) && (0 == memcmp(zInput, pKey->z, pKey->n)))) {
      int nNear =  10;
      int nKey =  pKey->n;
      char cNext;
      if ((pKey->eType == 1)) {
        ((void ) 0);
        if (((zInput[4] == '/') && (zInput[5] >= '0') && (zInput[5] <= '9'))) {
          (nNear = 0);
          for ((nKey = 5); ((zInput[nKey] >= '0') && (zInput[nKey] <= '9')); nKey++) {
            (nNear = ((nNear * 10) + (zInput[nKey] - '0')));
          }
        }  
      }  
      (cNext = zInput[nKey]);
      if ((fts3isspace(cNext) || (cNext == '"') || (cNext == '(') || (cNext == ')') || (cNext == 0))) {
        (pRet = ((_1273_Fts3Expr *) fts3MallocZero(sizeof(_1273_Fts3Expr ))));
        if ((! pRet)) {
          return 7;
        }  
        (pRet->eType = pKey->eType);
        (pRet->nNear = nNear);
        ((*ppExpr) = pRet);
        ((*pnConsumed) = ((int ) ((zInput - z) + nKey)));
        return 0;
      }  
    }  
  }
  if (0) {
    if (((*zInput) == '(')) {
      int nConsumed;
      pParse->nNest++;
      (rc = fts3ExprParse(pParse, (&zInput[1]), (nInput - 1), ppExpr, (&nConsumed)));
      if (((rc == 0) && (! (*ppExpr)))) {
        (rc = 101);
      }  
      ((*pnConsumed) = ((int ) ((zInput - z) + 1 + nConsumed)));
      return rc;
    }  
    if (((*zInput) == ')')) {
      pParse->nNest--;
      ((*pnConsumed) = ((int ) ((zInput - z) + 1)));
      return 101;
    }  
  }  
  if (((*zInput) == '"')) {
    for ((ii = 1); ((ii < nInput) && (zInput[ii] != '"')); ii++) {
      
    }
    ((*pnConsumed) = ((int ) ((zInput - z) + ii + 1)));
    if ((ii == nInput)) {
      return 1;
    }  
    return getNextString(pParse, (&zInput[1]), (ii - 1), ppExpr);
  }  
  (iCol = pParse->iDefaultCol);
  (iColLen = 0);
  for ((ii = 0); (ii < pParse->nCol); ii++) {
    const char *zStr =  pParse->azCol[ii];
    int nStr =  ((int ) strlen(zStr));
    if (((nInput > nStr) && (zInput[nStr] == ':') && (sqlite3_strnicmp(zStr, zInput, nStr) == 0))) {
      (iCol = ii);
      (iColLen = ((int ) ((zInput - z) + nStr + 1)));
      break;
    }  
  }
  (rc = getNextToken(pParse, iCol, (&z[iColLen]), (n - iColLen), ppExpr, pnConsumed));
  ((*pnConsumed) += iColLen);
  return rc;
}
static  int opPrecedence(_1273_Fts3Expr *p )  {
  ((void ) 0);
  if (0) {
    return p->eType;
  } 
  else if ((p->eType == 1)) {
    return 1;
  }
  
  else if ((p->eType == 4)) {
    return 2;
  } 
  ((void ) 0);
  return 3;
}
static  void insertBinaryOperator(_1273_Fts3Expr **ppHead , _1273_Fts3Expr *pPrev , _1273_Fts3Expr *pNew )  {
  _1273_Fts3Expr *pSplit =  pPrev;
  while ((pSplit->pParent && (opPrecedence(pSplit->pParent) <= opPrecedence(pNew)))) {
    (pSplit = pSplit->pParent);
  }
  if (pSplit->pParent) {
    ((void ) 0);
    (pSplit->pParent->pRight = pNew);
    (pNew->pParent = pSplit->pParent);
  }  
  else {
    ((*ppHead) = pNew);
  }
  (pNew->pLeft = pSplit);
  (pSplit->pParent = pNew);
}
static  int fts3ExprParse(_1273_ParseContext *pParse , const  char *z , int n , _1273_Fts3Expr **ppExpr , int *pnConsumed )  {
  _1273_Fts3Expr *pRet =  0;
  _1273_Fts3Expr *pPrev =  0;
  _1273_Fts3Expr *pNotBranch =  0;
  int nIn =  n;
  const char *zIn =  z;
  int rc =  0;
  int isRequirePhrase =  1;
  while ((rc == 0)) {
    _1273_Fts3Expr *p =  0;
    int nByte =  0;
    (rc = getNextNode(pParse, zIn, nIn, (&p), (&nByte)));
    if ((rc == 0)) {
      int isPhrase;
      if (((! 0) && (p->eType == 5) && pParse->isNot)) {
        _1273_Fts3Expr *pNot =  fts3MallocZero(sizeof(_1273_Fts3Expr ));
        if ((! pNot)) {
          sqlite3Fts3ExprFree(p);
          (rc = 7);
          goto _1273_exprparse_out;
        }  
        (pNot->eType = 2);
        (pNot->pRight = p);
        (p->pParent = pNot);
        if (pNotBranch) {
          (pNot->pLeft = pNotBranch);
          (pNotBranch->pParent = pNot);
        }  
        (pNotBranch = pNot);
        (p = pPrev);
      }  
      else {
        int eType =  p->eType;
        (isPhrase = ((eType == 5) || p->pLeft));
        if (((! isPhrase) && isRequirePhrase)) {
          sqlite3Fts3ExprFree(p);
          (rc = 1);
          goto _1273_exprparse_out;
        }  
        if ((isPhrase && (! isRequirePhrase))) {
          _1273_Fts3Expr *pAnd;
          ((void ) 0);
          (pAnd = fts3MallocZero(sizeof(_1273_Fts3Expr )));
          if ((! pAnd)) {
            sqlite3Fts3ExprFree(p);
            (rc = 7);
            goto _1273_exprparse_out;
          }  
          (pAnd->eType = 3);
          insertBinaryOperator((&pRet), pPrev, pAnd);
          (pPrev = pAnd);
        }  
        if ((pPrev && (((eType == 1) && (! isPhrase) && (pPrev->eType != 5)) || ((eType != 5) && isPhrase && (pPrev->eType == 1))))) {
          sqlite3Fts3ExprFree(p);
          (rc = 1);
          goto _1273_exprparse_out;
        }  
        if (isPhrase) {
          if (pRet) {
            ((void ) 0);
            (pPrev->pRight = p);
            (p->pParent = pPrev);
          }  
          else {
            (pRet = p);
          }
        }  
        else {
          insertBinaryOperator((&pRet), pPrev, p);
        }
        (isRequirePhrase = (! isPhrase));
      }
      ((void ) 0);
    }  
    ((void ) 0);
    (nIn -= nByte);
    (zIn += nByte);
    (pPrev = p);
  }
  if (((rc == 101) && pRet && isRequirePhrase)) {
    (rc = 1);
  }  
  if ((rc == 101)) {
    (rc = 0);
    if (((! 0) && pNotBranch)) {
      if ((! pRet)) {
        (rc = 1);
      }  
      else {
        _1273_Fts3Expr *pIter =  pNotBranch;
        while (pIter->pLeft) {
          (pIter = pIter->pLeft);
        }
        (pIter->pLeft = pRet);
        (pRet->pParent = pIter);
        (pRet = pNotBranch);
      }
    }  
  }  
  ((*pnConsumed) = (n - nIn));
  _1273_exprparse_out:
  if ((rc != 0)) {
    sqlite3Fts3ExprFree(pRet);
    sqlite3Fts3ExprFree(pNotBranch);
    (pRet = 0);
  }  
  ((*ppExpr) = pRet);
  return rc;
}
static  int fts3ExprCheckDepth(_1273_Fts3Expr *p , int nMaxDepth )  {
  int rc =  0;
  if (p) {
    if ((nMaxDepth < 0)) {
      (rc = 18);
    }  
    else {
      (rc = fts3ExprCheckDepth(p->pLeft, (nMaxDepth - 1)));
      if ((rc == 0)) {
        (rc = fts3ExprCheckDepth(p->pRight, (nMaxDepth - 1)));
      }  
    }
  }  
  return rc;
}
static  int fts3ExprBalance(_1273_Fts3Expr **pp , int nMaxDepth )  {
  int rc =  0;
  _1273_Fts3Expr *pRoot =  (*pp);
  _1273_Fts3Expr *pFree =  0;
  int eType =  pRoot->eType;
  if ((nMaxDepth == 0)) {
    (rc = 1);
  }  
  if (((rc == 0) && ((eType == 3) || (eType == 4)))) {
    _1273_Fts3Expr **apLeaf;
    (apLeaf = ((_1273_Fts3Expr **) sqlite3_malloc((sizeof(_1273_Fts3Expr *) * nMaxDepth))));
    if ((0 == apLeaf)) {
      (rc = 7);
    }  
    else {
      memset(apLeaf, 0, (sizeof(_1273_Fts3Expr *) * nMaxDepth));
    }
    if ((rc == 0)) {
      int i;
      _1273_Fts3Expr *p;
      for ((p = pRoot); (p->eType == eType); (p = p->pLeft)) {
        ((void ) 0);
        ((void ) 0);
      }
      while (1) {
        int iLvl;
        _1273_Fts3Expr *pParent =  p->pParent;
        ((void ) 0);
        (p->pParent = 0);
        if (pParent) {
          (pParent->pLeft = 0);
        }  
        else {
          (pRoot = 0);
        }
        (rc = fts3ExprBalance((&p), (nMaxDepth - 1)));
        if ((rc != 0)) {
          break;
        }  
        for ((iLvl = 0); (p && (iLvl < nMaxDepth)); iLvl++) {
          if ((apLeaf[iLvl] == 0)) {
            (apLeaf[iLvl] = p);
            (p = 0);
          }  
          else {
            ((void ) 0);
            (pFree->pLeft = apLeaf[iLvl]);
            (pFree->pRight = p);
            (pFree->pLeft->pParent = pFree);
            (pFree->pRight->pParent = pFree);
            (p = pFree);
            (pFree = pFree->pParent);
            (p->pParent = 0);
            (apLeaf[iLvl] = 0);
          }
        }
        if (p) {
          sqlite3Fts3ExprFree(p);
          (rc = 18);
          break;
        }  
        if ((pParent == 0)) {
          break;
        }  
        for ((p = pParent->pRight); (p->eType == eType); (p = p->pLeft)) {
          
        }
        ((void ) 0);
        (pParent->pRight->pParent = pParent->pParent);
        if (pParent->pParent) {
          (pParent->pParent->pLeft = pParent->pRight);
        }  
        else {
          ((void ) 0);
          (pRoot = pParent->pRight);
        }
        (pParent->pParent = pFree);
        (pFree = pParent);
      }
      if ((rc == 0)) {
        (p = 0);
        for ((i = 0); (i < nMaxDepth); i++) {
          if (apLeaf[i]) {
            if ((p == 0)) {
              (p = apLeaf[i]);
              (p->pParent = 0);
            }  
            else {
              ((void ) 0);
              (pFree->pRight = p);
              (pFree->pLeft = apLeaf[i]);
              (pFree->pLeft->pParent = pFree);
              (pFree->pRight->pParent = pFree);
              (p = pFree);
              (pFree = pFree->pParent);
              (p->pParent = 0);
            }
          }  
        }
        (pRoot = p);
      }  
      else {
        _1273_Fts3Expr *pDel;
        for ((i = 0); (i < nMaxDepth); i++) {
          sqlite3Fts3ExprFree(apLeaf[i]);
        }
        while (((pDel = pFree) != 0)) {
          (pFree = pDel->pParent);
          sqlite3_free(pDel);
        }
      }
      ((void ) 0);
      sqlite3_free(apLeaf);
    }  
  }  
  if ((rc != 0)) {
    sqlite3Fts3ExprFree(pRoot);
    (pRoot = 0);
  }  
  ((*pp) = pRoot);
  return rc;
}
static  int fts3ExprParseUnbalanced(_1273_sqlite3_tokenizer *pTokenizer , int iLangid , char **azCol , int bFts4 , int nCol , int iDefaultCol , const  char *z , int n , _1273_Fts3Expr **ppExpr )  {
  int nParsed;
  int rc;
  _1273_ParseContext sParse;
  memset((&sParse), 0, sizeof(_1273_ParseContext ));
  (sParse.pTokenizer = pTokenizer);
  (sParse.iLangid = iLangid);
  (sParse.azCol = ((const  char **) azCol));
  (sParse.nCol = nCol);
  (sParse.iDefaultCol = iDefaultCol);
  (sParse.bFts4 = bFts4);
  if ((z == 0)) {
    ((*ppExpr) = 0);
    return 0;
  }  
  if ((n < 0)) {
    (n = ((int ) strlen(z)));
  }  
  (rc = fts3ExprParse((&sParse), z, n, ppExpr, (&nParsed)));
  ((void ) 0);
  if (((rc == 0) && sParse.nNest)) {
    (rc = 1);
  }  
  return rc;
}
static  int sqlite3Fts3ExprParse(_1273_sqlite3_tokenizer *pTokenizer , int iLangid , char **azCol , int bFts4 , int nCol , int iDefaultCol , const  char *z , int n , _1273_Fts3Expr **ppExpr , char **pzErr )  {
  int rc =  fts3ExprParseUnbalanced(pTokenizer, iLangid, azCol, bFts4, nCol, iDefaultCol, z, n, ppExpr);
  if (((rc == 0) && (*ppExpr))) {
    (rc = fts3ExprBalance(ppExpr, 12));
    if ((rc == 0)) {
      (rc = fts3ExprCheckDepth((*ppExpr), 12));
    }  
  }  
  if ((rc != 0)) {
    sqlite3Fts3ExprFree((*ppExpr));
    ((*ppExpr) = 0);
    if ((rc == 18)) {
      ((*pzErr) = sqlite3_mprintf("FTS expression tree is too large (maximum depth %d)", 12));
      (rc = 1);
    } 
    else if ((rc == 1)) {
      ((*pzErr) = sqlite3_mprintf("malformed MATCH expression: [%s]", z));
    } 
  }  
  return rc;
}
static  void fts3FreeExprNode(_1273_Fts3Expr *p )  {
  ((void ) 0);
  sqlite3Fts3EvalPhraseCleanup(p->pPhrase);
  sqlite3_free(p->aMI);
  sqlite3_free(p);
}
static  void sqlite3Fts3ExprFree(_1273_Fts3Expr *pDel )  {
  _1273_Fts3Expr *p;
  ((void ) 0);
  for ((p = pDel); (p && (p->pLeft || p->pRight)); (p = (p->pLeft ? p->pLeft : p->pRight))) {
    ((void ) 0);
  }
  while (p) {
    _1273_Fts3Expr *pParent =  p->pParent;
    fts3FreeExprNode(p);
    if ((pParent && (p == pParent->pLeft) && pParent->pRight)) {
      (p = pParent->pRight);
      while ((p && (p->pLeft || p->pRight))) {
        ((void ) 0);
        (p = (p->pLeft ? p->pLeft : p->pRight));
      }
    }  
    else {
      (p = pParent);
    }
  }
}
static  void *fts3HashMalloc(int n )  {
  void *p =  sqlite3_malloc(n);
  if (p) {
    memset(p, 0, n);
  }  
  return p;
}
static  void fts3HashFree(void *p )  {
  sqlite3_free(p);
}
static  void sqlite3Fts3HashInit(_1273_Fts3Hash *pNew , char keyClass , char copyKey )  {
  ((void ) 0);
  ((void ) 0);
  (pNew->keyClass = keyClass);
  (pNew->copyKey = copyKey);
  (pNew->first = 0);
  (pNew->count = 0);
  (pNew->htsize = 0);
  (pNew->ht = 0);
}
static  void sqlite3Fts3HashClear(_1273_Fts3Hash *pH )  {
  _1273_Fts3HashElem *elem;
  ((void ) 0);
  (elem = pH->first);
  (pH->first = 0);
  fts3HashFree(pH->ht);
  (pH->ht = 0);
  (pH->htsize = 0);
  while (elem) {
    _1273_Fts3HashElem *next_elem =  elem->next;
    if ((pH->copyKey && elem->pKey)) {
      fts3HashFree(elem->pKey);
    }  
    fts3HashFree(elem);
    (elem = next_elem);
  }
  (pH->count = 0);
}
static  int fts3StrHash(const  void *pKey , int nKey )  {
  const char *z =  ((const  char *) pKey);
  int h =  0;
  if ((nKey <= 0)) {
    (nKey = ((int ) strlen(z)));
  }  
  while ((nKey > 0)) {
    (h = ((h << 3) ^ h ^ (*z++)));
    nKey--;
  }
  return (h & 0x7fffffff);
}
static  int fts3StrCompare(const  void *pKey1 , int n1 , const  void *pKey2 , int n2 )  {
  if ((n1 != n2)) {
    return 1;
  }  
  return strncmp(((const  char *) pKey1), ((const  char *) pKey2), n1);
}
static  int fts3BinHash(const  void *pKey , int nKey )  {
  int h =  0;
  const char *z =  ((const  char *) pKey);
  while ((nKey-- > 0)) {
    (h = ((h << 3) ^ h ^ (*z++)));
  }
  return (h & 0x7fffffff);
}
static  int fts3BinCompare(const  void *pKey1 , int n1 , const  void *pKey2 , int n2 )  {
  if ((n1 != n2)) {
    return 1;
  }  
  return memcmp(pKey1, pKey2, n1);
}
static  int ( *ftsHashFunction(int keyClass ))(const  void * , int )  {
  if ((keyClass == 1)) {
    return (&fts3StrHash);
  }  
  else {
    ((void ) 0);
    return (&fts3BinHash);
  }
}
static  int ( *ftsCompareFunction(int keyClass ))(const  void * , int , const  void * , int )  {
  if ((keyClass == 1)) {
    return (&fts3StrCompare);
  }  
  else {
    ((void ) 0);
    return (&fts3BinCompare);
  }
}
static  void fts3HashInsertElement(_1273_Fts3Hash *pH , struct  _fts3ht   *pEntry , _1273_Fts3HashElem *pNew )  {
  _1273_Fts3HashElem *pHead;
  (pHead = pEntry->chain);
  if (pHead) {
    (pNew->next = pHead);
    (pNew->prev = pHead->prev);
    if (pHead->prev) {
      (pHead->prev->next = pNew);
    }  
    else {
      (pH->first = pNew);
    }
    (pHead->prev = pNew);
  }  
  else {
    (pNew->next = pH->first);
    if (pH->first) {
      (pH->first->prev = pNew);
    }  
    (pNew->prev = 0);
    (pH->first = pNew);
  }
  pEntry->count++;
  (pEntry->chain = pNew);
}
static  int fts3Rehash(_1273_Fts3Hash *pH , int new_size )  {
  struct  _fts3ht   *new_ht;
  _1273_Fts3HashElem *elem, *next_elem;
  int ( *xHash)(const  void * , int );
  ((void ) 0);
  (new_ht = ((struct  _fts3ht   *) fts3HashMalloc((new_size * sizeof(struct  _fts3ht   )))));
  if ((new_ht == 0)) {
    return 1;
  }  
  fts3HashFree(pH->ht);
  (pH->ht = new_ht);
  (pH->htsize = new_size);
  (xHash = ftsHashFunction(pH->keyClass));
  for ((elem = pH->first), (pH->first = 0); elem; (elem = next_elem)) {
    int h =  ((*xHash)(elem->pKey, elem->nKey) & (new_size - 1));
    (next_elem = elem->next);
    fts3HashInsertElement(pH, (&new_ht[h]), elem);
  }
  return 0;
}
static  _1273_Fts3HashElem *fts3FindElementByHash(const  _1273_Fts3Hash *pH , const  void *pKey , int nKey , int h )  {
  _1273_Fts3HashElem *elem;
  int count;
  int ( *xCompare)(const  void * , int , const  void * , int );
  if (pH->ht) {
    struct  _fts3ht   *pEntry =  (&pH->ht[h]);
    (elem = pEntry->chain);
    (count = pEntry->count);
    (xCompare = ftsCompareFunction(pH->keyClass));
    while ((count-- && elem)) {
      if (((*xCompare)(elem->pKey, elem->nKey, pKey, nKey) == 0)) {
        return elem;
      }  
      (elem = elem->next);
    }
  }  
  return 0;
}
static  void fts3RemoveElementByHash(_1273_Fts3Hash *pH , _1273_Fts3HashElem *elem , int h )  {
  struct  _fts3ht   *pEntry;
  if (elem->prev) {
    (elem->prev->next = elem->next);
  }  
  else {
    (pH->first = elem->next);
  }
  if (elem->next) {
    (elem->next->prev = elem->prev);
  }  
  (pEntry = (&pH->ht[h]));
  if ((pEntry->chain == elem)) {
    (pEntry->chain = elem->next);
  }  
  pEntry->count--;
  if ((pEntry->count <= 0)) {
    (pEntry->chain = 0);
  }  
  if ((pH->copyKey && elem->pKey)) {
    fts3HashFree(elem->pKey);
  }  
  fts3HashFree(elem);
  pH->count--;
  if ((pH->count <= 0)) {
    ((void ) 0);
    ((void ) 0);
    sqlite3Fts3HashClear(pH);
  }  
}
static  _1273_Fts3HashElem *sqlite3Fts3HashFindElem(const  _1273_Fts3Hash *pH , const  void *pKey , int nKey )  {
  int h;
  int ( *xHash)(const  void * , int );
  if (((pH == 0) || (pH->ht == 0))) {
    return 0;
  }  
  (xHash = ftsHashFunction(pH->keyClass));
  ((void ) 0);
  (h = (*xHash)(pKey, nKey));
  ((void ) 0);
  return fts3FindElementByHash(pH, pKey, nKey, (h & (pH->htsize - 1)));
}
static  void *sqlite3Fts3HashFind(const  _1273_Fts3Hash *pH , const  void *pKey , int nKey )  {
  _1273_Fts3HashElem *pElem;
  (pElem = sqlite3Fts3HashFindElem(pH, pKey, nKey));
  return (pElem ? pElem->data : 0);
}
static  void *sqlite3Fts3HashInsert(_1273_Fts3Hash *pH , const  void *pKey , int nKey , void *data )  {
  int hraw;
  int h;
  _1273_Fts3HashElem *elem;
  _1273_Fts3HashElem *new_elem;
  int ( *xHash)(const  void * , int );
  ((void ) 0);
  (xHash = ftsHashFunction(pH->keyClass));
  ((void ) 0);
  (hraw = (*xHash)(pKey, nKey));
  ((void ) 0);
  (h = (hraw & (pH->htsize - 1)));
  (elem = fts3FindElementByHash(pH, pKey, nKey, h));
  if (elem) {
    void *old_data =  elem->data;
    if ((data == 0)) {
      fts3RemoveElementByHash(pH, elem, h);
    }  
    else {
      (elem->data = data);
    }
    return old_data;
  }  
  if ((data == 0)) {
    return 0;
  }  
  if ((((pH->htsize == 0) && fts3Rehash(pH, 8)) || ((pH->count >= pH->htsize) && fts3Rehash(pH, (pH->htsize * 2))))) {
    (pH->count = 0);
    return data;
  }  
  ((void ) 0);
  (new_elem = ((_1273_Fts3HashElem *) fts3HashMalloc(sizeof(_1273_Fts3HashElem ))));
  if ((new_elem == 0)) {
    return data;
  }  
  if ((pH->copyKey && (pKey != 0))) {
    (new_elem->pKey = fts3HashMalloc(nKey));
    if ((new_elem->pKey == 0)) {
      fts3HashFree(new_elem);
      return data;
    }  
    memcpy(((void *) new_elem->pKey), pKey, nKey);
  }  
  else {
    (new_elem->pKey = ((void *) pKey));
  }
  (new_elem->nKey = nKey);
  pH->count++;
  ((void ) 0);
  ((void ) 0);
  (h = (hraw & (pH->htsize - 1)));
  fts3HashInsertElement(pH, (&pH->ht[h]), new_elem);
  (new_elem->data = data);
  return 0;
}
typedef struct  _1273_porter_tokenizer {
  _1273_sqlite3_tokenizer base ;
}  _1273_porter_tokenizer;
typedef struct  _1273_porter_tokenizer_cursor {
  _1273_sqlite3_tokenizer_cursor base ;
  const  char *zInput ;
  int nInput ;
  int iOffset ;
  int iToken ;
  char *zToken ;
  int nAllocated ;
}  _1273_porter_tokenizer_cursor;
static  int porterCreate(int argc , const  char *const *argv , _1273_sqlite3_tokenizer **ppTokenizer )  {
  _1273_porter_tokenizer *t;
  ((void ) argc);
  ((void ) argv);
  (t = ((_1273_porter_tokenizer *) sqlite3_malloc(sizeof((*t)))));
  if ((t == ((void *) 0))) {
    return 7;
  }  
  memset(t, 0, sizeof((*t)));
  ((*ppTokenizer) = (&t->base));
  return 0;
}
static  int porterDestroy(_1273_sqlite3_tokenizer *pTokenizer )  {
  sqlite3_free(pTokenizer);
  return 0;
}
static  int porterOpen(_1273_sqlite3_tokenizer *pTokenizer , const  char *zInput , int nInput , _1273_sqlite3_tokenizer_cursor **ppCursor )  {
  _1273_porter_tokenizer_cursor *c;
  ((void ) pTokenizer);
  (c = ((_1273_porter_tokenizer_cursor *) sqlite3_malloc(sizeof((*c)))));
  if ((c == ((void *) 0))) {
    return 7;
  }  
  (c->zInput = zInput);
  if ((zInput == 0)) {
    (c->nInput = 0);
  } 
  else if ((nInput < 0)) {
    (c->nInput = ((int ) strlen(zInput)));
  } 
  else {
    (c->nInput = nInput);
  }
  (c->iOffset = 0);
  (c->iToken = 0);
  (c->zToken = ((void *) 0));
  (c->nAllocated = 0);
  ((*ppCursor) = (&c->base));
  return 0;
}
static  int porterClose(_1273_sqlite3_tokenizer_cursor *pCursor )  {
  _1273_porter_tokenizer_cursor *c =  ((_1273_porter_tokenizer_cursor *) pCursor);
  sqlite3_free(c->zToken);
  sqlite3_free(c);
  return 0;
}
static const char cType[] =  { 0,  1,  1,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  2,  1};
static int isVowel(const  char * );
static  int isConsonant(const  char *z )  {
  int j;
  char x =  (*z);
  if ((x == 0)) {
    return 0;
  }  
  ((void ) 0);
  (j = cType[(x - 'a')]);
  if ((j < 2)) {
    return j;
  }  
  return ((z[1] == 0) || isVowel((z + 1)));
}
static  int isVowel(const  char *z )  {
  int j;
  char x =  (*z);
  if ((x == 0)) {
    return 0;
  }  
  ((void ) 0);
  (j = cType[(x - 'a')]);
  if ((j < 2)) {
    return (1 - j);
  }  
  return isConsonant((z + 1));
}
static  int m_gt_0(const  char *z )  {
  while (isVowel(z)) {
    z++;
  }
  if (((*z) == 0)) {
    return 0;
  }  
  while (isConsonant(z)) {
    z++;
  }
  return ((*z) != 0);
}
static  int m_eq_1(const  char *z )  {
  while (isVowel(z)) {
    z++;
  }
  if (((*z) == 0)) {
    return 0;
  }  
  while (isConsonant(z)) {
    z++;
  }
  if (((*z) == 0)) {
    return 0;
  }  
  while (isVowel(z)) {
    z++;
  }
  if (((*z) == 0)) {
    return 1;
  }  
  while (isConsonant(z)) {
    z++;
  }
  return ((*z) == 0);
}
static  int m_gt_1(const  char *z )  {
  while (isVowel(z)) {
    z++;
  }
  if (((*z) == 0)) {
    return 0;
  }  
  while (isConsonant(z)) {
    z++;
  }
  if (((*z) == 0)) {
    return 0;
  }  
  while (isVowel(z)) {
    z++;
  }
  if (((*z) == 0)) {
    return 0;
  }  
  while (isConsonant(z)) {
    z++;
  }
  return ((*z) != 0);
}
static  int hasVowel(const  char *z )  {
  while (isConsonant(z)) {
    z++;
  }
  return ((*z) != 0);
}
static  int doubleConsonant(const  char *z )  {
  return (isConsonant(z) && (z[0] == z[1]));
}
static  int star_oh(const  char *z )  {
  return (isConsonant(z) && (z[0] != 'w') && (z[0] != 'x') && (z[0] != 'y') && isVowel((z + 1)) && isConsonant((z + 2)));
}
static  int stem(char **pz , const  char *zFrom , const  char *zTo , int ( *xCond)(const  char * ) )  {
  char *z =  (*pz);
  while (((*zFrom) && ((*zFrom) == (*z)))) {
    z++;
    zFrom++;
  }
  if (((*zFrom) != 0)) {
    return 0;
  }  
  if ((xCond && (! xCond(z)))) {
    return 1;
  }  
  while ((*zTo)) {
    ((*--z) = (*zTo++));
  }
  ((*pz) = z);
  return 1;
}
static  void copy_stemmer(const  char *zIn , int nIn , char *zOut , int *pnOut )  {
  int i, mx, j;
  int hasDigit =  0;
  for ((i = 0); (i < nIn); i++) {
    char c =  zIn[i];
    if (((c >= 'A') && (c <= 'Z'))) {
      (zOut[i] = (c - 'A' + 'a'));
    }  
    else {
      if (((c >= '0') && (c <= '9'))) {
        (hasDigit = 1);
      }  
      (zOut[i] = c);
    }
  }
  (mx = (hasDigit ? 3 : 10));
  if ((nIn > (mx * 2))) {
    for ((j = mx), (i = (nIn - mx)); (i < nIn); i++, j++) {
      (zOut[j] = zOut[i]);
    }
    (i = j);
  }  
  (zOut[i] = 0);
  ((*pnOut) = i);
}
static  void porter_stemmer(const  char *zIn , int nIn , char *zOut , int *pnOut )  {
  int i, j;
  char zReverse[28];
  char *z, *z2;
  if (((nIn < 3) || (nIn >= (((int ) sizeof(zReverse)) - 7)))) {
    copy_stemmer(zIn, nIn, zOut, pnOut);
    return;
  }  
  for ((i = 0), (j = (sizeof(zReverse) - 6)); (i < nIn); i++, j--) {
    char c =  zIn[i];
    if (((c >= 'A') && (c <= 'Z'))) {
      (zReverse[j] = (c + 'a' - 'A'));
    } 
    else if (((c >= 'a') && (c <= 'z'))) {
      (zReverse[j] = c);
    } 
    else {
      copy_stemmer(zIn, nIn, zOut, pnOut);
      return;
    }
  }
  memset((&zReverse[(sizeof(zReverse) - 5)]), 0, 5);
  (z = (&zReverse[(j + 1)]));
  if ((z[0] == 's')) {
    if (((! stem((&z), "sess", "ss", 0)) && (! stem((&z), "sei", "i", 0)) && (! stem((&z), "ss", "ss", 0)))) {
      z++;
    }  
  }  
  (z2 = z);
  if (stem((&z), "dee", "ee", m_gt_0)) {
    
  } 
  else if (((stem((&z), "gni", "", hasVowel) || stem((&z), "de", "", hasVowel)) && (z != z2))) {
    if ((stem((&z), "ta", "ate", 0) || stem((&z), "lb", "ble", 0) || stem((&z), "zi", "ize", 0))) {
      
    } 
    else if ((doubleConsonant(z) && (((*z) != 'l') && ((*z) != 's') && ((*z) != 'z')))) {
      z++;
    }
    
    else if ((m_eq_1(z) && star_oh(z))) {
      ((*--z) = 'e');
    } 
  } 
  if (((z[0] == 'y') && hasVowel((z + 1)))) {
    (z[0] = 'i');
  }  
  switch (z[1]) {
    case 'a':
    (stem((&z), "lanoita", "ate", m_gt_0) || stem((&z), "lanoit", "tion", m_gt_0));
    break;
    case 'c':
    (stem((&z), "icne", "ence", m_gt_0) || stem((&z), "icna", "ance", m_gt_0));
    break;
    case 'e':
    stem((&z), "rezi", "ize", m_gt_0);
    break;
    case 'g':
    stem((&z), "igol", "log", m_gt_0);
    break;
    case 'l':
    (stem((&z), "ilb", "ble", m_gt_0) || stem((&z), "illa", "al", m_gt_0) || stem((&z), "iltne", "ent", m_gt_0) || stem((&z), "ile", "e", m_gt_0) || stem((&z), "ilsuo", "ous", m_gt_0));
    break;
    case 'o':
    (stem((&z), "noitazi", "ize", m_gt_0) || stem((&z), "noita", "ate", m_gt_0) || stem((&z), "rota", "ate", m_gt_0));
    break;
    case 's':
    (stem((&z), "msila", "al", m_gt_0) || stem((&z), "ssenevi", "ive", m_gt_0) || stem((&z), "ssenluf", "ful", m_gt_0) || stem((&z), "ssensuo", "ous", m_gt_0));
    break;
    case 't':
    (stem((&z), "itila", "al", m_gt_0) || stem((&z), "itivi", "ive", m_gt_0) || stem((&z), "itilib", "ble", m_gt_0));
    break;
  }
  switch (z[0]) {
    case 'e':
    (stem((&z), "etaci", "ic", m_gt_0) || stem((&z), "evita", "", m_gt_0) || stem((&z), "ezila", "al", m_gt_0));
    break;
    case 'i':
    stem((&z), "itici", "ic", m_gt_0);
    break;
    case 'l':
    (stem((&z), "laci", "ic", m_gt_0) || stem((&z), "luf", "", m_gt_0));
    break;
    case 's':
    stem((&z), "ssen", "", m_gt_0);
    break;
  }
  switch (z[1]) {
    case 'a':
    if (((z[0] == 'l') && m_gt_1((z + 2)))) {
      (z += 2);
    }  
    break;
    case 'c':
    if (((z[0] == 'e') && (z[2] == 'n') && ((z[3] == 'a') || (z[3] == 'e')) && m_gt_1((z + 4)))) {
      (z += 4);
    }  
    break;
    case 'e':
    if (((z[0] == 'r') && m_gt_1((z + 2)))) {
      (z += 2);
    }  
    break;
    case 'i':
    if (((z[0] == 'c') && m_gt_1((z + 2)))) {
      (z += 2);
    }  
    break;
    case 'l':
    if (((z[0] == 'e') && (z[2] == 'b') && ((z[3] == 'a') || (z[3] == 'i')) && m_gt_1((z + 4)))) {
      (z += 4);
    }  
    break;
    case 'n':
    if ((z[0] == 't')) {
      if ((z[2] == 'a')) {
        if (m_gt_1((z + 3))) {
          (z += 3);
        }  
      } 
      else if ((z[2] == 'e')) {
        (stem((&z), "tneme", "", m_gt_1) || stem((&z), "tnem", "", m_gt_1) || stem((&z), "tne", "", m_gt_1));
      } 
    }  
    break;
    case 'o':
    if ((z[0] == 'u')) {
      if (m_gt_1((z + 2))) {
        (z += 2);
      }  
    } 
    else if (((z[3] == 's') || (z[3] == 't'))) {
      stem((&z), "noi", "", m_gt_1);
    } 
    break;
    case 's':
    if (((z[0] == 'm') && (z[2] == 'i') && m_gt_1((z + 3)))) {
      (z += 3);
    }  
    break;
    case 't':
    (stem((&z), "eta", "", m_gt_1) || stem((&z), "iti", "", m_gt_1));
    break;
    case 'u':
    if (((z[0] == 's') && (z[2] == 'o') && m_gt_1((z + 3)))) {
      (z += 3);
    }  
    break;
    case 'v':
    case 'z':
    if (((z[0] == 'e') && (z[2] == 'i') && m_gt_1((z + 3)))) {
      (z += 3);
    }  
    break;
  }
  if ((z[0] == 'e')) {
    if (m_gt_1((z + 1))) {
      z++;
    } 
    else if ((m_eq_1((z + 1)) && (! star_oh((z + 1))))) {
      z++;
    } 
  }  
  if ((m_gt_1(z) && (z[0] == 'l') && (z[1] == 'l'))) {
    z++;
  }  
  ((*pnOut) = (i = ((int ) strlen(z))));
  (zOut[i] = 0);
  while ((*z)) {
    (zOut[--i] = (*z++));
  }
}
static const char porterIdChar[] =  { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0};
static  int porterNext(_1273_sqlite3_tokenizer_cursor *pCursor , const  char **pzToken , int *pnBytes , int *piStartOffset , int *piEndOffset , int *piPosition )  {
  _1273_porter_tokenizer_cursor *c =  ((_1273_porter_tokenizer_cursor *) pCursor);
  const char *z =  c->zInput;
  while ((c->iOffset < c->nInput)) {
    int iStartOffset, ch;
    while (((c->iOffset < c->nInput) && ((((ch = z[c->iOffset]) & 0x80) == 0) && ((ch < 0x30) || (! porterIdChar[(ch - 0x30)]))))) {
      c->iOffset++;
    }
    (iStartOffset = c->iOffset);
    while (((c->iOffset < c->nInput) && (! ((((ch = z[c->iOffset]) & 0x80) == 0) && ((ch < 0x30) || (! porterIdChar[(ch - 0x30)])))))) {
      c->iOffset++;
    }
    if ((c->iOffset > iStartOffset)) {
      int n =  (c->iOffset - iStartOffset);
      if ((n > c->nAllocated)) {
        char *pNew;
        (c->nAllocated = (n + 20));
        (pNew = sqlite3_realloc(c->zToken, c->nAllocated));
        if ((! pNew)) {
          return 7;
        }  
        (c->zToken = pNew);
      }  
      porter_stemmer((&z[iStartOffset]), n, c->zToken, pnBytes);
      ((*pzToken) = c->zToken);
      ((*piStartOffset) = iStartOffset);
      ((*piEndOffset) = c->iOffset);
      ((*piPosition) = c->iToken++);
      return 0;
    }  
  }
  return 101;
}
static const _1273_sqlite3_tokenizer_module porterTokenizerModule =  { 0,  porterCreate,  porterDestroy,  porterOpen,  porterClose,  porterNext,  0};
static  void sqlite3Fts3PorterTokenizerModule(_1273_sqlite3_tokenizer_module  const **ppModule )  {
  ((*ppModule) = (&porterTokenizerModule));
}
static  void scalarFunc(sqlite3_context *context , int argc , sqlite3_value **argv )  {
  _1273_Fts3Hash *pHash;
  void *pPtr =  0;
  const unsigned char *zName;
  int nName;
  ((void ) 0);
  (pHash = ((_1273_Fts3Hash *) sqlite3_user_data(context)));
  (zName = sqlite3_value_text(argv[0]));
  (nName = (sqlite3_value_bytes(argv[0]) + 1));
  if ((argc == 2)) {
    void *pOld;
    int n =  sqlite3_value_bytes(argv[1]);
    if ((n != sizeof(pPtr))) {
      sqlite3_result_error(context, "argument type mismatch", (- 1));
      return;
    }  
    (pPtr = (*((void **) sqlite3_value_blob(argv[1]))));
    (pOld = sqlite3Fts3HashInsert(pHash, ((void *) zName), nName, pPtr));
    if ((pOld == pPtr)) {
      sqlite3_result_error(context, "out of memory", (- 1));
      return;
    }  
  }  
  else {
    (pPtr = sqlite3Fts3HashFind(pHash, zName, nName));
    if ((! pPtr)) {
      char *zErr =  sqlite3_mprintf("unknown tokenizer: %s", zName);
      sqlite3_result_error(context, zErr, (- 1));
      sqlite3_free(zErr);
      return;
    }  
  }
  sqlite3_result_blob(context, ((void *) (&pPtr)), sizeof(pPtr), ((sqlite3_destructor_type ) (- 1)));
}
static  int sqlite3Fts3IsIdChar(char c )  {
  static const char isFtsIdChar[] =  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0};
  return ((c & 0x80) || isFtsIdChar[((int ) c)]);
}
static  const  char *sqlite3Fts3NextToken(const  char *zStr , int *pn )  {
  const char *z1;
  const char *z2 =  0;
  (z1 = zStr);
  while ((z2 == 0)) {
    char c =  (*z1);
    switch (c) {
      case '\0':
      return 0;
      case '\'':
      case '"':
      case '`':
      {
        (z2 = z1);
        while (((*++z2) && (((*z2) != c) || ((*++z2) == c)))) {
          
        }
        break;
      }
      case '[':
      (z2 = (&z1[1]));
      while (((*z2) && (z2[0] != ']'))) {
        z2++;
      }
      if ((*z2)) {
        z2++;
      }  
      break;
      id2i_label_1:
      default:
      if (sqlite3Fts3IsIdChar((*z1))) {
        (z2 = (&z1[1]));
        while (sqlite3Fts3IsIdChar((*z2))) {
          z2++;
        }
      }  
      else {
        z1++;
      }
    }
  }
  ((*pn) = ((int ) (z2 - z1)));
  return z1;
}
static  int sqlite3Fts3InitTokenizer(_1273_Fts3Hash *pHash , const  char *zArg , _1273_sqlite3_tokenizer **ppTok , char **pzErr )  {
  int rc;
  char *z =  ((char *) zArg);
  int n =  0;
  char *zCopy;
  char *zEnd;
  _1273_sqlite3_tokenizer_module *m;
  (zCopy = sqlite3_mprintf("%s", zArg));
  if ((! zCopy)) {
    return 7;
  }  
  (zEnd = (&zCopy[strlen(zCopy)]));
  (z = ((char *) sqlite3Fts3NextToken(zCopy, (&n))));
  (z[n] = '\0');
  sqlite3Fts3Dequote(z);
  (m = ((_1273_sqlite3_tokenizer_module *) sqlite3Fts3HashFind(pHash, z, (((int ) strlen(z)) + 1))));
  if ((! m)) {
    ((*pzErr) = sqlite3_mprintf("unknown tokenizer: %s", z));
    (rc = 1);
  }  
  else {
    char const **aArg =  0;
    int iArg =  0;
    (z = (&z[(n + 1)]));
    while (((z < zEnd) && (((void *) 0) != (z = ((char *) sqlite3Fts3NextToken(z, (&n))))))) {
      int nNew =  (sizeof(char *) * (iArg + 1));
      char const **aNew =  ((const  char **) sqlite3_realloc(((void *) aArg), nNew));
      if ((! aNew)) {
        sqlite3_free(zCopy);
        sqlite3_free(((void *) aArg));
        return 7;
      }  
      (aArg = aNew);
      (aArg[iArg++] = z);
      (z[n] = '\0');
      sqlite3Fts3Dequote(z);
      (z = (&z[(n + 1)]));
    }
    (rc = m->xCreate(iArg, aArg, ppTok));
    ((void ) 0);
    if ((rc != 0)) {
      ((*pzErr) = sqlite3_mprintf("unknown tokenizer"));
    }  
    else {
      ((*ppTok)->pModule = m);
    }
    sqlite3_free(((void *) aArg));
  }
  sqlite3_free(zCopy);
  return rc;
}
static  int sqlite3Fts3InitHashTable(sqlite3 *db , _1273_Fts3Hash *pHash , const  char *zName )  {
  int rc =  0;
  void *p =  ((void *) pHash);
  const int any =  5;
  if ((0 == rc)) {
    (rc = sqlite3_create_function(db, zName, 1, any, p, scalarFunc, 0, 0));
  }  
  if ((0 == rc)) {
    (rc = sqlite3_create_function(db, zName, 2, any, p, scalarFunc, 0, 0));
  }  
  return rc;
}
typedef struct  _1273_simple_tokenizer {
  _1273_sqlite3_tokenizer base ;
  char delim[128] ;
}  _1273_simple_tokenizer;
typedef struct  _1273_simple_tokenizer_cursor {
  _1273_sqlite3_tokenizer_cursor base ;
  const  char *pInput ;
  int nBytes ;
  int iOffset ;
  int iToken ;
  char *pToken ;
  int nTokenAllocated ;
}  _1273_simple_tokenizer_cursor;
static  int simpleDelim(_1273_simple_tokenizer *t , unsigned  char c )  {
  return ((c < 0x80) && t->delim[c]);
}
static  int fts3_isalnum(int x )  {
  return (((x >= '0') && (x <= '9')) || ((x >= 'A') && (x <= 'Z')) || ((x >= 'a') && (x <= 'z')));
}
static  int simpleCreate(int argc , const  char *const *argv , _1273_sqlite3_tokenizer **ppTokenizer )  {
  _1273_simple_tokenizer *t;
  (t = ((_1273_simple_tokenizer *) sqlite3_malloc(sizeof((*t)))));
  if ((t == ((void *) 0))) {
    return 7;
  }  
  memset(t, 0, sizeof((*t)));
  if ((argc > 1)) {
    int i, n =  ((int ) strlen(argv[1]));
    for ((i = 0); (i < n); i++) {
      unsigned char ch =  argv[1][i];
      if ((ch >= 0x80)) {
        sqlite3_free(t);
        return 1;
      }  
      (t->delim[ch] = 1);
    }
  }  
  else {
    int i;
    for ((i = 1); (i < 0x80); i++) {
      (t->delim[i] = ((! fts3_isalnum(i)) ? (- 1) : 0));
    }
  }
  ((*ppTokenizer) = (&t->base));
  return 0;
}
static  int simpleDestroy(_1273_sqlite3_tokenizer *pTokenizer )  {
  sqlite3_free(pTokenizer);
  return 0;
}
static  int simpleOpen(_1273_sqlite3_tokenizer *pTokenizer , const  char *pInput , int nBytes , _1273_sqlite3_tokenizer_cursor **ppCursor )  {
  _1273_simple_tokenizer_cursor *c;
  ((void ) pTokenizer);
  (c = ((_1273_simple_tokenizer_cursor *) sqlite3_malloc(sizeof((*c)))));
  if ((c == ((void *) 0))) {
    return 7;
  }  
  (c->pInput = pInput);
  if ((pInput == 0)) {
    (c->nBytes = 0);
  } 
  else if ((nBytes < 0)) {
    (c->nBytes = ((int ) strlen(pInput)));
  } 
  else {
    (c->nBytes = nBytes);
  }
  (c->iOffset = 0);
  (c->iToken = 0);
  (c->pToken = ((void *) 0));
  (c->nTokenAllocated = 0);
  ((*ppCursor) = (&c->base));
  return 0;
}
static  int simpleClose(_1273_sqlite3_tokenizer_cursor *pCursor )  {
  _1273_simple_tokenizer_cursor *c =  ((_1273_simple_tokenizer_cursor *) pCursor);
  sqlite3_free(c->pToken);
  sqlite3_free(c);
  return 0;
}
static  int simpleNext(_1273_sqlite3_tokenizer_cursor *pCursor , const  char **ppToken , int *pnBytes , int *piStartOffset , int *piEndOffset , int *piPosition )  {
  _1273_simple_tokenizer_cursor *c =  ((_1273_simple_tokenizer_cursor *) pCursor);
  _1273_simple_tokenizer *t =  ((_1273_simple_tokenizer *) pCursor->pTokenizer);
  unsigned char *p =  ((unsigned  char *) c->pInput);
  while ((c->iOffset < c->nBytes)) {
    int iStartOffset;
    while (((c->iOffset < c->nBytes) && simpleDelim(t, p[c->iOffset]))) {
      c->iOffset++;
    }
    (iStartOffset = c->iOffset);
    while (((c->iOffset < c->nBytes) && (! simpleDelim(t, p[c->iOffset])))) {
      c->iOffset++;
    }
    if ((c->iOffset > iStartOffset)) {
      int i, n =  (c->iOffset - iStartOffset);
      if ((n > c->nTokenAllocated)) {
        char *pNew;
        (c->nTokenAllocated = (n + 20));
        (pNew = sqlite3_realloc(c->pToken, c->nTokenAllocated));
        if ((! pNew)) {
          return 7;
        }  
        (c->pToken = pNew);
      }  
      for ((i = 0); (i < n); i++) {
        unsigned char ch =  p[(iStartOffset + i)];
        (c->pToken[i] = ((char ) (((ch >= 'A') && (ch <= 'Z')) ? (ch - 'A' + 'a') : ch)));
      }
      ((*ppToken) = c->pToken);
      ((*pnBytes) = n);
      ((*piStartOffset) = iStartOffset);
      ((*piEndOffset) = c->iOffset);
      ((*piPosition) = c->iToken++);
      return 0;
    }  
  }
  return 101;
}
static const _1273_sqlite3_tokenizer_module simpleTokenizerModule =  { 0,  simpleCreate,  simpleDestroy,  simpleOpen,  simpleClose,  simpleNext,  0};
static  void sqlite3Fts3SimpleTokenizerModule(_1273_sqlite3_tokenizer_module  const **ppModule )  {
  ((*ppModule) = (&simpleTokenizerModule));
}
typedef struct  _1273_Fts3tokTable   _1273_Fts3tokTable;
typedef struct  _1273_Fts3tokCursor   _1273_Fts3tokCursor;
struct  _1273_Fts3tokTable {
  sqlite3_vtab base ;
  const  _1273_sqlite3_tokenizer_module *pMod ;
  _1273_sqlite3_tokenizer *pTok ;
}  ;
struct  _1273_Fts3tokCursor {
  sqlite3_vtab_cursor base ;
  char *zInput ;
  _1273_sqlite3_tokenizer_cursor *pCsr ;
  int iRowid ;
  const  char *zToken ;
  int nToken ;
  int iStart ;
  int iEnd ;
  int iPos ;
}  ;
static  int fts3tokQueryTokenizer(_1273_Fts3Hash *pHash , const  char *zName , const  _1273_sqlite3_tokenizer_module **pp , char **pzErr )  {
  _1273_sqlite3_tokenizer_module *p;
  int nName =  ((int ) strlen(zName));
  (p = ((_1273_sqlite3_tokenizer_module *) sqlite3Fts3HashFind(pHash, zName, (nName + 1))));
  if ((! p)) {
    ((*pzErr) = sqlite3_mprintf("unknown tokenizer: %s", zName));
    return 1;
  }  
  ((*pp) = p);
  return 0;
}
static  int fts3tokDequoteArray(int argc , const  char *const *argv , char ***pazDequote )  {
  int rc =  0;
  if ((argc == 0)) {
    ((*pazDequote) = 0);
  }  
  else {
    int i;
    int nByte =  0;
    char **azDequote;
    for ((i = 0); (i < argc); i++) {
      (nByte += ((int ) (strlen(argv[i]) + 1)));
    }
    ((*pazDequote) = (azDequote = sqlite3_malloc(((sizeof(char *) * argc) + nByte))));
    if ((azDequote == 0)) {
      (rc = 7);
    }  
    else {
      char *pSpace =  ((char *) (&azDequote[argc]));
      for ((i = 0); (i < argc); i++) {
        int n =  ((int ) strlen(argv[i]));
        (azDequote[i] = pSpace);
        memcpy(pSpace, argv[i], (n + 1));
        sqlite3Fts3Dequote(pSpace);
        (pSpace += (n + 1));
      }
    }
  }
  return rc;
}
static  int fts3tokConnectMethod(sqlite3 *db , void *pHash , int argc , const  char *const *argv , sqlite3_vtab **ppVtab , char **pzErr )  {
  _1273_Fts3tokTable *pTab;
  const _1273_sqlite3_tokenizer_module *pMod =  0;
  _1273_sqlite3_tokenizer *pTok =  0;
  int rc;
  char **azDequote =  0;
  int nDequote;
  (rc = sqlite3_declare_vtab(db, "CREATE TABLE x(input, token, start, end, position)"));
  if ((rc != 0)) {
    return rc;
  }  
  (nDequote = (argc - 3));
  (rc = fts3tokDequoteArray(nDequote, (&argv[3]), (&azDequote)));
  if ((rc == 0)) {
    const char *zModule;
    if ((nDequote < 1)) {
      (zModule = "simple");
    }  
    else {
      (zModule = azDequote[0]);
    }
    (rc = fts3tokQueryTokenizer(((_1273_Fts3Hash *) pHash), zModule, (&pMod), pzErr));
  }  
  ((void ) 0);
  if ((rc == 0)) {
    const char *const *azArg =  ((const  char *const *) (&azDequote[1]));
    (rc = pMod->xCreate(((nDequote > 1) ? (nDequote - 1) : 0), azArg, (&pTok)));
  }  
  if ((rc == 0)) {
    (pTab = ((_1273_Fts3tokTable *) sqlite3_malloc(sizeof(_1273_Fts3tokTable ))));
    if ((pTab == 0)) {
      (rc = 7);
    }  
  }  
  if ((rc == 0)) {
    memset(pTab, 0, sizeof(_1273_Fts3tokTable ));
    (pTab->pMod = pMod);
    (pTab->pTok = pTok);
    ((*ppVtab) = (&pTab->base));
  }  
  else {
    if (pTok) {
      pMod->xDestroy(pTok);
    }  
  }
  sqlite3_free(azDequote);
  return rc;
}
static  int fts3tokDisconnectMethod(sqlite3_vtab *pVtab )  {
  _1273_Fts3tokTable *pTab =  ((_1273_Fts3tokTable *) pVtab);
  pTab->pMod->xDestroy(pTab->pTok);
  sqlite3_free(pTab);
  return 0;
}
static  int fts3tokBestIndexMethod(sqlite3_vtab *pVTab , sqlite3_index_info *pInfo )  {
  int i;
  ((void ) pVTab);
  for ((i = 0); (i < pInfo->nConstraint); i++) {
    if ((pInfo->aConstraint[i].usable && (pInfo->aConstraint[i].iColumn == 0) && (pInfo->aConstraint[i].op == 2))) {
      (pInfo->idxNum = 1);
      (pInfo->aConstraintUsage[i].argvIndex = 1);
      (pInfo->aConstraintUsage[i].omit = 1);
      (pInfo->estimatedCost = 1);
      return 0;
    }  
  }
  (pInfo->idxNum = 0);
  ((void ) 0);
  return 0;
}
static  int fts3tokOpenMethod(sqlite3_vtab *pVTab , sqlite3_vtab_cursor **ppCsr )  {
  _1273_Fts3tokCursor *pCsr;
  ((void ) pVTab);
  (pCsr = ((_1273_Fts3tokCursor *) sqlite3_malloc(sizeof(_1273_Fts3tokCursor ))));
  if ((pCsr == 0)) {
    return 7;
  }  
  memset(pCsr, 0, sizeof(_1273_Fts3tokCursor ));
  ((*ppCsr) = ((sqlite3_vtab_cursor *) pCsr));
  return 0;
}
static  void fts3tokResetCursor(_1273_Fts3tokCursor *pCsr )  {
  if (pCsr->pCsr) {
    _1273_Fts3tokTable *pTab =  ((_1273_Fts3tokTable *) pCsr->base.pVtab);
    pTab->pMod->xClose(pCsr->pCsr);
    (pCsr->pCsr = 0);
  }  
  sqlite3_free(pCsr->zInput);
  (pCsr->zInput = 0);
  (pCsr->zToken = 0);
  (pCsr->nToken = 0);
  (pCsr->iStart = 0);
  (pCsr->iEnd = 0);
  (pCsr->iPos = 0);
  (pCsr->iRowid = 0);
}
static  int fts3tokCloseMethod(sqlite3_vtab_cursor *pCursor )  {
  _1273_Fts3tokCursor *pCsr =  ((_1273_Fts3tokCursor *) pCursor);
  fts3tokResetCursor(pCsr);
  sqlite3_free(pCsr);
  return 0;
}
static  int fts3tokNextMethod(sqlite3_vtab_cursor *pCursor )  {
  _1273_Fts3tokCursor *pCsr =  ((_1273_Fts3tokCursor *) pCursor);
  _1273_Fts3tokTable *pTab =  ((_1273_Fts3tokTable *) pCursor->pVtab);
  int rc;
  pCsr->iRowid++;
  (rc = pTab->pMod->xNext(pCsr->pCsr, (&pCsr->zToken), (&pCsr->nToken), (&pCsr->iStart), (&pCsr->iEnd), (&pCsr->iPos)));
  if ((rc != 0)) {
    fts3tokResetCursor(pCsr);
    if ((rc == 101)) {
      (rc = 0);
    }  
  }  
  return rc;
}
static  int fts3tokFilterMethod(sqlite3_vtab_cursor *pCursor , int idxNum , const  char *idxStr , int nVal , sqlite3_value **apVal )  {
  int rc =  1;
  _1273_Fts3tokCursor *pCsr =  ((_1273_Fts3tokCursor *) pCursor);
  _1273_Fts3tokTable *pTab =  ((_1273_Fts3tokTable *) pCursor->pVtab);
  ((void ) idxStr);
  ((void ) nVal);
  fts3tokResetCursor(pCsr);
  if ((idxNum == 1)) {
    const char *zByte =  ((const  char *) sqlite3_value_text(apVal[0]));
    int nByte =  sqlite3_value_bytes(apVal[0]);
    (pCsr->zInput = sqlite3_malloc((nByte + 1)));
    if ((pCsr->zInput == 0)) {
      (rc = 7);
    }  
    else {
      memcpy(pCsr->zInput, zByte, nByte);
      (pCsr->zInput[nByte] = 0);
      (rc = pTab->pMod->xOpen(pTab->pTok, pCsr->zInput, nByte, (&pCsr->pCsr)));
      if ((rc == 0)) {
        (pCsr->pCsr->pTokenizer = pTab->pTok);
      }  
    }
  }  
  if ((rc != 0)) {
    return rc;
  }  
  return fts3tokNextMethod(pCursor);
}
static  int fts3tokEofMethod(sqlite3_vtab_cursor *pCursor )  {
  _1273_Fts3tokCursor *pCsr =  ((_1273_Fts3tokCursor *) pCursor);
  return (pCsr->zToken == 0);
}
static  int fts3tokColumnMethod(sqlite3_vtab_cursor *pCursor , sqlite3_context *pCtx , int iCol )  {
  _1273_Fts3tokCursor *pCsr =  ((_1273_Fts3tokCursor *) pCursor);
  switch (iCol) {
    case 0:
    sqlite3_result_text(pCtx, pCsr->zInput, (- 1), ((sqlite3_destructor_type ) (- 1)));
    break;
    case 1:
    sqlite3_result_text(pCtx, pCsr->zToken, pCsr->nToken, ((sqlite3_destructor_type ) (- 1)));
    break;
    case 2:
    sqlite3_result_int(pCtx, pCsr->iStart);
    break;
    case 3:
    sqlite3_result_int(pCtx, pCsr->iEnd);
    break;
    id2i_label_1:
    default:
    ((void ) 0);
    sqlite3_result_int(pCtx, pCsr->iPos);
    break;
  }
  return 0;
}
static  int fts3tokRowidMethod(sqlite3_vtab_cursor *pCursor , sqlite_int64 *pRowid )  {
  _1273_Fts3tokCursor *pCsr =  ((_1273_Fts3tokCursor *) pCursor);
  ((*pRowid) = ((sqlite3_int64 ) pCsr->iRowid));
  return 0;
}
static  int sqlite3Fts3InitTok(sqlite3 *db , _1273_Fts3Hash *pHash )  {
  static const sqlite3_module fts3tok_module =  { 0,  fts3tokConnectMethod,  fts3tokConnectMethod,  fts3tokBestIndexMethod,  fts3tokDisconnectMethod,  fts3tokDisconnectMethod,  fts3tokOpenMethod,  fts3tokCloseMethod,  fts3tokFilterMethod,  fts3tokNextMethod,  fts3tokEofMethod,  fts3tokColumnMethod,  fts3tokRowidMethod,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0};
  int rc;
  (rc = sqlite3_create_module(db, "fts3tokenize", (&fts3tok_module), ((void *) pHash)));
  return rc;
}
typedef struct  _1273_PendingList   _1273_PendingList;
typedef struct  _1273_SegmentNode   _1273_SegmentNode;
typedef struct  _1273_SegmentWriter   _1273_SegmentWriter;
struct  _1273_PendingList {
  int nData ;
  char *aData ;
  int nSpace ;
  sqlite3_int64 iLastDocid ;
  sqlite3_int64 iLastCol ;
  sqlite3_int64 iLastPos ;
}  ;
struct  _1273_Fts3DeferredToken {
  _1273_Fts3PhraseToken *pToken ;
  int iCol ;
  _1273_Fts3DeferredToken *pNext ;
  _1273_PendingList *pList ;
}  ;
struct  _1273_Fts3SegReader {
  int iIdx ;
  u8 bLookup ;
  u8 rootOnly ;
  sqlite3_int64 iStartBlock ;
  sqlite3_int64 iLeafEndBlock ;
  sqlite3_int64 iEndBlock ;
  sqlite3_int64 iCurrentBlock ;
  char *aNode ;
  int nNode ;
  int nPopulate ;
  sqlite3_blob *pBlob ;
  _1273_Fts3HashElem **ppNextElem ;
  int nTerm ;
  char *zTerm ;
  int nTermAlloc ;
  char *aDoclist ;
  int nDoclist ;
  char *pOffsetList ;
  int nOffsetList ;
  sqlite3_int64 iDocid ;
}  ;
struct  _1273_SegmentWriter {
  _1273_SegmentNode *pTree ;
  sqlite3_int64 iFirst ;
  sqlite3_int64 iFree ;
  char *zTerm ;
  int nTerm ;
  int nMalloc ;
  char *zMalloc ;
  int nSize ;
  int nData ;
  char *aData ;
}  ;
struct  _1273_SegmentNode {
  _1273_SegmentNode *pParent ;
  _1273_SegmentNode *pRight ;
  _1273_SegmentNode *pLeftmost ;
  int nEntry ;
  char *zTerm ;
  int nTerm ;
  int nMalloc ;
  char *zMalloc ;
  int nData ;
  char *aData ;
}  ;
static  int fts3SqlStmt(_1273_Fts3Table *p , int eStmt , sqlite3_stmt **pp , sqlite3_value **apVal )  {
  const char *azSql[] =  { "DELETE FROM %Q.'%q_content' WHERE rowid = ?",  "SELECT NOT EXISTS(SELECT docid FROM %Q.'%q_content' WHERE rowid!=?)",  "DELETE FROM %Q.'%q_content'",  "DELETE FROM %Q.'%q_segments'",  "DELETE FROM %Q.'%q_segdir'",  "DELETE FROM %Q.'%q_docsize'",  "DELETE FROM %Q.'%q_stat'",  "SELECT %s WHERE rowid=?",  "SELECT (SELECT max(idx) FROM %Q.'%q_segdir' WHERE level = ?) + 1",  "REPLACE INTO %Q.'%q_segments'(blockid, block) VALUES(?, ?)",  "SELECT coalesce((SELECT max(blockid) FROM %Q.'%q_segments') + 1, 1)",  "REPLACE INTO %Q.'%q_segdir' VALUES(?,?,?,?,?,?)",  "SELECT idx, start_block, leaves_end_block, end_block, root " "FROM %Q.'%q_segdir' WHERE level = ? ORDER BY idx ASC",  "SELECT idx, start_block, leaves_end_block, end_block, root " "FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?" "ORDER BY level DESC, idx ASC",  "SELECT count(*) FROM %Q.'%q_segdir' WHERE level = ?",  "SELECT max(level) FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?",  "DELETE FROM %Q.'%q_segdir' WHERE level = ?",  "DELETE FROM %Q.'%q_segments' WHERE blockid BETWEEN ? AND ?",  "INSERT INTO %Q.'%q_content' VALUES(%s)",  "DELETE FROM %Q.'%q_docsize' WHERE docid = ?",  "REPLACE INTO %Q.'%q_docsize' VALUES(?,?)",  "SELECT size FROM %Q.'%q_docsize' WHERE docid=?",  "SELECT value FROM %Q.'%q_stat' WHERE id=?",  "REPLACE INTO %Q.'%q_stat' VALUES(?,?)",  "",  "",  "DELETE FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?",  "SELECT DISTINCT level / (1024 * ?) FROM %Q.'%q_segdir'",  "SELECT level FROM %Q.'%q_segdir' GROUP BY level HAVING count(*)>=?" "  ORDER BY (level %% 1024) ASC LIMIT 1",  "SELECT 2 * total(1 + leaves_end_block - start_block) " "  FROM %Q.'%q_segdir' WHERE level = ? AND idx < ?",  "DELETE FROM %Q.'%q_segdir' WHERE level = ? AND idx = ?",  "UPDATE %Q.'%q_segdir' SET idx = ? WHERE level=? AND idx=?",  "SELECT idx, start_block, leaves_end_block, end_block, root " "FROM %Q.'%q_segdir' WHERE level = ? AND idx = ?",  "UPDATE %Q.'%q_segdir' SET start_block = ?, root = ?" "WHERE level = ? AND idx = ?",  "SELECT 1 FROM %Q.'%q_segments' WHERE blockid=? AND block IS NULL",  "SELECT idx FROM %Q.'%q_segdir' WHERE level=? ORDER BY 1 ASC",  "SELECT max( level %% 1024 ) FROM %Q.'%q_segdir'"};
  int rc =  0;
  sqlite3_stmt *pStmt;
  ((void ) 0);
  ((void ) 0);
  (pStmt = p->aStmt[eStmt]);
  if ((! pStmt)) {
    char *zSql;
    if ((eStmt == 18)) {
      (zSql = sqlite3_mprintf(azSql[eStmt], p->zDb, p->zName, p->zWriteExprlist));
    } 
    else if ((eStmt == 7)) {
      (zSql = sqlite3_mprintf(azSql[eStmt], p->zReadExprlist));
    } 
    else {
      (zSql = sqlite3_mprintf(azSql[eStmt], p->zDb, p->zName));
    }
    if ((! zSql)) {
      (rc = 7);
    }  
    else {
      (rc = sqlite3_prepare_v2(p->db, zSql, (- 1), (&pStmt), ((void *) 0)));
      sqlite3_free(zSql);
      ((void ) 0);
      (p->aStmt[eStmt] = pStmt);
    }
  }  
  if (apVal) {
    int i;
    int nParam =  sqlite3_bind_parameter_count(pStmt);
    for ((i = 0); ((rc == 0) && (i < nParam)); i++) {
      (rc = sqlite3_bind_value(pStmt, (i + 1), apVal[i]));
    }
  }  
  ((*pp) = pStmt);
  return rc;
}
static  int fts3SelectDocsize(_1273_Fts3Table *pTab , sqlite3_int64 iDocid , sqlite3_stmt **ppStmt )  {
  sqlite3_stmt *pStmt =  0;
  int rc;
  (rc = fts3SqlStmt(pTab, 21, (&pStmt), 0));
  if ((rc == 0)) {
    sqlite3_bind_int64(pStmt, 1, iDocid);
    (rc = sqlite3_step(pStmt));
    if (((rc != 100) || (sqlite3_column_type(pStmt, 0) != 4))) {
      (rc = sqlite3_reset(pStmt));
      if ((rc == 0)) {
        (rc = (11 | (1 << 8)));
      }  
      (pStmt = 0);
    }  
    else {
      (rc = 0);
    }
  }  
  ((*ppStmt) = pStmt);
  return rc;
}
static  int sqlite3Fts3SelectDoctotal(_1273_Fts3Table *pTab , sqlite3_stmt **ppStmt )  {
  sqlite3_stmt *pStmt =  0;
  int rc;
  (rc = fts3SqlStmt(pTab, 22, (&pStmt), 0));
  if ((rc == 0)) {
    sqlite3_bind_int(pStmt, 1, 0);
    if (((sqlite3_step(pStmt) != 100) || (sqlite3_column_type(pStmt, 0) != 4))) {
      (rc = sqlite3_reset(pStmt));
      if ((rc == 0)) {
        (rc = (11 | (1 << 8)));
      }  
      (pStmt = 0);
    }  
  }  
  ((*ppStmt) = pStmt);
  return rc;
}
static  int sqlite3Fts3SelectDocsize(_1273_Fts3Table *pTab , sqlite3_int64 iDocid , sqlite3_stmt **ppStmt )  {
  return fts3SelectDocsize(pTab, iDocid, ppStmt);
}
static  void fts3SqlExec(int *pRC , _1273_Fts3Table *p , int eStmt , sqlite3_value **apVal )  {
  sqlite3_stmt *pStmt;
  int rc;
  if ((*pRC)) {
    return;
  }  
  (rc = fts3SqlStmt(p, eStmt, (&pStmt), apVal));
  if ((rc == 0)) {
    sqlite3_step(pStmt);
    (rc = sqlite3_reset(pStmt));
  }  
  ((*pRC) = rc);
}
static  int fts3Writelock(_1273_Fts3Table *p )  {
  int rc =  0;
  if ((p->nPendingData == 0)) {
    sqlite3_stmt *pStmt;
    (rc = fts3SqlStmt(p, 16, (&pStmt), 0));
    if ((rc == 0)) {
      sqlite3_bind_null(pStmt, 1);
      sqlite3_step(pStmt);
      (rc = sqlite3_reset(pStmt));
    }  
  }  
  return rc;
}
static  sqlite3_int64 getAbsoluteLevel(_1273_Fts3Table *p , int iLangid , int iIndex , int iLevel )  {
  sqlite3_int64 iBase;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (iBase = (((((sqlite3_int64 ) iLangid) * p->nIndex) + iIndex) * 1024));
  return (iBase + iLevel);
}
static  int sqlite3Fts3AllSegdirs(_1273_Fts3Table *p , int iLangid , int iIndex , int iLevel , sqlite3_stmt **ppStmt )  {
  int rc;
  sqlite3_stmt *pStmt =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  if ((iLevel < 0)) {
    (rc = fts3SqlStmt(p, 13, (&pStmt), 0));
    if ((rc == 0)) {
      sqlite3_bind_int64(pStmt, 1, getAbsoluteLevel(p, iLangid, iIndex, 0));
      sqlite3_bind_int64(pStmt, 2, getAbsoluteLevel(p, iLangid, iIndex, (1024 - 1)));
    }  
  }  
  else {
    (rc = fts3SqlStmt(p, 12, (&pStmt), 0));
    if ((rc == 0)) {
      sqlite3_bind_int64(pStmt, 1, getAbsoluteLevel(p, iLangid, iIndex, iLevel));
    }  
  }
  ((*ppStmt) = pStmt);
  return rc;
}
static  int fts3PendingListAppendVarint(_1273_PendingList **pp , sqlite3_int64 i )  {
  _1273_PendingList *p =  (*pp);
  if ((! p)) {
    (p = sqlite3_malloc((sizeof((*p)) + 100)));
    if ((! p)) {
      return 7;
    }  
    (p->nSpace = 100);
    (p->aData = ((char *) (&p[1])));
    (p->nData = 0);
  } 
  else if (((p->nData + 10 + 1) > p->nSpace)) {
    int nNew =  (p->nSpace * 2);
    (p = sqlite3_realloc(p, (sizeof((*p)) + nNew)));
    if ((! p)) {
      sqlite3_free((*pp));
      ((*pp) = 0);
      return 7;
    }  
    (p->nSpace = nNew);
    (p->aData = ((char *) (&p[1])));
  } 
  (p->nData += sqlite3Fts3PutVarint((&p->aData[p->nData]), i));
  (p->aData[p->nData] = '\0');
  ((*pp) = p);
  return 0;
}
static  int fts3PendingListAppend(_1273_PendingList **pp , sqlite3_int64 iDocid , sqlite3_int64 iCol , sqlite3_int64 iPos , int *pRc )  {
  _1273_PendingList *p =  (*pp);
  int rc =  0;
  ((void ) 0);
  if (((! p) || (p->iLastDocid != iDocid))) {
    sqlite3_int64 iDelta =  (iDocid - (p ? p->iLastDocid : 0));
    if (p) {
      ((void ) 0);
      ((void ) 0);
      p->nData++;
    }  
    if ((0 != (rc = fts3PendingListAppendVarint((&p), iDelta)))) {
      goto _1273_pendinglistappend_out;
    }  
    (p->iLastCol = (- 1));
    (p->iLastPos = 0);
    (p->iLastDocid = iDocid);
  }  
  if (((iCol > 0) && (p->iLastCol != iCol))) {
    if (((0 != (rc = fts3PendingListAppendVarint((&p), 1))) || (0 != (rc = fts3PendingListAppendVarint((&p), iCol))))) {
      goto _1273_pendinglistappend_out;
    }  
    (p->iLastCol = iCol);
    (p->iLastPos = 0);
  }  
  if ((iCol >= 0)) {
    ((void ) 0);
    (rc = fts3PendingListAppendVarint((&p), (2 + iPos - p->iLastPos)));
    if ((rc == 0)) {
      (p->iLastPos = iPos);
    }  
  }  
  _1273_pendinglistappend_out:
  ((*pRc) = rc);
  if ((p != (*pp))) {
    ((*pp) = p);
    return 1;
  }  
  return 0;
}
static  void fts3PendingListDelete(_1273_PendingList *pList )  {
  sqlite3_free(pList);
}
static  int fts3PendingTermsAddOne(_1273_Fts3Table *p , int iCol , int iPos , _1273_Fts3Hash *pHash , const  char *zToken , int nToken )  {
  _1273_PendingList *pList;
  int rc =  0;
  (pList = ((_1273_PendingList *) sqlite3Fts3HashFind(pHash, zToken, nToken)));
  if (pList) {
    (p->nPendingData -= (pList->nData + nToken + sizeof(_1273_Fts3HashElem )));
  }  
  if (fts3PendingListAppend((&pList), p->iPrevDocid, iCol, iPos, (&rc))) {
    if ((pList == sqlite3Fts3HashInsert(pHash, zToken, nToken, pList))) {
      ((void ) 0);
      sqlite3_free(pList);
      (rc = 7);
    }  
  }  
  if ((rc == 0)) {
    (p->nPendingData += (pList->nData + nToken + sizeof(_1273_Fts3HashElem )));
  }  
  return rc;
}
static  int fts3PendingTermsAdd(_1273_Fts3Table *p , int iLangid , const  char *zText , int iCol , u32 *pnWord )  {
  int rc;
  int iStart =  0;
  int iEnd =  0;
  int iPos =  0;
  int nWord =  0;
  char const *zToken;
  int nToken =  0;
  _1273_sqlite3_tokenizer *pTokenizer =  p->pTokenizer;
  _1273_sqlite3_tokenizer_module const *pModule =  pTokenizer->pModule;
  _1273_sqlite3_tokenizer_cursor *pCsr;
  int ( *xNext)(_1273_sqlite3_tokenizer_cursor *pCursor , const  char ** , int * , int * , int * , int * );
  ((void ) 0);
  if ((zText == 0)) {
    ((*pnWord) = 0);
    return 0;
  }  
  (rc = sqlite3Fts3OpenTokenizer(pTokenizer, iLangid, zText, (- 1), (&pCsr)));
  if ((rc != 0)) {
    return rc;
  }  
  (xNext = pModule->xNext);
  while (((0 == rc) && (0 == (rc = xNext(pCsr, (&zToken), (&nToken), (&iStart), (&iEnd), (&iPos)))))) {
    int i;
    if ((iPos >= nWord)) {
      (nWord = (iPos + 1));
    }  
    if (((iPos < 0) || (! zToken) || (nToken <= 0))) {
      (rc = 1);
      break;
    }  
    (rc = fts3PendingTermsAddOne(p, iCol, iPos, (&p->aIndex[0].hPending), zToken, nToken));
    for ((i = 1); ((rc == 0) && (i < p->nIndex)); i++) {
      struct  Fts3Index   *pIndex =  (&p->aIndex[i]);
      if ((nToken < pIndex->nPrefix)) {
        continue;
      }  
      (rc = fts3PendingTermsAddOne(p, iCol, iPos, (&pIndex->hPending), zToken, pIndex->nPrefix));
    }
  }
  pModule->xClose(pCsr);
  ((*pnWord) += nWord);
  return ((rc == 101) ? 0 : rc);
}
static  int fts3PendingTermsDocid(_1273_Fts3Table *p , int iLangid , sqlite_int64 iDocid )  {
  ((void ) 0);
  if (((iDocid <= p->iPrevDocid) || (p->iPrevLangid != iLangid) || (p->nPendingData > p->nMaxPendingData))) {
    int rc =  sqlite3Fts3PendingTermsFlush(p);
    if ((rc != 0)) {
      return rc;
    }  
  }  
  (p->iPrevDocid = iDocid);
  (p->iPrevLangid = iLangid);
  return 0;
}
static  void sqlite3Fts3PendingTermsClear(_1273_Fts3Table *p )  {
  int i;
  for ((i = 0); (i < p->nIndex); i++) {
    _1273_Fts3HashElem *pElem;
    _1273_Fts3Hash *pHash =  (&p->aIndex[i].hPending);
    for ((pElem = pHash->first); pElem; (pElem = pElem->next)) {
      _1273_PendingList *pList =  ((_1273_PendingList *) pElem->data);
      fts3PendingListDelete(pList);
    }
    sqlite3Fts3HashClear(pHash);
  }
  (p->nPendingData = 0);
}
static  int fts3InsertTerms(_1273_Fts3Table *p , int iLangid , sqlite3_value **apVal , u32 *aSz )  {
  int i;
  for ((i = 2); (i < (p->nColumn + 2)); i++) {
    int iCol =  (i - 2);
    if ((p->abNotindexed[iCol] == 0)) {
      const char *zText =  ((const  char *) sqlite3_value_text(apVal[i]));
      int rc =  fts3PendingTermsAdd(p, iLangid, zText, iCol, (&aSz[iCol]));
      if ((rc != 0)) {
        return rc;
      }  
      (aSz[p->nColumn] += sqlite3_value_bytes(apVal[i]));
    }  
  }
  return 0;
}
static  int fts3InsertData(_1273_Fts3Table *p , sqlite3_value **apVal , sqlite3_int64 *piDocid )  {
  int rc;
  sqlite3_stmt *pContentInsert;
  if (p->zContentTbl) {
    sqlite3_value *pRowid =  apVal[(p->nColumn + 3)];
    if ((sqlite3_value_type(pRowid) == 5)) {
      (pRowid = apVal[1]);
    }  
    if ((sqlite3_value_type(pRowid) != 1)) {
      return 19;
    }  
    ((*piDocid) = sqlite3_value_int64(pRowid));
    return 0;
  }  
  (rc = fts3SqlStmt(p, 18, (&pContentInsert), (&apVal[1])));
  if (((rc == 0) && p->zLanguageid)) {
    (rc = sqlite3_bind_int(pContentInsert, (p->nColumn + 2), sqlite3_value_int(apVal[(p->nColumn + 4)])));
  }  
  if ((rc != 0)) {
    return rc;
  }  
  if ((5 != sqlite3_value_type(apVal[(3 + p->nColumn)]))) {
    if (((5 == sqlite3_value_type(apVal[0])) && (5 != sqlite3_value_type(apVal[1])))) {
      return 1;
    }  
    (rc = sqlite3_bind_value(pContentInsert, 1, apVal[(3 + p->nColumn)]));
    if ((rc != 0)) {
      return rc;
    }  
  }  
  sqlite3_step(pContentInsert);
  (rc = sqlite3_reset(pContentInsert));
  ((*piDocid) = sqlite3_last_insert_rowid(p->db));
  return rc;
}
static  int fts3DeleteAll(_1273_Fts3Table *p , int bContent )  {
  int rc =  0;
  sqlite3Fts3PendingTermsClear(p);
  ((void ) 0);
  if (bContent) {
    fts3SqlExec((&rc), p, 2, 0);
  }  
  fts3SqlExec((&rc), p, 3, 0);
  fts3SqlExec((&rc), p, 4, 0);
  if (p->bHasDocsize) {
    fts3SqlExec((&rc), p, 5, 0);
  }  
  if (p->bHasStat) {
    fts3SqlExec((&rc), p, 6, 0);
  }  
  return rc;
}
static  int langidFromSelect(_1273_Fts3Table *p , sqlite3_stmt *pSelect )  {
  int iLangid =  0;
  if (p->zLanguageid) {
    (iLangid = sqlite3_column_int(pSelect, (p->nColumn + 1)));
  }  
  return iLangid;
}
static  void fts3DeleteTerms(int *pRC , _1273_Fts3Table *p , sqlite3_value *pRowid , u32 *aSz , int *pbFound )  {
  int rc;
  sqlite3_stmt *pSelect;
  ((void ) 0);
  if ((*pRC)) {
    return;
  }  
  (rc = fts3SqlStmt(p, 7, (&pSelect), (&pRowid)));
  if ((rc == 0)) {
    if ((100 == sqlite3_step(pSelect))) {
      int i;
      int iLangid =  langidFromSelect(p, pSelect);
      (rc = fts3PendingTermsDocid(p, iLangid, sqlite3_column_int64(pSelect, 0)));
      for ((i = 1); ((rc == 0) && (i <= p->nColumn)); i++) {
        int iCol =  (i - 1);
        if ((p->abNotindexed[iCol] == 0)) {
          const char *zText =  ((const  char *) sqlite3_column_text(pSelect, i));
          (rc = fts3PendingTermsAdd(p, iLangid, zText, (- 1), (&aSz[iCol])));
          (aSz[p->nColumn] += sqlite3_column_bytes(pSelect, i));
        }  
      }
      if ((rc != 0)) {
        sqlite3_reset(pSelect);
        ((*pRC) = rc);
        return;
      }  
      ((*pbFound) = 1);
    }  
    (rc = sqlite3_reset(pSelect));
  }  
  else {
    sqlite3_reset(pSelect);
  }
  ((*pRC) = rc);
}
static int fts3SegmentMerge(_1273_Fts3Table * , int , int , int );
static  int fts3AllocateSegdirIdx(_1273_Fts3Table *p , int iLangid , int iIndex , int iLevel , int *piIdx )  {
  int rc;
  sqlite3_stmt *pNextIdx;
  int iNext =  0;
  ((void ) 0);
  ((void ) 0);
  (rc = fts3SqlStmt(p, 8, (&pNextIdx), 0));
  if ((rc == 0)) {
    sqlite3_bind_int64(pNextIdx, 1, getAbsoluteLevel(p, iLangid, iIndex, iLevel));
    if ((100 == sqlite3_step(pNextIdx))) {
      (iNext = sqlite3_column_int(pNextIdx, 0));
    }  
    (rc = sqlite3_reset(pNextIdx));
  }  
  if ((rc == 0)) {
    if ((iNext >= 16)) {
      (rc = fts3SegmentMerge(p, iLangid, iIndex, iLevel));
      ((*piIdx) = 0);
    }  
    else {
      ((*piIdx) = iNext);
    }
  }  
  return rc;
}
static  int sqlite3Fts3ReadBlock(_1273_Fts3Table *p , sqlite3_int64 iBlockid , char **paBlob , int *pnBlob , int *pnLoad )  {
  int rc;
  ((void ) 0);
  if (p->pSegments) {
    (rc = sqlite3_blob_reopen(p->pSegments, iBlockid));
  }  
  else {
    if ((0 == p->zSegmentsTbl)) {
      (p->zSegmentsTbl = sqlite3_mprintf("%s_segments", p->zName));
      if ((0 == p->zSegmentsTbl)) {
        return 7;
      }  
    }  
    (rc = sqlite3_blob_open(p->db, p->zDb, p->zSegmentsTbl, "block", iBlockid, 0, (&p->pSegments)));
  }
  if ((rc == 0)) {
    int nByte =  sqlite3_blob_bytes(p->pSegments);
    ((*pnBlob) = nByte);
    if (paBlob) {
      char *aByte =  sqlite3_malloc((nByte + (10 * 2)));
      if ((! aByte)) {
        (rc = 7);
      }  
      else {
        if ((pnLoad && (nByte > ((4 * 1024) * 4)))) {
          (nByte = (4 * 1024));
          ((*pnLoad) = nByte);
        }  
        (rc = sqlite3_blob_read(p->pSegments, aByte, nByte, 0));
        memset((&aByte[nByte]), 0, (10 * 2));
        if ((rc != 0)) {
          sqlite3_free(aByte);
          (aByte = 0);
        }  
      }
      ((*paBlob) = aByte);
    }  
  }  
  return rc;
}
static  void sqlite3Fts3SegmentsClose(_1273_Fts3Table *p )  {
  sqlite3_blob_close(p->pSegments);
  (p->pSegments = 0);
}
static  int fts3SegReaderIncrRead(_1273_Fts3SegReader *pReader )  {
  int nRead;
  int rc;
  (nRead = (((pReader->nNode - pReader->nPopulate) < (4 * 1024)) ? (pReader->nNode - pReader->nPopulate) : (4 * 1024)));
  (rc = sqlite3_blob_read(pReader->pBlob, (&pReader->aNode[pReader->nPopulate]), nRead, pReader->nPopulate));
  if ((rc == 0)) {
    (pReader->nPopulate += nRead);
    memset((&pReader->aNode[pReader->nPopulate]), 0, (10 * 2));
    if ((pReader->nPopulate == pReader->nNode)) {
      sqlite3_blob_close(pReader->pBlob);
      (pReader->pBlob = 0);
      (pReader->nPopulate = 0);
    }  
  }  
  return rc;
}
static  int fts3SegReaderRequire(_1273_Fts3SegReader *pReader , char *pFrom , int nByte )  {
  int rc =  0;
  ((void ) 0);
  while ((pReader->pBlob && (rc == 0) && ((pFrom - pReader->aNode + nByte) > pReader->nPopulate))) {
    (rc = fts3SegReaderIncrRead(pReader));
  }
  return rc;
}
static  void fts3SegReaderSetEof(_1273_Fts3SegReader *pSeg )  {
  if ((! (pSeg->rootOnly != 0))) {
    sqlite3_free(pSeg->aNode);
    sqlite3_blob_close(pSeg->pBlob);
    (pSeg->pBlob = 0);
  }  
  (pSeg->aNode = 0);
}
static  int fts3SegReaderNext(_1273_Fts3Table *p , _1273_Fts3SegReader *pReader , int bIncr )  {
  int rc;
  char *pNext;
  int nPrefix;
  int nSuffix;
  if ((! pReader->aDoclist)) {
    (pNext = pReader->aNode);
  }  
  else {
    (pNext = (&pReader->aDoclist[pReader->nDoclist]));
  }
  if (((! pNext) || (pNext >= (&pReader->aNode[pReader->nNode])))) {
    if ((pReader->ppNextElem != 0)) {
      _1273_Fts3HashElem *pElem =  (*pReader->ppNextElem);
      if ((pElem == 0)) {
        (pReader->aNode = 0);
      }  
      else {
        _1273_PendingList *pList =  ((_1273_PendingList *) pElem->data);
        (pReader->zTerm = ((char *) pElem->pKey));
        (pReader->nTerm = pElem->nKey);
        (pReader->nNode = (pReader->nDoclist = (pList->nData + 1)));
        (pReader->aNode = (pReader->aDoclist = pList->aData));
        pReader->ppNextElem++;
        ((void ) 0);
      }
      return 0;
    }  
    fts3SegReaderSetEof(pReader);
    ((void ) 0);
    if ((pReader->iCurrentBlock >= pReader->iLeafEndBlock)) {
      return 0;
    }  
    (rc = sqlite3Fts3ReadBlock(p, ++pReader->iCurrentBlock, (&pReader->aNode), (&pReader->nNode), (bIncr ? (&pReader->nPopulate) : 0)));
    if ((rc != 0)) {
      return rc;
    }  
    ((void ) 0);
    if ((bIncr && (pReader->nPopulate < pReader->nNode))) {
      (pReader->pBlob = p->pSegments);
      (p->pSegments = 0);
    }  
    (pNext = pReader->aNode);
  }  
  ((void ) 0);
  (rc = fts3SegReaderRequire(pReader, pNext, (10 * 2)));
  if ((rc != 0)) {
    return rc;
  }  
  (pNext += sqlite3Fts3GetVarint32(pNext, (&nPrefix)));
  (pNext += sqlite3Fts3GetVarint32(pNext, (&nSuffix)));
  if (((nPrefix < 0) || (nSuffix <= 0) || ((&pNext[nSuffix]) > (&pReader->aNode[pReader->nNode])))) {
    return (11 | (1 << 8));
  }  
  if (((nPrefix + nSuffix) > pReader->nTermAlloc)) {
    int nNew =  ((nPrefix + nSuffix) * 2);
    char *zNew =  sqlite3_realloc(pReader->zTerm, nNew);
    if ((! zNew)) {
      return 7;
    }  
    (pReader->zTerm = zNew);
    (pReader->nTermAlloc = nNew);
  }  
  (rc = fts3SegReaderRequire(pReader, pNext, (nSuffix + 10)));
  if ((rc != 0)) {
    return rc;
  }  
  memcpy((&pReader->zTerm[nPrefix]), pNext, nSuffix);
  (pReader->nTerm = (nPrefix + nSuffix));
  (pNext += nSuffix);
  (pNext += sqlite3Fts3GetVarint32(pNext, (&pReader->nDoclist)));
  (pReader->aDoclist = pNext);
  (pReader->pOffsetList = 0);
  if ((((&pReader->aDoclist[pReader->nDoclist]) > (&pReader->aNode[pReader->nNode])) || ((pReader->nPopulate == 0) && pReader->aDoclist[(pReader->nDoclist - 1)]))) {
    return (11 | (1 << 8));
  }  
  return 0;
}
static  int fts3SegReaderFirstDocid(_1273_Fts3Table *pTab , _1273_Fts3SegReader *pReader )  {
  int rc =  0;
  ((void ) 0);
  ((void ) 0);
  if ((pTab->bDescIdx && (pReader->ppNextElem != 0))) {
    u8 bEof =  0;
    (pReader->iDocid = 0);
    (pReader->nOffsetList = 0);
    sqlite3Fts3DoclistPrev(0, pReader->aDoclist, pReader->nDoclist, (&pReader->pOffsetList), (&pReader->iDocid), (&pReader->nOffsetList), (&bEof));
  }  
  else {
    (rc = fts3SegReaderRequire(pReader, pReader->aDoclist, 10));
    if ((rc == 0)) {
      int n =  sqlite3Fts3GetVarint(pReader->aDoclist, (&pReader->iDocid));
      (pReader->pOffsetList = (&pReader->aDoclist[n]));
    }  
  }
  return rc;
}
static  int fts3SegReaderNextDocid(_1273_Fts3Table *pTab , _1273_Fts3SegReader *pReader , char **ppOffsetList , int *pnOffsetList )  {
  int rc =  0;
  char *p =  pReader->pOffsetList;
  char c =  0;
  ((void ) 0);
  if ((pTab->bDescIdx && (pReader->ppNextElem != 0))) {
    u8 bEof =  0;
    if (ppOffsetList) {
      ((*ppOffsetList) = pReader->pOffsetList);
      ((*pnOffsetList) = (pReader->nOffsetList - 1));
    }  
    sqlite3Fts3DoclistPrev(0, pReader->aDoclist, pReader->nDoclist, (&p), (&pReader->iDocid), (&pReader->nOffsetList), (&bEof));
    if (bEof) {
      (pReader->pOffsetList = 0);
    }  
    else {
      (pReader->pOffsetList = p);
    }
  }  
  else {
    char *pEnd =  (&pReader->aDoclist[pReader->nDoclist]);
    while (1) {
      while (((*p) | c)) {
        (c = ((*p++) & 0x80));
      }
      ((void ) 0);
      if (((pReader->pBlob == 0) || (p < (&pReader->aNode[pReader->nPopulate])))) {
        break;
      }  
      (rc = fts3SegReaderIncrRead(pReader));
      if ((rc != 0)) {
        return rc;
      }  
    }
    p++;
    if (ppOffsetList) {
      ((*ppOffsetList) = pReader->pOffsetList);
      ((*pnOffsetList) = ((int ) (p - pReader->pOffsetList - 1)));
    }  
    while (((p < pEnd) && ((*p) == 0))) {
      p++;
    }
    if ((p >= pEnd)) {
      (pReader->pOffsetList = 0);
    }  
    else {
      (rc = fts3SegReaderRequire(pReader, p, 10));
      if ((rc == 0)) {
        sqlite3_int64 iDelta;
        (pReader->pOffsetList = (p + sqlite3Fts3GetVarint(p, (&iDelta))));
        if (pTab->bDescIdx) {
          (pReader->iDocid -= iDelta);
        }  
        else {
          (pReader->iDocid += iDelta);
        }
      }  
    }
  }
  return 0;
}
static  int sqlite3Fts3MsrOvfl(_1273_Fts3Cursor *pCsr , _1273_Fts3MultiSegReader *pMsr , int *pnOvfl )  {
  _1273_Fts3Table *p =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  int nOvfl =  0;
  int ii;
  int rc =  0;
  int pgsz =  p->nPgsz;
  ((void ) 0);
  ((void ) 0);
  for ((ii = 0); ((rc == 0) && (ii < pMsr->nSegment)); ii++) {
    _1273_Fts3SegReader *pReader =  pMsr->apSegment[ii];
    if (((! (pReader->ppNextElem != 0)) && (! (pReader->rootOnly != 0)))) {
      sqlite3_int64 jj;
      for ((jj = pReader->iStartBlock); (jj <= pReader->iLeafEndBlock); jj++) {
        int nBlob;
        (rc = sqlite3Fts3ReadBlock(p, jj, 0, (&nBlob), 0));
        if ((rc != 0)) {
          break;
        }  
        if (((nBlob + 35) > pgsz)) {
          (nOvfl += ((nBlob + 34) / pgsz));
        }  
      }
    }  
  }
  ((*pnOvfl) = nOvfl);
  return rc;
}
static  void sqlite3Fts3SegReaderFree(_1273_Fts3SegReader *pReader )  {
  if ((pReader && (! (pReader->ppNextElem != 0)))) {
    sqlite3_free(pReader->zTerm);
    if ((! (pReader->rootOnly != 0))) {
      sqlite3_free(pReader->aNode);
      sqlite3_blob_close(pReader->pBlob);
    }  
  }  
  sqlite3_free(pReader);
}
static  int sqlite3Fts3SegReaderNew(int iAge , int bLookup , sqlite3_int64 iStartLeaf , sqlite3_int64 iEndLeaf , sqlite3_int64 iEndBlock , const  char *zRoot , int nRoot , _1273_Fts3SegReader **ppReader )  {
  _1273_Fts3SegReader *pReader;
  int nExtra =  0;
  ((void ) 0);
  if ((iStartLeaf == 0)) {
    (nExtra = (nRoot + (10 * 2)));
  }  
  (pReader = ((_1273_Fts3SegReader *) sqlite3_malloc((sizeof(_1273_Fts3SegReader ) + nExtra))));
  if ((! pReader)) {
    return 7;
  }  
  memset(pReader, 0, sizeof(_1273_Fts3SegReader ));
  (pReader->iIdx = iAge);
  (pReader->bLookup = (bLookup != 0));
  (pReader->iStartBlock = iStartLeaf);
  (pReader->iLeafEndBlock = iEndLeaf);
  (pReader->iEndBlock = iEndBlock);
  if (nExtra) {
    (pReader->aNode = ((char *) (&pReader[1])));
    (pReader->rootOnly = 1);
    (pReader->nNode = nRoot);
    memcpy(pReader->aNode, zRoot, nRoot);
    memset((&pReader->aNode[nRoot]), 0, (10 * 2));
  }  
  else {
    (pReader->iCurrentBlock = (iStartLeaf - 1));
  }
  ((*ppReader) = pReader);
  return 0;
}
static  int fts3CompareElemByTerm(const  void *lhs , const  void *rhs )  {
  char *z1 =  (*((_1273_Fts3HashElem **) lhs))->pKey;
  char *z2 =  (*((_1273_Fts3HashElem **) rhs))->pKey;
  int n1 =  (*((_1273_Fts3HashElem **) lhs))->nKey;
  int n2 =  (*((_1273_Fts3HashElem **) rhs))->nKey;
  int n =  ((n1 < n2) ? n1 : n2);
  int c =  memcmp(z1, z2, n);
  if ((c == 0)) {
    (c = (n1 - n2));
  }  
  return c;
}
static  int sqlite3Fts3SegReaderPending(_1273_Fts3Table *p , int iIndex , const  char *zTerm , int nTerm , int bPrefix , _1273_Fts3SegReader **ppReader )  {
  _1273_Fts3SegReader *pReader =  0;
  _1273_Fts3HashElem *pE;
  _1273_Fts3HashElem **aElem =  0;
  int nElem =  0;
  int rc =  0;
  _1273_Fts3Hash *pHash;
  (pHash = (&p->aIndex[iIndex].hPending));
  if (bPrefix) {
    int nAlloc =  0;
    for ((pE = pHash->first); pE; (pE = pE->next)) {
      char *zKey =  ((char *) pE->pKey);
      int nKey =  pE->nKey;
      if (((nTerm == 0) || ((nKey >= nTerm) && (0 == memcmp(zKey, zTerm, nTerm))))) {
        if ((nElem == nAlloc)) {
          _1273_Fts3HashElem **aElem2;
          (nAlloc += 16);
          (aElem2 = ((_1273_Fts3HashElem **) sqlite3_realloc(aElem, (nAlloc * sizeof(_1273_Fts3HashElem *)))));
          if ((! aElem2)) {
            (rc = 7);
            (nElem = 0);
            break;
          }  
          (aElem = aElem2);
        }  
        (aElem[nElem++] = pE);
      }  
    }
    if ((nElem > 1)) {
      qsort(aElem, nElem, sizeof(_1273_Fts3HashElem *), fts3CompareElemByTerm);
    }  
  }  
  else {
    (pE = sqlite3Fts3HashFindElem(pHash, zTerm, nTerm));
    if (pE) {
      (aElem = (&pE));
      (nElem = 1);
    }  
  }
  if ((nElem > 0)) {
    int nByte =  (sizeof(_1273_Fts3SegReader ) + ((nElem + 1) * sizeof(_1273_Fts3HashElem *)));
    (pReader = ((_1273_Fts3SegReader *) sqlite3_malloc(nByte)));
    if ((! pReader)) {
      (rc = 7);
    }  
    else {
      memset(pReader, 0, nByte);
      (pReader->iIdx = 0x7FFFFFFF);
      (pReader->ppNextElem = ((_1273_Fts3HashElem **) (&pReader[1])));
      memcpy(pReader->ppNextElem, aElem, (nElem * sizeof(_1273_Fts3HashElem *)));
    }
  }  
  if (bPrefix) {
    sqlite3_free(aElem);
  }  
  ((*ppReader) = pReader);
  return rc;
}
static  int fts3SegReaderCmp(_1273_Fts3SegReader *pLhs , _1273_Fts3SegReader *pRhs )  {
  int rc;
  if ((pLhs->aNode && pRhs->aNode)) {
    int rc2 =  (pLhs->nTerm - pRhs->nTerm);
    if ((rc2 < 0)) {
      (rc = memcmp(pLhs->zTerm, pRhs->zTerm, pLhs->nTerm));
    }  
    else {
      (rc = memcmp(pLhs->zTerm, pRhs->zTerm, pRhs->nTerm));
    }
    if ((rc == 0)) {
      (rc = rc2);
    }  
  }  
  else {
    (rc = ((pLhs->aNode == 0) - (pRhs->aNode == 0)));
  }
  if ((rc == 0)) {
    (rc = (pRhs->iIdx - pLhs->iIdx));
  }  
  ((void ) 0);
  return rc;
}
static  int fts3SegReaderDoclistCmp(_1273_Fts3SegReader *pLhs , _1273_Fts3SegReader *pRhs )  {
  int rc =  ((pLhs->pOffsetList == 0) - (pRhs->pOffsetList == 0));
  if ((rc == 0)) {
    if ((pLhs->iDocid == pRhs->iDocid)) {
      (rc = (pRhs->iIdx - pLhs->iIdx));
    }  
    else {
      (rc = ((pLhs->iDocid > pRhs->iDocid) ? 1 : (- 1)));
    }
  }  
  ((void ) 0);
  return rc;
}
static  int fts3SegReaderDoclistCmpRev(_1273_Fts3SegReader *pLhs , _1273_Fts3SegReader *pRhs )  {
  int rc =  ((pLhs->pOffsetList == 0) - (pRhs->pOffsetList == 0));
  if ((rc == 0)) {
    if ((pLhs->iDocid == pRhs->iDocid)) {
      (rc = (pRhs->iIdx - pLhs->iIdx));
    }  
    else {
      (rc = ((pLhs->iDocid < pRhs->iDocid) ? 1 : (- 1)));
    }
  }  
  ((void ) 0);
  return rc;
}
static  int fts3SegReaderTermCmp(_1273_Fts3SegReader *pSeg , const  char *zTerm , int nTerm )  {
  int res =  0;
  if (pSeg->aNode) {
    if ((pSeg->nTerm > nTerm)) {
      (res = memcmp(pSeg->zTerm, zTerm, nTerm));
    }  
    else {
      (res = memcmp(pSeg->zTerm, zTerm, pSeg->nTerm));
    }
    if ((res == 0)) {
      (res = (pSeg->nTerm - nTerm));
    }  
  }  
  return res;
}
static  void fts3SegReaderSort(_1273_Fts3SegReader **apSegment , int nSegment , int nSuspect , int ( *xCmp)(_1273_Fts3SegReader * , _1273_Fts3SegReader * ) )  {
  int i;
  ((void ) 0);
  if ((nSuspect == nSegment)) {
    nSuspect--;
  }  
  for ((i = (nSuspect - 1)); (i >= 0); i--) {
    int j;
    for ((j = i); (j < (nSegment - 1)); j++) {
      _1273_Fts3SegReader *pTmp;
      if ((xCmp(apSegment[j], apSegment[(j + 1)]) < 0)) {
        break;
      }  
      (pTmp = apSegment[(j + 1)]);
      (apSegment[(j + 1)] = apSegment[j]);
      (apSegment[j] = pTmp);
    }
  }
}
static  int fts3WriteSegment(_1273_Fts3Table *p , sqlite3_int64 iBlock , char *z , int n )  {
  sqlite3_stmt *pStmt;
  int rc =  fts3SqlStmt(p, 9, (&pStmt), 0);
  if ((rc == 0)) {
    sqlite3_bind_int64(pStmt, 1, iBlock);
    sqlite3_bind_blob(pStmt, 2, z, n, ((sqlite3_destructor_type ) 0));
    sqlite3_step(pStmt);
    (rc = sqlite3_reset(pStmt));
  }  
  return rc;
}
static  int sqlite3Fts3MaxLevel(_1273_Fts3Table *p , int *pnMax )  {
  int rc;
  int mxLevel =  0;
  sqlite3_stmt *pStmt =  0;
  (rc = fts3SqlStmt(p, 36, (&pStmt), 0));
  if ((rc == 0)) {
    if ((100 == sqlite3_step(pStmt))) {
      (mxLevel = sqlite3_column_int(pStmt, 0));
    }  
    (rc = sqlite3_reset(pStmt));
  }  
  ((*pnMax) = mxLevel);
  return rc;
}
static  int fts3WriteSegdir(_1273_Fts3Table *p , sqlite3_int64 iLevel , int iIdx , sqlite3_int64 iStartBlock , sqlite3_int64 iLeafEndBlock , sqlite3_int64 iEndBlock , char *zRoot , int nRoot )  {
  sqlite3_stmt *pStmt;
  int rc =  fts3SqlStmt(p, 11, (&pStmt), 0);
  if ((rc == 0)) {
    sqlite3_bind_int64(pStmt, 1, iLevel);
    sqlite3_bind_int(pStmt, 2, iIdx);
    sqlite3_bind_int64(pStmt, 3, iStartBlock);
    sqlite3_bind_int64(pStmt, 4, iLeafEndBlock);
    sqlite3_bind_int64(pStmt, 5, iEndBlock);
    sqlite3_bind_blob(pStmt, 6, zRoot, nRoot, ((sqlite3_destructor_type ) 0));
    sqlite3_step(pStmt);
    (rc = sqlite3_reset(pStmt));
  }  
  return rc;
}
static  int fts3PrefixCompress(const  char *zPrev , int nPrev , const  char *zNext , int nNext )  {
  int n;
  ((void ) nNext);
  for ((n = 0); ((n < nPrev) && (zPrev[n] == zNext[n])); n++) {
    
  }
  return n;
}
static  int fts3NodeAddTerm(_1273_Fts3Table *p , _1273_SegmentNode **ppTree , int isCopyTerm , const  char *zTerm , int nTerm )  {
  _1273_SegmentNode *pTree =  (*ppTree);
  int rc;
  _1273_SegmentNode *pNew;
  if (pTree) {
    int nData =  pTree->nData;
    int nReq =  nData;
    int nPrefix;
    int nSuffix;
    (nPrefix = fts3PrefixCompress(pTree->zTerm, pTree->nTerm, zTerm, nTerm));
    (nSuffix = (nTerm - nPrefix));
    (nReq += (sqlite3Fts3VarintLen(nPrefix) + sqlite3Fts3VarintLen(nSuffix) + nSuffix));
    if (((nReq <= p->nNodeSize) || (! pTree->zTerm))) {
      if ((nReq > p->nNodeSize)) {
        ((void ) 0);
        (pTree->aData = ((char *) sqlite3_malloc(nReq)));
        if ((! pTree->aData)) {
          return 7;
        }  
      }  
      if (pTree->zTerm) {
        (nData += sqlite3Fts3PutVarint((&pTree->aData[nData]), nPrefix));
      }  
      (nData += sqlite3Fts3PutVarint((&pTree->aData[nData]), nSuffix));
      memcpy((&pTree->aData[nData]), (&zTerm[nPrefix]), nSuffix);
      (pTree->nData = (nData + nSuffix));
      pTree->nEntry++;
      if (isCopyTerm) {
        if ((pTree->nMalloc < nTerm)) {
          char *zNew =  sqlite3_realloc(pTree->zMalloc, (nTerm * 2));
          if ((! zNew)) {
            return 7;
          }  
          (pTree->nMalloc = (nTerm * 2));
          (pTree->zMalloc = zNew);
        }  
        (pTree->zTerm = pTree->zMalloc);
        memcpy(pTree->zTerm, zTerm, nTerm);
        (pTree->nTerm = nTerm);
      }  
      else {
        (pTree->zTerm = ((char *) zTerm));
        (pTree->nTerm = nTerm);
      }
      return 0;
    }  
  }  
  (pNew = ((_1273_SegmentNode *) sqlite3_malloc((sizeof(_1273_SegmentNode ) + p->nNodeSize))));
  if ((! pNew)) {
    return 7;
  }  
  memset(pNew, 0, sizeof(_1273_SegmentNode ));
  (pNew->nData = (1 + 10));
  (pNew->aData = ((char *) (&pNew[1])));
  if (pTree) {
    _1273_SegmentNode *pParent =  pTree->pParent;
    (rc = fts3NodeAddTerm(p, (&pParent), isCopyTerm, zTerm, nTerm));
    if ((pTree->pParent == 0)) {
      (pTree->pParent = pParent);
    }  
    (pTree->pRight = pNew);
    (pNew->pLeftmost = pTree->pLeftmost);
    (pNew->pParent = pParent);
    (pNew->zMalloc = pTree->zMalloc);
    (pNew->nMalloc = pTree->nMalloc);
    (pTree->zMalloc = 0);
  }  
  else {
    (pNew->pLeftmost = pNew);
    (rc = fts3NodeAddTerm(p, (&pNew), isCopyTerm, zTerm, nTerm));
  }
  ((*ppTree) = pNew);
  return rc;
}
static  int fts3TreeFinishNode(_1273_SegmentNode *pTree , int iHeight , sqlite3_int64 iLeftChild )  {
  int nStart;
  ((void ) 0);
  (nStart = (10 - sqlite3Fts3VarintLen(iLeftChild)));
  (pTree->aData[nStart] = ((char ) iHeight));
  sqlite3Fts3PutVarint((&pTree->aData[(nStart + 1)]), iLeftChild);
  return nStart;
}
static  int fts3NodeWrite(_1273_Fts3Table *p , _1273_SegmentNode *pTree , int iHeight , sqlite3_int64 iLeaf , sqlite3_int64 iFree , sqlite3_int64 *piLast , char **paRoot , int *pnRoot )  {
  int rc =  0;
  if ((! pTree->pParent)) {
    int nStart =  fts3TreeFinishNode(pTree, iHeight, iLeaf);
    ((*piLast) = (iFree - 1));
    ((*pnRoot) = (pTree->nData - nStart));
    ((*paRoot) = (&pTree->aData[nStart]));
  }  
  else {
    _1273_SegmentNode *pIter;
    sqlite3_int64 iNextFree =  iFree;
    sqlite3_int64 iNextLeaf =  iLeaf;
    for ((pIter = pTree->pLeftmost); (pIter && (rc == 0)); (pIter = pIter->pRight)) {
      int nStart =  fts3TreeFinishNode(pIter, iHeight, iNextLeaf);
      int nWrite =  (pIter->nData - nStart);
      (rc = fts3WriteSegment(p, iNextFree, (&pIter->aData[nStart]), nWrite));
      iNextFree++;
      (iNextLeaf += (pIter->nEntry + 1));
    }
    if ((rc == 0)) {
      ((void ) 0);
      (rc = fts3NodeWrite(p, pTree->pParent, (iHeight + 1), iFree, iNextFree, piLast, paRoot, pnRoot));
    }  
  }
  return rc;
}
static  void fts3NodeFree(_1273_SegmentNode *pTree )  {
  if (pTree) {
    _1273_SegmentNode *p =  pTree->pLeftmost;
    fts3NodeFree(p->pParent);
    while (p) {
      _1273_SegmentNode *pRight =  p->pRight;
      if ((p->aData != ((char *) (&p[1])))) {
        sqlite3_free(p->aData);
      }  
      ((void ) 0);
      sqlite3_free(p->zMalloc);
      sqlite3_free(p);
      (p = pRight);
    }
  }  
}
static  int fts3SegWriterAdd(_1273_Fts3Table *p , _1273_SegmentWriter **ppWriter , int isCopyTerm , const  char *zTerm , int nTerm , const  char *aDoclist , int nDoclist )  {
  int nPrefix;
  int nSuffix;
  int nReq;
  int nData;
  _1273_SegmentWriter *pWriter =  (*ppWriter);
  if ((! pWriter)) {
    int rc;
    sqlite3_stmt *pStmt;
    (pWriter = ((_1273_SegmentWriter *) sqlite3_malloc(sizeof(_1273_SegmentWriter ))));
    if ((! pWriter)) {
      return 7;
    }  
    memset(pWriter, 0, sizeof(_1273_SegmentWriter ));
    ((*ppWriter) = pWriter);
    (pWriter->aData = ((char *) sqlite3_malloc(p->nNodeSize)));
    if ((! pWriter->aData)) {
      return 7;
    }  
    (pWriter->nSize = p->nNodeSize);
    (rc = fts3SqlStmt(p, 10, (&pStmt), 0));
    if ((rc != 0)) {
      return rc;
    }  
    if ((100 == sqlite3_step(pStmt))) {
      (pWriter->iFree = sqlite3_column_int64(pStmt, 0));
      (pWriter->iFirst = pWriter->iFree);
    }  
    (rc = sqlite3_reset(pStmt));
    if ((rc != 0)) {
      return rc;
    }  
  }  
  (nData = pWriter->nData);
  (nPrefix = fts3PrefixCompress(pWriter->zTerm, pWriter->nTerm, zTerm, nTerm));
  (nSuffix = (nTerm - nPrefix));
  (nReq = (sqlite3Fts3VarintLen(nPrefix) + sqlite3Fts3VarintLen(nSuffix) + nSuffix + sqlite3Fts3VarintLen(nDoclist) + nDoclist));
  if (((nData > 0) && ((nData + nReq) > p->nNodeSize))) {
    int rc;
    (rc = fts3WriteSegment(p, pWriter->iFree++, pWriter->aData, nData));
    if ((rc != 0)) {
      return rc;
    }  
    p->nLeafAdd++;
    ((void ) 0);
    (rc = fts3NodeAddTerm(p, (&pWriter->pTree), isCopyTerm, zTerm, (nPrefix + 1)));
    if ((rc != 0)) {
      return rc;
    }  
    (nData = 0);
    (pWriter->nTerm = 0);
    (nPrefix = 0);
    (nSuffix = nTerm);
    (nReq = (1 + sqlite3Fts3VarintLen(nTerm) + nTerm + sqlite3Fts3VarintLen(nDoclist) + nDoclist));
  }  
  if ((nReq > pWriter->nSize)) {
    char *aNew =  sqlite3_realloc(pWriter->aData, nReq);
    if ((! aNew)) {
      return 7;
    }  
    (pWriter->aData = aNew);
    (pWriter->nSize = nReq);
  }  
  ((void ) 0);
  (nData += sqlite3Fts3PutVarint((&pWriter->aData[nData]), nPrefix));
  (nData += sqlite3Fts3PutVarint((&pWriter->aData[nData]), nSuffix));
  memcpy((&pWriter->aData[nData]), (&zTerm[nPrefix]), nSuffix);
  (nData += nSuffix);
  (nData += sqlite3Fts3PutVarint((&pWriter->aData[nData]), nDoclist));
  memcpy((&pWriter->aData[nData]), aDoclist, nDoclist);
  (pWriter->nData = (nData + nDoclist));
  if (isCopyTerm) {
    if ((nTerm > pWriter->nMalloc)) {
      char *zNew =  sqlite3_realloc(pWriter->zMalloc, (nTerm * 2));
      if ((! zNew)) {
        return 7;
      }  
      (pWriter->nMalloc = (nTerm * 2));
      (pWriter->zMalloc = zNew);
      (pWriter->zTerm = zNew);
    }  
    ((void ) 0);
    memcpy(pWriter->zTerm, zTerm, nTerm);
  }  
  else {
    (pWriter->zTerm = ((char *) zTerm));
  }
  (pWriter->nTerm = nTerm);
  return 0;
}
static  int fts3SegWriterFlush(_1273_Fts3Table *p , _1273_SegmentWriter *pWriter , sqlite3_int64 iLevel , int iIdx )  {
  int rc;
  if (pWriter->pTree) {
    sqlite3_int64 iLast =  0;
    sqlite3_int64 iLastLeaf;
    char *zRoot =  ((void *) 0);
    int nRoot =  0;
    (iLastLeaf = pWriter->iFree);
    (rc = fts3WriteSegment(p, pWriter->iFree++, pWriter->aData, pWriter->nData));
    if ((rc == 0)) {
      (rc = fts3NodeWrite(p, pWriter->pTree, 1, pWriter->iFirst, pWriter->iFree, (&iLast), (&zRoot), (&nRoot)));
    }  
    if ((rc == 0)) {
      (rc = fts3WriteSegdir(p, iLevel, iIdx, pWriter->iFirst, iLastLeaf, iLast, zRoot, nRoot));
    }  
  }  
  else {
    (rc = fts3WriteSegdir(p, iLevel, iIdx, 0, 0, 0, pWriter->aData, pWriter->nData));
  }
  p->nLeafAdd++;
  return rc;
}
static  void fts3SegWriterFree(_1273_SegmentWriter *pWriter )  {
  if (pWriter) {
    sqlite3_free(pWriter->aData);
    sqlite3_free(pWriter->zMalloc);
    fts3NodeFree(pWriter->pTree);
    sqlite3_free(pWriter);
  }  
}
static  int fts3IsEmpty(_1273_Fts3Table *p , sqlite3_value *pRowid , int *pisEmpty )  {
  sqlite3_stmt *pStmt;
  int rc;
  if (p->zContentTbl) {
    ((*pisEmpty) = 0);
    (rc = 0);
  }  
  else {
    (rc = fts3SqlStmt(p, 1, (&pStmt), (&pRowid)));
    if ((rc == 0)) {
      if ((100 == sqlite3_step(pStmt))) {
        ((*pisEmpty) = sqlite3_column_int(pStmt, 0));
      }  
      (rc = sqlite3_reset(pStmt));
    }  
  }
  return rc;
}
static  int fts3SegmentMaxLevel(_1273_Fts3Table *p , int iLangid , int iIndex , sqlite3_int64 *pnMax )  {
  sqlite3_stmt *pStmt;
  int rc;
  ((void ) 0);
  (rc = fts3SqlStmt(p, 15, (&pStmt), 0));
  if ((rc != 0)) {
    return rc;
  }  
  sqlite3_bind_int64(pStmt, 1, getAbsoluteLevel(p, iLangid, iIndex, 0));
  sqlite3_bind_int64(pStmt, 2, getAbsoluteLevel(p, iLangid, iIndex, (1024 - 1)));
  if ((100 == sqlite3_step(pStmt))) {
    ((*pnMax) = sqlite3_column_int64(pStmt, 0));
  }  
  return sqlite3_reset(pStmt);
}
static  int fts3DeleteSegment(_1273_Fts3Table *p , _1273_Fts3SegReader *pSeg )  {
  int rc =  0;
  if (pSeg->iStartBlock) {
    sqlite3_stmt *pDelete;
    (rc = fts3SqlStmt(p, 17, (&pDelete), 0));
    if ((rc == 0)) {
      sqlite3_bind_int64(pDelete, 1, pSeg->iStartBlock);
      sqlite3_bind_int64(pDelete, 2, pSeg->iEndBlock);
      sqlite3_step(pDelete);
      (rc = sqlite3_reset(pDelete));
    }  
  }  
  return rc;
}
static  int fts3DeleteSegdir(_1273_Fts3Table *p , int iLangid , int iIndex , int iLevel , _1273_Fts3SegReader **apSegment , int nReader )  {
  int rc =  0;
  int i;
  sqlite3_stmt *pDelete =  0;
  for ((i = 0); ((rc == 0) && (i < nReader)); i++) {
    (rc = fts3DeleteSegment(p, apSegment[i]));
  }
  if ((rc != 0)) {
    return rc;
  }  
  ((void ) 0);
  if ((iLevel == (- 2))) {
    (rc = fts3SqlStmt(p, 26, (&pDelete), 0));
    if ((rc == 0)) {
      sqlite3_bind_int64(pDelete, 1, getAbsoluteLevel(p, iLangid, iIndex, 0));
      sqlite3_bind_int64(pDelete, 2, getAbsoluteLevel(p, iLangid, iIndex, (1024 - 1)));
    }  
  }  
  else {
    (rc = fts3SqlStmt(p, 16, (&pDelete), 0));
    if ((rc == 0)) {
      sqlite3_bind_int64(pDelete, 1, getAbsoluteLevel(p, iLangid, iIndex, iLevel));
    }  
  }
  if ((rc == 0)) {
    sqlite3_step(pDelete);
    (rc = sqlite3_reset(pDelete));
  }  
  return rc;
}
static  void fts3ColumnFilter(int iCol , int bZero , char **ppList , int *pnList )  {
  char *pList =  (*ppList);
  int nList =  (*pnList);
  char *pEnd =  (&pList[nList]);
  int iCurrent =  0;
  char *p =  pList;
  ((void ) 0);
  while (1) {
    char c =  0;
    while (((p < pEnd) && ((c | (*p)) & 0xFE))) {
      (c = ((*p++) & 0x80));
    }
    if ((iCol == iCurrent)) {
      (nList = ((int ) (p - pList)));
      break;
    }  
    (nList -= ((int ) (p - pList)));
    (pList = p);
    if ((nList == 0)) {
      break;
    }  
    (p = (&pList[1]));
    (p += sqlite3Fts3GetVarint32(p, (&iCurrent)));
  }
  if ((bZero && ((&pList[nList]) != pEnd))) {
    memset((&pList[nList]), 0, (pEnd - (&pList[nList])));
  }  
  ((*ppList) = pList);
  ((*pnList) = nList);
}
static  int fts3MsrBufferData(_1273_Fts3MultiSegReader *pMsr , char *pList , int nList )  {
  if ((nList > pMsr->nBuffer)) {
    char *pNew;
    (pMsr->nBuffer = (nList * 2));
    (pNew = ((char *) sqlite3_realloc(pMsr->aBuffer, pMsr->nBuffer)));
    if ((! pNew)) {
      return 7;
    }  
    (pMsr->aBuffer = pNew);
  }  
  memcpy(pMsr->aBuffer, pList, nList);
  return 0;
}
static  int sqlite3Fts3MsrIncrNext(_1273_Fts3Table *p , _1273_Fts3MultiSegReader *pMsr , sqlite3_int64 *piDocid , char **paPoslist , int *pnPoslist )  {
  int nMerge =  pMsr->nAdvance;
  _1273_Fts3SegReader **apSegment =  pMsr->apSegment;
  int ( *xCmp)(_1273_Fts3SegReader * , _1273_Fts3SegReader * ) =  (p->bDescIdx ? fts3SegReaderDoclistCmpRev : fts3SegReaderDoclistCmp);
  if ((nMerge == 0)) {
    ((*paPoslist) = 0);
    return 0;
  }  
  while (1) {
    _1273_Fts3SegReader *pSeg;
    (pSeg = pMsr->apSegment[0]);
    if ((pSeg->pOffsetList == 0)) {
      ((*paPoslist) = 0);
      break;
    }  
    else {
      int rc;
      char *pList;
      int nList;
      int j;
      sqlite3_int64 iDocid =  apSegment[0]->iDocid;
      (rc = fts3SegReaderNextDocid(p, apSegment[0], (&pList), (&nList)));
      (j = 1);
      while (((rc == 0) && (j < nMerge) && apSegment[j]->pOffsetList && (apSegment[j]->iDocid == iDocid))) {
        (rc = fts3SegReaderNextDocid(p, apSegment[j], 0, 0));
        j++;
      }
      if ((rc != 0)) {
        return rc;
      }  
      fts3SegReaderSort(pMsr->apSegment, nMerge, j, xCmp);
      if (((nList > 0) && (apSegment[0]->ppNextElem != 0))) {
        (rc = fts3MsrBufferData(pMsr, pList, (nList + 1)));
        if ((rc != 0)) {
          return rc;
        }  
        ((void ) 0);
        (pList = pMsr->aBuffer);
      }  
      if ((pMsr->iColFilter >= 0)) {
        fts3ColumnFilter(pMsr->iColFilter, 1, (&pList), (&nList));
      }  
      if ((nList > 0)) {
        ((*paPoslist) = pList);
        ((*piDocid) = iDocid);
        ((*pnPoslist) = nList);
        break;
      }  
    }
  }
  return 0;
}
static  int fts3SegReaderStart(_1273_Fts3Table *p , _1273_Fts3MultiSegReader *pCsr , const  char *zTerm , int nTerm )  {
  int i;
  int nSeg =  pCsr->nSegment;
  for ((i = 0); ((pCsr->bRestart == 0) && (i < pCsr->nSegment)); i++) {
    int res =  0;
    _1273_Fts3SegReader *pSeg =  pCsr->apSegment[i];
    do {
      int rc =  fts3SegReaderNext(p, pSeg, 0);
      if ((rc != 0)) {
        return rc;
      }  
    } while ((zTerm && ((res = fts3SegReaderTermCmp(pSeg, zTerm, nTerm)) < 0)));
    if ((pSeg->bLookup && (res != 0))) {
      fts3SegReaderSetEof(pSeg);
    }  
  }
  fts3SegReaderSort(pCsr->apSegment, nSeg, nSeg, fts3SegReaderCmp);
  return 0;
}
static  int sqlite3Fts3SegReaderStart(_1273_Fts3Table *p , _1273_Fts3MultiSegReader *pCsr , _1273_Fts3SegFilter *pFilter )  {
  (pCsr->pFilter = pFilter);
  return fts3SegReaderStart(p, pCsr, pFilter->zTerm, pFilter->nTerm);
}
static  int sqlite3Fts3MsrIncrStart(_1273_Fts3Table *p , _1273_Fts3MultiSegReader *pCsr , int iCol , const  char *zTerm , int nTerm )  {
  int i;
  int rc;
  int nSegment =  pCsr->nSegment;
  int ( *xCmp)(_1273_Fts3SegReader * , _1273_Fts3SegReader * ) =  (p->bDescIdx ? fts3SegReaderDoclistCmpRev : fts3SegReaderDoclistCmp);
  ((void ) 0);
  ((void ) 0);
  (rc = fts3SegReaderStart(p, pCsr, zTerm, nTerm));
  if ((rc != 0)) {
    return rc;
  }  
  for ((i = 0); (i < nSegment); i++) {
    _1273_Fts3SegReader *pSeg =  pCsr->apSegment[i];
    if (((! pSeg->aNode) || fts3SegReaderTermCmp(pSeg, zTerm, nTerm))) {
      break;
    }  
  }
  (pCsr->nAdvance = i);
  for ((i = 0); (i < pCsr->nAdvance); i++) {
    (rc = fts3SegReaderFirstDocid(p, pCsr->apSegment[i]));
    if ((rc != 0)) {
      return rc;
    }  
  }
  fts3SegReaderSort(pCsr->apSegment, i, i, xCmp);
  ((void ) 0);
  (pCsr->iColFilter = iCol);
  return 0;
}
static  int sqlite3Fts3MsrIncrRestart(_1273_Fts3MultiSegReader *pCsr )  {
  int i;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (pCsr->nAdvance = 0);
  (pCsr->bRestart = 1);
  for ((i = 0); (i < pCsr->nSegment); i++) {
    (pCsr->apSegment[i]->pOffsetList = 0);
    (pCsr->apSegment[i]->nOffsetList = 0);
    (pCsr->apSegment[i]->iDocid = 0);
  }
  return 0;
}
static  int sqlite3Fts3SegReaderStep(_1273_Fts3Table *p , _1273_Fts3MultiSegReader *pCsr )  {
  int rc =  0;
  int isIgnoreEmpty =  (pCsr->pFilter->flags & 0x00000002);
  int isRequirePos =  (pCsr->pFilter->flags & 0x00000001);
  int isColFilter =  (pCsr->pFilter->flags & 0x00000004);
  int isPrefix =  (pCsr->pFilter->flags & 0x00000008);
  int isScan =  (pCsr->pFilter->flags & 0x00000010);
  int isFirst =  (pCsr->pFilter->flags & 0x00000020);
  _1273_Fts3SegReader **apSegment =  pCsr->apSegment;
  int nSegment =  pCsr->nSegment;
  _1273_Fts3SegFilter *pFilter =  pCsr->pFilter;
  int ( *xCmp)(_1273_Fts3SegReader * , _1273_Fts3SegReader * ) =  (p->bDescIdx ? fts3SegReaderDoclistCmpRev : fts3SegReaderDoclistCmp);
  if ((pCsr->nSegment == 0)) {
    return 0;
  }  
  do {
    int nMerge;
    int i;
    for ((i = 0); (i < pCsr->nAdvance); i++) {
      _1273_Fts3SegReader *pSeg =  apSegment[i];
      if (pSeg->bLookup) {
        fts3SegReaderSetEof(pSeg);
      }  
      else {
        (rc = fts3SegReaderNext(p, pSeg, 0));
      }
      if ((rc != 0)) {
        return rc;
      }  
    }
    fts3SegReaderSort(apSegment, nSegment, pCsr->nAdvance, fts3SegReaderCmp);
    (pCsr->nAdvance = 0);
    ((void ) 0);
    if ((apSegment[0]->aNode == 0)) {
      break;
    }  
    (pCsr->nTerm = apSegment[0]->nTerm);
    (pCsr->zTerm = apSegment[0]->zTerm);
    if ((pFilter->zTerm && (! isScan))) {
      if (((pCsr->nTerm < pFilter->nTerm) || ((! isPrefix) && (pCsr->nTerm > pFilter->nTerm)) || memcmp(pCsr->zTerm, pFilter->zTerm, pFilter->nTerm))) {
        break;
      }  
    }  
    (nMerge = 1);
    while (((nMerge < nSegment) && apSegment[nMerge]->aNode && (apSegment[nMerge]->nTerm == pCsr->nTerm) && (0 == memcmp(pCsr->zTerm, apSegment[nMerge]->zTerm, pCsr->nTerm)))) {
      nMerge++;
    }
    ((void ) 0);
    if (((nMerge == 1) && (! isIgnoreEmpty) && (! isFirst) && ((p->bDescIdx == 0) || ((apSegment[0]->ppNextElem != 0) == 0)))) {
      (pCsr->nDoclist = apSegment[0]->nDoclist);
      if ((apSegment[0]->ppNextElem != 0)) {
        (rc = fts3MsrBufferData(pCsr, apSegment[0]->aDoclist, pCsr->nDoclist));
        (pCsr->aDoclist = pCsr->aBuffer);
      }  
      else {
        (pCsr->aDoclist = apSegment[0]->aDoclist);
      }
      if ((rc == 0)) {
        (rc = 100);
      }  
    }  
    else {
      int nDoclist =  0;
      sqlite3_int64 iPrev =  0;
      for ((i = 0); (i < nMerge); i++) {
        fts3SegReaderFirstDocid(p, apSegment[i]);
      }
      fts3SegReaderSort(apSegment, nMerge, nMerge, xCmp);
      while (apSegment[0]->pOffsetList) {
        int j;
        char *pList =  0;
        int nList =  0;
        int nByte;
        sqlite3_int64 iDocid =  apSegment[0]->iDocid;
        fts3SegReaderNextDocid(p, apSegment[0], (&pList), (&nList));
        (j = 1);
        while (((j < nMerge) && apSegment[j]->pOffsetList && (apSegment[j]->iDocid == iDocid))) {
          fts3SegReaderNextDocid(p, apSegment[j], 0, 0);
          j++;
        }
        if (isColFilter) {
          fts3ColumnFilter(pFilter->iCol, 0, (&pList), (&nList));
        }  
        if (((! isIgnoreEmpty) || (nList > 0))) {
          sqlite3_int64 iDelta;
          if ((p->bDescIdx && (nDoclist > 0))) {
            (iDelta = (iPrev - iDocid));
          }  
          else {
            (iDelta = (iDocid - iPrev));
          }
          ((void ) 0);
          ((void ) 0);
          (nByte = (sqlite3Fts3VarintLen(iDelta) + (isRequirePos ? (nList + 1) : 0)));
          if (((nDoclist + nByte) > pCsr->nBuffer)) {
            char *aNew;
            (pCsr->nBuffer = ((nDoclist + nByte) * 2));
            (aNew = sqlite3_realloc(pCsr->aBuffer, pCsr->nBuffer));
            if ((! aNew)) {
              return 7;
            }  
            (pCsr->aBuffer = aNew);
          }  
          if (isFirst) {
            char *a =  (&pCsr->aBuffer[nDoclist]);
            int nWrite;
            (nWrite = sqlite3Fts3FirstFilter(iDelta, pList, nList, a));
            if (nWrite) {
              (iPrev = iDocid);
              (nDoclist += nWrite);
            }  
          }  
          else {
            (nDoclist += sqlite3Fts3PutVarint((&pCsr->aBuffer[nDoclist]), iDelta));
            (iPrev = iDocid);
            if (isRequirePos) {
              memcpy((&pCsr->aBuffer[nDoclist]), pList, nList);
              (nDoclist += nList);
              (pCsr->aBuffer[nDoclist++] = '\0');
            }  
          }
        }  
        fts3SegReaderSort(apSegment, nMerge, j, xCmp);
      }
      if ((nDoclist > 0)) {
        (pCsr->aDoclist = pCsr->aBuffer);
        (pCsr->nDoclist = nDoclist);
        (rc = 100);
      }  
    }
    (pCsr->nAdvance = nMerge);
  } while ((rc == 0));
  return rc;
}
static  void sqlite3Fts3SegReaderFinish(_1273_Fts3MultiSegReader *pCsr )  {
  if (pCsr) {
    int i;
    for ((i = 0); (i < pCsr->nSegment); i++) {
      sqlite3Fts3SegReaderFree(pCsr->apSegment[i]);
    }
    sqlite3_free(pCsr->apSegment);
    sqlite3_free(pCsr->aBuffer);
    (pCsr->nSegment = 0);
    (pCsr->apSegment = 0);
    (pCsr->aBuffer = 0);
  }  
}
static  int fts3SegmentMerge(_1273_Fts3Table *p , int iLangid , int iIndex , int iLevel )  {
  int rc;
  int iIdx =  0;
  sqlite3_int64 iNewLevel =  0;
  _1273_SegmentWriter *pWriter =  0;
  _1273_Fts3SegFilter filter;
  _1273_Fts3MultiSegReader csr;
  int bIgnoreEmpty =  0;
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  (rc = sqlite3Fts3SegReaderCursor(p, iLangid, iIndex, iLevel, 0, 0, 1, 0, (&csr)));
  if (((rc != 0) || (csr.nSegment == 0))) {
    goto _1273_finished;
  }  
  if ((iLevel == (- 2))) {
    if ((csr.nSegment == 1)) {
      (rc = 101);
      goto _1273_finished;
    }  
    (rc = fts3SegmentMaxLevel(p, iLangid, iIndex, (&iNewLevel)));
    (bIgnoreEmpty = 1);
  } 
  else if ((iLevel == (- 1))) {
    (iNewLevel = getAbsoluteLevel(p, iLangid, iIndex, 0));
    (rc = fts3AllocateSegdirIdx(p, iLangid, iIndex, 0, (&iIdx)));
  } 
  else {
    (rc = fts3AllocateSegdirIdx(p, iLangid, iIndex, (iLevel + 1), (&iIdx)));
    (iNewLevel = getAbsoluteLevel(p, iLangid, iIndex, (iLevel + 1)));
  }
  if ((rc != 0)) {
    goto _1273_finished;
  }  
  ((void ) 0);
  ((void ) 0);
  ((void ) 0);
  memset((&filter), 0, sizeof(_1273_Fts3SegFilter ));
  (filter.flags = 0x00000001);
  (filter.flags |= (bIgnoreEmpty ? 0x00000002 : 0));
  (rc = sqlite3Fts3SegReaderStart(p, (&csr), (&filter)));
  while ((0 == rc)) {
    (rc = sqlite3Fts3SegReaderStep(p, (&csr)));
    if ((rc != 100)) {
      break;
    }  
    (rc = fts3SegWriterAdd(p, (&pWriter), 1, csr.zTerm, csr.nTerm, csr.aDoclist, csr.nDoclist));
  }
  if ((rc != 0)) {
    goto _1273_finished;
  }  
  ((void ) 0);
  if ((iLevel != (- 1))) {
    (rc = fts3DeleteSegdir(p, iLangid, iIndex, iLevel, csr.apSegment, csr.nSegment));
    if ((rc != 0)) {
      goto _1273_finished;
    }  
  }  
  (rc = fts3SegWriterFlush(p, pWriter, iNewLevel, iIdx));
  _1273_finished:
  fts3SegWriterFree(pWriter);
  sqlite3Fts3SegReaderFinish((&csr));
  return rc;
}
static  int sqlite3Fts3PendingTermsFlush(_1273_Fts3Table *p )  {
  int rc =  0;
  int i;
  for ((i = 0); ((rc == 0) && (i < p->nIndex)); i++) {
    (rc = fts3SegmentMerge(p, p->iPrevLangid, i, (- 1)));
    if ((rc == 101)) {
      (rc = 0);
    }  
  }
  sqlite3Fts3PendingTermsClear(p);
  if (((rc == 0) && p->bHasStat && (p->bAutoincrmerge == 0xff) && (p->nLeafAdd > 0))) {
    sqlite3_stmt *pStmt =  0;
    (rc = fts3SqlStmt(p, 22, (&pStmt), 0));
    if ((rc == 0)) {
      sqlite3_bind_int(pStmt, 1, 2);
      (rc = sqlite3_step(pStmt));
      (p->bAutoincrmerge = ((rc == 100) && sqlite3_column_int(pStmt, 0)));
      (rc = sqlite3_reset(pStmt));
    }  
  }  
  return rc;
}
static  void fts3EncodeIntArray(int N , u32 *a , char *zBuf , int *pNBuf )  {
  int i, j;
  for ((i = (j = 0)); (i < N); i++) {
    (j += sqlite3Fts3PutVarint((&zBuf[j]), ((sqlite3_int64 ) a[i])));
  }
  ((*pNBuf) = j);
}
static  void fts3DecodeIntArray(int N , u32 *a , const  char *zBuf , int nBuf )  {
  int i, j;
  ((void ) nBuf);
  for ((i = (j = 0)); (i < N); i++) {
    sqlite3_int64 x;
    (j += sqlite3Fts3GetVarint((&zBuf[j]), (&x)));
    ((void ) 0);
    (a[i] = ((u32 ) (x & 0xffffffff)));
  }
}
static  void fts3InsertDocsize(int *pRC , _1273_Fts3Table *p , u32 *aSz )  {
  char *pBlob;
  int nBlob;
  sqlite3_stmt *pStmt;
  int rc;
  if ((*pRC)) {
    return;
  }  
  (pBlob = sqlite3_malloc((10 * p->nColumn)));
  if ((pBlob == 0)) {
    ((*pRC) = 7);
    return;
  }  
  fts3EncodeIntArray(p->nColumn, aSz, pBlob, (&nBlob));
  (rc = fts3SqlStmt(p, 20, (&pStmt), 0));
  if (rc) {
    sqlite3_free(pBlob);
    ((*pRC) = rc);
    return;
  }  
  sqlite3_bind_int64(pStmt, 1, p->iPrevDocid);
  sqlite3_bind_blob(pStmt, 2, pBlob, nBlob, sqlite3_free);
  sqlite3_step(pStmt);
  ((*pRC) = sqlite3_reset(pStmt));
}
static  void fts3UpdateDocTotals(int *pRC , _1273_Fts3Table *p , u32 *aSzIns , u32 *aSzDel , int nChng )  {
  char *pBlob;
  int nBlob;
  u32 *a;
  sqlite3_stmt *pStmt;
  int i;
  int rc;
  const int nStat =  (p->nColumn + 2);
  if ((*pRC)) {
    return;
  }  
  (a = sqlite3_malloc(((sizeof(u32 ) + 10) * nStat)));
  if ((a == 0)) {
    ((*pRC) = 7);
    return;
  }  
  (pBlob = ((char *) (&a[nStat])));
  (rc = fts3SqlStmt(p, 22, (&pStmt), 0));
  if (rc) {
    sqlite3_free(a);
    ((*pRC) = rc);
    return;
  }  
  sqlite3_bind_int(pStmt, 1, 0);
  if ((sqlite3_step(pStmt) == 100)) {
    fts3DecodeIntArray(nStat, a, sqlite3_column_blob(pStmt, 0), sqlite3_column_bytes(pStmt, 0));
  }  
  else {
    memset(a, 0, (sizeof(u32 ) * nStat));
  }
  (rc = sqlite3_reset(pStmt));
  if ((rc != 0)) {
    sqlite3_free(a);
    ((*pRC) = rc);
    return;
  }  
  if (((nChng < 0) && (a[0] < ((u32 ) (- nChng))))) {
    (a[0] = 0);
  }  
  else {
    (a[0] += nChng);
  }
  for ((i = 0); (i < (p->nColumn + 1)); i++) {
    u32 x =  a[(i + 1)];
    if (((x + aSzIns[i]) < aSzDel[i])) {
      (x = 0);
    }  
    else {
      (x = (x + aSzIns[i] - aSzDel[i]));
    }
    (a[(i + 1)] = x);
  }
  fts3EncodeIntArray(nStat, a, pBlob, (&nBlob));
  (rc = fts3SqlStmt(p, 23, (&pStmt), 0));
  if (rc) {
    sqlite3_free(a);
    ((*pRC) = rc);
    return;
  }  
  sqlite3_bind_int(pStmt, 1, 0);
  sqlite3_bind_blob(pStmt, 2, pBlob, nBlob, ((sqlite3_destructor_type ) 0));
  sqlite3_step(pStmt);
  ((*pRC) = sqlite3_reset(pStmt));
  sqlite3_free(a);
}
static  int fts3DoOptimize(_1273_Fts3Table *p , int bReturnDone )  {
  int bSeenDone =  0;
  int rc;
  sqlite3_stmt *pAllLangid =  0;
  (rc = fts3SqlStmt(p, 27, (&pAllLangid), 0));
  if ((rc == 0)) {
    int rc2;
    sqlite3_bind_int(pAllLangid, 1, p->nIndex);
    while ((sqlite3_step(pAllLangid) == 100)) {
      int i;
      int iLangid =  sqlite3_column_int(pAllLangid, 0);
      for ((i = 0); ((rc == 0) && (i < p->nIndex)); i++) {
        (rc = fts3SegmentMerge(p, iLangid, i, (- 2)));
        if ((rc == 101)) {
          (bSeenDone = 1);
          (rc = 0);
        }  
      }
    }
    (rc2 = sqlite3_reset(pAllLangid));
    if ((rc == 0)) {
      (rc = rc2);
    }  
  }  
  sqlite3Fts3SegmentsClose(p);
  sqlite3Fts3PendingTermsClear(p);
  return (((rc == 0) && bReturnDone && bSeenDone) ? 101 : rc);
}
static  int fts3DoRebuild(_1273_Fts3Table *p )  {
  int rc;
  (rc = fts3DeleteAll(p, 0));
  if ((rc == 0)) {
    u32 *aSz =  0;
    u32 *aSzIns =  0;
    u32 *aSzDel =  0;
    sqlite3_stmt *pStmt =  0;
    int nEntry =  0;
    char *zSql =  sqlite3_mprintf("SELECT %s", p->zReadExprlist);
    if ((! zSql)) {
      (rc = 7);
    }  
    else {
      (rc = sqlite3_prepare_v2(p->db, zSql, (- 1), (&pStmt), 0));
      sqlite3_free(zSql);
    }
    if ((rc == 0)) {
      int nByte =  (sizeof(u32 ) * (p->nColumn + 1) * 3);
      (aSz = ((u32 *) sqlite3_malloc(nByte)));
      if ((aSz == 0)) {
        (rc = 7);
      }  
      else {
        memset(aSz, 0, nByte);
        (aSzIns = (&aSz[(p->nColumn + 1)]));
        (aSzDel = (&aSzIns[(p->nColumn + 1)]));
      }
    }  
    while (((rc == 0) && (100 == sqlite3_step(pStmt)))) {
      int iCol;
      int iLangid =  langidFromSelect(p, pStmt);
      (rc = fts3PendingTermsDocid(p, iLangid, sqlite3_column_int64(pStmt, 0)));
      memset(aSz, 0, (sizeof(aSz[0]) * (p->nColumn + 1)));
      for ((iCol = 0); ((rc == 0) && (iCol < p->nColumn)); iCol++) {
        if ((p->abNotindexed[iCol] == 0)) {
          const char *z =  ((const  char *) sqlite3_column_text(pStmt, (iCol + 1)));
          (rc = fts3PendingTermsAdd(p, iLangid, z, iCol, (&aSz[iCol])));
          (aSz[p->nColumn] += sqlite3_column_bytes(pStmt, (iCol + 1)));
        }  
      }
      if (p->bHasDocsize) {
        fts3InsertDocsize((&rc), p, aSz);
      }  
      if ((rc != 0)) {
        sqlite3_finalize(pStmt);
        (pStmt = 0);
      }  
      else {
        nEntry++;
        for ((iCol = 0); (iCol <= p->nColumn); iCol++) {
          (aSzIns[iCol] += aSz[iCol]);
        }
      }
    }
    if (p->bFts4) {
      fts3UpdateDocTotals((&rc), p, aSzIns, aSzDel, nEntry);
    }  
    sqlite3_free(aSz);
    if (pStmt) {
      int rc2 =  sqlite3_finalize(pStmt);
      if ((rc == 0)) {
        (rc = rc2);
      }  
    }  
  }  
  return rc;
}
static  int fts3IncrmergeCsr(_1273_Fts3Table *p , sqlite3_int64 iAbsLevel , int nSeg , _1273_Fts3MultiSegReader *pCsr )  {
  int rc;
  sqlite3_stmt *pStmt =  0;
  int nByte;
  memset(pCsr, 0, sizeof((*pCsr)));
  (nByte = (sizeof(_1273_Fts3SegReader *) * nSeg));
  (pCsr->apSegment = ((_1273_Fts3SegReader **) sqlite3_malloc(nByte)));
  if ((pCsr->apSegment == 0)) {
    (rc = 7);
  }  
  else {
    memset(pCsr->apSegment, 0, nByte);
    (rc = fts3SqlStmt(p, 12, (&pStmt), 0));
  }
  if ((rc == 0)) {
    int i;
    int rc2;
    sqlite3_bind_int64(pStmt, 1, iAbsLevel);
    ((void ) 0);
    for ((i = 0); ((rc == 0) && (sqlite3_step(pStmt) == 100) && (i < nSeg)); i++) {
      (rc = sqlite3Fts3SegReaderNew(i, 0, sqlite3_column_int64(pStmt, 1), sqlite3_column_int64(pStmt, 2), sqlite3_column_int64(pStmt, 3), sqlite3_column_blob(pStmt, 4), sqlite3_column_bytes(pStmt, 4), (&pCsr->apSegment[i])));
      pCsr->nSegment++;
    }
    (rc2 = sqlite3_reset(pStmt));
    if ((rc == 0)) {
      (rc = rc2);
    }  
  }  
  return rc;
}
typedef struct  _1273_IncrmergeWriter   _1273_IncrmergeWriter;
typedef struct  _1273_NodeWriter   _1273_NodeWriter;
typedef struct  _1273_Blob   _1273_Blob;
typedef struct  _1273_NodeReader   _1273_NodeReader;
struct  _1273_Blob {
  char *a ;
  int n ;
  int nAlloc ;
}  ;
struct  _1273_NodeWriter {
  sqlite3_int64 iBlock ;
  _1273_Blob key ;
  _1273_Blob block ;
}  ;
struct  _1273_IncrmergeWriter {
  int nLeafEst ;
  int nWork ;
  sqlite3_int64 iAbsLevel ;
  int iIdx ;
  sqlite3_int64 iStart ;
  sqlite3_int64 iEnd ;
  _1273_NodeWriter aNodeWriter[16] ;
}  ;
struct  _1273_NodeReader {
  const  char *aNode ;
  int nNode ;
  int iOff ;
  sqlite3_int64 iChild ;
  _1273_Blob term ;
  const  char *aDoclist ;
  int nDoclist ;
}  ;
static  void blobGrowBuffer(_1273_Blob *pBlob , int nMin , int *pRc )  {
  if ((((*pRc) == 0) && (nMin > pBlob->nAlloc))) {
    int nAlloc =  nMin;
    char *a =  ((char *) sqlite3_realloc(pBlob->a, nAlloc));
    if (a) {
      (pBlob->nAlloc = nAlloc);
      (pBlob->a = a);
    }  
    else {
      ((*pRc) = 7);
    }
  }  
}
static  int nodeReaderNext(_1273_NodeReader *p )  {
  int bFirst =  (p->term.n == 0);
  int nPrefix =  0;
  int nSuffix =  0;
  int rc =  0;
  ((void ) 0);
  if ((p->iChild && (bFirst == 0))) {
    p->iChild++;
  }  
  if ((p->iOff >= p->nNode)) {
    (p->aNode = 0);
  }  
  else {
    if ((bFirst == 0)) {
      (p->iOff += sqlite3Fts3GetVarint32((&p->aNode[p->iOff]), (&nPrefix)));
    }  
    (p->iOff += sqlite3Fts3GetVarint32((&p->aNode[p->iOff]), (&nSuffix)));
    blobGrowBuffer((&p->term), (nPrefix + nSuffix), (&rc));
    if ((rc == 0)) {
      memcpy((&p->term.a[nPrefix]), (&p->aNode[p->iOff]), nSuffix);
      (p->term.n = (nPrefix + nSuffix));
      (p->iOff += nSuffix);
      if ((p->iChild == 0)) {
        (p->iOff += sqlite3Fts3GetVarint32((&p->aNode[p->iOff]), (&p->nDoclist)));
        (p->aDoclist = (&p->aNode[p->iOff]));
        (p->iOff += p->nDoclist);
      }  
    }  
  }
  ((void ) 0);
  return rc;
}
static  void nodeReaderRelease(_1273_NodeReader *p )  {
  sqlite3_free(p->term.a);
}
static  int nodeReaderInit(_1273_NodeReader *p , const  char *aNode , int nNode )  {
  memset(p, 0, sizeof(_1273_NodeReader ));
  (p->aNode = aNode);
  (p->nNode = nNode);
  if (p->aNode[0]) {
    (p->iOff = (1 + sqlite3Fts3GetVarint((&p->aNode[1]), (&p->iChild))));
  }  
  else {
    (p->iOff = 1);
  }
  return nodeReaderNext(p);
}
static  int fts3IncrmergePush(_1273_Fts3Table *p , _1273_IncrmergeWriter *pWriter , const  char *zTerm , int nTerm )  {
  sqlite3_int64 iPtr =  pWriter->aNodeWriter[0].iBlock;
  int iLayer;
  ((void ) 0);
  if (((id2i_sqlite_coverage_test ) )) {
    for ((iLayer = 1); 1; iLayer++) {
      sqlite3_int64 iNextPtr =  0;
      _1273_NodeWriter *pNode =  (&pWriter->aNodeWriter[iLayer]);
      int rc =  0;
      int nPrefix;
      int nSuffix;
      int nSpace;
      (nPrefix = fts3PrefixCompress(pNode->key.a, pNode->key.n, zTerm, nTerm));
      (nSuffix = (nTerm - nPrefix));
      (nSpace = sqlite3Fts3VarintLen(nPrefix));
      (nSpace += (sqlite3Fts3VarintLen(nSuffix) + nSuffix));
      if (((pNode->key.n == 0) || ((pNode->block.n + nSpace) <= p->nNodeSize))) {
        _1273_Blob *pBlk =  (&pNode->block);
        if ((pBlk->n == 0)) {
          blobGrowBuffer(pBlk, p->nNodeSize, (&rc));
          if ((rc == 0)) {
            (pBlk->a[0] = ((char ) iLayer));
            (pBlk->n = (1 + sqlite3Fts3PutVarint((&pBlk->a[1]), iPtr)));
          }  
        }  
        blobGrowBuffer(pBlk, (pBlk->n + nSpace), (&rc));
        blobGrowBuffer((&pNode->key), nTerm, (&rc));
        if ((rc == 0)) {
          if (pNode->key.n) {
            (pBlk->n += sqlite3Fts3PutVarint((&pBlk->a[pBlk->n]), nPrefix));
          }  
          (pBlk->n += sqlite3Fts3PutVarint((&pBlk->a[pBlk->n]), nSuffix));
          memcpy((&pBlk->a[pBlk->n]), (&zTerm[nPrefix]), nSuffix);
          (pBlk->n += nSuffix);
          memcpy(pNode->key.a, zTerm, nTerm);
          (pNode->key.n = nTerm);
        }  
      }  
      else {
        (rc = fts3WriteSegment(p, pNode->iBlock, pNode->block.a, pNode->block.n));
        ((void ) 0);
        (pNode->block.a[0] = ((char ) iLayer));
        (pNode->block.n = (1 + sqlite3Fts3PutVarint((&pNode->block.a[1]), (iPtr + 1))));
        (iNextPtr = pNode->iBlock);
        pNode->iBlock++;
        (pNode->key.n = 0);
      }
      if (((rc != 0) || (iNextPtr == 0))) {
        return rc;
      }  
      (iPtr = iNextPtr);
    }
  }  
  if ((((! id2i_sqlite_coverage_test) ) )) {
    for ((iLayer = 1); (iLayer < 16); iLayer++) {
      sqlite3_int64 iNextPtr =  0;
      _1273_NodeWriter *pNode =  (&pWriter->aNodeWriter[iLayer]);
      int rc =  0;
      int nPrefix;
      int nSuffix;
      int nSpace;
      (nPrefix = fts3PrefixCompress(pNode->key.a, pNode->key.n, zTerm, nTerm));
      (nSuffix = (nTerm - nPrefix));
      (nSpace = sqlite3Fts3VarintLen(nPrefix));
      (nSpace += (sqlite3Fts3VarintLen(nSuffix) + nSuffix));
      if (((pNode->key.n == 0) || ((pNode->block.n + nSpace) <= p->nNodeSize))) {
        _1273_Blob *pBlk =  (&pNode->block);
        if ((pBlk->n == 0)) {
          blobGrowBuffer(pBlk, p->nNodeSize, (&rc));
          if ((rc == 0)) {
            (pBlk->a[0] = ((char ) iLayer));
            (pBlk->n = (1 + sqlite3Fts3PutVarint((&pBlk->a[1]), iPtr)));
          }  
        }  
        blobGrowBuffer(pBlk, (pBlk->n + nSpace), (&rc));
        blobGrowBuffer((&pNode->key), nTerm, (&rc));
        if ((rc == 0)) {
          if (pNode->key.n) {
            (pBlk->n += sqlite3Fts3PutVarint((&pBlk->a[pBlk->n]), nPrefix));
          }  
          (pBlk->n += sqlite3Fts3PutVarint((&pBlk->a[pBlk->n]), nSuffix));
          memcpy((&pBlk->a[pBlk->n]), (&zTerm[nPrefix]), nSuffix);
          (pBlk->n += nSuffix);
          memcpy(pNode->key.a, zTerm, nTerm);
          (pNode->key.n = nTerm);
        }  
      }  
      else {
        (rc = fts3WriteSegment(p, pNode->iBlock, pNode->block.a, pNode->block.n));
        ((void ) 0);
        (pNode->block.a[0] = ((char ) iLayer));
        (pNode->block.n = (1 + sqlite3Fts3PutVarint((&pNode->block.a[1]), (iPtr + 1))));
        (iNextPtr = pNode->iBlock);
        pNode->iBlock++;
        (pNode->key.n = 0);
      }
      if (((rc != 0) || (iNextPtr == 0))) {
        return rc;
      }  
      (iPtr = iNextPtr);
    }
  }  
  ((void ) 0);
  return 0;
}
static  int fts3AppendToNode(_1273_Blob *pNode , _1273_Blob *pPrev , const  char *zTerm , int nTerm , const  char *aDoclist , int nDoclist )  {
  int rc =  0;
  int bFirst =  (pPrev->n == 0);
  int nPrefix;
  int nSuffix;
  ((void ) 0);
  ((void ) 0);
  blobGrowBuffer(pPrev, nTerm, (&rc));
  if ((rc != 0)) {
    return rc;
  }  
  (nPrefix = fts3PrefixCompress(pPrev->a, pPrev->n, zTerm, nTerm));
  (nSuffix = (nTerm - nPrefix));
  memcpy(pPrev->a, zTerm, nTerm);
  (pPrev->n = nTerm);
  if ((bFirst == 0)) {
    (pNode->n += sqlite3Fts3PutVarint((&pNode->a[pNode->n]), nPrefix));
  }  
  (pNode->n += sqlite3Fts3PutVarint((&pNode->a[pNode->n]), nSuffix));
  memcpy((&pNode->a[pNode->n]), (&zTerm[nPrefix]), nSuffix);
  (pNode->n += nSuffix);
  if (aDoclist) {
    (pNode->n += sqlite3Fts3PutVarint((&pNode->a[pNode->n]), nDoclist));
    memcpy((&pNode->a[pNode->n]), aDoclist, nDoclist);
    (pNode->n += nDoclist);
  }  
  ((void ) 0);
  return 0;
}
static  int fts3IncrmergeAppend(_1273_Fts3Table *p , _1273_IncrmergeWriter *pWriter , _1273_Fts3MultiSegReader *pCsr )  {
  const char *zTerm =  pCsr->zTerm;
  int nTerm =  pCsr->nTerm;
  const char *aDoclist =  pCsr->aDoclist;
  int nDoclist =  pCsr->nDoclist;
  int rc =  0;
  int nSpace;
  int nPrefix;
  int nSuffix;
  _1273_NodeWriter *pLeaf;
  (pLeaf = (&pWriter->aNodeWriter[0]));
  (nPrefix = fts3PrefixCompress(pLeaf->key.a, pLeaf->key.n, zTerm, nTerm));
  (nSuffix = (nTerm - nPrefix));
  (nSpace = sqlite3Fts3VarintLen(nPrefix));
  (nSpace += (sqlite3Fts3VarintLen(nSuffix) + nSuffix));
  (nSpace += (sqlite3Fts3VarintLen(nDoclist) + nDoclist));
  if (((pLeaf->block.n > 0) && ((pLeaf->block.n + nSpace) > p->nNodeSize))) {
    (rc = fts3WriteSegment(p, pLeaf->iBlock, pLeaf->block.a, pLeaf->block.n));
    pWriter->nWork++;
    if ((rc == 0)) {
      (rc = fts3IncrmergePush(p, pWriter, zTerm, (nPrefix + 1)));
    }  
    pLeaf->iBlock++;
    (pLeaf->key.n = 0);
    (pLeaf->block.n = 0);
    (nSuffix = nTerm);
    (nSpace = 1);
    (nSpace += (sqlite3Fts3VarintLen(nSuffix) + nSuffix));
    (nSpace += (sqlite3Fts3VarintLen(nDoclist) + nDoclist));
  }  
  blobGrowBuffer((&pLeaf->block), (pLeaf->block.n + nSpace), (&rc));
  if ((rc == 0)) {
    if ((pLeaf->block.n == 0)) {
      (pLeaf->block.n = 1);
      (pLeaf->block.a[0] = '\0');
    }  
    (rc = fts3AppendToNode((&pLeaf->block), (&pLeaf->key), zTerm, nTerm, aDoclist, nDoclist));
  }  
  return rc;
}
static  void fts3IncrmergeRelease(_1273_Fts3Table *p , _1273_IncrmergeWriter *pWriter , int *pRc )  {
  int i;
  int iRoot;
  _1273_NodeWriter *pRoot;
  int rc =  (*pRc);
  for ((iRoot = (16 - 1)); (iRoot >= 0); iRoot--) {
    _1273_NodeWriter *pNode =  (&pWriter->aNodeWriter[iRoot]);
    if ((pNode->block.n > 0)) {
      break;
    }  
    ((void ) 0);
    ((void ) 0);
    sqlite3_free(pNode->block.a);
    sqlite3_free(pNode->key.a);
  }
  if ((iRoot < 0)) {
    return;
  }  
  if ((iRoot == 0)) {
    _1273_Blob *pBlock =  (&pWriter->aNodeWriter[1].block);
    blobGrowBuffer(pBlock, (1 + 10), (&rc));
    if ((rc == 0)) {
      (pBlock->a[0] = 0x01);
      (pBlock->n = (1 + sqlite3Fts3PutVarint((&pBlock->a[1]), pWriter->aNodeWriter[0].iBlock)));
    }  
    (iRoot = 1);
  }  
  (pRoot = (&pWriter->aNodeWriter[iRoot]));
  for ((i = 0); (i < iRoot); i++) {
    _1273_NodeWriter *pNode =  (&pWriter->aNodeWriter[i]);
    if (((pNode->block.n > 0) && (rc == 0))) {
      (rc = fts3WriteSegment(p, pNode->iBlock, pNode->block.a, pNode->block.n));
    }  
    sqlite3_free(pNode->block.a);
    sqlite3_free(pNode->key.a);
  }
  if ((rc == 0)) {
    (rc = fts3WriteSegdir(p, (pWriter->iAbsLevel + 1), pWriter->iIdx, pWriter->iStart, pWriter->aNodeWriter[0].iBlock, pWriter->iEnd, pRoot->block.a, pRoot->block.n));
  }  
  sqlite3_free(pRoot->block.a);
  sqlite3_free(pRoot->key.a);
  ((*pRc) = rc);
}
static  int fts3TermCmp(const  char *zLhs , int nLhs , const  char *zRhs , int nRhs )  {
  int nCmp =  ((nLhs < nRhs) ? nLhs : nRhs);
  int res;
  (res = memcmp(zLhs, zRhs, nCmp));
  if ((res == 0)) {
    (res = (nLhs - nRhs));
  }  
  return res;
}
static  int fts3IsAppendable(_1273_Fts3Table *p , sqlite3_int64 iEnd , int *pbRes )  {
  int bRes =  0;
  sqlite3_stmt *pCheck =  0;
  int rc;
  (rc = fts3SqlStmt(p, 34, (&pCheck), 0));
  if ((rc == 0)) {
    sqlite3_bind_int64(pCheck, 1, iEnd);
    if ((100 == sqlite3_step(pCheck))) {
      (bRes = 1);
    }  
    (rc = sqlite3_reset(pCheck));
  }  
  ((*pbRes) = bRes);
  return rc;
}
static  int fts3IncrmergeLoad(_1273_Fts3Table *p , sqlite3_int64 iAbsLevel , int iIdx , const  char *zKey , int nKey , _1273_IncrmergeWriter *pWriter )  {
  int rc;
  sqlite3_stmt *pSelect =  0;
  (rc = fts3SqlStmt(p, 32, (&pSelect), 0));
  if ((rc == 0)) {
    sqlite3_int64 iStart =  0;
    sqlite3_int64 iLeafEnd =  0;
    sqlite3_int64 iEnd =  0;
    const char *aRoot =  0;
    int nRoot =  0;
    int rc2;
    int bAppendable =  0;
    sqlite3_bind_int64(pSelect, 1, (iAbsLevel + 1));
    sqlite3_bind_int(pSelect, 2, iIdx);
    if ((sqlite3_step(pSelect) == 100)) {
      (iStart = sqlite3_column_int64(pSelect, 1));
      (iLeafEnd = sqlite3_column_int64(pSelect, 2));
      (iEnd = sqlite3_column_int64(pSelect, 3));
      (nRoot = sqlite3_column_bytes(pSelect, 4));
      (aRoot = sqlite3_column_blob(pSelect, 4));
    }  
    else {
      return sqlite3_reset(pSelect);
    }
    (rc = fts3IsAppendable(p, iEnd, (&bAppendable)));
    if (((rc == 0) && bAppendable)) {
      char *aLeaf =  0;
      int nLeaf =  0;
      (rc = sqlite3Fts3ReadBlock(p, iLeafEnd, (&aLeaf), (&nLeaf), 0));
      if ((rc == 0)) {
        _1273_NodeReader reader;
        for ((rc = nodeReaderInit((&reader), aLeaf, nLeaf)); ((rc == 0) && reader.aNode); (rc = nodeReaderNext((&reader)))) {
          ((void ) 0);
        }
        if ((fts3TermCmp(zKey, nKey, reader.term.a, reader.term.n) <= 0)) {
          (bAppendable = 0);
        }  
        nodeReaderRelease((&reader));
      }  
      sqlite3_free(aLeaf);
    }  
    if (((rc == 0) && bAppendable)) {
      int i;
      int nHeight =  ((int ) aRoot[0]);
      _1273_NodeWriter *pNode;
      (pWriter->nLeafEst = (((int ) ((iEnd - iStart) + 1)) / 16));
      (pWriter->iStart = iStart);
      (pWriter->iEnd = iEnd);
      (pWriter->iAbsLevel = iAbsLevel);
      (pWriter->iIdx = iIdx);
      for ((i = (nHeight + 1)); (i < 16); i++) {
        (pWriter->aNodeWriter[i].iBlock = (pWriter->iStart + (i * pWriter->nLeafEst)));
      }
      (pNode = (&pWriter->aNodeWriter[nHeight]));
      (pNode->iBlock = (pWriter->iStart + (pWriter->nLeafEst * nHeight)));
      blobGrowBuffer((&pNode->block), ((nRoot > p->nNodeSize) ? nRoot : p->nNodeSize), (&rc));
      if ((rc == 0)) {
        memcpy(pNode->block.a, aRoot, nRoot);
        (pNode->block.n = nRoot);
      }  
      for ((i = nHeight); ((i >= 0) && (rc == 0)); i--) {
        _1273_NodeReader reader;
        (pNode = (&pWriter->aNodeWriter[i]));
        (rc = nodeReaderInit((&reader), pNode->block.a, pNode->block.n));
        while ((reader.aNode && (rc == 0))) {
          (rc = nodeReaderNext((&reader)));
        }
        blobGrowBuffer((&pNode->key), reader.term.n, (&rc));
        if ((rc == 0)) {
          memcpy(pNode->key.a, reader.term.a, reader.term.n);
          (pNode->key.n = reader.term.n);
          if ((i > 0)) {
            char *aBlock =  0;
            int nBlock =  0;
            (pNode = (&pWriter->aNodeWriter[(i - 1)]));
            (pNode->iBlock = reader.iChild);
            (rc = sqlite3Fts3ReadBlock(p, reader.iChild, (&aBlock), (&nBlock), 0));
            blobGrowBuffer((&pNode->block), ((nBlock > p->nNodeSize) ? nBlock : p->nNodeSize), (&rc));
            if ((rc == 0)) {
              memcpy(pNode->block.a, aBlock, nBlock);
              (pNode->block.n = nBlock);
            }  
            sqlite3_free(aBlock);
          }  
        }  
        nodeReaderRelease((&reader));
      }
    }  
    (rc2 = sqlite3_reset(pSelect));
    if ((rc == 0)) {
      (rc = rc2);
    }  
  }  
  return rc;
}
static  int fts3IncrmergeOutputIdx(_1273_Fts3Table *p , sqlite3_int64 iAbsLevel , int *piIdx )  {
  int rc;
  sqlite3_stmt *pOutputIdx =  0;
  (rc = fts3SqlStmt(p, 8, (&pOutputIdx), 0));
  if ((rc == 0)) {
    sqlite3_bind_int64(pOutputIdx, 1, (iAbsLevel + 1));
    sqlite3_step(pOutputIdx);
    ((*piIdx) = sqlite3_column_int(pOutputIdx, 0));
    (rc = sqlite3_reset(pOutputIdx));
  }  
  return rc;
}
static  int fts3IncrmergeWriter(_1273_Fts3Table *p , sqlite3_int64 iAbsLevel , int iIdx , _1273_Fts3MultiSegReader *pCsr , _1273_IncrmergeWriter *pWriter )  {
  int rc;
  int i;
  int nLeafEst =  0;
  sqlite3_stmt *pLeafEst =  0;
  sqlite3_stmt *pFirstBlock =  0;
  (rc = fts3SqlStmt(p, 29, (&pLeafEst), 0));
  if ((rc == 0)) {
    sqlite3_bind_int64(pLeafEst, 1, iAbsLevel);
    sqlite3_bind_int64(pLeafEst, 2, pCsr->nSegment);
    if ((100 == sqlite3_step(pLeafEst))) {
      (nLeafEst = sqlite3_column_int(pLeafEst, 0));
    }  
    (rc = sqlite3_reset(pLeafEst));
  }  
  if ((rc != 0)) {
    return rc;
  }  
  (rc = fts3SqlStmt(p, 10, (&pFirstBlock), 0));
  if ((rc == 0)) {
    if ((100 == sqlite3_step(pFirstBlock))) {
      (pWriter->iStart = sqlite3_column_int64(pFirstBlock, 0));
      (pWriter->iEnd = (pWriter->iStart - 1));
      (pWriter->iEnd += (nLeafEst * 16));
    }  
    (rc = sqlite3_reset(pFirstBlock));
  }  
  if ((rc != 0)) {
    return rc;
  }  
  (rc = fts3WriteSegment(p, pWriter->iEnd, 0, 0));
  if ((rc != 0)) {
    return rc;
  }  
  (pWriter->iAbsLevel = iAbsLevel);
  (pWriter->nLeafEst = nLeafEst);
  (pWriter->iIdx = iIdx);
  for ((i = 0); (i < 16); i++) {
    (pWriter->aNodeWriter[i].iBlock = (pWriter->iStart + (i * pWriter->nLeafEst)));
  }
  return 0;
}
static  int fts3RemoveSegdirEntry(_1273_Fts3Table *p , sqlite3_int64 iAbsLevel , int iIdx )  {
  int rc;
  sqlite3_stmt *pDelete =  0;
  (rc = fts3SqlStmt(p, 30, (&pDelete), 0));
  if ((rc == 0)) {
    sqlite3_bind_int64(pDelete, 1, iAbsLevel);
    sqlite3_bind_int(pDelete, 2, iIdx);
    sqlite3_step(pDelete);
    (rc = sqlite3_reset(pDelete));
  }  
  return rc;
}
static  int fts3RepackSegdirLevel(_1273_Fts3Table *p , sqlite3_int64 iAbsLevel )  {
  int rc;
  int *aIdx =  0;
  int nIdx =  0;
  int nAlloc =  0;
  int i;
  sqlite3_stmt *pSelect =  0;
  sqlite3_stmt *pUpdate =  0;
  (rc = fts3SqlStmt(p, 35, (&pSelect), 0));
  if ((rc == 0)) {
    int rc2;
    sqlite3_bind_int64(pSelect, 1, iAbsLevel);
    while ((100 == sqlite3_step(pSelect))) {
      if ((nIdx >= nAlloc)) {
        int *aNew;
        (nAlloc += 16);
        (aNew = sqlite3_realloc(aIdx, (nAlloc * sizeof(int ))));
        if ((! aNew)) {
          (rc = 7);
          break;
        }  
        (aIdx = aNew);
      }  
      (aIdx[nIdx++] = sqlite3_column_int(pSelect, 0));
    }
    (rc2 = sqlite3_reset(pSelect));
    if ((rc == 0)) {
      (rc = rc2);
    }  
  }  
  if ((rc == 0)) {
    (rc = fts3SqlStmt(p, 31, (&pUpdate), 0));
  }  
  if ((rc == 0)) {
    sqlite3_bind_int64(pUpdate, 2, iAbsLevel);
  }  
  ((void ) 0);
  (p->bIgnoreSavepoint = 1);
  for ((i = 0); ((rc == 0) && (i < nIdx)); i++) {
    if ((aIdx[i] != i)) {
      sqlite3_bind_int(pUpdate, 3, aIdx[i]);
      sqlite3_bind_int(pUpdate, 1, i);
      sqlite3_step(pUpdate);
      (rc = sqlite3_reset(pUpdate));
    }  
  }
  (p->bIgnoreSavepoint = 0);
  sqlite3_free(aIdx);
  return rc;
}
static  void fts3StartNode(_1273_Blob *pNode , int iHeight , sqlite3_int64 iChild )  {
  (pNode->a[0] = ((char ) iHeight));
  if (iChild) {
    ((void ) 0);
    (pNode->n = (1 + sqlite3Fts3PutVarint((&pNode->a[1]), iChild)));
  }  
  else {
    ((void ) 0);
    (pNode->n = 1);
  }
}
static  int fts3TruncateNode(const  char *aNode , int nNode , _1273_Blob *pNew , const  char *zTerm , int nTerm , sqlite3_int64 *piBlock )  {
  _1273_NodeReader reader;
  _1273_Blob prev =  { 0,  0,  0};
  int rc =  0;
  int bLeaf =  (aNode[0] == '\0');
  blobGrowBuffer(pNew, nNode, (&rc));
  if ((rc != 0)) {
    return rc;
  }  
  (pNew->n = 0);
  for ((rc = nodeReaderInit((&reader), aNode, nNode)); ((rc == 0) && reader.aNode); (rc = nodeReaderNext((&reader)))) {
    if ((pNew->n == 0)) {
      int res =  fts3TermCmp(reader.term.a, reader.term.n, zTerm, nTerm);
      if (((res < 0) || ((bLeaf == 0) && (res == 0)))) {
        continue;
      }  
      fts3StartNode(pNew, ((int ) aNode[0]), reader.iChild);
      ((*piBlock) = reader.iChild);
    }  
    (rc = fts3AppendToNode(pNew, (&prev), reader.term.a, reader.term.n, reader.aDoclist, reader.nDoclist));
    if ((rc != 0)) {
      break;
    }  
  }
  if ((pNew->n == 0)) {
    fts3StartNode(pNew, ((int ) aNode[0]), reader.iChild);
    ((*piBlock) = reader.iChild);
  }  
  ((void ) 0);
  nodeReaderRelease((&reader));
  sqlite3_free(prev.a);
  return rc;
}
static  int fts3TruncateSegment(_1273_Fts3Table *p , sqlite3_int64 iAbsLevel , int iIdx , const  char *zTerm , int nTerm )  {
  int rc =  0;
  _1273_Blob root =  { 0,  0,  0};
  _1273_Blob block =  { 0,  0,  0};
  sqlite3_int64 iBlock =  0;
  sqlite3_int64 iNewStart =  0;
  sqlite3_int64 iOldStart =  0;
  sqlite3_stmt *pFetch =  0;
  (rc = fts3SqlStmt(p, 32, (&pFetch), 0));
  if ((rc == 0)) {
    int rc2;
    sqlite3_bind_int64(pFetch, 1, iAbsLevel);
    sqlite3_bind_int(pFetch, 2, iIdx);
    if ((100 == sqlite3_step(pFetch))) {
      const char *aRoot =  sqlite3_column_blob(pFetch, 4);
      int nRoot =  sqlite3_column_bytes(pFetch, 4);
      (iOldStart = sqlite3_column_int64(pFetch, 1));
      (rc = fts3TruncateNode(aRoot, nRoot, (&root), zTerm, nTerm, (&iBlock)));
    }  
    (rc2 = sqlite3_reset(pFetch));
    if ((rc == 0)) {
      (rc = rc2);
    }  
  }  
  while (((rc == 0) && iBlock)) {
    char *aBlock =  0;
    int nBlock =  0;
    (iNewStart = iBlock);
    (rc = sqlite3Fts3ReadBlock(p, iBlock, (&aBlock), (&nBlock), 0));
    if ((rc == 0)) {
      (rc = fts3TruncateNode(aBlock, nBlock, (&block), zTerm, nTerm, (&iBlock)));
    }  
    if ((rc == 0)) {
      (rc = fts3WriteSegment(p, iNewStart, block.a, block.n));
    }  
    sqlite3_free(aBlock);
  }
  if (((rc == 0) && iNewStart)) {
    sqlite3_stmt *pDel =  0;
    (rc = fts3SqlStmt(p, 17, (&pDel), 0));
    if ((rc == 0)) {
      sqlite3_bind_int64(pDel, 1, iOldStart);
      sqlite3_bind_int64(pDel, 2, (iNewStart - 1));
      sqlite3_step(pDel);
      (rc = sqlite3_reset(pDel));
    }  
  }  
  if ((rc == 0)) {
    sqlite3_stmt *pChomp =  0;
    (rc = fts3SqlStmt(p, 33, (&pChomp), 0));
    if ((rc == 0)) {
      sqlite3_bind_int64(pChomp, 1, iNewStart);
      sqlite3_bind_blob(pChomp, 2, root.a, root.n, ((sqlite3_destructor_type ) 0));
      sqlite3_bind_int64(pChomp, 3, iAbsLevel);
      sqlite3_bind_int(pChomp, 4, iIdx);
      sqlite3_step(pChomp);
      (rc = sqlite3_reset(pChomp));
    }  
  }  
  sqlite3_free(root.a);
  sqlite3_free(block.a);
  return rc;
}
static  int fts3IncrmergeChomp(_1273_Fts3Table *p , sqlite3_int64 iAbsLevel , _1273_Fts3MultiSegReader *pCsr , int *pnRem )  {
  int i;
  int nRem =  0;
  int rc =  0;
  for ((i = (pCsr->nSegment - 1)); ((i >= 0) && (rc == 0)); i--) {
    _1273_Fts3SegReader *pSeg =  0;
    int j;
    if (((id2i_sqlite_coverage_test ) )) {
      for ((j = 0); 1; j++) {
        (pSeg = pCsr->apSegment[j]);
        if ((pSeg->iIdx == i)) {
          break;
        }  
      }
    }  
    if ((((! id2i_sqlite_coverage_test) ) )) {
      for ((j = 0); (j < pCsr->nSegment); j++) {
        (pSeg = pCsr->apSegment[j]);
        if ((pSeg->iIdx == i)) {
          break;
        }  
      }
    }  
    ((void ) 0);
    if ((pSeg->aNode == 0)) {
      (rc = fts3DeleteSegment(p, pSeg));
      if ((rc == 0)) {
        (rc = fts3RemoveSegdirEntry(p, iAbsLevel, pSeg->iIdx));
      }  
      ((*pnRem) = 0);
    }  
    else {
      const char *zTerm =  pSeg->zTerm;
      int nTerm =  pSeg->nTerm;
      (rc = fts3TruncateSegment(p, iAbsLevel, pSeg->iIdx, zTerm, nTerm));
      nRem++;
    }
  }
  if (((rc == 0) && (nRem != pCsr->nSegment))) {
    (rc = fts3RepackSegdirLevel(p, iAbsLevel));
  }  
  ((*pnRem) = nRem);
  return rc;
}
static  int fts3IncrmergeHintStore(_1273_Fts3Table *p , _1273_Blob *pHint )  {
  sqlite3_stmt *pReplace =  0;
  int rc;
  (rc = fts3SqlStmt(p, 23, (&pReplace), 0));
  if ((rc == 0)) {
    sqlite3_bind_int(pReplace, 1, 1);
    sqlite3_bind_blob(pReplace, 2, pHint->a, pHint->n, ((sqlite3_destructor_type ) 0));
    sqlite3_step(pReplace);
    (rc = sqlite3_reset(pReplace));
  }  
  return rc;
}
static  int fts3IncrmergeHintLoad(_1273_Fts3Table *p , _1273_Blob *pHint )  {
  sqlite3_stmt *pSelect =  0;
  int rc;
  (pHint->n = 0);
  (rc = fts3SqlStmt(p, 22, (&pSelect), 0));
  if ((rc == 0)) {
    int rc2;
    sqlite3_bind_int(pSelect, 1, 1);
    if ((100 == sqlite3_step(pSelect))) {
      const char *aHint =  sqlite3_column_blob(pSelect, 0);
      int nHint =  sqlite3_column_bytes(pSelect, 0);
      if (aHint) {
        blobGrowBuffer(pHint, nHint, (&rc));
        if ((rc == 0)) {
          memcpy(pHint->a, aHint, nHint);
          (pHint->n = nHint);
        }  
      }  
    }  
    (rc2 = sqlite3_reset(pSelect));
    if ((rc == 0)) {
      (rc = rc2);
    }  
  }  
  return rc;
}
static  void fts3IncrmergeHintPush(_1273_Blob *pHint , i64 iAbsLevel , int nInput , int *pRc )  {
  blobGrowBuffer(pHint, (pHint->n + (2 * 10)), pRc);
  if (((*pRc) == 0)) {
    (pHint->n += sqlite3Fts3PutVarint((&pHint->a[pHint->n]), iAbsLevel));
    (pHint->n += sqlite3Fts3PutVarint((&pHint->a[pHint->n]), ((i64 ) nInput)));
  }  
}
static  int fts3IncrmergeHintPop(_1273_Blob *pHint , i64 *piAbsLevel , int *pnInput )  {
  const int nHint =  pHint->n;
  int i;
  (i = (pHint->n - 2));
  while (((i > 0) && (pHint->a[(i - 1)] & 0x80))) {
    i--;
  }
  while (((i > 0) && (pHint->a[(i - 1)] & 0x80))) {
    i--;
  }
  (pHint->n = i);
  (i += sqlite3Fts3GetVarint((&pHint->a[i]), piAbsLevel));
  (i += sqlite3Fts3GetVarint32((&pHint->a[i]), pnInput));
  if ((i != nHint)) {
    return (11 | (1 << 8));
  }  
  return 0;
}
static  int sqlite3Fts3Incrmerge(_1273_Fts3Table *p , int nMerge , int nMin )  {
  int rc;
  int nRem =  nMerge;
  _1273_Fts3MultiSegReader *pCsr;
  _1273_Fts3SegFilter *pFilter;
  _1273_IncrmergeWriter *pWriter;
  int nSeg =  0;
  sqlite3_int64 iAbsLevel =  0;
  _1273_Blob hint =  { 0,  0,  0};
  int bDirtyHint =  0;
  const int nAlloc =  (sizeof((*pCsr)) + sizeof((*pFilter)) + sizeof((*pWriter)));
  (pWriter = ((_1273_IncrmergeWriter *) sqlite3_malloc(nAlloc)));
  if ((! pWriter)) {
    return 7;
  }  
  (pFilter = ((_1273_Fts3SegFilter *) (&pWriter[1])));
  (pCsr = ((_1273_Fts3MultiSegReader *) (&pFilter[1])));
  (rc = fts3IncrmergeHintLoad(p, (&hint)));
  while (((rc == 0) && (nRem > 0))) {
    const i64 nMod =  (1024 * p->nIndex);
    sqlite3_stmt *pFindLevel =  0;
    int bUseHint =  0;
    (rc = fts3SqlStmt(p, 28, (&pFindLevel), 0));
    sqlite3_bind_int(pFindLevel, 1, nMin);
    if ((sqlite3_step(pFindLevel) == 100)) {
      (iAbsLevel = sqlite3_column_int64(pFindLevel, 0));
      (nSeg = nMin);
    }  
    else {
      (nSeg = (- 1));
    }
    (rc = sqlite3_reset(pFindLevel));
    if (((rc == 0) && hint.n)) {
      int nHint =  hint.n;
      sqlite3_int64 iHintAbsLevel =  0;
      int nHintSeg =  0;
      (rc = fts3IncrmergeHintPop((&hint), (&iHintAbsLevel), (&nHintSeg)));
      if (((nSeg < 0) || ((iAbsLevel % nMod) >= (iHintAbsLevel % nMod)))) {
        (iAbsLevel = iHintAbsLevel);
        (nSeg = nHintSeg);
        (bUseHint = 1);
        (bDirtyHint = 1);
      }  
      else {
        (hint.n = nHint);
      }
    }  
    if ((nSeg < 0)) {
      break;
    }  
    memset(pWriter, 0, nAlloc);
    (pFilter->flags = 0x00000001);
    if ((rc == 0)) {
      (rc = fts3IncrmergeCsr(p, iAbsLevel, nSeg, pCsr));
    }  
    if (((0 == rc) && (pCsr->nSegment == nSeg) && (0 == (rc = sqlite3Fts3SegReaderStart(p, pCsr, pFilter))) && (100 == (rc = sqlite3Fts3SegReaderStep(p, pCsr))))) {
      int iIdx =  0;
      (rc = fts3IncrmergeOutputIdx(p, iAbsLevel, (&iIdx)));
      if ((rc == 0)) {
        if ((bUseHint && (iIdx > 0))) {
          const char *zKey =  pCsr->zTerm;
          int nKey =  pCsr->nTerm;
          (rc = fts3IncrmergeLoad(p, iAbsLevel, (iIdx - 1), zKey, nKey, pWriter));
        }  
        else {
          (rc = fts3IncrmergeWriter(p, iAbsLevel, iIdx, pCsr, pWriter));
        }
      }  
      if (((rc == 0) && pWriter->nLeafEst)) {
        do {
          (rc = fts3IncrmergeAppend(p, pWriter, pCsr));
          if ((rc == 0)) {
            (rc = sqlite3Fts3SegReaderStep(p, pCsr));
          }  
          if (((pWriter->nWork >= nRem) && (rc == 100))) {
            (rc = 0);
          }  
        } while ((rc == 100));
        if ((rc == 0)) {
          (nRem -= (1 + pWriter->nWork));
          (rc = fts3IncrmergeChomp(p, iAbsLevel, pCsr, (&nSeg)));
          if ((nSeg != 0)) {
            (bDirtyHint = 1);
            fts3IncrmergeHintPush((&hint), iAbsLevel, nSeg, (&rc));
          }  
        }  
      }  
      fts3IncrmergeRelease(p, pWriter, (&rc));
    }  
    sqlite3Fts3SegReaderFinish(pCsr);
  }
  if ((bDirtyHint && (rc == 0))) {
    (rc = fts3IncrmergeHintStore(p, (&hint)));
  }  
  sqlite3_free(pWriter);
  sqlite3_free(hint.a);
  return rc;
}
static  int fts3Getint(const  char **pz )  {
  const char *z =  (*pz);
  int i =  0;
  while ((((*z) >= '0') && ((*z) <= '9'))) {
    (i = ((10 * i) + (*z++) - '0'));
  }
  ((*pz) = z);
  return i;
}
static  int fts3DoIncrmerge(_1273_Fts3Table *p , const  char *zParam )  {
  int rc;
  int nMin =  (16 / 2);
  int nMerge =  0;
  const char *z =  zParam;
  (nMerge = fts3Getint((&z)));
  if (((z[0] == ',') && (z[1] != '\0'))) {
    z++;
    (nMin = fts3Getint((&z)));
  }  
  if (((z[0] != '\0') || (nMin < 2))) {
    (rc = 1);
  }  
  else {
    (rc = 0);
    if ((! p->bHasStat)) {
      ((void ) 0);
      sqlite3Fts3CreateStatTable((&rc), p);
    }  
    if ((rc == 0)) {
      (rc = sqlite3Fts3Incrmerge(p, nMerge, nMin));
    }  
    sqlite3Fts3SegmentsClose(p);
  }
  return rc;
}
static  int fts3DoAutoincrmerge(_1273_Fts3Table *p , const  char *zParam )  {
  int rc =  0;
  sqlite3_stmt *pStmt =  0;
  (p->bAutoincrmerge = (fts3Getint((&zParam)) != 0));
  if ((! p->bHasStat)) {
    ((void ) 0);
    sqlite3Fts3CreateStatTable((&rc), p);
    if (rc) {
      return rc;
    }  
  }  
  (rc = fts3SqlStmt(p, 23, (&pStmt), 0));
  if (rc) {
    return rc;
  }  
  sqlite3_bind_int(pStmt, 1, 2);
  sqlite3_bind_int(pStmt, 2, p->bAutoincrmerge);
  sqlite3_step(pStmt);
  (rc = sqlite3_reset(pStmt));
  return rc;
}
static  u64 fts3ChecksumEntry(const  char *zTerm , int nTerm , int iLangid , int iIndex , i64 iDocid , int iCol , int iPos )  {
  int i;
  u64 ret =  ((u64 ) iDocid);
  (ret += ((ret << 3) + iLangid));
  (ret += ((ret << 3) + iIndex));
  (ret += ((ret << 3) + iCol));
  (ret += ((ret << 3) + iPos));
  for ((i = 0); (i < nTerm); i++) {
    (ret += ((ret << 3) + zTerm[i]));
  }
  return ret;
}
static  u64 fts3ChecksumIndex(_1273_Fts3Table *p , int iLangid , int iIndex , int *pRc )  {
  _1273_Fts3SegFilter filter;
  _1273_Fts3MultiSegReader csr;
  int rc;
  u64 cksum =  0;
  ((void ) 0);
  memset((&filter), 0, sizeof(filter));
  memset((&csr), 0, sizeof(csr));
  (filter.flags = (0x00000001 | 0x00000002));
  (filter.flags |= 0x00000010);
  (rc = sqlite3Fts3SegReaderCursor(p, iLangid, iIndex, (- 2), 0, 0, 0, 1, (&csr)));
  if ((rc == 0)) {
    (rc = sqlite3Fts3SegReaderStart(p, (&csr), (&filter)));
  }  
  if ((rc == 0)) {
    while ((100 == (rc = sqlite3Fts3SegReaderStep(p, (&csr))))) {
      char *pCsr =  csr.aDoclist;
      char *pEnd =  (&pCsr[csr.nDoclist]);
      i64 iDocid =  0;
      i64 iCol =  0;
      i64 iPos =  0;
      (pCsr += sqlite3Fts3GetVarint(pCsr, (&iDocid)));
      while ((pCsr < pEnd)) {
        i64 iVal =  0;
        (pCsr += sqlite3Fts3GetVarint(pCsr, (&iVal)));
        if ((pCsr < pEnd)) {
          if (((iVal == 0) || (iVal == 1))) {
            (iCol = 0);
            (iPos = 0);
            if (iVal) {
              (pCsr += sqlite3Fts3GetVarint(pCsr, (&iCol)));
            }  
            else {
              (pCsr += sqlite3Fts3GetVarint(pCsr, (&iVal)));
              (iDocid += iVal);
            }
          }  
          else {
            (iPos += (iVal - 2));
            (cksum = (cksum ^ fts3ChecksumEntry(csr.zTerm, csr.nTerm, iLangid, iIndex, iDocid, ((int ) iCol), ((int ) iPos))));
          }
        }  
      }
    }
  }  
  sqlite3Fts3SegReaderFinish((&csr));
  ((*pRc) = rc);
  return cksum;
}
static  int fts3IntegrityCheck(_1273_Fts3Table *p , int *pbOk )  {
  int rc =  0;
  u64 cksum1 =  0;
  u64 cksum2 =  0;
  sqlite3_stmt *pAllLangid =  0;
  (rc = fts3SqlStmt(p, 27, (&pAllLangid), 0));
  if ((rc == 0)) {
    int rc2;
    sqlite3_bind_int(pAllLangid, 1, p->nIndex);
    while (((rc == 0) && (sqlite3_step(pAllLangid) == 100))) {
      int iLangid =  sqlite3_column_int(pAllLangid, 0);
      int i;
      for ((i = 0); (i < p->nIndex); i++) {
        (cksum1 = (cksum1 ^ fts3ChecksumIndex(p, iLangid, i, (&rc))));
      }
    }
    (rc2 = sqlite3_reset(pAllLangid));
    if ((rc == 0)) {
      (rc = rc2);
    }  
  }  
  (rc = fts3SqlStmt(p, 27, (&pAllLangid), 0));
  if ((rc == 0)) {
    _1273_sqlite3_tokenizer_module const *pModule =  p->pTokenizer->pModule;
    sqlite3_stmt *pStmt =  0;
    char *zSql;
    (zSql = sqlite3_mprintf("SELECT %s", p->zReadExprlist));
    if ((! zSql)) {
      (rc = 7);
    }  
    else {
      (rc = sqlite3_prepare_v2(p->db, zSql, (- 1), (&pStmt), 0));
      sqlite3_free(zSql);
    }
    while (((rc == 0) && (100 == sqlite3_step(pStmt)))) {
      i64 iDocid =  sqlite3_column_int64(pStmt, 0);
      int iLang =  langidFromSelect(p, pStmt);
      int iCol;
      for ((iCol = 0); ((rc == 0) && (iCol < p->nColumn)); iCol++) {
        const char *zText =  ((const  char *) sqlite3_column_text(pStmt, (iCol + 1)));
        int nText =  sqlite3_column_bytes(pStmt, (iCol + 1));
        _1273_sqlite3_tokenizer_cursor *pT =  0;
        (rc = sqlite3Fts3OpenTokenizer(p->pTokenizer, iLang, zText, nText, (&pT)));
        while ((rc == 0)) {
          char const *zToken;
          int nToken =  0;
          int iDum1 =  0, iDum2 =  0;
          int iPos =  0;
          (rc = pModule->xNext(pT, (&zToken), (&nToken), (&iDum1), (&iDum2), (&iPos)));
          if ((rc == 0)) {
            int i;
            (cksum2 = (cksum2 ^ fts3ChecksumEntry(zToken, nToken, iLang, 0, iDocid, iCol, iPos)));
            for ((i = 1); (i < p->nIndex); i++) {
              if ((p->aIndex[i].nPrefix <= nToken)) {
                (cksum2 = (cksum2 ^ fts3ChecksumEntry(zToken, p->aIndex[i].nPrefix, iLang, i, iDocid, iCol, iPos)));
              }  
            }
          }  
        }
        if (pT) {
          pModule->xClose(pT);
        }  
        if ((rc == 101)) {
          (rc = 0);
        }  
      }
    }
    sqlite3_finalize(pStmt);
  }  
  ((*pbOk) = (cksum1 == cksum2));
  return rc;
}
static  int fts3DoIntegrityCheck(_1273_Fts3Table *p )  {
  int rc;
  int bOk =  0;
  (rc = fts3IntegrityCheck(p, (&bOk)));
  if (((rc == 0) && (bOk == 0))) {
    (rc = (11 | (1 << 8)));
  }  
  return rc;
}
static  int fts3SpecialInsert(_1273_Fts3Table *p , sqlite3_value *pVal )  {
  int rc;
  const char *zVal =  ((const  char *) sqlite3_value_text(pVal));
  int nVal =  sqlite3_value_bytes(pVal);
  if ((! zVal)) {
    return 7;
  } 
  else if (((nVal == 8) && (0 == sqlite3_strnicmp(zVal, "optimize", 8)))) {
    (rc = fts3DoOptimize(p, 0));
  }
  
  else if (((nVal == 7) && (0 == sqlite3_strnicmp(zVal, "rebuild", 7)))) {
    (rc = fts3DoRebuild(p));
  }
  
  else if (((nVal == 15) && (0 == sqlite3_strnicmp(zVal, "integrity-check", 15)))) {
    (rc = fts3DoIntegrityCheck(p));
  }
  
  else if (((nVal > 6) && (0 == sqlite3_strnicmp(zVal, "merge=", 6)))) {
    (rc = fts3DoIncrmerge(p, (&zVal[6])));
  }
  
  else if (((nVal > 10) && (0 == sqlite3_strnicmp(zVal, "automerge=", 10)))) {
    (rc = fts3DoAutoincrmerge(p, (&zVal[10])));
  } 
  else {
    (rc = 1);
  }
  return rc;
}
static  void sqlite3Fts3FreeDeferredDoclists(_1273_Fts3Cursor *pCsr )  {
  _1273_Fts3DeferredToken *pDef;
  for ((pDef = pCsr->pDeferred); pDef; (pDef = pDef->pNext)) {
    fts3PendingListDelete(pDef->pList);
    (pDef->pList = 0);
  }
}
static  void sqlite3Fts3FreeDeferredTokens(_1273_Fts3Cursor *pCsr )  {
  _1273_Fts3DeferredToken *pDef;
  _1273_Fts3DeferredToken *pNext;
  for ((pDef = pCsr->pDeferred); pDef; (pDef = pNext)) {
    (pNext = pDef->pNext);
    fts3PendingListDelete(pDef->pList);
    sqlite3_free(pDef);
  }
  (pCsr->pDeferred = 0);
}
static  int sqlite3Fts3CacheDeferredDoclists(_1273_Fts3Cursor *pCsr )  {
  int rc =  0;
  if (pCsr->pDeferred) {
    int i;
    sqlite3_int64 iDocid;
    _1273_Fts3DeferredToken *pDef;
    _1273_Fts3Table *p =  ((_1273_Fts3Table *) pCsr->base.pVtab);
    _1273_sqlite3_tokenizer *pT =  p->pTokenizer;
    _1273_sqlite3_tokenizer_module const *pModule =  pT->pModule;
    ((void ) 0);
    (iDocid = sqlite3_column_int64(pCsr->pStmt, 0));
    for ((i = 0); ((i < p->nColumn) && (rc == 0)); i++) {
      if ((p->abNotindexed[i] == 0)) {
        const char *zText =  ((const  char *) sqlite3_column_text(pCsr->pStmt, (i + 1)));
        _1273_sqlite3_tokenizer_cursor *pTC =  0;
        (rc = sqlite3Fts3OpenTokenizer(pT, pCsr->iLangid, zText, (- 1), (&pTC)));
        while ((rc == 0)) {
          char const *zToken;
          int nToken =  0;
          int iDum1 =  0, iDum2 =  0;
          int iPos =  0;
          (rc = pModule->xNext(pTC, (&zToken), (&nToken), (&iDum1), (&iDum2), (&iPos)));
          for ((pDef = pCsr->pDeferred); (pDef && (rc == 0)); (pDef = pDef->pNext)) {
            _1273_Fts3PhraseToken *pPT =  pDef->pToken;
            if ((((pDef->iCol >= p->nColumn) || (pDef->iCol == i)) && ((pPT->bFirst == 0) || (iPos == 0)) && ((pPT->n == nToken) || (pPT->isPrefix && (pPT->n < nToken))) && (0 == memcmp(zToken, pPT->z, pPT->n)))) {
              fts3PendingListAppend((&pDef->pList), iDocid, i, iPos, (&rc));
            }  
          }
        }
        if (pTC) {
          pModule->xClose(pTC);
        }  
        if ((rc == 101)) {
          (rc = 0);
        }  
      }  
    }
    for ((pDef = pCsr->pDeferred); (pDef && (rc == 0)); (pDef = pDef->pNext)) {
      if (pDef->pList) {
        (rc = fts3PendingListAppendVarint((&pDef->pList), 0));
      }  
    }
  }  
  return rc;
}
static  int sqlite3Fts3DeferredTokenList(_1273_Fts3DeferredToken *p , char **ppData , int *pnData )  {
  char *pRet;
  int nSkip;
  sqlite3_int64 dummy;
  ((*ppData) = 0);
  ((*pnData) = 0);
  if ((p->pList == 0)) {
    return 0;
  }  
  (pRet = ((char *) sqlite3_malloc(p->pList->nData)));
  if ((! pRet)) {
    return 7;
  }  
  (nSkip = sqlite3Fts3GetVarint(p->pList->aData, (&dummy)));
  ((*pnData) = (p->pList->nData - nSkip));
  ((*ppData) = pRet);
  memcpy(pRet, (&p->pList->aData[nSkip]), (*pnData));
  return 0;
}
static  int sqlite3Fts3DeferToken(_1273_Fts3Cursor *pCsr , _1273_Fts3PhraseToken *pToken , int iCol )  {
  _1273_Fts3DeferredToken *pDeferred;
  (pDeferred = sqlite3_malloc(sizeof((*pDeferred))));
  if ((! pDeferred)) {
    return 7;
  }  
  memset(pDeferred, 0, sizeof((*pDeferred)));
  (pDeferred->pToken = pToken);
  (pDeferred->pNext = pCsr->pDeferred);
  (pDeferred->iCol = iCol);
  (pCsr->pDeferred = pDeferred);
  ((void ) 0);
  (pToken->pDeferred = pDeferred);
  return 0;
}
static  int fts3DeleteByRowid(_1273_Fts3Table *p , sqlite3_value *pRowid , int *pnChng , u32 *aSzDel )  {
  int rc =  0;
  int bFound =  0;
  fts3DeleteTerms((&rc), p, pRowid, aSzDel, (&bFound));
  if ((bFound && (rc == 0))) {
    int isEmpty =  0;
    (rc = fts3IsEmpty(p, pRowid, (&isEmpty)));
    if ((rc == 0)) {
      if (isEmpty) {
        (rc = fts3DeleteAll(p, 1));
        ((*pnChng) = 0);
        memset(aSzDel, 0, (sizeof(u32 ) * (p->nColumn + 1) * 2));
      }  
      else {
        ((*pnChng) = ((*pnChng) - 1));
        if ((p->zContentTbl == 0)) {
          fts3SqlExec((&rc), p, 0, (&pRowid));
        }  
        if (p->bHasDocsize) {
          fts3SqlExec((&rc), p, 19, (&pRowid));
        }  
      }
    }  
  }  
  return rc;
}
static  int sqlite3Fts3UpdateMethod(sqlite3_vtab *pVtab , int nArg , sqlite3_value **apVal , sqlite_int64 *pRowid )  {
  _1273_Fts3Table *p =  ((_1273_Fts3Table *) pVtab);
  int rc =  0;
  int isRemove =  0;
  u32 *aSzIns =  0;
  u32 *aSzDel =  0;
  int nChng =  0;
  int bInsertDone =  0;
  ((void ) 0);
  ((void ) 0);
  if (((nArg > 1) && (sqlite3_value_type(apVal[0]) == 5) && (sqlite3_value_type(apVal[(p->nColumn + 2)]) != 5))) {
    (rc = fts3SpecialInsert(p, apVal[(p->nColumn + 2)]));
    goto _1273_update_out;
  }  
  if (((nArg > 1) && (sqlite3_value_int(apVal[(2 + p->nColumn + 2)]) < 0))) {
    (rc = 19);
    goto _1273_update_out;
  }  
  (aSzDel = sqlite3_malloc((sizeof(aSzDel[0]) * (p->nColumn + 1) * 2)));
  if ((aSzDel == 0)) {
    (rc = 7);
    goto _1273_update_out;
  }  
  (aSzIns = (&aSzDel[(p->nColumn + 1)]));
  memset(aSzDel, 0, (sizeof(aSzDel[0]) * (p->nColumn + 1) * 2));
  (rc = fts3Writelock(p));
  if ((rc != 0)) {
    goto _1273_update_out;
  }  
  if (((nArg > 1) && (p->zContentTbl == 0))) {
    sqlite3_value *pNewRowid =  apVal[(3 + p->nColumn)];
    if ((sqlite3_value_type(pNewRowid) == 5)) {
      (pNewRowid = apVal[1]);
    }  
    if (((sqlite3_value_type(pNewRowid) != 5) && ((sqlite3_value_type(apVal[0]) == 5) || (sqlite3_value_int64(apVal[0]) != sqlite3_value_int64(pNewRowid))))) {
      if ((sqlite3_vtab_on_conflict(p->db) == 5)) {
        (rc = fts3DeleteByRowid(p, pNewRowid, (&nChng), aSzDel));
      }  
      else {
        (rc = fts3InsertData(p, apVal, pRowid));
        (bInsertDone = 1);
      }
    }  
  }  
  if ((rc != 0)) {
    goto _1273_update_out;
  }  
  if ((sqlite3_value_type(apVal[0]) != 5)) {
    ((void ) 0);
    (rc = fts3DeleteByRowid(p, apVal[0], (&nChng), aSzDel));
    (isRemove = 1);
  }  
  if (((nArg > 1) && (rc == 0))) {
    int iLangid =  sqlite3_value_int(apVal[(2 + p->nColumn + 2)]);
    if ((bInsertDone == 0)) {
      (rc = fts3InsertData(p, apVal, pRowid));
      if (((rc == 19) && (p->zContentTbl == 0))) {
        (rc = (11 | (1 << 8)));
      }  
    }  
    if (((rc == 0) && ((! isRemove) || ((*pRowid) != p->iPrevDocid)))) {
      (rc = fts3PendingTermsDocid(p, iLangid, (*pRowid)));
    }  
    if ((rc == 0)) {
      ((void ) 0);
      (rc = fts3InsertTerms(p, iLangid, apVal, aSzIns));
    }  
    if (p->bHasDocsize) {
      fts3InsertDocsize((&rc), p, aSzIns);
    }  
    nChng++;
  }  
  if (p->bFts4) {
    fts3UpdateDocTotals((&rc), p, aSzIns, aSzDel, nChng);
  }  
  _1273_update_out:
  sqlite3_free(aSzDel);
  sqlite3Fts3SegmentsClose(p);
  return rc;
}
static  int sqlite3Fts3Optimize(_1273_Fts3Table *p )  {
  int rc;
  (rc = sqlite3_exec(p->db, "SAVEPOINT fts3", 0, 0, 0));
  if ((rc == 0)) {
    (rc = fts3DoOptimize(p, 1));
    if (((rc == 0) || (rc == 101))) {
      int rc2 =  sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
      if ((rc2 != 0)) {
        (rc = rc2);
      }  
    }  
    else {
      sqlite3_exec(p->db, "ROLLBACK TO fts3", 0, 0, 0);
      sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
    }
  }  
  sqlite3Fts3SegmentsClose(p);
  return rc;
}
typedef struct  _1273_LoadDoclistCtx   _1273_LoadDoclistCtx;
struct  _1273_LoadDoclistCtx {
  _1273_Fts3Cursor *pCsr ;
  int nPhrase ;
  int nToken ;
}  ;
typedef struct  _1273_SnippetIter   _1273_SnippetIter;
typedef struct  _1273_SnippetPhrase   _1273_SnippetPhrase;
typedef struct  _1273_SnippetFragment   _1273_SnippetFragment;
struct  _1273_SnippetIter {
  _1273_Fts3Cursor *pCsr ;
  int iCol ;
  int nSnippet ;
  int nPhrase ;
  _1273_SnippetPhrase *aPhrase ;
  int iCurrent ;
}  ;
struct  _1273_SnippetPhrase {
  int nToken ;
  char *pList ;
  int iHead ;
  char *pHead ;
  int iTail ;
  char *pTail ;
}  ;
struct  _1273_SnippetFragment {
  int iCol ;
  int iPos ;
  u64 covered ;
  u64 hlmask ;
}  ;
typedef struct  _1273_MatchInfo   _1273_MatchInfo;
struct  _1273_MatchInfo {
  _1273_Fts3Cursor *pCursor ;
  int nCol ;
  int nPhrase ;
  sqlite3_int64 nDoc ;
  u32 *aMatchinfo ;
}  ;
typedef struct  _1273_StrBuffer   _1273_StrBuffer;
struct  _1273_StrBuffer {
  char *z ;
  int n ;
  int nAlloc ;
}  ;
static  void fts3GetDeltaPosition(char **pp , int *piPos )  {
  int iVal;
  ((*pp) += sqlite3Fts3GetVarint32((*pp), (&iVal)));
  ((*piPos) += (iVal - 2));
}
static  int fts3ExprIterate2(_1273_Fts3Expr *pExpr , int *piPhrase , int ( *x)(_1273_Fts3Expr * , int , void * ) , void *pCtx )  {
  int rc;
  int eType =  pExpr->eType;
  if ((eType != 5)) {
    ((void ) 0);
    (rc = fts3ExprIterate2(pExpr->pLeft, piPhrase, x, pCtx));
    if (((rc == 0) && (eType != 2))) {
      (rc = fts3ExprIterate2(pExpr->pRight, piPhrase, x, pCtx));
    }  
  }  
  else {
    (rc = x(pExpr, (*piPhrase), pCtx));
    (*piPhrase)++;
  }
  return rc;
}
static  int fts3ExprIterate(_1273_Fts3Expr *pExpr , int ( *x)(_1273_Fts3Expr * , int , void * ) , void *pCtx )  {
  int iPhrase =  0;
  return fts3ExprIterate2(pExpr, (&iPhrase), x, pCtx);
}
static  int fts3ExprLoadDoclistsCb(_1273_Fts3Expr *pExpr , int iPhrase , void *ctx )  {
  int rc =  0;
  _1273_Fts3Phrase *pPhrase =  pExpr->pPhrase;
  _1273_LoadDoclistCtx *p =  ((_1273_LoadDoclistCtx *) ctx);
  ((void ) iPhrase);
  p->nPhrase++;
  (p->nToken += pPhrase->nToken);
  return rc;
}
static  int fts3ExprLoadDoclists(_1273_Fts3Cursor *pCsr , int *pnPhrase , int *pnToken )  {
  int rc;
  _1273_LoadDoclistCtx sCtx =  { 0,  0,  0};
  (sCtx.pCsr = pCsr);
  (rc = fts3ExprIterate(pCsr->pExpr, fts3ExprLoadDoclistsCb, ((void *) (&sCtx))));
  if (pnPhrase) {
    ((*pnPhrase) = sCtx.nPhrase);
  }  
  if (pnToken) {
    ((*pnToken) = sCtx.nToken);
  }  
  return rc;
}
static  int fts3ExprPhraseCountCb(_1273_Fts3Expr *pExpr , int iPhrase , void *ctx )  {
  (*((int *) ctx))++;
  ((void ) pExpr);
  ((void ) iPhrase);
  return 0;
}
static  int fts3ExprPhraseCount(_1273_Fts3Expr *pExpr )  {
  int nPhrase =  0;
  ((void ) fts3ExprIterate(pExpr, fts3ExprPhraseCountCb, ((void *) (&nPhrase))));
  return nPhrase;
}
static  void fts3SnippetAdvance(char **ppIter , int *piIter , int iNext )  {
  char *pIter =  (*ppIter);
  if (pIter) {
    int iIter =  (*piIter);
    while ((iIter < iNext)) {
      if ((0 == ((*pIter) & 0xFE))) {
        (iIter = (- 1));
        (pIter = 0);
        break;
      }  
      fts3GetDeltaPosition((&pIter), (&iIter));
    }
    ((*piIter) = iIter);
    ((*ppIter) = pIter);
  }  
}
static  int fts3SnippetNextCandidate(_1273_SnippetIter *pIter )  {
  int i;
  if ((pIter->iCurrent < 0)) {
    (pIter->iCurrent = 0);
    for ((i = 0); (i < pIter->nPhrase); i++) {
      _1273_SnippetPhrase *pPhrase =  (&pIter->aPhrase[i]);
      fts3SnippetAdvance((&pPhrase->pHead), (&pPhrase->iHead), pIter->nSnippet);
    }
  }  
  else {
    int iStart;
    int iEnd =  0x7FFFFFFF;
    for ((i = 0); (i < pIter->nPhrase); i++) {
      _1273_SnippetPhrase *pPhrase =  (&pIter->aPhrase[i]);
      if ((pPhrase->pHead && (pPhrase->iHead < iEnd))) {
        (iEnd = pPhrase->iHead);
      }  
    }
    if ((iEnd == 0x7FFFFFFF)) {
      return 1;
    }  
    (pIter->iCurrent = (iStart = (iEnd - pIter->nSnippet + 1)));
    for ((i = 0); (i < pIter->nPhrase); i++) {
      _1273_SnippetPhrase *pPhrase =  (&pIter->aPhrase[i]);
      fts3SnippetAdvance((&pPhrase->pHead), (&pPhrase->iHead), (iEnd + 1));
      fts3SnippetAdvance((&pPhrase->pTail), (&pPhrase->iTail), iStart);
    }
  }
  return 0;
}
static  void fts3SnippetDetails(_1273_SnippetIter *pIter , u64 mCovered , int *piToken , int *piScore , u64 *pmCover , u64 *pmHighlight )  {
  int iStart =  pIter->iCurrent;
  int iScore =  0;
  int i;
  u64 mCover =  0;
  u64 mHighlight =  0;
  for ((i = 0); (i < pIter->nPhrase); i++) {
    _1273_SnippetPhrase *pPhrase =  (&pIter->aPhrase[i]);
    if (pPhrase->pTail) {
      char *pCsr =  pPhrase->pTail;
      int iCsr =  pPhrase->iTail;
      while ((iCsr < (iStart + pIter->nSnippet))) {
        int j;
        u64 mPhrase =  (((u64 ) 1) << i);
        u64 mPos =  (((u64 ) 1) << (iCsr - iStart));
        ((void ) 0);
        if (((mCover | mCovered) & mPhrase)) {
          iScore++;
        }  
        else {
          (iScore += 1000);
        }
        (mCover |= mPhrase);
        for ((j = 0); (j < pPhrase->nToken); j++) {
          (mHighlight |= (mPos >> j));
        }
        if ((0 == ((*pCsr) & 0x0FE))) {
          break;
        }  
        fts3GetDeltaPosition((&pCsr), (&iCsr));
      }
    }  
  }
  ((*piToken) = iStart);
  ((*piScore) = iScore);
  ((*pmCover) = mCover);
  ((*pmHighlight) = mHighlight);
}
static  int fts3SnippetFindPositions(_1273_Fts3Expr *pExpr , int iPhrase , void *ctx )  {
  _1273_SnippetIter *p =  ((_1273_SnippetIter *) ctx);
  _1273_SnippetPhrase *pPhrase =  (&p->aPhrase[iPhrase]);
  char *pCsr;
  int rc;
  (pPhrase->nToken = pExpr->pPhrase->nToken);
  (rc = sqlite3Fts3EvalPhrasePoslist(p->pCsr, pExpr, p->iCol, (&pCsr)));
  ((void ) 0);
  if (pCsr) {
    int iFirst =  0;
    (pPhrase->pList = pCsr);
    fts3GetDeltaPosition((&pCsr), (&iFirst));
    ((void ) 0);
    (pPhrase->pHead = pCsr);
    (pPhrase->pTail = pCsr);
    (pPhrase->iHead = iFirst);
    (pPhrase->iTail = iFirst);
  }  
  else {
    ((void ) 0);
  }
  return rc;
}
static  int fts3BestSnippet(int nSnippet , _1273_Fts3Cursor *pCsr , int iCol , u64 mCovered , u64 *pmSeen , _1273_SnippetFragment *pFragment , int *piScore )  {
  int rc;
  int nList;
  _1273_SnippetIter sIter;
  int nByte;
  int iBestScore =  (- 1);
  int i;
  memset((&sIter), 0, sizeof(sIter));
  (rc = fts3ExprLoadDoclists(pCsr, (&nList), 0));
  if ((rc != 0)) {
    return rc;
  }  
  (nByte = (sizeof(_1273_SnippetPhrase ) * nList));
  (sIter.aPhrase = ((_1273_SnippetPhrase *) sqlite3_malloc(nByte)));
  if ((! sIter.aPhrase)) {
    return 7;
  }  
  memset(sIter.aPhrase, 0, nByte);
  (sIter.pCsr = pCsr);
  (sIter.iCol = iCol);
  (sIter.nSnippet = nSnippet);
  (sIter.nPhrase = nList);
  (sIter.iCurrent = (- 1));
  ((void ) fts3ExprIterate(pCsr->pExpr, fts3SnippetFindPositions, ((void *) (&sIter))));
  for ((i = 0); (i < nList); i++) {
    if (sIter.aPhrase[i].pHead) {
      ((*pmSeen) |= (((u64 ) 1) << i));
    }  
  }
  (pFragment->iCol = iCol);
  while ((! fts3SnippetNextCandidate((&sIter)))) {
    int iPos;
    int iScore;
    u64 mCover;
    u64 mHighlight;
    fts3SnippetDetails((&sIter), mCovered, (&iPos), (&iScore), (&mCover), (&mHighlight));
    ((void ) 0);
    if ((iScore > iBestScore)) {
      (pFragment->iPos = iPos);
      (pFragment->hlmask = mHighlight);
      (pFragment->covered = mCover);
      (iBestScore = iScore);
    }  
  }
  sqlite3_free(sIter.aPhrase);
  ((*piScore) = iBestScore);
  return 0;
}
static  int fts3StringAppend(_1273_StrBuffer *pStr , const  char *zAppend , int nAppend )  {
  if ((nAppend < 0)) {
    (nAppend = ((int ) strlen(zAppend)));
  }  
  if (((pStr->n + nAppend + 1) >= pStr->nAlloc)) {
    int nAlloc =  (pStr->nAlloc + nAppend + 100);
    char *zNew =  sqlite3_realloc(pStr->z, nAlloc);
    if ((! zNew)) {
      return 7;
    }  
    (pStr->z = zNew);
    (pStr->nAlloc = nAlloc);
  }  
  ((void ) 0);
  memcpy((&pStr->z[pStr->n]), zAppend, nAppend);
  (pStr->n += nAppend);
  (pStr->z[pStr->n] = '\0');
  return 0;
}
static  int fts3SnippetShift(_1273_Fts3Table *pTab , int iLangid , int nSnippet , const  char *zDoc , int nDoc , int *piPos , u64 *pHlmask )  {
  u64 hlmask =  (*pHlmask);
  if (hlmask) {
    int nLeft;
    int nRight;
    int nDesired;
    for ((nLeft = 0); (! (hlmask & (((u64 ) 1) << nLeft))); nLeft++) {
      
    }
    for ((nRight = 0); (! (hlmask & (((u64 ) 1) << (nSnippet - 1 - nRight)))); nRight++) {
      
    }
    (nDesired = ((nLeft - nRight) / 2));
    if ((nDesired > 0)) {
      int nShift;
      int iCurrent =  0;
      int rc;
      _1273_sqlite3_tokenizer_module *pMod;
      _1273_sqlite3_tokenizer_cursor *pC;
      (pMod = ((_1273_sqlite3_tokenizer_module *) pTab->pTokenizer->pModule));
      (rc = sqlite3Fts3OpenTokenizer(pTab->pTokenizer, iLangid, zDoc, nDoc, (&pC)));
      if ((rc != 0)) {
        return rc;
      }  
      while (((rc == 0) && (iCurrent < (nSnippet + nDesired)))) {
        const char *ZDUMMY;
        int DUMMY1 =  0, DUMMY2 =  0, DUMMY3 =  0;
        (rc = pMod->xNext(pC, (&ZDUMMY), (&DUMMY1), (&DUMMY2), (&DUMMY3), (&iCurrent)));
      }
      pMod->xClose(pC);
      if (((rc != 0) && (rc != 101))) {
        return rc;
      }  
      (nShift = ((rc == 101) + iCurrent - nSnippet));
      ((void ) 0);
      if ((nShift > 0)) {
        ((*piPos) += nShift);
        ((*pHlmask) = (hlmask >> nShift));
      }  
    }  
  }  
  return 0;
}
static  int fts3SnippetText(_1273_Fts3Cursor *pCsr , _1273_SnippetFragment *pFragment , int iFragment , int isLast , int nSnippet , const  char *zOpen , const  char *zClose , const  char *zEllipsis , _1273_StrBuffer *pOut )  {
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  int rc;
  const char *zDoc;
  int nDoc;
  int iCurrent =  0;
  int iEnd =  0;
  int isShiftDone =  0;
  int iPos =  pFragment->iPos;
  u64 hlmask =  pFragment->hlmask;
  int iCol =  (pFragment->iCol + 1);
  _1273_sqlite3_tokenizer_module *pMod;
  _1273_sqlite3_tokenizer_cursor *pC;
  (zDoc = ((const  char *) sqlite3_column_text(pCsr->pStmt, iCol)));
  if ((zDoc == 0)) {
    if ((sqlite3_column_type(pCsr->pStmt, iCol) != 5)) {
      return 7;
    }  
    return 0;
  }  
  (nDoc = sqlite3_column_bytes(pCsr->pStmt, iCol));
  (pMod = ((_1273_sqlite3_tokenizer_module *) pTab->pTokenizer->pModule));
  (rc = sqlite3Fts3OpenTokenizer(pTab->pTokenizer, pCsr->iLangid, zDoc, nDoc, (&pC)));
  if ((rc != 0)) {
    return rc;
  }  
  while ((rc == 0)) {
    const char *ZDUMMY;
    int DUMMY1 =  (- 1);
    int iBegin =  0;
    int iFin =  0;
    int isHighlight =  0;
    (rc = pMod->xNext(pC, (&ZDUMMY), (&DUMMY1), (&iBegin), (&iFin), (&iCurrent)));
    if ((rc != 0)) {
      if ((rc == 101)) {
        (rc = fts3StringAppend(pOut, (&zDoc[iEnd]), (- 1)));
      }  
      break;
    }  
    if ((iCurrent < iPos)) {
      continue;
    }  
    if ((! isShiftDone)) {
      int n =  (nDoc - iBegin);
      (rc = fts3SnippetShift(pTab, pCsr->iLangid, nSnippet, (&zDoc[iBegin]), n, (&iPos), (&hlmask)));
      (isShiftDone = 1);
      if (((rc == 0) && ((iPos > 0) || (iFragment > 0)))) {
        (rc = fts3StringAppend(pOut, zEllipsis, (- 1)));
      }  
      if (((rc != 0) || (iCurrent < iPos))) {
        continue;
      }  
    }  
    if ((iCurrent >= (iPos + nSnippet))) {
      if (isLast) {
        (rc = fts3StringAppend(pOut, zEllipsis, (- 1)));
      }  
      break;
    }  
    (isHighlight = ((hlmask & (((u64 ) 1) << (iCurrent - iPos))) != 0));
    if ((iCurrent > iPos)) {
      (rc = fts3StringAppend(pOut, (&zDoc[iEnd]), (iBegin - iEnd)));
    }  
    if (((rc == 0) && isHighlight)) {
      (rc = fts3StringAppend(pOut, zOpen, (- 1)));
    }  
    if ((rc == 0)) {
      (rc = fts3StringAppend(pOut, (&zDoc[iBegin]), (iFin - iBegin)));
    }  
    if (((rc == 0) && isHighlight)) {
      (rc = fts3StringAppend(pOut, zClose, (- 1)));
    }  
    (iEnd = iFin);
  }
  pMod->xClose(pC);
  return rc;
}
static  int fts3ColumnlistCount(char **ppCollist )  {
  char *pEnd =  (*ppCollist);
  char c =  0;
  int nEntry =  0;
  while ((0xFE & ((*pEnd) | c))) {
    (c = ((*pEnd++) & 0x80));
    if ((! c)) {
      nEntry++;
    }  
  }
  ((*ppCollist) = pEnd);
  return nEntry;
}
static  int fts3ExprGlobalHitsCb(_1273_Fts3Expr *pExpr , int iPhrase , void *pCtx )  {
  _1273_MatchInfo *p =  ((_1273_MatchInfo *) pCtx);
  return sqlite3Fts3EvalPhraseStats(p->pCursor, pExpr, (&p->aMatchinfo[(3 * iPhrase * p->nCol)]));
}
static  int fts3ExprLocalHitsCb(_1273_Fts3Expr *pExpr , int iPhrase , void *pCtx )  {
  int rc =  0;
  _1273_MatchInfo *p =  ((_1273_MatchInfo *) pCtx);
  int iStart =  (iPhrase * p->nCol * 3);
  int i;
  for ((i = 0); ((i < p->nCol) && (rc == 0)); i++) {
    char *pCsr;
    (rc = sqlite3Fts3EvalPhrasePoslist(p->pCursor, pExpr, i, (&pCsr)));
    if (pCsr) {
      (p->aMatchinfo[(iStart + (i * 3))] = fts3ColumnlistCount((&pCsr)));
    }  
    else {
      (p->aMatchinfo[(iStart + (i * 3))] = 0);
    }
  }
  return rc;
}
static  int fts3MatchinfoCheck(_1273_Fts3Table *pTab , char cArg , char **pzErr )  {
  if (((cArg == 'p') || (cArg == 'c') || ((cArg == 'n') && pTab->bFts4) || ((cArg == 'a') && pTab->bFts4) || ((cArg == 'l') && pTab->bHasDocsize) || (cArg == 's') || (cArg == 'x'))) {
    return 0;
  }  
  ((*pzErr) = sqlite3_mprintf("unrecognized matchinfo request: %c", cArg));
  return 1;
}
static  int fts3MatchinfoSize(_1273_MatchInfo *pInfo , char cArg )  {
  int nVal;
  switch (cArg) {
    case 'n':
    case 'p':
    case 'c':
    (nVal = 1);
    break;
    case 'a':
    case 'l':
    case 's':
    (nVal = pInfo->nCol);
    break;
    id2i_label_1:
    default:
    ((void ) 0);
    (nVal = (pInfo->nCol * pInfo->nPhrase * 3));
    break;
  }
  return nVal;
}
static  int fts3MatchinfoSelectDoctotal(_1273_Fts3Table *pTab , sqlite3_stmt **ppStmt , sqlite3_int64 *pnDoc , const  char **paLen )  {
  sqlite3_stmt *pStmt;
  const char *a;
  sqlite3_int64 nDoc;
  if ((! (*ppStmt))) {
    int rc =  sqlite3Fts3SelectDoctotal(pTab, ppStmt);
    if ((rc != 0)) {
      return rc;
    }  
  }  
  (pStmt = (*ppStmt));
  ((void ) 0);
  (a = sqlite3_column_blob(pStmt, 0));
  (a += sqlite3Fts3GetVarint(a, (&nDoc)));
  if ((nDoc == 0)) {
    return (11 | (1 << 8));
  }  
  ((*pnDoc) = ((u32 ) nDoc));
  if (paLen) {
    ((*paLen) = a);
  }  
  return 0;
}
typedef struct  _1273_LcsIterator   _1273_LcsIterator;
struct  _1273_LcsIterator {
  _1273_Fts3Expr *pExpr ;
  int iPosOffset ;
  char *pRead ;
  int iPos ;
}  ;
static  int fts3MatchinfoLcsCb(_1273_Fts3Expr *pExpr , int iPhrase , void *pCtx )  {
  _1273_LcsIterator *aIter =  ((_1273_LcsIterator *) pCtx);
  (aIter[iPhrase].pExpr = pExpr);
  return 0;
}
static  int fts3LcsIteratorAdvance(_1273_LcsIterator *pIter )  {
  char *pRead =  pIter->pRead;
  sqlite3_int64 iRead;
  int rc =  0;
  (pRead += sqlite3Fts3GetVarint(pRead, (&iRead)));
  if (((iRead == 0) || (iRead == 1))) {
    (pRead = 0);
    (rc = 1);
  }  
  else {
    (pIter->iPos += ((int ) (iRead - 2)));
  }
  (pIter->pRead = pRead);
  return rc;
}
static  int fts3MatchinfoLcs(_1273_Fts3Cursor *pCsr , _1273_MatchInfo *pInfo )  {
  _1273_LcsIterator *aIter;
  int i;
  int iCol;
  int nToken =  0;
  (aIter = sqlite3_malloc((sizeof(_1273_LcsIterator ) * pCsr->nPhrase)));
  if ((! aIter)) {
    return 7;
  }  
  memset(aIter, 0, (sizeof(_1273_LcsIterator ) * pCsr->nPhrase));
  ((void ) fts3ExprIterate(pCsr->pExpr, fts3MatchinfoLcsCb, ((void *) aIter)));
  for ((i = 0); (i < pInfo->nPhrase); i++) {
    _1273_LcsIterator *pIter =  (&aIter[i]);
    (nToken -= pIter->pExpr->pPhrase->nToken);
    (pIter->iPosOffset = nToken);
  }
  for ((iCol = 0); (iCol < pInfo->nCol); iCol++) {
    int nLcs =  0;
    int nLive =  0;
    for ((i = 0); (i < pInfo->nPhrase); i++) {
      int rc;
      _1273_LcsIterator *pIt =  (&aIter[i]);
      (rc = sqlite3Fts3EvalPhrasePoslist(pCsr, pIt->pExpr, iCol, (&pIt->pRead)));
      if ((rc != 0)) {
        return rc;
      }  
      if (pIt->pRead) {
        (pIt->iPos = pIt->iPosOffset);
        fts3LcsIteratorAdvance((&aIter[i]));
        nLive++;
      }  
    }
    while ((nLive > 0)) {
      _1273_LcsIterator *pAdv =  0;
      int nThisLcs =  0;
      for ((i = 0); (i < pInfo->nPhrase); i++) {
        _1273_LcsIterator *pIter =  (&aIter[i]);
        if ((pIter->pRead == 0)) {
          (nThisLcs = 0);
        }  
        else {
          if (((pAdv == 0) || (pIter->iPos < pAdv->iPos))) {
            (pAdv = pIter);
          }  
          if (((nThisLcs == 0) || (pIter->iPos == pIter[(- 1)].iPos))) {
            nThisLcs++;
          }  
          else {
            (nThisLcs = 1);
          }
          if ((nThisLcs > nLcs)) {
            (nLcs = nThisLcs);
          }  
        }
      }
      if (fts3LcsIteratorAdvance(pAdv)) {
        nLive--;
      }  
    }
    (pInfo->aMatchinfo[iCol] = nLcs);
  }
  sqlite3_free(aIter);
  return 0;
}
static  int fts3MatchinfoValues(_1273_Fts3Cursor *pCsr , int bGlobal , _1273_MatchInfo *pInfo , const  char *zArg )  {
  int rc =  0;
  int i;
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  sqlite3_stmt *pSelect =  0;
  for ((i = 0); ((rc == 0) && zArg[i]); i++) {
    switch (zArg[i]) {
      case 'p':
      if (bGlobal) {
        (pInfo->aMatchinfo[0] = pInfo->nPhrase);
      }  
      break;
      case 'c':
      if (bGlobal) {
        (pInfo->aMatchinfo[0] = pInfo->nCol);
      }  
      break;
      case 'n':
      if (bGlobal) {
        sqlite3_int64 nDoc =  0;
        (rc = fts3MatchinfoSelectDoctotal(pTab, (&pSelect), (&nDoc), 0));
        (pInfo->aMatchinfo[0] = ((u32 ) nDoc));
      }  
      break;
      case 'a':
      if (bGlobal) {
        sqlite3_int64 nDoc;
        const char *a;
        (rc = fts3MatchinfoSelectDoctotal(pTab, (&pSelect), (&nDoc), (&a)));
        if ((rc == 0)) {
          int iCol;
          for ((iCol = 0); (iCol < pInfo->nCol); iCol++) {
            u32 iVal;
            sqlite3_int64 nToken;
            (a += sqlite3Fts3GetVarint(a, (&nToken)));
            (iVal = ((u32 ) ((((u32 ) (nToken & 0xffffffff)) + (nDoc / 2)) / nDoc)));
            (pInfo->aMatchinfo[iCol] = iVal);
          }
        }  
      }  
      break;
      case 'l':
      {
        sqlite3_stmt *pSelectDocsize =  0;
        (rc = sqlite3Fts3SelectDocsize(pTab, pCsr->iPrevId, (&pSelectDocsize)));
        if ((rc == 0)) {
          int iCol;
          const char *a =  sqlite3_column_blob(pSelectDocsize, 0);
          for ((iCol = 0); (iCol < pInfo->nCol); iCol++) {
            sqlite3_int64 nToken;
            (a += sqlite3Fts3GetVarint(a, (&nToken)));
            (pInfo->aMatchinfo[iCol] = ((u32 ) nToken));
          }
        }  
        sqlite3_reset(pSelectDocsize);
        break;
      }
      case 's':
      (rc = fts3ExprLoadDoclists(pCsr, 0, 0));
      if ((rc == 0)) {
        (rc = fts3MatchinfoLcs(pCsr, pInfo));
      }  
      break;
      id2i_label_1:
      default:
      {
        _1273_Fts3Expr *pExpr;
        ((void ) 0);
        (pExpr = pCsr->pExpr);
        (rc = fts3ExprLoadDoclists(pCsr, 0, 0));
        if ((rc != 0)) {
          break;
        }  
        if (bGlobal) {
          if (pCsr->pDeferred) {
            (rc = fts3MatchinfoSelectDoctotal(pTab, (&pSelect), (&pInfo->nDoc), 0));
            if ((rc != 0)) {
              break;
            }  
          }  
          (rc = fts3ExprIterate(pExpr, fts3ExprGlobalHitsCb, ((void *) pInfo)));
          if ((rc != 0)) {
            break;
          }  
        }  
        ((void ) fts3ExprIterate(pExpr, fts3ExprLocalHitsCb, ((void *) pInfo)));
        break;
      }
    }
    (pInfo->aMatchinfo += fts3MatchinfoSize(pInfo, zArg[i]));
  }
  sqlite3_reset(pSelect);
  return rc;
}
static  int fts3GetMatchinfo(_1273_Fts3Cursor *pCsr , const  char *zArg )  {
  _1273_MatchInfo sInfo;
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  int rc =  0;
  int bGlobal =  0;
  memset((&sInfo), 0, sizeof(_1273_MatchInfo ));
  (sInfo.pCursor = pCsr);
  (sInfo.nCol = pTab->nColumn);
  if ((pCsr->zMatchinfo && strcmp(pCsr->zMatchinfo, zArg))) {
    ((void ) 0);
    sqlite3_free(pCsr->aMatchinfo);
    (pCsr->zMatchinfo = 0);
    (pCsr->aMatchinfo = 0);
  }  
  if ((pCsr->aMatchinfo == 0)) {
    int nMatchinfo =  0;
    int nArg;
    int i;
    (pCsr->nPhrase = fts3ExprPhraseCount(pCsr->pExpr));
    (sInfo.nPhrase = pCsr->nPhrase);
    for ((i = 0); zArg[i]; i++) {
      (nMatchinfo += fts3MatchinfoSize((&sInfo), zArg[i]));
    }
    (nArg = ((int ) strlen(zArg)));
    (pCsr->aMatchinfo = ((u32 *) sqlite3_malloc(((sizeof(u32 ) * nMatchinfo) + nArg + 1))));
    if ((! pCsr->aMatchinfo)) {
      return 7;
    }  
    (pCsr->zMatchinfo = ((char *) (&pCsr->aMatchinfo[nMatchinfo])));
    (pCsr->nMatchinfo = nMatchinfo);
    memcpy(pCsr->zMatchinfo, zArg, (nArg + 1));
    memset(pCsr->aMatchinfo, 0, (sizeof(u32 ) * nMatchinfo));
    (pCsr->isMatchinfoNeeded = 1);
    (bGlobal = 1);
  }  
  (sInfo.aMatchinfo = pCsr->aMatchinfo);
  (sInfo.nPhrase = pCsr->nPhrase);
  if (pCsr->isMatchinfoNeeded) {
    (rc = fts3MatchinfoValues(pCsr, bGlobal, (&sInfo), zArg));
    (pCsr->isMatchinfoNeeded = 0);
  }  
  return rc;
}
static  void sqlite3Fts3Snippet(sqlite3_context *pCtx , _1273_Fts3Cursor *pCsr , const  char *zStart , const  char *zEnd , const  char *zEllipsis , int iCol , int nToken )  {
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  int rc =  0;
  int i;
  _1273_StrBuffer res =  { 0,  0,  0};
  int nSnippet =  0;
  _1273_SnippetFragment aSnippet[4];
  int nFToken =  (- 1);
  if ((! pCsr->pExpr)) {
    sqlite3_result_text(pCtx, "", 0, ((sqlite3_destructor_type ) 0));
    return;
  }  
  for ((nSnippet = 1); 1; nSnippet++) {
    int iSnip;
    u64 mCovered =  0;
    u64 mSeen =  0;
    if ((nToken >= 0)) {
      (nFToken = ((nToken + nSnippet - 1) / nSnippet));
    }  
    else {
      (nFToken = ((- 1) * nToken));
    }
    for ((iSnip = 0); (iSnip < nSnippet); iSnip++) {
      int iBestScore =  (- 1);
      int iRead;
      _1273_SnippetFragment *pFragment =  (&aSnippet[iSnip]);
      memset(pFragment, 0, sizeof((*pFragment)));
      for ((iRead = 0); (iRead < pTab->nColumn); iRead++) {
        _1273_SnippetFragment sF =  { 0,  0,  0,  0};
        int iS;
        if (((iCol >= 0) && (iRead != iCol))) {
          continue;
        }  
        (rc = fts3BestSnippet(nFToken, pCsr, iRead, mCovered, (&mSeen), (&sF), (&iS)));
        if ((rc != 0)) {
          goto _1273_snippet_out;
        }  
        if ((iS > iBestScore)) {
          ((*pFragment) = sF);
          (iBestScore = iS);
        }  
      }
      (mCovered |= pFragment->covered);
    }
    ((void ) 0);
    if (((mSeen == mCovered) || (nSnippet == ((int ) (sizeof(aSnippet) / sizeof(aSnippet[0])))))) {
      break;
    }  
  }
  ((void ) 0);
  for ((i = 0); ((i < nSnippet) && (rc == 0)); i++) {
    (rc = fts3SnippetText(pCsr, (&aSnippet[i]), i, (i == (nSnippet - 1)), nFToken, zStart, zEnd, zEllipsis, (&res)));
  }
  _1273_snippet_out:
  sqlite3Fts3SegmentsClose(pTab);
  if ((rc != 0)) {
    sqlite3_result_error_code(pCtx, rc);
    sqlite3_free(res.z);
  }  
  else {
    sqlite3_result_text(pCtx, res.z, (- 1), sqlite3_free);
  }
}
typedef struct  _1273_TermOffset   _1273_TermOffset;
typedef struct  _1273_TermOffsetCtx   _1273_TermOffsetCtx;
struct  _1273_TermOffset {
  char *pList ;
  int iPos ;
  int iOff ;
}  ;
struct  _1273_TermOffsetCtx {
  _1273_Fts3Cursor *pCsr ;
  int iCol ;
  int iTerm ;
  sqlite3_int64 iDocid ;
  _1273_TermOffset *aTerm ;
}  ;
static  int fts3ExprTermOffsetInit(_1273_Fts3Expr *pExpr , int iPhrase , void *ctx )  {
  _1273_TermOffsetCtx *p =  ((_1273_TermOffsetCtx *) ctx);
  int nTerm;
  int iTerm;
  char *pList;
  int iPos =  0;
  int rc;
  ((void ) iPhrase);
  (rc = sqlite3Fts3EvalPhrasePoslist(p->pCsr, pExpr, p->iCol, (&pList)));
  (nTerm = pExpr->pPhrase->nToken);
  if (pList) {
    fts3GetDeltaPosition((&pList), (&iPos));
    ((void ) 0);
  }  
  for ((iTerm = 0); (iTerm < nTerm); iTerm++) {
    _1273_TermOffset *pT =  (&p->aTerm[p->iTerm++]);
    (pT->iOff = (nTerm - iTerm - 1));
    (pT->pList = pList);
    (pT->iPos = iPos);
  }
  return rc;
}
static  void sqlite3Fts3Offsets(sqlite3_context *pCtx , _1273_Fts3Cursor *pCsr )  {
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  _1273_sqlite3_tokenizer_module const *pMod =  pTab->pTokenizer->pModule;
  int rc;
  int nToken;
  int iCol;
  _1273_StrBuffer res =  { 0,  0,  0};
  _1273_TermOffsetCtx sCtx;
  if ((! pCsr->pExpr)) {
    sqlite3_result_text(pCtx, "", 0, ((sqlite3_destructor_type ) 0));
    return;
  }  
  memset((&sCtx), 0, sizeof(sCtx));
  ((void ) 0);
  (rc = fts3ExprLoadDoclists(pCsr, 0, (&nToken)));
  if ((rc != 0)) {
    goto _1273_offsets_out;
  }  
  (sCtx.aTerm = ((_1273_TermOffset *) sqlite3_malloc((sizeof(_1273_TermOffset ) * nToken))));
  if ((0 == sCtx.aTerm)) {
    (rc = 7);
    goto _1273_offsets_out;
  }  
  (sCtx.iDocid = pCsr->iPrevId);
  (sCtx.pCsr = pCsr);
  for ((iCol = 0); (iCol < pTab->nColumn); iCol++) {
    _1273_sqlite3_tokenizer_cursor *pC;
    const char *ZDUMMY;
    int NDUMMY =  0;
    int iStart =  0;
    int iEnd =  0;
    int iCurrent =  0;
    const char *zDoc;
    int nDoc;
    (sCtx.iCol = iCol);
    (sCtx.iTerm = 0);
    ((void ) fts3ExprIterate(pCsr->pExpr, fts3ExprTermOffsetInit, ((void *) (&sCtx))));
    (zDoc = ((const  char *) sqlite3_column_text(pCsr->pStmt, (iCol + 1))));
    (nDoc = sqlite3_column_bytes(pCsr->pStmt, (iCol + 1)));
    if ((zDoc == 0)) {
      if ((sqlite3_column_type(pCsr->pStmt, (iCol + 1)) == 5)) {
        continue;
      }  
      (rc = 7);
      goto _1273_offsets_out;
    }  
    (rc = sqlite3Fts3OpenTokenizer(pTab->pTokenizer, pCsr->iLangid, zDoc, nDoc, (&pC)));
    if ((rc != 0)) {
      goto _1273_offsets_out;
    }  
    (rc = pMod->xNext(pC, (&ZDUMMY), (&NDUMMY), (&iStart), (&iEnd), (&iCurrent)));
    while ((rc == 0)) {
      int i;
      int iMinPos =  0x7FFFFFFF;
      _1273_TermOffset *pTerm =  0;
      for ((i = 0); (i < nToken); i++) {
        _1273_TermOffset *pT =  (&sCtx.aTerm[i]);
        if ((pT->pList && ((pT->iPos - pT->iOff) < iMinPos))) {
          (iMinPos = (pT->iPos - pT->iOff));
          (pTerm = pT);
        }  
      }
      if ((! pTerm)) {
        (rc = 101);
      }  
      else {
        ((void ) 0);
        if ((0 == (0xFE & (*pTerm->pList)))) {
          (pTerm->pList = 0);
        }  
        else {
          fts3GetDeltaPosition((&pTerm->pList), (&pTerm->iPos));
        }
        while (((rc == 0) && (iCurrent < iMinPos))) {
          (rc = pMod->xNext(pC, (&ZDUMMY), (&NDUMMY), (&iStart), (&iEnd), (&iCurrent)));
        }
        if ((rc == 0)) {
          char aBuffer[64];
          sqlite3_snprintf(sizeof(aBuffer), aBuffer, "%d %d %d %d ", iCol, (pTerm - sCtx.aTerm), iStart, (iEnd - iStart));
          (rc = fts3StringAppend((&res), aBuffer, (- 1)));
        } 
        else if (((rc == 101) && (pTab->zContentTbl == 0))) {
          (rc = (11 | (1 << 8)));
        } 
      }
    }
    if ((rc == 101)) {
      (rc = 0);
    }  
    pMod->xClose(pC);
    if ((rc != 0)) {
      goto _1273_offsets_out;
    }  
  }
  _1273_offsets_out:
  sqlite3_free(sCtx.aTerm);
  ((void ) 0);
  sqlite3Fts3SegmentsClose(pTab);
  if ((rc != 0)) {
    sqlite3_result_error_code(pCtx, rc);
    sqlite3_free(res.z);
  }  
  else {
    sqlite3_result_text(pCtx, res.z, (res.n - 1), sqlite3_free);
  }
  return;
}
static  void sqlite3Fts3Matchinfo(sqlite3_context *pContext , _1273_Fts3Cursor *pCsr , const  char *zArg )  {
  _1273_Fts3Table *pTab =  ((_1273_Fts3Table *) pCsr->base.pVtab);
  int rc;
  int i;
  const char *zFormat;
  if (zArg) {
    for ((i = 0); zArg[i]; i++) {
      char *zErr =  0;
      if (fts3MatchinfoCheck(pTab, zArg[i], (&zErr))) {
        sqlite3_result_error(pContext, zErr, (- 1));
        sqlite3_free(zErr);
        return;
      }  
    }
    (zFormat = zArg);
  }  
  else {
    (zFormat = "pcx");
  }
  if ((! pCsr->pExpr)) {
    sqlite3_result_blob(pContext, "", 0, ((sqlite3_destructor_type ) 0));
    return;
  }  
  (rc = fts3GetMatchinfo(pCsr, zFormat));
  sqlite3Fts3SegmentsClose(pTab);
  if ((rc != 0)) {
    sqlite3_result_error_code(pContext, rc);
  }  
  else {
    int n =  (pCsr->nMatchinfo * sizeof(u32 ));
    sqlite3_result_blob(pContext, pCsr->aMatchinfo, n, ((sqlite3_destructor_type ) (- 1)));
  }
}
typedef struct  _1367_unicode_tokenizer   _1367_unicode_tokenizer;
typedef struct  _1367_unicode_cursor   _1367_unicode_cursor;
struct  _1367_unicode_tokenizer {
  _1273_sqlite3_tokenizer base ;
  int bRemoveDiacritic ;
  int nException ;
  int *aiException ;
}  ;
struct  _1367_unicode_cursor {
  _1273_sqlite3_tokenizer_cursor base ;
  const  unsigned  char *aInput ;
  int nInput ;
  int iOff ;
  int iToken ;
  char *zToken ;
  int nAlloc ;
}  ;
static  int unicodeDestroy(_1273_sqlite3_tokenizer *pTokenizer )  {
  if (pTokenizer) {
    _1367_unicode_tokenizer *p =  ((_1367_unicode_tokenizer *) pTokenizer);
    sqlite3_free(p->aiException);
    sqlite3_free(p);
  }  
  return 0;
}
static  int unicodeAddExceptions(_1367_unicode_tokenizer *p , int bAlnum , const  char *zIn , int nIn )  {
  const unsigned char *z =  ((const  unsigned  char *) zIn);
  const unsigned char *zTerm =  (&z[nIn]);
  int iCode;
  int nEntry =  0;
  ((void ) 0);
  while ((z < zTerm)) {
    (iCode = (*z++));
    if ((iCode >= 0xc0)) {
      (iCode = sqlite3Utf8Trans1[(iCode - 0xc0)]);
      while (((z != zTerm) && (((*z) & 0xc0) == 0x80))) {
        (iCode = ((iCode << 6) + (0x3f & (*z++))));
      }
      if (((iCode < 0x80) || ((iCode & 0xFFFFF800) == 0xD800) || ((iCode & 0xFFFFFFFE) == 0xFFFE))) {
        (iCode = 0xFFFD);
      }  
    }  
    ((void ) 0);
    if (((sqlite3FtsUnicodeIsalnum(iCode) != bAlnum) && (sqlite3FtsUnicodeIsdiacritic(iCode) == 0))) {
      nEntry++;
    }  
  }
  if (nEntry) {
    int *aNew;
    int nNew;
    (aNew = sqlite3_realloc(p->aiException, ((p->nException + nEntry) * sizeof(int ))));
    if ((aNew == 0)) {
      return 7;
    }  
    (nNew = p->nException);
    (z = ((const  unsigned  char *) zIn));
    while ((z < zTerm)) {
      (iCode = (*z++));
      if ((iCode >= 0xc0)) {
        (iCode = sqlite3Utf8Trans1[(iCode - 0xc0)]);
        while (((z != zTerm) && (((*z) & 0xc0) == 0x80))) {
          (iCode = ((iCode << 6) + (0x3f & (*z++))));
        }
        if (((iCode < 0x80) || ((iCode & 0xFFFFF800) == 0xD800) || ((iCode & 0xFFFFFFFE) == 0xFFFE))) {
          (iCode = 0xFFFD);
        }  
      }  
      if (((sqlite3FtsUnicodeIsalnum(iCode) != bAlnum) && (sqlite3FtsUnicodeIsdiacritic(iCode) == 0))) {
        int i, j;
        for ((i = 0); ((i < nNew) && (aNew[i] < iCode)); i++) {
          
        }
        for ((j = nNew); (j > i); j--) {
          (aNew[j] = aNew[(j - 1)]);
        }
        (aNew[i] = iCode);
        nNew++;
      }  
    }
    (p->aiException = aNew);
    (p->nException = nNew);
  }  
  return 0;
}
static  int unicodeIsException(_1367_unicode_tokenizer *p , int iCode )  {
  if ((p->nException > 0)) {
    int *a =  p->aiException;
    int iLo =  0;
    int iHi =  (p->nException - 1);
    while ((iHi >= iLo)) {
      int iTest =  ((iHi + iLo) / 2);
      if ((iCode == a[iTest])) {
        return 1;
      } 
      else if ((iCode > a[iTest])) {
        (iLo = (iTest + 1));
      } 
      else {
        (iHi = (iTest - 1));
      }
    }
  }  
  return 0;
}
static  int unicodeIsAlnum(_1367_unicode_tokenizer *p , int iCode )  {
  ((void ) 0);
  return (sqlite3FtsUnicodeIsalnum(iCode) ^ unicodeIsException(p, iCode));
}
static  int unicodeCreate(int nArg , const  char *const *azArg , _1273_sqlite3_tokenizer **pp )  {
  _1367_unicode_tokenizer *pNew;
  int i;
  int rc =  0;
  (pNew = ((_1367_unicode_tokenizer *) sqlite3_malloc(sizeof(_1367_unicode_tokenizer ))));
  if ((pNew == ((void *) 0))) {
    return 7;
  }  
  memset(pNew, 0, sizeof(_1367_unicode_tokenizer ));
  (pNew->bRemoveDiacritic = 1);
  for ((i = 0); ((rc == 0) && (i < nArg)); i++) {
    const char *z =  azArg[i];
    int n =  strlen(z);
    if (((n == 19) && (memcmp("remove_diacritics=1", z, 19) == 0))) {
      (pNew->bRemoveDiacritic = 1);
    } 
    else if (((n == 19) && (memcmp("remove_diacritics=0", z, 19) == 0))) {
      (pNew->bRemoveDiacritic = 0);
    }
    
    else if (((n >= 11) && (memcmp("tokenchars=", z, 11) == 0))) {
      (rc = unicodeAddExceptions(pNew, 1, (&z[11]), (n - 11)));
    }
    
    else if (((n >= 11) && (memcmp("separators=", z, 11) == 0))) {
      (rc = unicodeAddExceptions(pNew, 0, (&z[11]), (n - 11)));
    } 
    else {
      (rc = 1);
    }
  }
  if ((rc != 0)) {
    unicodeDestroy(((_1273_sqlite3_tokenizer *) pNew));
    (pNew = 0);
  }  
  ((*pp) = ((_1273_sqlite3_tokenizer *) pNew));
  return rc;
}
static  int unicodeOpen(_1273_sqlite3_tokenizer *p , const  char *aInput , int nInput , _1273_sqlite3_tokenizer_cursor **pp )  {
  _1367_unicode_cursor *pCsr;
  (pCsr = ((_1367_unicode_cursor *) sqlite3_malloc(sizeof(_1367_unicode_cursor ))));
  if ((pCsr == 0)) {
    return 7;
  }  
  memset(pCsr, 0, sizeof(_1367_unicode_cursor ));
  (pCsr->aInput = ((const  unsigned  char *) aInput));
  if ((aInput == 0)) {
    (pCsr->nInput = 0);
  } 
  else if ((nInput < 0)) {
    (pCsr->nInput = ((int ) strlen(aInput)));
  } 
  else {
    (pCsr->nInput = nInput);
  }
  ((*pp) = (&pCsr->base));
  ((void ) p);
  return 0;
}
static  int unicodeClose(_1273_sqlite3_tokenizer_cursor *pCursor )  {
  _1367_unicode_cursor *pCsr =  ((_1367_unicode_cursor *) pCursor);
  sqlite3_free(pCsr->zToken);
  sqlite3_free(pCsr);
  return 0;
}
static  int unicodeNext(_1273_sqlite3_tokenizer_cursor *pC , const  char **paToken , int *pnToken , int *piStart , int *piEnd , int *piPos )  {
  _1367_unicode_cursor *pCsr =  ((_1367_unicode_cursor *) pC);
  _1367_unicode_tokenizer *p =  ((_1367_unicode_tokenizer *) pCsr->base.pTokenizer);
  int iCode;
  char *zOut;
  const unsigned char *z =  (&pCsr->aInput[pCsr->iOff]);
  const unsigned char *zStart =  z;
  const unsigned char *zEnd;
  const unsigned char *zTerm =  (&pCsr->aInput[pCsr->nInput]);
  while ((z < zTerm)) {
    (iCode = (*z++));
    if ((iCode >= 0xc0)) {
      (iCode = sqlite3Utf8Trans1[(iCode - 0xc0)]);
      while (((z != zTerm) && (((*z) & 0xc0) == 0x80))) {
        (iCode = ((iCode << 6) + (0x3f & (*z++))));
      }
      if (((iCode < 0x80) || ((iCode & 0xFFFFF800) == 0xD800) || ((iCode & 0xFFFFFFFE) == 0xFFFE))) {
        (iCode = 0xFFFD);
      }  
    }  
    if (unicodeIsAlnum(p, iCode)) {
      break;
    }  
    (zStart = z);
  }
  if ((zStart >= zTerm)) {
    return 101;
  }  
  (zOut = pCsr->zToken);
  do {
    int iOut;
    if (((zOut - pCsr->zToken) >= (pCsr->nAlloc - 4))) {
      char *zNew =  sqlite3_realloc(pCsr->zToken, (pCsr->nAlloc + 64));
      if ((! zNew)) {
        return 7;
      }  
      (zOut = (&zNew[(zOut - pCsr->zToken)]));
      (pCsr->zToken = zNew);
      (pCsr->nAlloc += 64);
    }  
    (zEnd = z);
    (iOut = sqlite3FtsUnicodeFold(iCode, p->bRemoveDiacritic));
    if (iOut) {
      {
        if ((iOut < 0x00080)) {
          ((*zOut++) = ((u8 ) (iOut & 0xFF)));
        } 
        else if ((iOut < 0x00800)) {
          ((*zOut++) = (0xC0 + ((u8 ) ((iOut >> 6) & 0x1F))));
          ((*zOut++) = (0x80 + ((u8 ) (iOut & 0x3F))));
        }
        
        else if ((iOut < 0x10000)) {
          ((*zOut++) = (0xE0 + ((u8 ) ((iOut >> 12) & 0x0F))));
          ((*zOut++) = (0x80 + ((u8 ) ((iOut >> 6) & 0x3F))));
          ((*zOut++) = (0x80 + ((u8 ) (iOut & 0x3F))));
        } 
        else {
          ((*zOut++) = (0xF0 + ((u8 ) ((iOut >> 18) & 0x07))));
          ((*zOut++) = (0x80 + ((u8 ) ((iOut >> 12) & 0x3F))));
          ((*zOut++) = (0x80 + ((u8 ) ((iOut >> 6) & 0x3F))));
          ((*zOut++) = (0x80 + ((u8 ) (iOut & 0x3F))));
        }
      }
    }  
    if ((z >= zTerm)) {
      break;
    }  
    (iCode = (*z++));
    if ((iCode >= 0xc0)) {
      (iCode = sqlite3Utf8Trans1[(iCode - 0xc0)]);
      while (((z != zTerm) && (((*z) & 0xc0) == 0x80))) {
        (iCode = ((iCode << 6) + (0x3f & (*z++))));
      }
      if (((iCode < 0x80) || ((iCode & 0xFFFFF800) == 0xD800) || ((iCode & 0xFFFFFFFE) == 0xFFFE))) {
        (iCode = 0xFFFD);
      }  
    }  
  } while ((unicodeIsAlnum(p, iCode) || sqlite3FtsUnicodeIsdiacritic(iCode)));
  (pCsr->iOff = (z - pCsr->aInput));
  ((*paToken) = pCsr->zToken);
  ((*pnToken) = (zOut - pCsr->zToken));
  ((*piStart) = (zStart - pCsr->aInput));
  ((*piEnd) = (zEnd - pCsr->aInput));
  ((*piPos) = pCsr->iToken++);
  return 0;
}
static  void sqlite3Fts3UnicodeTokenizer(_1273_sqlite3_tokenizer_module  const **ppModule )  {
  static const _1273_sqlite3_tokenizer_module module =  { 0,  unicodeCreate,  unicodeDestroy,  unicodeOpen,  unicodeClose,  unicodeNext,  0};
  ((*ppModule) = (&module));
}
static  int sqlite3FtsUnicodeIsalnum(int c )  {
  const static unsigned int aEntry[] =  { 0x00000030,  0x0000E807,  0x00016C06,  0x0001EC2F,  0x0002AC07,  0x0002D001,  0x0002D803,  0x0002EC01,  0x0002FC01,  0x00035C01,  0x0003DC01,  0x000B0804,  0x000B480E,  0x000B9407,  0x000BB401,  0x000BBC81,  0x000DD401,  0x000DF801,  0x000E1002,  0x000E1C01,  0x000FD801,  0x00120808,  0x00156806,  0x00162402,  0x00163C01,  0x00164437,  0x0017CC02,  0x00180005,  0x00181816,  0x00187802,  0x00192C15,  0x0019A804,  0x0019C001,  0x001B5001,  0x001B580F,  0x001B9C07,  0x001BF402,  0x001C000E,  0x001C3C01,  0x001C4401,  0x001CC01B,  0x001E980B,  0x001FAC09,  0x001FD804,  0x00205804,  0x00206C09,  0x00209403,  0x0020A405,  0x0020C00F,  0x00216403,  0x00217801,  0x0023901B,  0x00240004,  0x0024E803,  0x0024F812,  0x00254407,  0x00258804,  0x0025C001,  0x00260403,  0x0026F001,  0x0026F807,  0x00271C02,  0x00272C03,  0x00275C01,  0x00278802,  0x0027C802,  0x0027E802,  0x00280403,  0x0028F001,  0x0028F805,  0x00291C02,  0x00292C03,  0x00294401,  0x0029C002,  0x0029D401,  0x002A0403,  0x002AF001,  0x002AF808,  0x002B1C03,  0x002B2C03,  0x002B8802,  0x002BC002,  0x002C0403,  0x002CF001,  0x002CF807,  0x002D1C02,  0x002D2C03,  0x002D5802,  0x002D8802,  0x002DC001,  0x002E0801,  0x002EF805,  0x002F1803,  0x002F2804,  0x002F5C01,  0x002FCC08,  0x00300403,  0x0030F807,  0x00311803,  0x00312804,  0x00315402,  0x00318802,  0x0031FC01,  0x00320802,  0x0032F001,  0x0032F807,  0x00331803,  0x00332804,  0x00335402,  0x00338802,  0x00340802,  0x0034F807,  0x00351803,  0x00352804,  0x00355C01,  0x00358802,  0x0035E401,  0x00360802,  0x00372801,  0x00373C06,  0x00375801,  0x00376008,  0x0037C803,  0x0038C401,  0x0038D007,  0x0038FC01,  0x00391C09,  0x00396802,  0x003AC401,  0x003AD006,  0x003AEC02,  0x003B2006,  0x003C041F,  0x003CD00C,  0x003DC417,  0x003E340B,  0x003E6424,  0x003EF80F,  0x003F380D,  0x0040AC14,  0x00412806,  0x00415804,  0x00417803,  0x00418803,  0x00419C07,  0x0041C404,  0x0042080C,  0x00423C01,  0x00426806,  0x0043EC01,  0x004D740C,  0x004E400A,  0x00500001,  0x0059B402,  0x005A0001,  0x005A6C02,  0x005BAC03,  0x005C4803,  0x005CC805,  0x005D4802,  0x005DC802,  0x005ED023,  0x005F6004,  0x005F7401,  0x0060000F,  0x0062A401,  0x0064800C,  0x0064C00C,  0x00650001,  0x00651002,  0x0066C011,  0x00672002,  0x00677822,  0x00685C05,  0x00687802,  0x0069540A,  0x0069801D,  0x0069FC01,  0x006A8007,  0x006AA006,  0x006C0005,  0x006CD011,  0x006D6823,  0x006E0003,  0x006E840D,  0x006F980E,  0x006FF004,  0x00709014,  0x0070EC05,  0x0071F802,  0x00730008,  0x00734019,  0x0073B401,  0x0073C803,  0x00770027,  0x0077F004,  0x007EF401,  0x007EFC03,  0x007F3403,  0x007F7403,  0x007FB403,  0x007FF402,  0x00800065,  0x0081A806,  0x0081E805,  0x00822805,  0x0082801A,  0x00834021,  0x00840002,  0x00840C04,  0x00842002,  0x00845001,  0x00845803,  0x00847806,  0x00849401,  0x00849C01,  0x0084A401,  0x0084B801,  0x0084E802,  0x00850005,  0x00852804,  0x00853C01,  0x00864264,  0x00900027,  0x0091000B,  0x0092704E,  0x00940200,  0x009C0475,  0x009E53B9,  0x00AD400A,  0x00B39406,  0x00B3BC03,  0x00B3E404,  0x00B3F802,  0x00B5C001,  0x00B5FC01,  0x00B7804F,  0x00B8C00C,  0x00BA001A,  0x00BA6C59,  0x00BC00D6,  0x00BFC00C,  0x00C00005,  0x00C02019,  0x00C0A807,  0x00C0D802,  0x00C0F403,  0x00C26404,  0x00C28001,  0x00C3EC01,  0x00C64002,  0x00C6580A,  0x00C70024,  0x00C8001F,  0x00C8A81E,  0x00C94001,  0x00C98020,  0x00CA2827,  0x00CB003F,  0x00CC0100,  0x01370040,  0x02924037,  0x0293F802,  0x02983403,  0x0299BC10,  0x029A7C01,  0x029BC008,  0x029C0017,  0x029C8002,  0x029E2402,  0x02A00801,  0x02A01801,  0x02A02C01,  0x02A08C09,  0x02A0D804,  0x02A1D004,  0x02A20002,  0x02A2D011,  0x02A33802,  0x02A38012,  0x02A3E003,  0x02A4980A,  0x02A51C0D,  0x02A57C01,  0x02A60004,  0x02A6CC1B,  0x02A77802,  0x02A8A40E,  0x02A90C01,  0x02A93002,  0x02A97004,  0x02A9DC03,  0x02A9EC01,  0x02AAC001,  0x02AAC803,  0x02AADC02,  0x02AAF802,  0x02AB0401,  0x02AB7802,  0x02ABAC07,  0x02ABD402,  0x02AF8C0B,  0x03600001,  0x036DFC02,  0x036FFC02,  0x037FFC01,  0x03EC7801,  0x03ECA401,  0x03EEC810,  0x03F4F802,  0x03F7F002,  0x03F8001A,  0x03F88007,  0x03F8C023,  0x03F95013,  0x03F9A004,  0x03FBFC01,  0x03FC040F,  0x03FC6807,  0x03FCEC06,  0x03FD6C0B,  0x03FF8007,  0x03FFA007,  0x03FFE405,  0x04040003,  0x0404DC09,  0x0405E411,  0x0406400C,  0x0407402E,  0x040E7C01,  0x040F4001,  0x04215C01,  0x04247C01,  0x0424FC01,  0x04280403,  0x04281402,  0x04283004,  0x0428E003,  0x0428FC01,  0x04294009,  0x0429FC01,  0x042CE407,  0x04400003,  0x0440E016,  0x04420003,  0x0442C012,  0x04440003,  0x04449C0E,  0x04450004,  0x04460003,  0x0446CC0E,  0x04471404,  0x045AAC0D,  0x0491C004,  0x05BD442E,  0x05BE3C04,  0x074000F6,  0x07440027,  0x0744A4B5,  0x07480046,  0x074C0057,  0x075B0401,  0x075B6C01,  0x075BEC01,  0x075C5401,  0x075CD401,  0x075D3C01,  0x075DBC01,  0x075E2401,  0x075EA401,  0x075F0C01,  0x07BBC002,  0x07C0002C,  0x07C0C064,  0x07C2800F,  0x07C2C40E,  0x07C3040F,  0x07C3440F,  0x07C4401F,  0x07C4C03C,  0x07C5C02B,  0x07C7981D,  0x07C8402B,  0x07C90009,  0x07C94002,  0x07CC0021,  0x07CCC006,  0x07CCDC46,  0x07CE0014,  0x07CE8025,  0x07CF1805,  0x07CF8011,  0x07D0003F,  0x07D10001,  0x07D108B6,  0x07D3E404,  0x07D4003E,  0x07D50004,  0x07D54018,  0x07D7EC46,  0x07D9140B,  0x07DA0046,  0x07DC0074,  0x38000401,  0x38008060,  0x380400F0};
  static const unsigned int aAscii[4] =  { 0xFFFFFFFF,  0xFC00FFFF,  0xF8000001,  0xF8000001};
  if ((c < 128)) {
    return ((aAscii[(c >> 5)] & (1 << (c & 0x001F))) == 0);
  } 
  else if ((c < (1 << 22))) {
    unsigned int key =  ((((unsigned  int ) c) << 10) | 0x000003FF);
    int iRes;
    int iHi =  ((sizeof(aEntry) / sizeof(aEntry[0])) - 1);
    int iLo =  0;
    while ((iHi >= iLo)) {
      int iTest =  ((iHi + iLo) / 2);
      if ((key >= aEntry[iTest])) {
        (iRes = iTest);
        (iLo = (iTest + 1));
      }  
      else {
        (iHi = (iTest - 1));
      }
    }
    ((void ) 0);
    ((void ) 0);
    return (((unsigned  int ) c) >= ((aEntry[iRes] >> 10) + (aEntry[iRes] & 0x3FF)));
  } 
  return 1;
}
static  int remove_diacritic(int c )  {
  unsigned short aDia[] =  { 0,  1797,  1848,  1859,  1891,  1928,  1940,  1995,  2024,  2040,  2060,  2110,  2168,  2206,  2264,  2286,  2344,  2383,  2472,  2488,  2516,  2596,  2668,  2732,  2782,  2842,  2894,  2954,  2984,  3000,  3028,  3336,  3456,  3696,  3712,  3728,  3744,  3896,  3912,  3928,  3968,  4008,  4040,  4106,  4138,  4170,  4202,  4234,  4266,  4296,  4312,  4344,  4408,  4424,  4472,  4504,  6148,  6198,  6264,  6280,  6360,  6429,  6505,  6529,  61448,  61468,  61534,  61592,  61642,  61688,  61704,  61726,  61784,  61800,  61836,  61880,  61914,  61948,  61998,  62122,  62154,  62200,  62218,  62302,  62364,  62442,  62478,  62536,  62554,  62584,  62604,  62640,  62648,  62656,  62664,  62730,  62924,  63050,  63082,  63274,  63390};
  char aChar[] =  { '\0',  'a',  'c',  'e',  'i',  'n',  'o',  'u',  'y',  'y',  'a',  'c',  'd',  'e',  'e',  'g',  'h',  'i',  'j',  'k',  'l',  'n',  'o',  'r',  's',  't',  'u',  'u',  'w',  'y',  'z',  'o',  'u',  'a',  'i',  'o',  'u',  'g',  'k',  'o',  'j',  'g',  'n',  'a',  'e',  'i',  'o',  'r',  'u',  's',  't',  'h',  'a',  'e',  'o',  'y',  '\0',  '\0',  '\0',  '\0',  '\0',  '\0',  '\0',  '\0',  'a',  'b',  'd',  'd',  'e',  'f',  'g',  'h',  'h',  'i',  'k',  'l',  'l',  'm',  'n',  'p',  'r',  'r',  's',  't',  'u',  'v',  'w',  'w',  'x',  'y',  'z',  'h',  't',  'w',  'y',  'a',  'e',  'i',  'o',  'u',  'y'};
  unsigned int key =  ((((unsigned  int ) c) << 3) | 0x00000007);
  int iRes =  0;
  int iHi =  ((sizeof(aDia) / sizeof(aDia[0])) - 1);
  int iLo =  0;
  while ((iHi >= iLo)) {
    int iTest =  ((iHi + iLo) / 2);
    if ((key >= aDia[iTest])) {
      (iRes = iTest);
      (iLo = (iTest + 1));
    }  
    else {
      (iHi = (iTest - 1));
    }
  }
  ((void ) 0);
  return ((c > ((aDia[iRes] >> 3) + (aDia[iRes] & 0x07))) ? c : ((int ) aChar[iRes]));
}
static  int sqlite3FtsUnicodeIsdiacritic(int c )  {
  unsigned int mask0 =  0x08029FDF;
  unsigned int mask1 =  0x000361F8;
  if (((c < 768) || (c > 817))) {
    return 0;
  }  
  return ((c < (768 + 32)) ? (mask0 & (1 << (c - 768))) : (mask1 & (1 << (c - 768 - 32))));
}
static  int sqlite3FtsUnicodeFold(int c , int bRemoveDiacritic )  {
  static const struct  TableEntry {
    unsigned  short iCode ;
    unsigned  char flags ;
    unsigned  char nRange ;
  }  aEntry[] =  { { 65,  14,  26},  { 181,  64,  1},  { 192,  14,  23},  { 216,  14,  7},  { 256,  1,  48},  { 306,  1,  6},  { 313,  1,  16},  { 330,  1,  46},  { 376,  116,  1},  { 377,  1,  6},  { 383,  104,  1},  { 385,  50,  1},  { 386,  1,  4},  { 390,  44,  1},  { 391,  0,  1},  { 393,  42,  2},  { 395,  0,  1},  { 398,  32,  1},  { 399,  38,  1},  { 400,  40,  1},  { 401,  0,  1},  { 403,  42,  1},  { 404,  46,  1},  { 406,  52,  1},  { 407,  48,  1},  { 408,  0,  1},  { 412,  52,  1},  { 413,  54,  1},  { 415,  56,  1},  { 416,  1,  6},  { 422,  60,  1},  { 423,  0,  1},  { 425,  60,  1},  { 428,  0,  1},  { 430,  60,  1},  { 431,  0,  1},  { 433,  58,  2},  { 435,  1,  4},  { 439,  62,  1},  { 440,  0,  1},  { 444,  0,  1},  { 452,  2,  1},  { 453,  0,  1},  { 455,  2,  1},  { 456,  0,  1},  { 458,  2,  1},  { 459,  1,  18},  { 478,  1,  18},  { 497,  2,  1},  { 498,  1,  4},  { 502,  122,  1},  { 503,  134,  1},  { 504,  1,  40},  { 544,  110,  1},  { 546,  1,  18},  { 570,  70,  1},  { 571,  0,  1},  { 573,  108,  1},  { 574,  68,  1},  { 577,  0,  1},  { 579,  106,  1},  { 580,  28,  1},  { 581,  30,  1},  { 582,  1,  10},  { 837,  36,  1},  { 880,  1,  4},  { 886,  0,  1},  { 902,  18,  1},  { 904,  16,  3},  { 908,  26,  1},  { 910,  24,  2},  { 913,  14,  17},  { 931,  14,  9},  { 962,  0,  1},  { 975,  4,  1},  { 976,  140,  1},  { 977,  142,  1},  { 981,  146,  1},  { 982,  144,  1},  { 984,  1,  24},  { 1008,  136,  1},  { 1009,  138,  1},  { 1012,  130,  1},  { 1013,  128,  1},  { 1015,  0,  1},  { 1017,  152,  1},  { 1018,  0,  1},  { 1021,  110,  3},  { 1024,  34,  16},  { 1040,  14,  32},  { 1120,  1,  34},  { 1162,  1,  54},  { 1216,  6,  1},  { 1217,  1,  14},  { 1232,  1,  88},  { 1329,  22,  38},  { 4256,  66,  38},  { 4295,  66,  1},  { 4301,  66,  1},  { 7680,  1,  150},  { 7835,  132,  1},  { 7838,  96,  1},  { 7840,  1,  96},  { 7944,  150,  8},  { 7960,  150,  6},  { 7976,  150,  8},  { 7992,  150,  8},  { 8008,  150,  6},  { 8025,  151,  8},  { 8040,  150,  8},  { 8072,  150,  8},  { 8088,  150,  8},  { 8104,  150,  8},  { 8120,  150,  2},  { 8122,  126,  2},  { 8124,  148,  1},  { 8126,  100,  1},  { 8136,  124,  4},  { 8140,  148,  1},  { 8152,  150,  2},  { 8154,  120,  2},  { 8168,  150,  2},  { 8170,  118,  2},  { 8172,  152,  1},  { 8184,  112,  2},  { 8186,  114,  2},  { 8188,  148,  1},  { 8486,  98,  1},  { 8490,  92,  1},  { 8491,  94,  1},  { 8498,  12,  1},  { 8544,  8,  16},  { 8579,  0,  1},  { 9398,  10,  26},  { 11264,  22,  47},  { 11360,  0,  1},  { 11362,  88,  1},  { 11363,  102,  1},  { 11364,  90,  1},  { 11367,  1,  6},  { 11373,  84,  1},  { 11374,  86,  1},  { 11375,  80,  1},  { 11376,  82,  1},  { 11378,  0,  1},  { 11381,  0,  1},  { 11390,  78,  2},  { 11392,  1,  100},  { 11499,  1,  4},  { 11506,  0,  1},  { 42560,  1,  46},  { 42624,  1,  24},  { 42786,  1,  14},  { 42802,  1,  62},  { 42873,  1,  4},  { 42877,  76,  1},  { 42878,  1,  10},  { 42891,  0,  1},  { 42893,  74,  1},  { 42896,  1,  4},  { 42912,  1,  10},  { 42922,  72,  1},  { 65313,  14,  26}};
  static const unsigned short aiOff[] =  { 1,  2,  8,  15,  16,  26,  28,  32,  37,  38,  40,  48,  63,  64,  69,  71,  79,  80,  116,  202,  203,  205,  206,  207,  209,  210,  211,  213,  214,  217,  218,  219,  775,  7264,  10792,  10795,  23228,  23256,  30204,  54721,  54753,  54754,  54756,  54787,  54793,  54809,  57153,  57274,  57921,  58019,  58363,  61722,  65268,  65341,  65373,  65406,  65408,  65410,  65415,  65424,  65436,  65439,  65450,  65462,  65472,  65476,  65478,  65480,  65482,  65488,  65506,  65511,  65514,  65521,  65527,  65528,  65529};
  int ret =  c;
  ((void ) 0);
  ((void ) 0);
  if ((c < 128)) {
    if (((c >= 'A') && (c <= 'Z'))) {
      (ret = (c + ('a' - 'A')));
    }  
  } 
  else if ((c < 65536)) {
    int iHi =  ((sizeof(aEntry) / sizeof(aEntry[0])) - 1);
    int iLo =  0;
    int iRes =  (- 1);
    while ((iHi >= iLo)) {
      int iTest =  ((iHi + iLo) / 2);
      int cmp =  (c - aEntry[iTest].iCode);
      if ((cmp >= 0)) {
        (iRes = iTest);
        (iLo = (iTest + 1));
      }  
      else {
        (iHi = (iTest - 1));
      }
    }
    ((void ) 0);
    if ((iRes >= 0)) {
      const struct  TableEntry   *p =  (&aEntry[iRes]);
      if (((c < (p->iCode + p->nRange)) && (0 == (0x01 & p->flags & (p->iCode ^ c))))) {
        (ret = ((c + aiOff[(p->flags >> 1)]) & 0x0000FFFF));
        ((void ) 0);
      }  
    }  
    if (bRemoveDiacritic) {
      (ret = remove_diacritic(ret));
    }  
  }
  
  else if (((c >= 66560) && (c < 66600))) {
    (ret = (c + 40));
  } 
  return ret;
}